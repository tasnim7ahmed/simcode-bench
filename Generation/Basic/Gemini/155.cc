#include "ns3/core-module.h"
#include "ns3/network-module.h"
#include "ns3/internet-module.h"
#include "ns3/point-to-point-module.h"
#include "ns3/applications-module.h"
#include "ns3/ipv4-global-routing-helper.h"
#include "ns3/nstime.h"
#include "ns3/node.h" // For GetId()
#include "ns3/header.h"
#include "ns3/packet.h"
#include "ns3/tcp-socket-factory.h"
#include "ns3/inet-socket-address.h"

#include <fstream>
#include <iostream>
#include <vector>
#include <map>
#include <tuple>

using namespace ns3;

NS_LOG_COMPONENT_DEFINE("StarTopologyTCPDataset");

// Global CSV file for data logging
std::ofstream g_csvFile;

// Custom header to carry packet information
class MyPacketHeader : public Header
{
public:
    static TypeId GetTypeId();
    virtual TypeId GetInstanceTypeId() const;
    virtual void Serialize(Buffer::Iterator start) const;
    virtual uint32_t Deserialize(Buffer::Iterator start);
    virtual uint32_t GetSerializedSize() const;
    virtual void Print(std::ostream& os) const;

    void SetSrcNodeId(uint32_t id);
    uint32_t GetSrcNodeId() const;

    void SetDstNodeId(uint32_t id);
    uint32_t GetDstNodeId() const;

    void SetTxTimeNs(uint64_t timeNs);
    uint64_t GetTxTimeNs() const;

private:
    uint32_t m_srcNodeId;
    uint32_t m_dstNodeId;
    uint64_t m_txTimeNs; // Transmission Time in nanoseconds
};

TypeId MyPacketHeader::GetTypeId()
{
    static TypeId tid = TypeId("ns3::MyPacketHeader")
                            .SetParent<Header>()
                            .AddConstructor<MyPacketHeader>();
    return tid;
}

TypeId MyPacketHeader::GetInstanceTypeId() const
{
    return GetTypeId();
}

void MyPacketHeader::Serialize(Buffer::Iterator start) const
{
    start.WriteU32(m_srcNodeId);
    start.WriteU32(m_dstNodeId);
    start.WriteU64(m_txTimeNs);
}

uint32_t MyPacketHeader::Deserialize(Buffer::Iterator start)
{
    m_srcNodeId = start.ReadU32();
    m_dstNodeId = start.ReadU32();
    m_txTimeNs = start.ReadU64();
    return GetSerializedSize();
}

uint32_t MyPacketHeader::GetSerializedSize() const
{
    return sizeof(uint32_t) + sizeof(uint32_t) + sizeof(uint64_t); // 4 + 4 + 8 = 16 bytes
}

void MyPacketHeader::Print(std::ostream& os) const
{
    os << "SrcNodeId: " << m_srcNodeId
       << ", DstNodeId: " << m_dstNodeId
       << ", TxTimeNs: " << m_txTimeNs;
}

void MyPacketHeader::SetSrcNodeId(uint32_t id)
{
    m_srcNodeId = id;
}

uint32_t MyPacketHeader::GetSrcNodeId() const
{
    return m_srcNodeId;
}

void MyPacketHeader::SetDstNodeId(uint32_t id)
{
    m_dstNodeId = id;
}

uint32_t MyPacketHeader::GetDstNodeId() const
{
    return m_dstNodeId;
}

void MyPacketHeader::SetTxTimeNs(uint64_t timeNs)
{
    m_txTimeNs = timeNs;
}

uint64_t MyPacketHeader::GetTxTimeNs() const
{
    return m_txTimeNs;
}

// Custom Sender Application
class StarSenderApp : public Application
{
public:
    static TypeId GetTypeId();
    StarSenderApp();
    virtual ~StarSenderApp();

    void SetRemoteAddress(Address addr);
    void SetRemotePort(uint16_t port);
    void SetPacketSize(uint32_t size);
    void SetDataRate(DataRate rate);

protected:
    virtual void DoStart();
    virtual void DoStop();

private:
    void SendPacket();
    void ScheduleTx();
    void ConnectionSucceeded(Ptr<Socket> sock);
    void ConnectionFailed(Ptr<Socket> sock);

    Ptr<Socket> m_socket;
    Address m_peerAddress;
    uint16_t m_peerPort;
    uint32_t m_packetSize; // Total packet size including header
    DataRate m_dataRate;
    EventId m_sendEvent;
    uint32_t m_totalBytesSent;
    Time m_interval;
};

TypeId StarSenderApp::GetTypeId()
{
    static TypeId tid = TypeId("ns3::StarSenderApp")
                            .SetParent<Application>()
                            .AddConstructor<StarSenderApp>()
                            .AddAttribute("RemoteAddress",
                                          "The destination Address of the outbound packets.",
                                          AddressValue(),
                                          MakeAddressAccessor(&StarSenderApp::m_peerAddress),
                                          MakeAddressChecker())
                            .AddAttribute("RemotePort",
                                          "The destination port of the outbound packets.",
                                          UintegerValue(0),
                                          MakeUintegerAccessor(&StarSenderApp::m_peerPort),
                                          MakeUintegerChecker<uint16_t>())
                            .AddAttribute("PacketSize",
                                          "The size of packets generated by the application.",
                                          UintegerValue(1024),
                                          MakeUintegerAccessor(&StarSenderApp::m_packetSize),
                                          MakeUintegerChecker<uint32_t>(16)) // Min size for header
                            .AddAttribute("DataRate",
                                          "The data rate in bits/s.",
                                          DataRateValue(DataRate("1Mbps")),
                                          MakeDataRateAccessor(&StarSenderApp::m_dataRate),
                                          MakeDataRateChecker());
    return tid;
}

StarSenderApp::StarSenderApp()
    : m_socket(nullptr),
      m_peerAddress(),
      m_peerPort(0),
      m_packetSize(0),
      m_dataRate(0),
      m_sendEvent(),
      m_totalBytesSent(0),
      m_interval(0)
{
    NS_LOG_FUNCTION(this);
}

StarSenderApp::~StarSenderApp()
{
    NS_LOG_FUNCTION(this);
    m_socket = nullptr;
}

void StarSenderApp::SetRemoteAddress(Address addr)
{
    m_peerAddress = addr;
}

void StarSenderApp::SetRemotePort(uint16_t port)
{
    m_peerPort = port;
}

void StarSenderApp::SetPacketSize(uint32_t size)
{
    m_packetSize = size;
}

void StarSenderApp::SetDataRate(DataRate rate)
{
    m_dataRate = rate;
}

void StarSenderApp::DoStart()
{
    NS_LOG_FUNCTION(this);
    m_socket = Socket::CreateSocket(GetNode(), TcpSocketFactory::GetTypeId());
    m_socket->SetSendBufferSize(10 * 1024 * 1024); // Set a large send buffer for high data rates
    m_socket->SetRecvBufferSize(10 * 1024 * 1024); // Set a large receive buffer

    m_socket->SetConnectCallback(MakeCallback(&StarSenderApp::ConnectionSucceeded, this),
                                 MakeCallback(&StarSenderApp::ConnectionFailed, this));
    m_socket->Connect(InetSocketAddress(m_peerAddress, m_peerPort));

    m_interval = Time::FromSeconds(static_cast<double>(m_packetSize * 8) / m_dataRate.GetBitsPerSecond());
    NS_LOG_INFO("StarSenderApp " << GetNode()->GetId() << " connecting to " << InetSocketAddress::ConvertFrom(m_peerAddress).GetIpv4() << ":" << m_peerPort);
}

void StarSenderApp::DoStop()
{
    NS_LOG_FUNCTION(this);
    Simulator::Cancel(m_sendEvent);
    if (m_socket)
    {
        m_socket->Close();
    }
}

void StarSenderApp::ConnectionSucceeded(Ptr<Socket> sock)
{
    NS_LOG_FUNCTION(this << sock);
    NS_LOG_INFO("StarSenderApp " << GetNode()->GetId() << " connection to " << InetSocketAddress::ConvertFrom(sock->GetPeerAddress()).GetIpv4() << " succeeded.");
    ScheduleTx();
}

void StarSenderApp::ConnectionFailed(Ptr<Socket> sock)
{
    NS_LOG_FUNCTION(this << sock);
    NS_LOG_WARN("StarSenderApp " << GetNode()->GetId() << " connection to " << InetSocketAddress::ConvertFrom(sock->GetPeerAddress()).GetIpv4() << " failed.");
}

void StarSenderApp::SendPacket()
{
    NS_LOG_FUNCTION(this);

    // Create a new packet with our custom header
    Ptr<Packet> packet = Create<Packet>(m_packetSize - MyPacketHeader::GetTypeId().GetHeaderSize());
    MyPacketHeader header;
    header.SetSrcNodeId(GetNode()->GetId());
    header.SetDstNodeId(InetSocketAddress::ConvertFrom(m_peerAddress).GetNodeId()); // GetNodeId() is not directly available on InetSocketAddress. Need to map IPs to Node IDs if this doesn't work.
                                                                                // For this scenario, I'll rely on the fact that peerAddress points to one of the other nodes.
                                                                                // A more robust way would be to have a global map or pass the DstNodeId in setup.
    header.SetTxTimeNs(Simulator::Now().GetNanoSeconds());
    packet->AddHeader(header);

    int bytesSent = m_socket->Send(packet);

    if (bytesSent < 0)
    {
        // This could be TCP connection problems, or send buffer full
        NS_LOG_WARN("StarSenderApp " << GetNode()->GetId() << " socket error " << bytesSent);
        // Do not reschedule if send failed, wait for next timer or error handling
    }
    else if (bytesSent == (int)packet->GetSize())
    {
        m_totalBytesSent += bytesSent;
        NS_LOG_INFO("At time " << Simulator::Now().GetSeconds()
                               << "s StarSenderApp " << GetNode()->GetId()
                               << " sent " << bytesSent << " bytes to "
                               << InetSocketAddress::ConvertFrom(m_peerAddress).GetIpv4()
                               << ", total sent " << m_totalBytesSent << " bytes");
        ScheduleTx();
    }
    else // bytesSent > 0 but less than packet->GetSize()
    {
        // Not all bytes could be sent. Need to handle remaining data.
        // For simplicity in this example, we assume full packets are sent.
        // For real-world, TCP handles fragmentation and retransmissions.
        NS_LOG_WARN("StarSenderApp " << GetNode()->GetId() << " sent partial packet. This should not happen with TCP.");
        m_totalBytesSent += bytesSent;
        ScheduleTx(); // Still schedule next packet if possible
    }
}

void StarSenderApp::ScheduleTx()
{
    NS_LOG_FUNCTION(this);
    if (m_socket->GetTxAvailable() > 0)
    {
        m_sendEvent = Simulator::Schedule(m_interval, &StarSenderApp::SendPacket, this);
    }
    else
    {
        // No space in TCP buffer, try again later
        m_sendEvent = Simulator::Schedule(MicroSeconds(100), &StarSenderApp::ScheduleTx, this);
        NS_LOG_DEBUG("StarSenderApp " << GetNode()->GetId() << " Tx buffer full, rescheduling.");
    }
}

// Custom Receiver Application
class StarReceiverApp : public Application
{
public:
    static TypeId GetTypeId();
    StarReceiverApp();
    virtual ~StarReceiverApp();

    void SetLocalAddress(Address addr);
    void SetLocalPort(uint16_t port);

protected:
    virtual void DoStart();
    virtual void DoStop();

private:
    void HandleRead(Ptr<Socket> socket);
    void HandleAccept(Ptr<Socket> s, const Address& from);
    void HandlePeerClose(Ptr<Socket> sock);
    void HandlePeerError(Ptr<Socket> sock);

    Ptr<Socket> m_socket;      // Listening socket
    Address m_localAddress;
    uint16_t m_localPort;
    std::vector<Ptr<Socket>> m_peerSockets; // Accepted sockets
    uint32_t m_totalBytesReceived;
};

TypeId StarReceiverApp::GetTypeId()
{
    static TypeId tid = TypeId("ns3::StarReceiverApp")
                            .SetParent<Application>()
                            .AddConstructor<StarReceiverApp>()
                            .AddAttribute("LocalAddress",
                                          "The Address to bind to.",
                                          AddressValue(),
                                          MakeAddressAccessor(&StarReceiverApp::m_localAddress),
                                          MakeAddressChecker())
                            .AddAttribute("LocalPort",
                                          "The port to bind to.",
                                          UintegerValue(0),
                                          MakeUintegerAccessor(&StarReceiverApp::m_localPort),
                                          MakeUintegerChecker<uint16_t>());
    return tid;
}

StarReceiverApp::StarReceiverApp()
    : m_socket(nullptr),
      m_localAddress(),
      m_localPort(0),
      m_totalBytesReceived(0)
{
    NS_LOG_FUNCTION(this);
}

StarReceiverApp::~StarReceiverApp()
{
    NS_LOG_FUNCTION(this);
    m_socket = nullptr;
    for (auto sock : m_peerSockets)
    {
        sock = nullptr;
    }
    m_peerSockets.clear();
}

void StarReceiverApp::SetLocalAddress(Address addr)
{
    m_localAddress = addr;
}

void StarReceiverApp::SetLocalPort(uint16_t port)
{
    m_localPort = port;
}

void StarReceiverApp::DoStart()
{
    NS_LOG_FUNCTION(this);
    m_socket = Socket::CreateSocket(GetNode(), TcpSocketFactory::GetTypeId());
    m_socket->SetRecvBufferSize(10 * 1024 * 1024); // Set a large receive buffer
    m_socket->Bind(InetSocketAddress(m_localAddress, m_localPort));
    m_socket->Listen();
    m_socket->SetAcceptCallback(MakeCallback(&StarReceiverApp::HandleAccept, this),
                               MakeCallback(&StarReceiverApp::HandlePeerClose, this));
    NS_LOG_INFO("StarReceiverApp " << GetNode()->GetId() << " listening on " << InetSocketAddress::ConvertFrom(m_localAddress).GetIpv4() << ":" << m_localPort);
}

void StarReceiverApp::DoStop()
{
    NS_LOG_FUNCTION(this);
    if (m_socket)
    {
        m_socket->Close();
    }
    for (auto sock : m_peerSockets)
    {
        if (sock)
        {
            sock->Close();
        }
    }
}

void StarReceiverApp::HandleAccept(Ptr<Socket> s, const Address& from)
{
    NS_LOG_FUNCTION(this << s << from);
    s->SetRecvCallback(MakeCallback(&StarReceiverApp::HandleRead, this));
    s->SetCloseCallbacks(MakeCallback(&StarReceiverApp::HandlePeerClose, this),
                         MakeCallback(&StarReceiverApp::HandlePeerError, this));
    m_peerSockets.push_back(s);
    NS_LOG_INFO("StarReceiverApp " << GetNode()->GetId() << " accepted connection from " << InetSocketAddress::ConvertFrom(from).GetIpv4());
}

void StarReceiverApp::HandleRead(Ptr<Socket> socket)
{
    NS_LOG_FUNCTION(this << socket);
    Ptr<Packet> packet;
    Address from;
    while ((packet = socket->RecvFrom(from)))
    {
        if (packet->GetSize() == 0)
        {
            break;
        }

        m_totalBytesReceived += packet->GetSize();

        MyPacketHeader header;
        if (packet->RemoveHeader(header))
        {
            uint32_t srcNodeId = header.GetSrcNodeId();
            uint32_t dstNodeId = GetNode()->GetId();
            uint32_t packetSize = packet->GetSize() + MyPacketHeader::GetTypeId().GetHeaderSize();
            uint64_t txTimeNs = header.GetTxTimeNs();
            uint64_t rxTimeNs = Simulator::Now().GetNanoSeconds();

            g_csvFile << srcNodeId << ","
                      << dstNodeId << ","
                      << packetSize << ","
                      << txTimeNs << ","
                      << rxTimeNs << "\n";
            NS_LOG_INFO("At time " << Simulator::Now().GetSeconds() << "s Receiver " << GetNode()->GetId()
                                   << " received packet from " << srcNodeId
                                   << " size " << packetSize << " bytes. TxTime: " << txTimeNs
                                   << "ns, RxTime: " << rxTimeNs << "ns.");
        }
        else
        {
            NS_LOG_WARN("StarReceiverApp " << GetNode()->GetId() << " received packet without MyPacketHeader.");
        }
    }
}

void StarReceiverApp::HandlePeerClose(Ptr<Socket> sock)
{
    NS_LOG_FUNCTION(this);
    NS_LOG_INFO("StarReceiverApp " << GetNode()->GetId() << " peer closed connection.");
}

void StarReceiverApp::HandlePeerError(Ptr<Socket> sock)
{
    NS_LOG_FUNCTION(this);
    NS_LOG_ERROR("StarReceiverApp " << GetNode()->GetId() << " peer error.");
}

int main(int argc, char* argv[])
{
    // Enable logging (optional)
    LogComponentEnable("StarTopologyTCPDataset", LOG_LEVEL_INFO);
    LogComponentEnable("StarSenderApp", LOG_LEVEL_INFO);
    LogComponentEnable("StarReceiverApp", LOG_LEVEL_INFO);
    // LogComponentEnable("TcpSocketBase", LOG_LEVEL_ALL);
    // LogComponentEnable("TcpNewReno", LOG_LEVEL_ALL);

    // Open CSV file and write header
    g_csvFile.open("star_tcp_dataset.csv");
    g_csvFile << "SrcNodeId,DstNodeId,PacketSize,TxTimeNs,RxTimeNs\n";

    // 1. Create nodes
    NodeContainer nodes;
    nodes.Create(5); // Node 0 (center), Nodes 1-4 (peripherals)

    // 2. Install Internet Stack
    InternetStackHelper stack;
    stack.Install(nodes);

    // 3. Configure Point-to-Point links
    PointToPointHelper p2p;
    p2p.SetDeviceAttribute("DataRate", StringValue("10Mbps"));
    p2p.SetChannelAttribute("Delay", StringValue("2ms"));

    // 4. Assign IP addresses and connect nodes
    Ipv4AddressHelper address;
    Ipv4InterfaceContainer interfaces[4]; // For links (0,1), (0,2), (0,3), (0,4)
    NetDeviceContainer devices[4];

    // Link 0-1
    devices[0] = p2p.Install(nodes.Get(0), nodes.Get(1));
    address.SetBase("10.0.0.0", "255.255.255.0");
    interfaces[0] = address.Assign(devices[0]);

    // Link 0-2
    devices[1] = p2p.Install(nodes.Get(0), nodes.Get(2));
    address.SetBase("10.0.1.0", "255.255.255.0");
    interfaces[1] = address.Assign(devices[1]);

    // Link 0-3
    devices[2] = p2p.Install(nodes.Get(0), nodes.Get(3));
    address.SetBase("10.0.2.0", "255.255.255.0");
    interfaces[2] = address.Assign(devices[2]);

    // Link 0-4
    devices[3] = p2p.Install(nodes.Get(0), nodes.Get(4));
    address.SetBase("10.0.3.0", "255.255.255.0");
    interfaces[3] = address.Assign(devices[3]);

    // 5. Populate routing tables
    Ipv4GlobalRoutingHelper::PopulateRoutingTables();

    // 6. Setup Applications (StarSenderApp on Node 0, StarReceiverApp on Nodes 1-4)
    uint16_t port = 9000;
    uint32_t packetSize = 1000; // bytes (including custom header)
    DataRate dataRate("1Mbps"); // bits/s

    for (uint32_t i = 1; i <= 4; ++i)
    {
        // Receiver (Packet Sink) on peripheral node i
        Ptr<StarReceiverApp> receiverApp = CreateObject<StarReceiverApp>();
        receiverApp->SetLocalAddress(interfaces[i - 1].GetAddress(1)); // IP of peripheral node
        receiverApp->SetLocalPort(port + i);
        nodes.Get(i)->AddApplication(receiverApp);
        receiverApp->SetStartTime(Seconds(0.0));
        receiverApp->SetStopTime(Seconds(10.0));

        // Sender (On-Off) on central node (Node 0)
        Ptr<StarSenderApp> senderApp = CreateObject<StarSenderApp>();
        senderApp->SetRemoteAddress(interfaces[i - 1].GetAddress(1)); // IP of peripheral node
        senderApp->SetRemotePort(port + i);
        senderApp->SetPacketSize(packetSize);
        senderApp->SetDataRate(dataRate);
        nodes.Get(0)->AddApplication(senderApp);
        senderApp->SetStartTime(Seconds(1.0)); // Start sending after receivers are ready
        senderApp->SetStopTime(Seconds(9.0));  // Stop before simulation ends
    }

    // 7. Simulation
    Simulator::Stop(Seconds(10.0)); // Stop at 10 seconds
    Simulator::Run();
    Simulator::Destroy();

    // Close CSV file
    g_csvFile.close();

    return 0;
}