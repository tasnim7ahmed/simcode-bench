{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network with two nodes: one as a UDP server and the other as a UDP client. The client sends UDP packets (size 1024 bytes) at an interval of 100ms to the server. Use a constant bit rate (CBR) application on the client and set the server to listen on port 9."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for debugging\n    LogComponentEnable(\"WifiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Set up Wi-Fi devices\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::ArfWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"wifi-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer staDevice;\n    staDevice = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevice);\n    Ipv4InterfaceContainer apInterfaces = address.Assign(apDevice);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0), \"DeltaY\", DoubleValue(5.0), \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Set up UDP server (on the STA)\n    uint16_t port = 9;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client (on the AP)\n    UdpClientHelper client(staInterfaces.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = client.Install(wif"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 simulation library to model an ad hoc network with 10 nodes utilizing AODV routing protocol. Configure these nodes in a grid layout and enable random mobility within a defined area. Implement a UDP echo server on each node, allowing them to send echo requests to the next node in a circular manner, with clients sending requests every 4 seconds. Set the simulation parameters to enable PCAP tracing and optional printing of routing tables at specified intervals. Integrate a flow monitor to capture network statistics, including packet delivery ratios, end-to-end delays, and throughput, and output these metrics after the simulation completes. Additionally, create an animation file to visualize the simulation's activity."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/aodv-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocNetworkExample\");\n\nvoid UpdateNodePositions(NodeContainer &nodes)\n{\n    Ptr<UniformRandomVariable> rand = CreateObject<UniformRandomVariable>();\n    for (NodeContainer::Iterator it = nodes.Begin(); it != nodes.End(); ++it)\n    {\n        Ptr<MobilityModel> mobility = (*it)->GetObject<MobilityModel>();\n        double x = rand->GetValue(-100, 100);\n        double y = rand->GetValue(-100, 100);\n        mobility->SetPosition(Vector(x, y, 0.0));\n    }\n    Simulator::Schedule(Seconds(5.0), &UpdateNodePositions, nodes);\n}\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"AdhocNetworkExample\", LOG_LEVEL_INFO);\n\n    int size = 10;\n    int step = 50;\n    int totalTime = 100;\n    bool pcap = true;\n    bool printRoutes = true;\n\n    NodeContainer nodes;\n    nodes.Create(size);\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"pcap\", \"Write PCAP traces.\", pcap);\n    cmd.AddValue(\"printRoutes\", \"Print routing table dumps.\", printRoutes);\n    cmd.AddValue(\"size\", \"Number of nodes.\", size);\n    cmd.AddValue(\"time\", \"Simulation time, s.\", totalTime);\n    cmd.AddValue(\"step\", \"Grid step, m\", step);\n\n    cmd.Parse(argc, argv);\n\n    WifiHelper wifi;\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n    phy.Set(\"TxPowerStart\", DoubleValue(20));\n    phy.Set(\"TxPowerEnd\", DoubleValue(20));\n    phy.Set(\"TxGain\", DoubleValue(0.0));\n    phy.Set(\"RxGain\", DoubleValue(0.0));\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(20.0),\n                                  \"DeltaY\", DoubleValue(20.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue(Rectangle(-100, 100, -100, 100)));\n    mobility.Install(nodes);\n\n    if (pcap)\n    {\n        phy.EnablePcapAll(std::string(\"aodv\"));\n    }\n    AodvHelper aodv;\n    InternetStackHelper stack;\n    stack.SetRoutingHelper(aodv);\n    stack.Install(nodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.2.22.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    if (printRoutes)\n    {\n        Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(\"scratch/routingTable_update.routes\", std::ios::out);\n        for (int i = 2; i <= totalTime; i += 2)\n        {\n            aodv.PrintRoutingTableAllAt(Seconds(i), routingStream);\n            Simulator::Schedule(Seconds(i), &UpdateNodePositions, nodes); // Schedule position update\n        }\n    }\n    uint16_t port = 9;\n    UdpEchoServerHelper server(port);\n    ApplicationContainer serverApps;\n\n    for (int i = 0; i < size; i++)\n    {\n        serverApps.Add(server.Install(nodes.Get(i)));\n    }\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(totalTime));\n    ApplicationContainer clientApps[size];\n\n    for (int i = 0; i < size; i++)\n    {\n        UdpEchoClientHelper client(interfaces.GetAddress((i + 1) % size), port);\n        client.SetAttribute(\"MaxPackets\", UintegerValue(50));\n        client.SetAttribute(\"Interval\", TimeValue(Seconds(4.0)));\n        client.SetAttribute(\"PacketSize\", UintegerValue(512));\n        clientApps[i].Add(client.Install(nodes.Get(i)));\n    }\n\n    // Start and stop client applications\n    for (int i = 0; i < size; i++)\n    {\n        clientApps[i].Start(Seconds(2.0 + 10 * i));\n        clientApps[i].Stop(Seconds(totalTime));\n    }\n\n    // Define a flow monitor object\n    Ptr<FlowMonitor> flowMonitor;\n    FlowMonitorHelper flowHelper;\n    flowMonitor = flowHelper.InstallAll();\n\n    Simulator::Stop(Seconds(totalTime));\n\n    // Animation\n    AnimationInterface anim(\"ten_nodes_aodv.xml\");\n\n    // Run simulation\n    Simulator::Run();\n\n    // Calculate packet delivery ratio and end-to-end delay and throughput\n    uint32_t packetsDelivered = 0;\n    uint32_t totalPackets = 0;\n    double totalDelay = 0;\n\n    // Retrieve the flow statistics\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n    for (auto &it : stats)\n    {\n        FlowId flowId = it.first;\n        std::cout << \"Flow \" << flowId << std::endl;\n        std::cout << \" Tx Packets: \" << it.second.txPackets << std::endl;\n        std::cout << \" Tx Bytes: \" << it.second.txBytes << std::endl;\n        std::cout << \" Rx Packets: \" << it.second.rxPackets << std::endl;\n        std::cout << \" Rx Bytes: \" << it.second.rxBytes << std::endl;\n\n        if (it.second.rxPackets > 0)\n        {\n            packetsDelivered += it.second.rxPackets;\n            totalPackets += it.second.txPackets;\n            totalDelay += (it.second.delaySum.ToDouble(ns3::Time::S) / it.second.rxPackets);\n        }\n    }\n\n    double packetDeliveryRatio = (double)packetsDelivered / totalPackets;\n    double averageEndToEndDelay = totalDelay / packetsDelivered;\n    double throughput = (double)packetsDelivered * 512 * 8 / (totalTime - 1.0) / 1000000;\n\n    // Print the results\n    std::cout << \"Packets Delivered Ratio: \" << packetDeliveryRatio << std::endl;\n    std::cout << \"Average End-to-End Delay: \" << averageEndToEndDelay << std::endl;\n    std::cout << \"Throughput: \" << throughput << std::endl;\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and connects them using a Point-to-Point (P2P) link. The program should establish a basic network topology, assign unique node IDs, and print confirmation of the links established. Keep the example simple, focusing only on node creation and connectivity."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"NodeConnectionExample\", LOG_LEVEL_INFO);\n\n    // Create a container for two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Establish a Point-to-Point link between the nodes\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices = p2p.Install(nodes);\n\n    // Print confirmation of connection\n    NS_LOG_INFO(\"Created a Point-to-Point link between Node \" \n                << nodes.Get(0)->GetId() << \" and Node \" \n                << nodes.Get(1)->GetId());\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple point-to-point network in NS-3 with two nodes. The first node sends UDP packets to the second node. Use a link speed of 5Mbps and a delay of 2ms. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link with a 5Mbps link speed and 2ms delay\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install point-to-point devices\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP client application on node 0 (sender)\n    uint16_t port = 9;\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on node 1 (receiver)\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Wi-Fi network with two nodes. One node acts as a Wi-Fi Access Point (AP), and the other as a client that sends UDP packets to the server. The client should send 100 packets of 512 bytes at a rate of one packet every 0.1 seconds. Use port 9 for communication and run the simulation for 10 seconds. The Wi-Fi network should follow the 802.11b standard with SSID = 'ns3-wifi'."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes: one for the server and one for the client\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Create Wi-Fi devices and configure them\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n\n    WifiHelper wifiAp;\n    wifiAp.SetStandard(WIFI_PHY_STANDARD_80211b);\n    WifiMacHelper macAp;\n    macAp.SetType(\"ns3::ApWifiMac\",\n                  \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices;\n    devices.Add(wifi.Install(phy, mac, nodes.Get(0)));\n    devices.Add(wifiAp.Install(phy, macAp, nodes.Get(1)));\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Install the UDP server application on node 1 (server side)\n    UdpServerHelper udpServer(9); // Port 9\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Install the UDP client application on node 0 (client side)\n    UdpClientHelper udpClient(interfaces.GetAddress(1), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));    // Send 100 packets\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1))); // Send packets every 0.1 seconds\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));    // 512 bytes packets\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a simple TCP connection between three nodes. Two of the nodes (Node 0 and Node 1) act as clients, and one node (Node 2) is the TCP server. Use PointToPoint links to connect the nodes with a 1Mbps data rate and 2ms delay. The server (Node 2) listens on port 9, while the clients send TCP traffic starting at 2 seconds (Node 0) and 3 seconds (Node 1). The simulation should last for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpSimpleExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"TcpSimpleExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the network\n    NodeContainer nodes;\n    nodes.Create(3); // Three nodes: Two clients and one server\n\n    // Set up point-to-point link between nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes.Get(0), nodes.Get(1)); // Connection between node 0 and 1\n    pointToPoint.Install(nodes.Get(1), nodes.Get(2));           // Connection between node 1 and 2\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces;\n    interfaces = ipv4.Assign(devices);\n\n    // Set up the server application (Node 2)\n    uint16_t port = 9; // Server port\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(2)); // Install on Node 2 (Server)\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the client application (Node 0 and Node 1)\n    BulkSendHelper bulkSendHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(2), port));\n    bulkSendHelper.SetAttribute(\"MaxBytes\", UintegerValue(0));              // Unlimited data transfer\n    ApplicationContainer clientApp0 = bulkSendHelper.Install(nodes.Get(0)); // Install on Node 0 (Client 1)\n    ApplicationContainer clientApp1 = bulkSendHelper.Install(nodes.Get(1)); // Install on Node 1 (Client 2)\n\n    clientApp0.Start(Seconds(2.0));\n    clientApp0.Stop(Seconds(10.0));\n    clientApp1.Start(Seconds(3.0));\n    clientApp1.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple LTE network with one evolved NodeB (eNB) and one User Equipment (UE). The eNB should be static, while the UE should move randomly within a 100x100 area using the Random Walk mobility model. Set the IP address for the UE and eNB. Create a Simplex UDP server on the eNB and a Simplex UDP client on the UE, where the UE sends five 512-byte packets at 1-second intervals to the eNB. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create the eNB and UE nodes\n    NodeContainer eNBNode, ueNode;\n    eNBNode.Create(1);\n    ueNode.Create(1);\n\n    // Set up the mobility model (eNB is static, UE is moving)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(50.0),\n                                  \"DeltaY\", DoubleValue(50.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(eNBNode);\n\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(ueNode);\n\n    // Install LTE stack (eNB and UE)\n    LteHelper lteHelper;\n    InternetStackHelper internet;\n    lteHelper.Install(eNBNode);\n    lteHelper.Install(ueNode);\n\n    // Install IP stack for routing\n    Ipv4AddressHelper ipv4;\n    Ipv4InterfaceContainer ueIpIface, enbIpIface;\n    ueIpIface = lteHelper.AssignUeIpv4Address(ueNode.Get(0));\n    enbIpIface = lteHelper.AssignUeIpv4Address(eNBNode.Get(0));\n\n    // Create a Simplex UDP server on eNB (receiver)\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApps = udpServer.Install(eNBNode.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Create a Simplex UDP client on UE (sender)\n    UdpClientHelper udpClient(enbIpIface.GetAddress(0), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApps = udpClient.Install(ueNode.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Wi-Fi network with one Access Point (AP) and one Station (STA). The AP and STA should be assigned static positions. The STA should send UDP packets to the AP using a UDP Echo Client, and the AP should run a UDP Echo Server to respond. The simulation should use the 192.168.1.0/24 subnet, with the client starting at 2 seconds and stopping at 9 seconds, while the server runs from 1 second to 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create two nodes: one AP and one STA\n    NodeContainer wifiStaNode;\n    wifiStaNode.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n    NodeContainer wifiNodes = NodeContainer(wifiApNode, wifiStaNode);\n\n    // Set up Wi-Fi PHY and MAC\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Configure AP\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(wifiPhy, wifiMac, wifiApNode);\n\n    // Configure STA\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevice = wifi.Install(wifiPhy, wifiMac, wifiStaNode);\n\n    // Set mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterface = address.Assign(staDevice);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Set up UDP server on AP\n    uint16_t port = 9;\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApp = echoServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on STA\n    UdpEchoClientHelper echoClient(apInterface.GetAddress(0), port);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = echoClient.Install(wifiStaNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ simulation using ns-3 to simulate a ring topology with 4 nodes. In this configuration, each node is connected to two other nodes, forming a closed loop. Use point-to-point links with a data rate of 5Mbps and a delay of 1ms. Install the Internet stack, assign IP addresses, and simulate packet transmission in a circular fashion, where each node sends packets to its neighbor. Log the packet transmissions to observe the behavior of the network."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RingTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"RingTopologyExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(4); // Create 4 nodes\n\n    // Create a point-to-point link helper\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    // Install devices and set up point-to-point links in a ring topology\n    NetDeviceContainer devices;\n\n    for (uint32_t i = 0; i < nodes.GetN(); ++i)\n    {\n        // Connect each node to the next, and wrap around for the last node\n        NetDeviceContainer temp = pointToPoint.Install(nodes.Get(i), nodes.Get((i + 1) % nodes.GetN()));\n        devices.Add(temp);\n    }\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses in the 10.1.x.0/24 subnet\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfaces;\n\n    for (uint32_t i = 0; i < nodes.GetN(); ++i)\n    {\n        address.SetBase(\"10.1.\" + std::to_string(i + 1) + \".0\", \"255.255.255.0\");\n        interfaces.Add(address.Assign(devices.Get(i)));\n    }\n\n    // Application: Sending packets from each node to its clockwise neighbor\n    uint16_t port = 9; // Port for communication\n    for (uint32_t i = 0; i < nodes.GetN(); ++i)\n    {\n        // Each node sends packets to its clockwise neighbor\n        OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(interfaces.GetAddress((i + 1) % nodes.GetN()), port));\n        onoff.SetConstantRate(DataRate(\"1Mbps\"), 1024); // 1Mbps data rate, 1024-byte packets\n        ApplicationContainer app = onoff.Install(nodes.Get(i)); // Install on each node\n        app.Start(Seconds(1.0 + i)); // Stagger start times\n        app.Stop(Seconds(10.0)); // Stop at 10 seconds\n    }\n\n    // Set up a PacketSink on each node to receive packets\n    for (uint32_t i = 0; i < nodes.GetN(); ++i)\n    {\n        PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n        ApplicationContainer sinkApp = sink.Install(nodes.Get(i)); // Install sink on each node\n        sinkApp.Start(Seconds(1.0));\n        sinkApp.Stop(Seconds(10.0));\n    }\n\n    // Enable routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a three-node ad-hoc wireless network using the AODV routing protocol. The nodes should use the 802.11b Wi-Fi standard, be arranged in a linear layout with a 10-meter separation, and have unique IPv4 addresses in the 192.168.1.0/24 subnet. The last node should run a UDP echo server on port 9, while the first node should act as a client sending five packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ipv4-routing-helper.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create three nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Configure Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install Internet stack with AODV routing\n    AodvHelper aodv;\n    Ipv4ListRoutingHelper list;\n    list.Add(aodv, 10);\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(list);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP echo server on the last node\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(2));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP echo client on the first node\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(2), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a detailed C++ program using the ns-3 library to simulate the performance of 802.11n MIMO networks. The program should output a plot of throughput versus distance for every HT MCS value, ranging from 1 to 4 MIMO streams. It should allow configuration of parameters such as UDP or TCP traffic, frequency band (2.4 or 5.0 GHz), channel width, short guard interval, and preamble detection. The program must simulate a network with a single station and an access point, where the distance between them is varied. For each MIMO stream and MCS mode, simulate data transfer between the nodes and measure throughput. Use Gnuplot to plot the results, with appropriate axis labels and legends. The simulation should allow the user to configure step size, simulation time, and channel bonding, and use either UDP or TCP traffic. Include code to set up the Wi-Fi channel, PHY, MAC, mobility, and network stack, as well as data flow using UDP or TCP applications, and ensure that throughput is calculated and plotted."}, {"role": "assistant", "content": "// This example is used to validate 802.11n MIMO.\n//\n// It outputs plots of the throughput versus the distance\n// for every HT MCS value and from 1 to 4 MIMO streams.\n//\n// The simulation assumes a single station in an infrastructure network:\n//\n//  STA     AP\n//    *     *\n//    |     |\n//   n1     n2\n//\n// The user can choose whether UDP or TCP should be used and can configure\n// some 802.11n parameters (frequency, channel width and guard interval).\n//\n// An important configuration parameter is preamble detection.  It is enabled\n// by default (to match the default ns-3 configuration) but will dominate\n// performance at low SNRs, causing the different MCS to appear to have\n// the same range (because regardless of the MCS, the preamble detection\n// thresholds do not change).\n\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/ht-phy.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    std::ofstream file(\"80211n-mimo-throughput.plt\");\n\n    std::vector<std::string> modes = {\n        \"HtMcs0\",  \"HtMcs1\",  \"HtMcs2\",  \"HtMcs3\",  \"HtMcs4\",  \"HtMcs5\",  \"HtMcs6\",  \"HtMcs7\",\n        \"HtMcs8\",  \"HtMcs9\",  \"HtMcs10\", \"HtMcs11\", \"HtMcs12\", \"HtMcs13\", \"HtMcs14\", \"HtMcs15\",\n        \"HtMcs16\", \"HtMcs17\", \"HtMcs18\", \"HtMcs19\", \"HtMcs20\", \"HtMcs21\", \"HtMcs22\", \"HtMcs23\",\n        \"HtMcs24\", \"HtMcs25\", \"HtMcs26\", \"HtMcs27\", \"HtMcs28\", \"HtMcs29\", \"HtMcs30\", \"HtMcs31\",\n    };\n\n    bool udp{true};\n    Time simulationTime{\"5s\"};\n    double frequency{5.0}; // whether 2.4 or 5.0 GHz\n    double step{5};        // meters\n    bool shortGuardInterval{false};\n    bool channelBonding{false};\n    bool preambleDetection{true};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"step\", \"Granularity of the results to be plotted in meters\", step);\n    cmd.AddValue(\"simulationTime\", \"Simulation time per step\", simulationTime);\n    cmd.AddValue(\"channelBonding\",\n                 \"Enable/disable channel bonding (channel width = 20 MHz if false, channel width = \"\n                 \"40 MHz if true)\",\n                 channelBonding);\n    cmd.AddValue(\"preambleDetection\", \"Enable/disable preamble detection model\", preambleDetection);\n    cmd.AddValue(\"shortGuardInterval\", \"Enable/disable short guard interval\", shortGuardInterval);\n    cmd.AddValue(\"frequency\",\n                 \"Whether working in the 2.4 or 5.0 GHz band (other values gets rejected)\",\n                 frequency);\n    cmd.AddValue(\"udp\", \"UDP if set to 1, TCP otherwise\", udp);\n    cmd.Parse(argc, argv);\n\n    Gnuplot plot = Gnuplot(\"80211n-mimo-throughput.eps\");\n\n    for (uint32_t i = 0; i < modes.size(); i++) // MCS\n    {\n        std::cout << modes[i] << std::endl;\n        Gnuplot2dDataset dataset(modes[i]);\n        for (double d = 0; d <= 100;) // distance\n        {\n            std::cout << \"Distance = \" << d << \"m: \" << std::endl;\n            uint32_t payloadSize; // 1500 byte IP packet\n            if (udp)\n            {\n                payloadSize = 1472; // bytes\n            }\n            else\n            {\n                payloadSize = 1448; // bytes\n                Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n            }\n\n            uint8_t nStreams = 1 + (i / 8); // number of MIMO streams\n\n            NodeContainer wifiStaNode;\n            wifiStaNode.Create(1);\n            NodeContainer wifiApNode;\n            wifiApNode.Create(1);\n\n            YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n            YansWifiPhyHelper phy;\n            phy.SetChannel(channel.Create());\n            if (!preambleDetection)\n            {\n                phy.DisablePreambleDetectionModel();\n            }\n\n            // Set MIMO capabilities\n            phy.Set(\"Antennas\", UintegerValue(nStreams));\n            phy.Set(\"MaxSupportedTxSpatialStreams\", UintegerValue(nStreams));\n            phy.Set(\"MaxSupportedRxSpatialStreams\", UintegerValue(nStreams));\n            phy.Set(\"ChannelSettings\",\n                    StringValue(std::string(\"{0, \") + (channelBonding ? \"40, \" : \"20, \") +\n                                (frequency == 2.4 ? \"BAND_2_4GHZ\" : \"BAND_5GHZ\") + \", 0}\"));\n\n            WifiMacHelper mac;\n            WifiHelper wifi;\n            if (frequency == 5.0)\n            {\n                wifi.SetStandard(WIFI_STANDARD_80211n);\n            }\n            else if (frequency == 2.4)\n            {\n                wifi.SetStandard(WIFI_STANDARD_80211n);\n                Config::SetDefault(\"ns3::LogDistancePropagationLossModel::ReferenceLoss\",\n                                   DoubleValue(40.046));\n            }\n            else\n            {\n                std::cout << \"Wrong frequency value!\" << std::endl;\n                return 0;\n            }\n\n            StringValue ctrlRate;\n            if (frequency == 2.4)\n            {\n                ctrlRate = StringValue(\"ErpOfdmRate24Mbps\");\n            }\n            else\n            {\n                ctrlRate = StringValue(\"OfdmRate24Mbps\");\n            }\n            wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                         \"DataMode\",\n                                         StringValue(modes[i]),\n                                         \"ControlMode\",\n                                         ctrlRate);\n\n            Ssid ssid = Ssid(\"ns3-80211n\");\n\n            mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n            NetDeviceContainer staDevice;\n            staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n            mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n            NetDeviceContainer apDevice;\n            apDevice = wifi.Install(phy, mac, wifiApNode);\n\n            // Set guard interval\n            Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/\"\n                        \"ShortGuardIntervalSupported\",\n                        BooleanValue(shortGuardInterval));\n\n            // mobility.\n            MobilityHelper mobility;\n            Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n            positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n            positionAlloc->Add(Vector(d, 0.0, 0.0));\n            mobility.SetPositionAllocator(positionAlloc);\n\n            mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n            mobility.Install(wifiApNode);\n            mobility.Install(wifiStaNode);\n\n            /* Internet stack*/\n            InternetStackHelper stack;\n            stack.Install(wifiApNode);\n            stack.Install(wifiStaNode);\n\n            Ipv4AddressHelper address;\n            address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n            Ipv4InterfaceContainer staNodeInterface;\n            Ipv4InterfaceContainer apNodeInterface;\n\n            staNodeInterface = address.Assign(staDevice);\n            apNodeInterface = address.Assign(apDevice);\n\n            /* Setting applications */\n            const auto maxLoad = HtPhy::GetDataRate(i,\n                                                    channelBonding ? 40 : 20,\n                                                    NanoSeconds(shortGuardInterval ? 400 : 800),\n                                                    nStreams);\n            ApplicationContainer serverApp;\n            if (udp)\n            {\n                // UDP flow\n                uint16_t port = 9;\n                UdpServerHelper server(port);\n                serverApp = server.Install(wifiStaNode.Get(0));\n                serverApp.Start(Seconds(0.0));\n                serverApp.Stop(simulationTime + Seconds(1.0));\n                const auto packetInterval = payloadSize * 8.0 / maxLoad;\n\n                UdpClientHelper client(staNodeInterface.GetAddress(0), port);\n                client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n                client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n                client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n                clientApp.Start(Seconds(1.0));\n                clientApp.Stop(simulationTime + Seconds(1.0));\n            }\n            else\n            {\n                // TCP flow\n                uint16_t port = 50000;\n                Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n                PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n                serverApp = packetSinkHelper.Install(wifiStaNode.Get(0));\n                serverApp.Start(Seconds(0.0));\n                serverApp.Stop(simulationTime + Seconds(1.0));\n\n                OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n                onoff.SetAttribute(\"OnTime\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n                onoff.SetAttribute(\"OffTime\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n                onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                onoff.SetAttribute(\"DataRate\", DataRateValue(maxLoad));\n                AddressValue remoteAddress(InetSocketAddress(staNodeInterface.GetAddress(0), port));\n                onoff.SetAttribute(\"Remote\", remoteAddress);\n                ApplicationContainer clientApp = onoff.Install(wifiApNode.Get(0));\n                clientApp.Start(Seconds(1.0));\n                clientApp.Stop(simulationTime + Seconds(1.0));\n            }\n\n            Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n            Simulator::Stop(simulationTime + Seconds(1.0));\n            Simulator::Run();\n\n            double throughput = 0;\n            if (udp)\n            {\n                // UDP\n                double totalPacketsThrough =\n                    DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n                throughput = totalPacketsThrough * payloadSize * 8 /\n                             simulationTime.GetMicroSeconds(); // Mbit/s\n            }\n            else\n            {\n                // TCP\n                double totalPacketsThrough =\n                    DynamicCast<PacketSink>(serverApp.Get(0))->GetTotalRx();\n                throughput = totalPacketsThrough * 8 / simulationTime.GetMicroSeconds(); // Mbit/s\n            }\n            dataset.Add(d, throughput);\n            std::cout << throughput << \" Mbit/s\" << std::endl;\n            d += step;\n            Simulator::Destroy();\n        }\n        plot.AddDataset(dataset);\n    }\n\n    plot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    plot.SetLegend(\"Distance (Meters)\", \"Throughput (Mbit/s)\");\n    plot.SetExtra(\"set xrange [0:100]\\n\\\nset yrange [0:600]\\n\\\nset ytics 0,50,600\\n\\\nset style line 1 dashtype 1 linewidth 5\\n\\\nset style line 2 dashtype 1 linewidth 5\\n\\\nset style line 3 dashtype 1 linewidth 5\\n\\\nset style line 4 dashtype 1 linewidth 5\\n\\\nset style line 5 dashtype 1 linewidth 5\\n\\\nset style line 6 dashtype 1 linewidth 5\\n\\\nset style line 7 dashtype 1 linewidth 5\\n\\\nset style line 8 dashtype 1 linewidth 5\\n\\\nset style line 9 dashtype 2 linewidth 5\\n\\\nset style line 10 dashtype 2 linewidth 5\\n\\\nset style line 11 dashtype 2 linewidth 5\\n\\\nset style line 12 dashtype 2 linewidth 5\\n\\\nset style line 13 dashtype 2 linewidth 5\\n\\\nset style line 14 dashtype 2 linewidth 5\\n\\\nset style line 15 dashtype 2 linewidth 5\\n\\\nset style line 16 dashtype 2 linewidth 5\\n\\\nset style line 17 dashtype 3 linewidth 5\\n\\\nset style line 18 dashtype 3 linewidth 5\\n\\\nset style line 19 dashtype 3 linewidth 5\\n\\\nset style line 20 dashtype 3 linewidth 5\\n\\\nset style line 21 dashtype 3 linewidth 5\\n\\\nset style line 22 dashtype 3 linewidth 5\\n\\\nset style line 23 dashtype 3 linewidth 5\\n\\\nset style line 24 dashtype 3 linewidth 5\\n\\\nset style line 25 dashtype 4 linewidth 5\\n\\\nset style line 26 dashtype 4 linewidth 5\\n\\\nset style line 27 dashtype 4 linewidth 5\\n\\\nset style line 28 dashtype 4 linewidth 5\\n\\\nset style line 29 dashtype 4 linewidth 5\\n\\\nset style line 30 dashtype 4 linewidth 5\\n\\\nset style line 31 dashtype 4 linewidth 5\\n\\\nset style line 32 dashtype 4 linewidth 5\\n\\\nset style increment user\");\n    plot.GenerateOutput(file);\n    file.close();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 to simulate a line topology with 3 nodes. Node 0 connects to node 1, and node 1 connects to node 2 via point-to-point links. Configure UDP traffic where node 0 sends traffic to node 2 through node 1. Assign IP addresses to each network segment, and enable PCAP tracing to capture traffic. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LineTopology3Nodes\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"LineTopology3Nodes\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes: node 0, node 1, and node 2\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Set up point-to-point links\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install point-to-point links between node 0 to node 1 and node 1 to node 2\n    NetDeviceContainer device01, device12;\n    device01 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));  // Link between node 0 and node 1\n    device12 = pointToPoint.Install(nodes.Get(1), nodes.Get(2));  // Link between node 1 and node 2\n\n    // Install internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces01 = address.Assign(device01);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces12 = address.Assign(device12);\n\n    // Set up a UDP Echo server on node 2\n    UdpEchoServerHelper echoServer(9);  // Port number\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(2));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 0 to send packets to node 2\n    UdpEchoClientHelper echoClient(interfaces12.GetAddress(1), 9);  // Address of node 2\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));  // Client on node 0\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing to capture packet transmissions\n    pointToPoint.EnablePcapAll(\"line-topology-3-nodes\");\n\n    // Run the simulation\n    Simulator::Run();\n\n    // End the simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 that creates a basic point-to-point network with two nodes connected by a point-to-point link. Assign IP addresses to the nodes, set up a UDP communication between them, and enable packet tracing. Finally, generate a NetAnim XML trace file for visualizing the network simulation. The animation should include node positions and packet transmission animations."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleNetAnimExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for debugging\n    LogComponentEnable(\"SimpleNetAnimExample\", LOG_LEVEL_INFO);\n\n    // Step 1: Create two nodes\n    NS_LOG_INFO(\"Creating nodes.\");\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Step 2: Set up a point-to-point link between nodes\n    NS_LOG_INFO(\"Creating point-to-point link.\");\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Step 3: Install the internet stack on the nodes\n    NS_LOG_INFO(\"Installing internet stack.\");\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Step 4: Assign IP addresses to the nodes\n    NS_LOG_INFO(\"Assigning IP addresses.\");\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Step 5: Set up UDP communication\n    NS_LOG_INFO(\"Setting up UDP server and client.\");\n    uint16_t port = 9; // port number for the application\n\n    // UDP Server on node 1\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // UDP Client on node 0\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Step 6: Enable packet tracing\n    NS_LOG_INFO(\"Enabling packet tracing.\");\n    AsciiTraceHelper ascii;\n    pointToPoint.EnableAsciiAll(ascii.CreateFileStream(\"simple-netanim.tr\"));\n\n    // Step 7: Set up NetAnim for visualizing the network\n    NS_LOG_INFO(\"Setting up NetAnim.\");\n    AnimationInterface anim(\"simple-netanim.xml\");\n\n    // Set node positions for visualization\n    anim.SetConstantPosition(nodes.Get(0), 0.0, 0.0);  // Node 0 at (0,0)\n    anim.SetConstantPosition(nodes.Get(1), 10.0, 0.0); // Node 1 at (10,0)\n\n    // Step 8: Run the simulation\n    NS_LOG_INFO(\"Running the simulation.\");\n    Simulator::Run();\n\n    // Step 9: Clean up and destroy the simulation\n    NS_LOG_INFO(\"Destroying the simulation.\");\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 library to demonstrate the use of the Object Names service with a network topology of four nodes connected by a CSMA LAN. Assign human-readable names to nodes and devices, such as \"client\" and \"server,\" and demonstrate renaming nodes in the name system. Configure attributes of CSMA devices using the Object Names service and mix object names and node attributes in the configuration system. Install a UDP echo server on the named \"server\" node and a UDP echo client on the named \"client\" node, with packet tracing enabled and the use of pcap files."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1   n2   n3\n//       |     |    |    |\n//       =================\n//              LAN\n//\n// This program demonstrates some basic use of the Object names capability\n//\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ObjectNamesExample\");\n\n/// Counter of the received bytes.\nuint32_t bytesReceived = 0;\n\n/**\n * Function called when a packet is received.\n *\n * \\param context The context.\n * \\param packet The received packet.\n */\nvoid\nRxEvent(std::string context, Ptr<const Packet> packet)\n{\n    std::cout << Simulator::Now().GetSeconds() << \"s \" << context << \" packet size \"\n              << packet->GetSize() << std::endl;\n    bytesReceived += packet->GetSize();\n}\n\nint\nmain(int argc, char* argv[])\n{\n    bool outputValidated = true;\n\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    NodeContainer n;\n    n.Create(4);\n\n    //\n    // We're going to use the zeroth node in the container as the client, and\n    // the first node as the server.  Add some \"human readable\" names for these\n    // nodes.  The names below will go into the name system as \"/Names/clientZero\"\n    // and \"/Names/server\", but note that the Add function assumes that if you\n    // omit the leading \"/Names/\" the remaining string is assumed to be rooted\n    // in the \"/Names\" namespace. The following calls,\n    //\n    //  Names::Add (\"clientZero\", n.Get (0));\n    //  Names::Add (\"/Names/clientZero\", n.Get (0));\n    //\n    // will produce identical results.\n    //\n    Names::Add(\"clientZero\", n.Get(0));\n    Names::Add(\"/Names/server\", n.Get(1));\n\n    //\n    // It is possible to rename a node that has been previously named.  This is\n    // useful in automatic name generation.  You can automatically generate node\n    // names such as, \"node-0\", \"node-1\", etc., and then go back and change\n    // the name of some distinguished node to another value --  \"access-point\"\n    // for example.  We illustrate this by just changing the client's name.\n    // As is typical of the object name service, you can either provide or elide\n    // the \"/Names\" prefix as you choose.\n    //\n    Names::Rename(\"clientZero\", \"client\");\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    //\n    // Add some human readable names for the devices we'll be interested in.\n    // We add the names to the name space \"under\" the nodes we created above.\n    // This has the effect of making \"/Names/client/eth0\" and \"/Names/server/eth0\".\n    // In this case, we again omit the \"/Names/\" prefix on one call to illustrate\n    // the shortcut.\n    //\n    Names::Add(\"/Names/client/eth0\", d.Get(0));\n    Names::Add(\"server/eth0\", d.Get(1));\n\n    //\n    // You can use the object names that you've assigned in calls to the Config\n    // system to set Object Attributes.  For example, you can set the Mtu\n    // Attribute of a Csma devices using the object naming service.  Note that\n    // in this case, the \"/Names\" prefix is always required since the _Config_\n    // system always expects to see a fully qualified path name.\n    //\n\n    Ptr<CsmaNetDevice> csmaNetDevice = d.Get(0)->GetObject<CsmaNetDevice>();\n    UintegerValue val;\n    csmaNetDevice->GetAttribute(\"Mtu\", val);\n    std::cout << \"MTU on device 0 before configuration is \" << val.Get() << std::endl;\n\n    Config::Set(\"/Names/client/eth0/Mtu\", UintegerValue(1234));\n\n    // Check the attribute again\n    csmaNetDevice->GetAttribute(\"Mtu\", val);\n    std::cout << \"MTU on device 0 after configuration is \" << val.Get() << std::endl;\n\n    if (val.Get() != 1234)\n    {\n        outputValidated = false;\n    }\n\n    //\n    // You can mix and match names and Attributes in calls to the Config system.\n    // For example, if \"eth0\" is a named object, you can get to its parent through\n    // a different namespace.  For example, you could use the NodeList namespace\n    // to get to the server node, and then continue seamlessly adding named objects\n    // in the path. This is not nearly as readable as the previous version, but it\n    // illustrates how you can mix and match object names and Attribute names.\n    // Note that the config path now begins with a path in the \"/NodeList\"\n    // namespace.\n    //\n    Config::Set(\"/NodeList/1/eth0/Mtu\", UintegerValue(1234));\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(d);\n\n    uint16_t port = 9;\n    UdpEchoServerHelper server(port);\n    //\n    // Install the UdpEchoServer application on the server node using its name\n    // directly.\n    //\n    ApplicationContainer apps = server.Install(\"/Names/server\");\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 1;\n    Time interPacketInterval = Seconds(1.);\n    UdpEchoClientHelper client(i.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n    //\n    // Install the UdpEchoClient application on the server node using its name\n    // directly.\n    //\n    apps = client.Install(\"/Names/client\");\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    //\n    // Use the Config system to connect a trace source using the object name\n    // service to specify the path.  Note that in this case, the \"/Names\"\n    // prefix is always required since the _Config_ system always expects to\n    // see a fully qualified path name\n    //\n    Config::Connect(\"/Names/client/eth0/MacRx\", MakeCallback(&RxEvent));\n\n    //\n    // Set up some pcap tracing on the CSMA devices.  The names of the trace\n    // files will automatically correspond to the object names if present.\n    // In this case, you will find trace files called:\n    //\n    //   object-names-client-eth0.pcap\n    //   object-names-server-eth0.pcap\n    //\n    // since those nodes and devices have had names associated with them.  You\n    // will also see:\n    //\n    //   object-names-2-1.pcap\n    //   object-names-3-1.pcap\n    //\n    // since nodes two and three have no associated names.\n    //\n    csma.EnablePcapAll(\"object-names\");\n\n    //\n    // We can also create a trace file with a name we completely control by\n    // overriding a couple of default parameters.\n    //\n    csma.EnablePcap(\"client-device.pcap\", d.Get(0), false, true);\n\n    std::cout << \"Running simulation...\" << std::endl;\n    Simulator::Run();\n    Simulator::Destroy();\n\n    // Expected to see ARP exchange and one packet\n    // 64 bytes (minimum Ethernet frame size) x 2, plus (1024 + 8 + 20 + 18)\n    if (bytesReceived != (64 + 64 + 1070))\n    {\n        outputValidated = false;\n    }\n\n    if (!outputValidated)\n    {\n        std::cerr << \"Program internal checking failed; returning with error\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Vehicular Ad-Hoc Network (VANET) in ns-3 with 5 moving vehicles. Use the 802.11p (WAVE) standard for wireless communication between vehicles. Set up a scenario where vehicles exchange periodic messages (Basic Safety Messages - BSM) to simulate vehicle-to-vehicle (V2V) communication. Visualize the simulation using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wave-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"VANETExample\");\n\nclass BsmApplication : public Application\n{\npublic:\n    BsmApplication() {}\n    virtual ~BsmApplication() {}\n\nprotected:\n    virtual void StartApplication()\n    {\n        m_sendEvent = Simulator::Schedule(Seconds(1.0), &BsmApplication::SendBsm, this);\n    }\n\n    virtual void StopApplication()\n    {\n        Simulator::Cancel(m_sendEvent);\n    }\n\n    void SendBsm()\n    {\n        NS_LOG_INFO(\"Sending BSM (Basic Safety Message)\");\n        // Here we could add code to actually send a packet, but for now, it's just a log message\n        m_sendEvent = Simulator::Schedule(Seconds(1.0), &BsmApplication::SendBsm, this);\n    }\n\nprivate:\n    EventId m_sendEvent;\n};\n\nint main(int argc, char *argv[])\n{\n    // Create nodes for the vehicles\n    NodeContainer vehicleNodes;\n    vehicleNodes.Create(5); // 5 vehicles\n\n    // Set up the mobility model for vehicle movement\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n\n    // Position vehicles along a straight road\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(50.0),\n                                  \"GridWidth\", UintegerValue(5),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.Install(vehicleNodes);\n\n    // Set constant velocity for vehicles (50 m/s)\n    for (uint32_t i = 0; i < vehicleNodes.GetN(); ++i)\n    {\n        Ptr<ConstantVelocityMobilityModel> mobilityModel = vehicleNodes.Get(i)->GetObject<ConstantVelocityMobilityModel>();\n        mobilityModel->SetVelocity(Vector(50.0, 0.0, 0.0));\n    }\n\n    // Install Wave (802.11p) devices on vehicles\n    YansWifiPhyHelper wavePhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper waveChannel = YansWifiChannelHelper::Default();\n    wavePhy.SetChannel(waveChannel.Create());\n\n    NqosWaveMacHelper waveMac = NqosWaveMacHelper::Default();\n    Wifi80211pHelper waveHelper = Wifi80211pHelper::Default();\n\n    NetDeviceContainer vehicleDevices;\n    vehicleDevices = waveHelper.Install(wavePhy, waveMac, vehicleNodes);\n\n    // Install Internet stack on all vehicles\n    InternetStackHelper internet;\n    internet.Install(vehicleNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vehicleInterfaces = ipv4.Assign(vehicleDevices);\n\n    // Install BSM application on vehicles\n    for (uint32_t i = 0; i < vehicleNodes.GetN(); ++i)\n    {\n        Ptr<BsmApplication> app = CreateObject<BsmApplication>();\n        vehicleNodes.Get(i)->AddApplication(app);\n        app->SetStartTime(Seconds(1.0));\n        app->SetStopTime(Seconds(10.0));\n    }\n\n    // Enable NetAnim tracing\n    AnimationInterface anim(\"vanet_netanim.xml\");\n    anim.SetConstantPosition(vehicleNodes.Get(0), 0.0, 0.0);\n    anim.SetConstantPosition(vehicleNodes.Get(1), 50.0, 0.0);\n    anim.SetConstantPosition(vehicleNodes.Get(2), 100.0, 0.0);\n    anim.SetConstantPosition(vehicleNodes.Get(3), 150.0, 0.0);\n    anim.SetConstantPosition(vehicleNodes.Get(4), 200.0, 0.0);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a CSMA (Ethernet-based) network with four nodes. The first node should act as a TCP server on port 8080, while the other three nodes should be TCP clients sending data to the server at 5 Mbps. The CSMA network should have a 100 Mbps data rate with a propagation delay of 6560 ns. The simulation should run for 10 seconds, and packet capture (PCAP) should be enabled for analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CsmaTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"CsmaTcpExample\", LOG_LEVEL_INFO);\n\n    // Create CSMA nodes\n    NodeContainer csmaNodes;\n    csmaNodes.Create(4);\n\n    // Set up CSMA channel\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install CSMA devices on nodes\n    NetDeviceContainer csmaDevices;\n    csmaDevices = csma.Install(csmaNodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(csmaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer csmaInterfaces = address.Assign(csmaDevices);\n\n    // Set up a TCP server on node 0\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(csmaInterfaces.GetAddress(0), port));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = sinkHelper.Install(csmaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP clients on nodes 1, 2, and 3\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    clientHelper.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    clientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 1; i < 4; ++i)\n    {\n        clientApps.Add(clientHelper.Install(csmaNodes.Get(i)));\n    }\n\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable tracing\n    csma.EnablePcap(\"csma-tcp\", csmaDevices.Get(1), true);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple TCP connection between two nodes in NS-3. Node 0 (sender) sends data to Node 1 (receiver) using TCP over a connection. Both nodes should have IP addresses from the range 10.1.1.0/24. The server (Node 1) listens on port 9, and the client (Node 0) sends data packets of size 1024 bytes every millisecond for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(nodes);\n\n    // Set up TCP server (Receiver) on Node 1\n    uint16_t port = 9;\n    TcpServerHelper server(port);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up TCP client (Sender) on Node 0\n    TcpClientHelper client(interfaces.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(1)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that creates a point-to-point network between two nodes with a 10 Mbps data rate and a 2 ms propagation delay. The nodes should use the 10.1.1.0/24 subnet. Node 1 should act as a TCP server listening on port 8080, and Node 0 should be a TCP client sending a maximum of 500,000 bytes of data. The server should start at 1 second and the client at 2 seconds, with the simulation running for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleP2PExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure point-to-point connection\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on both nodes\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Configure TCP Server on Node 1\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper tcpSink(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = tcpSink.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Configure TCP Client on Node 0\n    BulkSendHelper tcpClient(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    tcpClient.SetAttribute(\"MaxBytes\", UintegerValue(500000));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run Simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library to simulate a three-router network topology where nodes A, B, and C are connected via point-to-point links. Configure static routing for the communication between the nodes, using /32 IP addressing for specific interfaces. Set up point-to-point channels with a specified data rate and delay. Assign appropriate IP addresses to the interfaces, and configure static routes from node A to node C through node B. Additionally, create an OnOff application on node A to send UDP packets to node C, and a packet sink on node C to receive these packets. Enable tracing and packet capture for the simulation."}, {"role": "assistant", "content": "// Test program for this 3-router scenario, using static routing\n//\n// (a.a.a.a/32)A<--x.x.x.0/30-->B<--y.y.y.0/30-->C(c.c.c.c/32)\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"StaticRoutingSlash32Test\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Ptr<Node> nA = CreateObject<Node>();\n    Ptr<Node> nB = CreateObject<Node>();\n    Ptr<Node> nC = CreateObject<Node>();\n\n    NodeContainer c = NodeContainer(nA, nB, nC);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // Point-to-point links\n    NodeContainer nAnB = NodeContainer(nA, nB);\n    NodeContainer nBnC = NodeContainer(nB, nC);\n\n    // We create the channels first without any IP addressing information\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer dAdB = p2p.Install(nAnB);\n\n    NetDeviceContainer dBdC = p2p.Install(nBnC);\n\n    Ptr<CsmaNetDevice> deviceA = CreateObject<CsmaNetDevice>();\n    deviceA->SetAddress(Mac48Address::Allocate());\n    nA->AddDevice(deviceA);\n    deviceA->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    Ptr<CsmaNetDevice> deviceC = CreateObject<CsmaNetDevice>();\n    deviceC->SetAddress(Mac48Address::Allocate());\n    nC->AddDevice(deviceC);\n    deviceC->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    // Later, we add IP addresses.\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iAiB = ipv4.Assign(dAdB);\n\n    ipv4.SetBase(\"10.1.1.4\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iBiC = ipv4.Assign(dBdC);\n\n    Ptr<Ipv4> ipv4A = nA->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4B = nB->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4C = nC->GetObject<Ipv4>();\n\n    int32_t ifIndexA = ipv4A->AddInterface(deviceA);\n    int32_t ifIndexC = ipv4C->AddInterface(deviceC);\n\n    Ipv4InterfaceAddress ifInAddrA =\n        Ipv4InterfaceAddress(Ipv4Address(\"172.16.1.1\"), Ipv4Mask(\"/32\"));\n    ipv4A->AddAddress(ifIndexA, ifInAddrA);\n    ipv4A->SetMetric(ifIndexA, 1);\n    ipv4A->SetUp(ifIndexA);\n\n    Ipv4InterfaceAddress ifInAddrC =\n        Ipv4InterfaceAddress(Ipv4Address(\"192.168.1.1\"), Ipv4Mask(\"/32\"));\n    ipv4C->AddAddress(ifIndexC, ifInAddrC);\n    ipv4C->SetMetric(ifIndexC, 1);\n    ipv4C->SetUp(ifIndexC);\n\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    // Create static routes from A to C\n    Ptr<Ipv4StaticRouting> staticRoutingA = ipv4RoutingHelper.GetStaticRouting(ipv4A);\n    // The ifIndex for this outbound route is 1; the first p2p link added\n    staticRoutingA->AddHostRouteTo(Ipv4Address(\"192.168.1.1\"), Ipv4Address(\"10.1.1.2\"), 1);\n    Ptr<Ipv4StaticRouting> staticRoutingB = ipv4RoutingHelper.GetStaticRouting(ipv4B);\n    // The ifIndex we want on node B is 2; 0 corresponds to loopback, and 1 to the first point to\n    // point link\n    staticRoutingB->AddHostRouteTo(Ipv4Address(\"192.168.1.1\"), Ipv4Address(\"10.1.1.6\"), 2);\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(ifInAddrC.GetLocal(), port)));\n    onoff.SetConstantRate(DataRate(6000));\n    ApplicationContainer apps = onoff.Install(nA);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(nC);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"static-routing-slash32.tr\"));\n    p2p.EnablePcapAll(\"static-routing-slash32\");\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a TCP client-server communication. There are two nodes: Node 0 (client) and Node 1 (server). The server listens on TCP port 8080 and starts accepting connections at 1 second, stopping at 10 seconds. The client sends 10 TCP packets, each of 1024 bytes, with an interval of 1 second, starting at 2 seconds and stopping at 10 seconds. Both nodes should have IP addresses in the subnet 10.1.1.0/24."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpClientServerExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"TcpClientServerExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the network\n    NodeContainer nodes;\n    nodes.Create(2); // Two nodes: Client and Server\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Set up IP addresses for the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(nodes.Get(0), nodes.Get(1));\n\n    // Set up the TCP server application on Node 1 (Server)\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(interfaces.GetAddress(1), port));\n    TcpServerHelper tcpServer(port);                                  // TCP port 8080\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1)); // Install on Node 1 (Server)\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the TCP client application on Node 0 (Client)\n    TcpClientHelper tcpClient(serverAddress);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));          // Number of packets to send\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));      // Interval between packets\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));        // Packet size in bytes\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0)); // Install on Node 0 (Client)\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a mobile node communicates with a static node using an Ad-hoc Wi-Fi (802.11s) network. The mobile node moves in a straight line while sending UDP packets to the static node, which logs the received data."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocWifiUdpExample\");\n\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a UDP packet!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"AdhocWifiUdpExample\", LOG_LEVEL_INFO);\n\n    uint16_t port = 5001;\n\n    // Create nodes (mobile client and static server)\n    NodeContainer nodes;\n    nodes.Create(2);\n    Ptr<Node> mobileNode = nodes.Get(0);\n    Ptr<Node> staticNode = nodes.Get(1);\n\n    // Configure Ad-hoc Wi-Fi (802.11s)\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211s);\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Mobility model (mobile node moves, static node stays)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\", \"Position\", Vector3DValue(Vector3D(0, 0, 0)));\n    mobility.Install(staticNode);\n\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(mobileNode);\n    mobileNode->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(5.0, 0.0, 0.0)); // Moves at 5 m/s\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Setup UDP Server (Static Node)\n    Ptr<Socket> serverSocket = Socket::CreateSocket(staticNode, UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client (Mobile Node)\n    Ptr<Socket> clientSocket = Socket::CreateSocket(mobileNode, UdpSocketFactory::GetTypeId());\n    InetSocketAddress serverAddress(interfaces.GetAddress(1), port);\n\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, clientSocket, Create<Packet>(128), 0, serverAddress);\n    Simulator::Schedule(Seconds(2.0), &Socket::SendTo, clientSocket, Create<Packet>(128), 0, serverAddress);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(5.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 to simulate a simple UDP Echo Client with one node. The program should configure a point-to-point connection, set up an echo server, and have a client on the same node send packets to the server using the UDP protocol. The simulation should log packet transmissions and reception. Set a simple scenario with a 5Mbps link, 2ms delay, and include packet size and interval configuration"}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UDPEchoExample\");\n\nint \nmain(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"UDPEchoExample\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create a node\n    NodeContainer nodes;\n    nodes.Create(1); // One node for both client and server\n\n    // Point-to-point link configuration (though it's only one node)\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install the network stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n\n    // Create a loopback network device (since only one node is involved)\n    Ipv4InterfaceContainer interfaces;\n    interfaces = address.Assign(pointToPoint.Install(nodes));\n\n    // Create and set up UDP Echo Server\n    uint16_t port = 9; // Echo server port number\n    UdpEchoServerHelper echoServer(port);\n\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create and set up UDP Echo Client\n    uint32_t packetSize = 1024; // Packet size\n    uint32_t nPackets = 10;     // Number of packets to send\n    double interval = 1.0;      // Time between packets (1 second)\n    \n    UdpEchoClientHelper echoClient(interfaces.GetAddress(0), port);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(nPackets));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(interval)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simulation in NS-3 that demonstrates the classical hidden terminal problem and its solution using RTS/CTS in an ad-hoc Wi-Fi network. Set up a topology with three nodes, where node 0 and node 2 are hidden from each other, and both communicate with node 1. Use the MatrixPropagationLossModel to simulate a 50 dB loss between adjacent nodes. Configure the simulation to use 802.11b Wi-Fi in ad-hoc mode, and install the Internet stack and IP addresses. Generate two CBR streams using the OnOffApplication, where node 0 sends to node 1, and node 2 sends to node 1, with each flow slightly staggered to avoid NS-3 bugs. Enable flow monitoring and simulate for 10 seconds, capturing performance statistics like throughput and packet loss. Run the simulation twice—once with RTS/CTS disabled and once with it enabled for packets larger than 100 bytes. Print out the flow statistics after each run."}, {"role": "assistant", "content": "/* Classical hidden terminal problem and its RTS/CTS solution.\n *\n * Topology: [node 0] <-- -50 dB --> [node 1] <-- -50 dB --> [node 2]\n *\n * This example illustrates the use of\n *  - Wifi in ad-hoc mode\n *  - Matrix propagation loss model\n *  - Use of OnOffApplication to generate CBR stream\n *  - IP flow monitor\n */\n\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/constant-position-mobility-model.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-flow-classifier.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/propagation-delay-model.h\"\n#include \"ns3/propagation-loss-model.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-echo-helper.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\n/**\n * Run single 10 seconds experiment\n *\n * \\param enableCtsRts if true, enable RTS/CTS for packets larger than 100 bytes.\n * \\param wifiManager WiFi manager to use.\n */\nvoid\nexperiment(bool enableCtsRts, std::string wifiManager)\n{\n    // 0. Enable or disable CTS/RTS\n    UintegerValue ctsThr = (enableCtsRts ? UintegerValue(100) : UintegerValue(2200));\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", ctsThr);\n\n    // 1. Create 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // 2. Place nodes somehow, this is required by every wireless simulation\n    for (uint8_t i = 0; i < 3; ++i)\n    {\n        nodes.Get(i)->AggregateObject(CreateObject<ConstantPositionMobilityModel>());\n    }\n\n    // 3. Create propagation loss matrix\n    Ptr<MatrixPropagationLossModel> lossModel = CreateObject<MatrixPropagationLossModel>();\n    lossModel->SetDefaultLoss(200); // set default loss to 200 dB (no link)\n    lossModel->SetLoss(nodes.Get(0)->GetObject<MobilityModel>(),\n                       nodes.Get(1)->GetObject<MobilityModel>(),\n                       50); // set symmetric loss 0 <-> 1 to 50 dB\n    lossModel->SetLoss(nodes.Get(2)->GetObject<MobilityModel>(),\n                       nodes.Get(1)->GetObject<MobilityModel>(),\n                       50); // set symmetric loss 2 <-> 1 to 50 dB\n\n    // 4. Create & setup wifi channel\n    Ptr<YansWifiChannel> wifiChannel = CreateObject<YansWifiChannel>();\n    wifiChannel->SetPropagationLossModel(lossModel);\n    wifiChannel->SetPropagationDelayModel(CreateObject<ConstantSpeedPropagationDelayModel>());\n\n    // 5. Install wireless devices\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n    wifi.SetRemoteStationManager(\"ns3::\" + wifiManager + \"WifiManager\");\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.SetChannel(wifiChannel);\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\"); // use ad-hoc MAC\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // uncomment the following to have athstats output\n    // AthstatsHelper athstats;\n    // athstats.EnableAthstats(enableCtsRts ? \"rtscts-athstats-node\" : \"basic-athstats-node\" ,\n    // nodes);\n\n    // uncomment the following to have pcap output\n    // wifiPhy.SetPcapDataLinkType (WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    // wifiPhy.EnablePcap (enableCtsRts ? \"rtscts-pcap-node\" : \"basic-pcap-node\" , nodes);\n\n    // 6. Install TCP/IP stack & assign IP addresses\n    InternetStackHelper internet;\n    internet.Install(nodes);\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.0.0.0\");\n    ipv4.Assign(devices);\n\n    // 7. Install applications: two CBR streams each saturating the channel\n    ApplicationContainer cbrApps;\n    uint16_t cbrPort = 12345;\n    OnOffHelper onOffHelper(\"ns3::UdpSocketFactory\",\n                            InetSocketAddress(Ipv4Address(\"10.0.0.2\"), cbrPort));\n    onOffHelper.SetAttribute(\"PacketSize\", UintegerValue(1400));\n    onOffHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    // flow 1:  node 0 -> node 1\n    onOffHelper.SetAttribute(\"DataRate\", StringValue(\"3000000bps\"));\n    onOffHelper.SetAttribute(\"StartTime\", TimeValue(Seconds(1.000000)));\n    cbrApps.Add(onOffHelper.Install(nodes.Get(0)));\n\n    // flow 2:  node 2 -> node 1\n    /**\n     * \\internal\n     * The slightly different start times and data rates are a workaround\n     * for \\bugid{388} and \\bugid{912}\n     */\n    onOffHelper.SetAttribute(\"DataRate\", StringValue(\"3001100bps\"));\n    onOffHelper.SetAttribute(\"StartTime\", TimeValue(Seconds(1.001)));\n    cbrApps.Add(onOffHelper.Install(nodes.Get(2)));\n\n    /**\n     * \\internal\n     * We also use separate UDP applications that will send a single\n     * packet before the CBR flows start.\n     * This is a workaround for the lack of perfect ARP, see \\bugid{187}\n     */\n    uint16_t echoPort = 9;\n    UdpEchoClientHelper echoClientHelper(Ipv4Address(\"10.0.0.2\"), echoPort);\n    echoClientHelper.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClientHelper.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    echoClientHelper.SetAttribute(\"PacketSize\", UintegerValue(10));\n    ApplicationContainer pingApps;\n\n    // again using different start times to workaround Bug 388 and Bug 912\n    echoClientHelper.SetAttribute(\"StartTime\", TimeValue(Seconds(0.001)));\n    pingApps.Add(echoClientHelper.Install(nodes.Get(0)));\n    echoClientHelper.SetAttribute(\"StartTime\", TimeValue(Seconds(0.006)));\n    pingApps.Add(echoClientHelper.Install(nodes.Get(2)));\n\n    // 8. Install FlowMonitor on all nodes\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // 9. Run simulation for 10 seconds\n    Simulator::Stop(Seconds(10));\n    Simulator::Run();\n\n    // 10. Print per flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n    for (auto i = stats.begin(); i != stats.end(); ++i)\n    {\n        // first 2 FlowIds are for ECHO apps, we don't want to display them\n        //\n        // Duration for throughput measurement is 9.0 seconds, since\n        //   StartTime of the OnOffApplication is at about \"second 1\"\n        // and\n        //   Simulator::Stops at \"second 10\".\n        if (i->first > 2)\n        {\n            Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n            std::cout << \"Flow \" << i->first - 2 << \" (\" << t.sourceAddress << \" -> \"\n                      << t.destinationAddress << \")\\n\";\n            std::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n            std::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n            std::cout << \"  TxOffered:  \" << i->second.txBytes * 8.0 / 9.0 / 1000 / 1000\n                      << \" Mbps\\n\";\n            std::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n            std::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n            std::cout << \"  Throughput: \" << i->second.rxBytes * 8.0 / 9.0 / 1000 / 1000\n                      << \" Mbps\\n\";\n        }\n    }\n\n    // 11. Cleanup\n    Simulator::Destroy();\n}\n\nint\nmain(int argc, char** argv)\n{\n    std::string wifiManager(\"Arf\");\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\n        \"wifiManager\",\n        \"Set wifi rate manager (Aarf, Aarfcd, Amrr, Arf, Cara, Ideal, Minstrel, Onoe, Rraa)\",\n        wifiManager);\n    cmd.Parse(argc, argv);\n\n    std::cout << \"Hidden station experiment with RTS/CTS disabled:\\n\" << std::flush;\n    experiment(false, wifiManager);\n    std::cout << \"------------------------------------------------\\n\";\n    std::cout << \"Hidden station experiment with RTS/CTS enabled:\\n\";\n    experiment(true, wifiManager);\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation demonstrating Wi-Fi communication between two nodes using the 802.11n standard in Ad-hoc mode. The simulation should include a UDP client-server application for testing data transmission, and it should generate a NetAnim visualization to display packet exchanges between the nodes."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiAdhocExample\");\n\nint main(int argc, char *argv[])\n{\n    // Simulation time\n    double simulationTime = 10.0; // seconds\n\n    // Create two nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Set up Wi-Fi and PHY layers for the nodes\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);  // Use the 802.11n standard (5 GHz)\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Use Ad-hoc mode (no infrastructure like APs)\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, wifiNodes);\n\n    // Install internet stack on the nodes\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set mobility model for the nodes (placing them in fixed positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Set up UDP server on Node 1\n    uint16_t port = 9;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Set up UDP client on Node 0 to send packets to Node 1\n    UdpClientHelper client(interfaces.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    client.SetAttribute(\"Interval\", TimeValue(Seconds(0.05))); // 20 packets per second\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024)); // 1024 bytes per packet\n\n    ApplicationContainer clientApp = client.Install(wifiNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Set up NetAnim for visualization\n    AnimationInterface anim(\"wifi_adhoc_netanim.xml\");\n\n    // Set constant positions for NetAnim visualization\n    anim.SetConstantPosition(wifiNodes.Get(0), 1.0, 1.0);  // Client node\n    anim.SetConstantPosition(wifiNodes.Get(1), 5.0, 1.0);  // Server node\n\n    // Enable packet metadata in NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple TCP connection in NS-3 with two nodes over a point-to-point link. The first node sends TCP packets to the second node. Use a 10Mbps link speed and a 5ms delay. Capture the throughput using a flow monitor and run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link with a 10Mbps link speed and 5ms delay\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    // Install point-to-point devices\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP client application on node 0 (sender)\n    uint16_t port = 9;\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up TCP server application on node 1 (receiver)\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up flow monitor to capture throughput\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // Run the simulation\n    Simulator::Run();\n\n    // Print flow monitor statistics\n    monitor->CheckForLostPackets();\n    monitor->SerializeToXmlFile(\"tcp_flow_monitor.xml\", true, true);\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the NS-3 library to simulate a network topology with three nodes, where n1 and n3 are connected to n2 through point-to-point links. Configure the access link between n1 and n2 with 100 Mbps bandwidth and 0.1 ms delay, while the bottleneck link between n2 and n3 has adjustable bandwidth and delay parameters. Implement several queue disc types, including PfifoFast, ARED, CoDel, FqCoDel, and PIE, for traffic control on the bottleneck link, and allow the option to enable Byte Queue Limits (BQL). Generate bidirectional TCP flows between n1 and n3, and monitor the goodput. Additionally, n1 should ping n3 to measure RTT. Output trace files for queue limits, bytes in the queue, goodput, and flow statistics."}, {"role": "assistant", "content": "// This example serves as a benchmark for all the queue discs (with BQL enabled or not)\n//\n// Network topology\n//\n//                192.168.1.0                             192.168.2.0\n// n1 ------------------------------------ n2 ----------------------------------- n3\n//   point-to-point (access link)                point-to-point (bottleneck link)\n//   100 Mbps, 0.1 ms                            bandwidth [10 Mbps], delay [5 ms]\n//   qdiscs PfifoFast with capacity              qdiscs queueDiscType in {PfifoFast, ARED, CoDel,\n//   FqCoDel, PIE} [PfifoFast] of 1000 packets                             with capacity of\n//   queueDiscSize packets [1000] netdevices queues with size of 100 packets  netdevices queues with\n//   size of netdevicesQueueSize packets [100] without BQL                                 bql BQL\n//   [false]\n//   *** fixed configuration ***\n//\n// Two TCP flows are generated: one from n1 to n3 and the other from n3 to n1.\n// Additionally, n1 pings n3, so that the RTT can be measured.\n//\n// The output will consist of a number of ping Rtt such as:\n//\n//    /NodeList/0/ApplicationList/2/$ns3::Ping/Rtt=111 ms\n//    /NodeList/0/ApplicationList/2/$ns3::Ping/Rtt=111 ms\n//    /NodeList/0/ApplicationList/2/$ns3::Ping/Rtt=110 ms\n//    /NodeList/0/ApplicationList/2/$ns3::Ping/Rtt=111 ms\n//    /NodeList/0/ApplicationList/2/$ns3::Ping/Rtt=111 ms\n//    /NodeList/0/ApplicationList/2/$ns3::Ping/Rtt=112 ms\n//    /NodeList/0/ApplicationList/2/$ns3::Ping/Rtt=111 ms\n//\n// The files output will consist of a trace file with bytes in queue and of a trace file for limits\n// (when BQL is enabled) both for bottleneck NetDevice on n2, two files with upload and download\n// goodput for flows configuration and a file with flow monitor stats.\n//\n// If you use an AQM as queue disc on the bottleneck netdevices, you can observe that the ping Rtt\n// decrease. A further decrease can be observed when you enable BQL.\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BenchmarkQueueDiscs\");\n\n/**\n * Print the queue limits.\n *\n * \\param stream The output stream.\n * \\param oldVal Old value.\n * \\param newVal New value.\n */\nvoid\nLimitsTrace(Ptr<OutputStreamWrapper> stream, uint32_t oldVal, uint32_t newVal)\n{\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << newVal << std::endl;\n}\n\n/**\n * Print the bytes in the queue.\n *\n * \\param stream The output stream.\n * \\param oldVal Old value.\n * \\param newVal New value.\n */\nvoid\nBytesInQueueTrace(Ptr<OutputStreamWrapper> stream, uint32_t oldVal, uint32_t newVal)\n{\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << newVal << std::endl;\n}\n\n/**\n * Sample and print the queue goodput.\n *\n * \\param app The Tx app.\n * \\param stream The output stream.\n * \\param period The sampling period.\n */\nstatic void\nGoodputSampling(ApplicationContainer app, Ptr<OutputStreamWrapper> stream, float period)\n{\n    Simulator::Schedule(Seconds(period), &GoodputSampling, app, stream, period);\n    double goodput;\n    uint64_t totalPackets = DynamicCast<PacketSink>(app.Get(0))->GetTotalRx();\n    goodput = totalPackets * 8 / (Simulator::Now().GetSeconds() * 1024); // Kbit/s\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << goodput << std::endl;\n}\n\n/**\n * Print the ping RTT.\n *\n * \\param context The context.\n * \\param rtt The RTT.\n */\nstatic void\nPingRtt(std::string context, uint16_t, Time rtt)\n{\n    std::cout << context << \"=\" << rtt.GetMilliSeconds() << \" ms\" << std::endl;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string bandwidth = \"10Mbps\";\n    std::string delay = \"5ms\";\n    std::string queueDiscType = \"PfifoFast\";\n    uint32_t queueDiscSize = 1000;\n    uint32_t netdevicesQueueSize = 50;\n    bool bql = false;\n\n    std::string flowsDatarate = \"20Mbps\";\n    uint32_t flowsPacketsSize = 1000;\n\n    float startTime = 0.1F; // in s\n    float simDuration = 60;\n    float samplingPeriod = 1;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"bandwidth\", \"Bottleneck bandwidth\", bandwidth);\n    cmd.AddValue(\"delay\", \"Bottleneck delay\", delay);\n    cmd.AddValue(\"queueDiscType\",\n                 \"Bottleneck queue disc type in {PfifoFast, ARED, CoDel, FqCoDel, PIE, prio}\",\n                 queueDiscType);\n    cmd.AddValue(\"queueDiscSize\", \"Bottleneck queue disc size in packets\", queueDiscSize);\n    cmd.AddValue(\"netdevicesQueueSize\",\n                 \"Bottleneck netdevices queue size in packets\",\n                 netdevicesQueueSize);\n    cmd.AddValue(\"bql\", \"Enable byte queue limits on bottleneck netdevices\", bql);\n    cmd.AddValue(\"flowsDatarate\", \"Upload and download flows datarate\", flowsDatarate);\n    cmd.AddValue(\"flowsPacketsSize\", \"Upload and download flows packets sizes\", flowsPacketsSize);\n    cmd.AddValue(\"startTime\", \"Simulation start time\", startTime);\n    cmd.AddValue(\"simDuration\", \"Simulation duration in seconds\", simDuration);\n    cmd.AddValue(\"samplingPeriod\", \"Goodput sampling period in seconds\", samplingPeriod);\n    cmd.Parse(argc, argv);\n\n    float stopTime = startTime + simDuration;\n\n    // Create nodes\n    NodeContainer n1;\n    NodeContainer n2;\n    NodeContainer n3;\n    n1.Create(1);\n    n2.Create(1);\n    n3.Create(1);\n\n    // Create and configure access link and bottleneck link\n    PointToPointHelper accessLink;\n    accessLink.SetDeviceAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    accessLink.SetChannelAttribute(\"Delay\", StringValue(\"0.1ms\"));\n    accessLink.SetQueue(\"ns3::DropTailQueue\", \"MaxSize\", StringValue(\"100p\"));\n\n    PointToPointHelper bottleneckLink;\n    bottleneckLink.SetDeviceAttribute(\"DataRate\", StringValue(bandwidth));\n    bottleneckLink.SetChannelAttribute(\"Delay\", StringValue(delay));\n    bottleneckLink.SetQueue(\"ns3::DropTailQueue\",\n                            \"MaxSize\",\n                            StringValue(std::to_string(netdevicesQueueSize) + \"p\"));\n\n    InternetStackHelper stack;\n    stack.InstallAll();\n\n    // Access link traffic control configuration\n    TrafficControlHelper tchPfifoFastAccess;\n    tchPfifoFastAccess.SetRootQueueDisc(\"ns3::PfifoFastQueueDisc\", \"MaxSize\", StringValue(\"1000p\"));\n\n    // Bottleneck link traffic control configuration\n    TrafficControlHelper tchBottleneck;\n\n    if (queueDiscType == \"PfifoFast\")\n    {\n        tchBottleneck.SetRootQueueDisc(\n            \"ns3::PfifoFastQueueDisc\",\n            \"MaxSize\",\n            QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, queueDiscSize)));\n    }\n    else if (queueDiscType == \"ARED\")\n    {\n        tchBottleneck.SetRootQueueDisc(\"ns3::RedQueueDisc\");\n        Config::SetDefault(\"ns3::RedQueueDisc::ARED\", BooleanValue(true));\n        Config::SetDefault(\"ns3::RedQueueDisc::MaxSize\",\n                           QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, queueDiscSize)));\n    }\n    else if (queueDiscType == \"CoDel\")\n    {\n        tchBottleneck.SetRootQueueDisc(\"ns3::CoDelQueueDisc\");\n        Config::SetDefault(\"ns3::CoDelQueueDisc::MaxSize\",\n                           QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, queueDiscSize)));\n    }\n    else if (queueDiscType == \"FqCoDel\")\n    {\n        tchBottleneck.SetRootQueueDisc(\"ns3::FqCoDelQueueDisc\");\n        Config::SetDefault(\"ns3::FqCoDelQueueDisc::MaxSize\",\n                           QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, queueDiscSize)));\n    }\n    else if (queueDiscType == \"PIE\")\n    {\n        tchBottleneck.SetRootQueueDisc(\"ns3::PieQueueDisc\");\n        Config::SetDefault(\"ns3::PieQueueDisc::MaxSize\",\n                           QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, queueDiscSize)));\n    }\n    else if (queueDiscType == \"prio\")\n    {\n        uint16_t handle =\n            tchBottleneck.SetRootQueueDisc(\"ns3::PrioQueueDisc\",\n                                           \"Priomap\",\n                                           StringValue(\"0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\"));\n        TrafficControlHelper::ClassIdList cid =\n            tchBottleneck.AddQueueDiscClasses(handle, 2, \"ns3::QueueDiscClass\");\n        tchBottleneck.AddChildQueueDisc(handle, cid[0], \"ns3::FifoQueueDisc\");\n        tchBottleneck.AddChildQueueDisc(handle, cid[1], \"ns3::RedQueueDisc\");\n    }\n    else\n    {\n        NS_ABORT_MSG(\"--queueDiscType not valid\");\n    }\n\n    if (bql)\n    {\n        tchBottleneck.SetQueueLimits(\"ns3::DynamicQueueLimits\");\n    }\n\n    NetDeviceContainer devicesAccessLink = accessLink.Install(n1.Get(0), n2.Get(0));\n    tchPfifoFastAccess.Install(devicesAccessLink);\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n    address.NewNetwork();\n    Ipv4InterfaceContainer interfacesAccess = address.Assign(devicesAccessLink);\n\n    NetDeviceContainer devicesBottleneckLink = bottleneckLink.Install(n2.Get(0), n3.Get(0));\n    QueueDiscContainer qdiscs;\n    qdiscs = tchBottleneck.Install(devicesBottleneckLink);\n\n    address.NewNetwork();\n    Ipv4InterfaceContainer interfacesBottleneck = address.Assign(devicesBottleneckLink);\n\n    Ptr<NetDeviceQueueInterface> interface =\n        devicesBottleneckLink.Get(0)->GetObject<NetDeviceQueueInterface>();\n    Ptr<NetDeviceQueue> queueInterface = interface->GetTxQueue(0);\n    Ptr<DynamicQueueLimits> queueLimits =\n        StaticCast<DynamicQueueLimits>(queueInterface->GetQueueLimits());\n\n    AsciiTraceHelper ascii;\n    if (bql)\n    {\n        queueDiscType = queueDiscType + \"-bql\";\n        Ptr<OutputStreamWrapper> streamLimits =\n            ascii.CreateFileStream(queueDiscType + \"-limits.txt\");\n        queueLimits->TraceConnectWithoutContext(\"Limit\",\n                                                MakeBoundCallback(&LimitsTrace, streamLimits));\n    }\n    Ptr<Queue<Packet>> queue =\n        StaticCast<PointToPointNetDevice>(devicesBottleneckLink.Get(0))->GetQueue();\n    Ptr<OutputStreamWrapper> streamBytesInQueue =\n        ascii.CreateFileStream(queueDiscType + \"-bytesInQueue.txt\");\n    queue->TraceConnectWithoutContext(\"BytesInQueue\",\n                                      MakeBoundCallback(&BytesInQueueTrace, streamBytesInQueue));\n\n    Ipv4InterfaceContainer n1Interface;\n    n1Interface.Add(interfacesAccess.Get(0));\n\n    Ipv4InterfaceContainer n3Interface;\n    n3Interface.Add(interfacesBottleneck.Get(1));\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(flowsPacketsSize));\n\n    // Flows configuration\n    // Bidirectional TCP streams with ping like flent tcp_bidirectional test.\n    uint16_t port = 7;\n    ApplicationContainer uploadApp;\n    ApplicationContainer downloadApp;\n    ApplicationContainer sourceApps;\n    // Configure and install upload flow\n    Address addUp(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper sinkHelperUp(\"ns3::TcpSocketFactory\", addUp);\n    sinkHelperUp.SetAttribute(\"Protocol\", TypeIdValue(TcpSocketFactory::GetTypeId()));\n    uploadApp.Add(sinkHelperUp.Install(n3));\n\n    InetSocketAddress socketAddressUp = InetSocketAddress(n3Interface.GetAddress(0), port);\n    OnOffHelper onOffHelperUp(\"ns3::TcpSocketFactory\", Address());\n    onOffHelperUp.SetAttribute(\"Remote\", AddressValue(socketAddressUp));\n    onOffHelperUp.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffHelperUp.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    onOffHelperUp.SetAttribute(\"PacketSize\", UintegerValue(flowsPacketsSize));\n    onOffHelperUp.SetAttribute(\"DataRate\", StringValue(flowsDatarate));\n    sourceApps.Add(onOffHelperUp.Install(n1));\n\n    port = 8;\n    // Configure and install download flow\n    Address addDown(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper sinkHelperDown(\"ns3::TcpSocketFactory\", addDown);\n    sinkHelperDown.SetAttribute(\"Protocol\", TypeIdValue(TcpSocketFactory::GetTypeId()));\n    downloadApp.Add(sinkHelperDown.Install(n1));\n\n    InetSocketAddress socketAddressDown = InetSocketAddress(n1Interface.GetAddress(0), port);\n    OnOffHelper onOffHelperDown(\"ns3::TcpSocketFactory\", Address());\n    onOffHelperDown.SetAttribute(\"Remote\", AddressValue(socketAddressDown));\n    onOffHelperDown.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffHelperDown.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    onOffHelperDown.SetAttribute(\"PacketSize\", UintegerValue(flowsPacketsSize));\n    onOffHelperDown.SetAttribute(\"DataRate\", StringValue(flowsDatarate));\n    sourceApps.Add(onOffHelperDown.Install(n3));\n\n    // Configure and install ping\n    PingHelper ping(n3Interface.GetAddress(0));\n    ping.SetAttribute(\"VerboseMode\", EnumValue(Ping::VerboseMode::QUIET));\n    ping.Install(n1);\n\n    Config::Connect(\"/NodeList/*/ApplicationList/*/$ns3::Ping/Rtt\", MakeCallback(&PingRtt));\n\n    uploadApp.Start(Seconds(0));\n    uploadApp.Stop(Seconds(stopTime));\n    downloadApp.Start(Seconds(0));\n    downloadApp.Stop(Seconds(stopTime));\n\n    sourceApps.Start(Seconds(0 + 0.1));\n    sourceApps.Stop(Seconds(stopTime - 0.1));\n\n    Ptr<OutputStreamWrapper> uploadGoodputStream =\n        ascii.CreateFileStream(queueDiscType + \"-upGoodput.txt\");\n    Simulator::Schedule(Seconds(samplingPeriod),\n                        &GoodputSampling,\n                        uploadApp,\n                        uploadGoodputStream,\n                        samplingPeriod);\n    Ptr<OutputStreamWrapper> downloadGoodputStream =\n        ascii.CreateFileStream(queueDiscType + \"-downGoodput.txt\");\n    Simulator::Schedule(Seconds(samplingPeriod),\n                        &GoodputSampling,\n                        downloadApp,\n                        downloadGoodputStream,\n                        samplingPeriod);\n\n    // Flow monitor\n    Ptr<FlowMonitor> flowMonitor;\n    FlowMonitorHelper flowHelper;\n    flowMonitor = flowHelper.InstallAll();\n\n    accessLink.EnablePcapAll(\"queue\");\n\n    Simulator::Stop(Seconds(stopTime));\n    Simulator::Run();\n\n    flowMonitor->SerializeToXmlFile(queueDiscType + \"-flowMonitor.xml\", true, true);\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to model a network topology with multiple hosts and routers, including Host 0, Host 1, Router 0, Router 1, Router 2, and Router 3. Configure the network so that Host 0 communicates with Host 1 through a series of routers using loose source routing. Ensure that the program sets up the necessary connections between the nodes, assigns IPv6 addresses, and configures routing appropriately. Implement ICMPv6 echo requests from Host 0 to Host 1, using specified routers in the source routing process. Additionally, set up packet tracing to a file named 'loose-routing-ipv6.tr'."}, {"role": "assistant", "content": "// Network topology\n// //\n// //\n// //                               +------------+\n// //  +------------+           |---|  Router 1  |---|\n// //  |   Host 0   |--|        |   [------------]   |\n// //  [------------]  |        |                    |\n// //                  |  +------------+             |\n// //                  +--|            |       +------------+\n// //                     |  Router 0  |       |  Router 2  |\n// //                  +--|            |       [------------]\n// //                  |  [------------]             |\n// //  +------------+  |        |                    |\n// //  |   Host 1   |--|        |   +------------+   |\n// //  [------------]           |---|  Router 3  |---|\n// //                               [------------]\n// //\n// //\n// // - Tracing of queues and packet receptions to file \"loose-routing-ipv6.tr\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-header.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LooseRoutingIpv6Example\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        // LogComponentEnable(\"Ipv6ExtensionLooseRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Extension\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"NdiscCache\", LOG_LEVEL_ALL);\n    }\n\n    // LogComponentEnable(\"Ping\", LOG_LEVEL_INFO);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> h0 = CreateObject<Node>();\n    Ptr<Node> h1 = CreateObject<Node>();\n    Ptr<Node> r0 = CreateObject<Node>();\n    Ptr<Node> r1 = CreateObject<Node>();\n    Ptr<Node> r2 = CreateObject<Node>();\n    Ptr<Node> r3 = CreateObject<Node>();\n\n    NodeContainer net1(h0, r0);\n    NodeContainer net2(h1, r0);\n    NodeContainer net3(r0, r1);\n    NodeContainer net4(r1, r2);\n    NodeContainer net5(r2, r3);\n    NodeContainer net6(r3, r0);\n    NodeContainer all;\n    all.Add(h0);\n    all.Add(h1);\n    all.Add(r0);\n    all.Add(r1);\n    all.Add(r2);\n    all.Add(r3);\n\n    NS_LOG_INFO(\"Create IPv6 Internet Stack\");\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1500));\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d1 = csma.Install(net1);\n    NetDeviceContainer d2 = csma.Install(net2);\n    NetDeviceContainer d3 = csma.Install(net3);\n    NetDeviceContainer d4 = csma.Install(net4);\n    NetDeviceContainer d5 = csma.Install(net5);\n    NetDeviceContainer d6 = csma.Install(net6);\n\n    NS_LOG_INFO(\"Create networks and assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i1 = ipv6.Assign(d1);\n    i1.SetForwarding(1, true);\n    i1.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i2 = ipv6.Assign(d2);\n    i2.SetForwarding(1, true);\n    i2.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:3::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i3 = ipv6.Assign(d3);\n    i3.SetForwarding(0, true);\n    i3.SetDefaultRouteInAllNodes(0);\n    i3.SetForwarding(1, true);\n    i3.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:4::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i4 = ipv6.Assign(d4);\n    i4.SetForwarding(0, true);\n    i4.SetDefaultRouteInAllNodes(0);\n    i4.SetForwarding(1, true);\n    i4.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:5::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i5 = ipv6.Assign(d5);\n    i5.SetForwarding(0, true);\n    i5.SetDefaultRouteInAllNodes(0);\n    i5.SetForwarding(1, true);\n    i5.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:6::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i6 = ipv6.Assign(d6);\n    i6.SetForwarding(0, true);\n    i6.SetDefaultRouteInAllNodes(0);\n    i6.SetForwarding(1, true);\n    i6.SetDefaultRouteInAllNodes(1);\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    /**\n     * ICMPv6 Echo from h0 to h1 port 7\n     */\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 1;\n    Time interPacketInterval = Seconds(1.0);\n\n    std::vector<Ipv6Address> routersAddress;\n    routersAddress.push_back(i3.GetAddress(1, 1));\n    routersAddress.push_back(i4.GetAddress(1, 1));\n    routersAddress.push_back(i5.GetAddress(1, 1));\n    routersAddress.push_back(i6.GetAddress(1, 1));\n    routersAddress.push_back(i2.GetAddress(0, 1));\n\n    // remote address is first routers in RH0 => source routing\n    PingHelper client(i1.GetAddress(1, 1));\n    client.SetAttribute(\"Count\", UintegerValue(maxPacketCount));\n    client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    client.SetAttribute(\"Size\", UintegerValue(packetSize));\n    ApplicationContainer apps = client.Install(h0);\n    DynamicCast<Ping>(apps.Get(0))->SetRouters(routersAddress);\n\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(20.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"loose-routing-ipv6.tr\"));\n    csma.EnablePcapAll(\"loose-routing-ipv6\", true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 to simulate a bus topology with 3 nodes. All nodes are connected to a shared bus network using a CSMA (Carrier Sense Multiple Access) channel. Set up a UDP Echo server on node 2 and configure node 0 to send traffic to node 2 via the shared bus. Assign IP addresses and enable PCAP tracing to capture traffic. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BusTopology3Nodes\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"BusTopology3Nodes\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes: node 0, node 1, and node 2\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Set up CSMA (bus) channel between nodes\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install CSMA devices on the nodes\n    NetDeviceContainer devices = csma.Install(nodes);\n\n    // Install the internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a UDP Echo server on node 2\n    UdpEchoServerHelper echoServer(9);  // Port number\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(2));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 0 to send packets to node 2\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(2), 9);  // Address of node 2\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));  // Client on node 0\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing to capture packet transmissions\n    csma.EnablePcapAll(\"bus-topology-3-nodes\");\n\n    // Run the simulation\n    Simulator::Run();\n\n    // End the simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where multiple mobile nodes communicate using UDP over a MANET (Mobile Ad-Hoc Network). The nodes should use the AODV routing protocol for dynamic path discovery. Each node should periodically send packets to a randomly chosen neighbor. The simulation should model node mobility using the RandomWaypoint model and run for 20 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n#include <cstdlib>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpManetExample\");\n\n// Function to send UDP packets to a random neighbor\nvoid SendPacket(Ptr<Socket> socket, Ipv4InterfaceContainer &interfaces) {\n    int numNodes = interfaces.GetN();\n    int targetNode = rand() % numNodes; // Choose a random target node\n\n    Ipv4Address dstAddr = interfaces.GetAddress(targetNode);\n    Ptr<Packet> packet = Create<Packet>(512); // 512-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(dstAddr, 8080));\n\n    Simulator::Schedule(Seconds(2.0), &SendPacket, socket, interfaces); // Schedule next packet\n}\n\n// Function to receive packets\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Node received a packet in MANET!\");\n    }\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpManetExample\", LOG_LEVEL_INFO);\n\n    int numNodes = 10;\n    double simTime = 20.0;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(numNodes);\n\n    // Configure Wi-Fi (Ad-Hoc Mode)\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set up mobility (Random Waypoint Model)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=100]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=100]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", StringValue(\"ns3::UniformRandomVariable[Min=5.0|Max=10.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=2.0]\"));\n    mobility.Install(nodes);\n\n    // Install Internet stack with AODV\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Setup UDP sockets\n    for (int i = 0; i < numNodes; i++) {\n        Ptr<Socket> recvSocket = Socket::CreateSocket(nodes.Get(i), UdpSocketFactory::GetTypeId());\n        recvSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), 8080));\n        recvSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n        Ptr<Socket> sendSocket = Socket::CreateSocket(nodes.Get(i), UdpSocketFactory::GetTypeId());\n        Simulator::Schedule(Seconds(2.0 + i * 0.5), &SendPacket, sendSocket, interfaces);\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 network simulator to create a local area network (LAN) connecting four nodes. Implement UDP communication where node n0 sends and receives UDP packets to and from node n1 using UdpEchoServer and UdpEchoClient applications. Configure a DropTail queue on the network and enable tracing of queue lengths and packet receptions, saving the results to a file named \"udp-echo.tr.\" Simulate this setup for 10 seconds, using either IPv4 or IPv6, based on user input."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1   n2   n3\n//       |     |    |    |\n//       =================\n//              LAN\n//\n// - UDP flows from n0 to n1 and back\n// - DropTail queues\n// - Tracing of queues and packet receptions to file \"udp-echo.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpEchoExample\");\n\nint\nmain(int argc, char* argv[])\n{\n//\n// Users may find it convenient to turn on explicit debugging\n// for selected modules; the below lines suggest how to do this\n//\n#if 0\n  LogComponentEnable (\"UdpEchoExample\", LOG_LEVEL_INFO);\n  LogComponentEnable (\"UdpEchoClientApplication\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"UdpEchoServerApplication\", LOG_LEVEL_ALL);\n#endif\n    //\n    // Allow the user to override any of the defaults and the above Bind() at\n    // run-time, via command-line arguments\n    //\n    bool useV6 = false;\n    Address serverAddress;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"useIpv6\", \"Use Ipv6\", useV6);\n    cmd.Parse(argc, argv);\n    //\n    // Explicitly create the nodes required by the topology (shown above).\n    //\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer n;\n    n.Create(4);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    NS_LOG_INFO(\"Create channels.\");\n    //\n    // Explicitly create the channels required by the topology (shown above).\n    //\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    //\n    // We've got the \"hardware\" in place.  Now we need to add IP addresses.\n    //\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    if (!useV6)\n    {\n        Ipv4AddressHelper ipv4;\n        ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer i = ipv4.Assign(d);\n        serverAddress = Address(i.GetAddress(1));\n    }\n    else\n    {\n        Ipv6AddressHelper ipv6;\n        ipv6.SetBase(\"2001:0000:f00d:cafe::\", Ipv6Prefix(64));\n        Ipv6InterfaceContainer i6 = ipv6.Assign(d);\n        serverAddress = Address(i6.GetAddress(1, 1));\n    }\n\n    NS_LOG_INFO(\"Create Applications.\");\n    //\n    // Create a UdpEchoServer application on node one.\n    //\n    uint16_t port = 9; // well-known echo port number\n    UdpEchoServerHelper server(port);\n    ApplicationContainer apps = server.Install(n.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    //\n    // Create a UdpEchoClient application to send UDP datagrams from node zero to\n    // node one.\n    //\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 1;\n    Time interPacketInterval = Seconds(1.);\n    UdpEchoClientHelper client(serverAddress, port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n    apps = client.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n#if 0\n//\n// Users may find it convenient to initialize echo packets with actual data;\n// the below lines suggest how to do this\n//\n  client.SetFill (apps.Get (0), \"Hello World\");\n\n  client.SetFill (apps.Get (0), 0xa5, 1024);\n\n  uint8_t fill[] = { 0, 1, 2, 3, 4, 5, 6};\n  client.SetFill (apps.Get (0), fill, sizeof(fill), 1024);\n#endif\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"udp-echo.tr\"));\n    csma.EnablePcapAll(\"udp-echo\", false);\n\n    //\n    // Now, do the actual simulation.\n    //\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple WiFi communication simulation in NS-3 between two nodes where one acts as a UDP server and the other as a client. The nodes should communicate using 802.11b standard, with an SSID 'wifi-network'. Set the UDP client to send 1000 packets with a 10ms interval."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/point-to-point-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up WiFi devices and configure the SSID\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n    WifiMacHelper mac;\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-network\")));\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 1\n    uint16_t port = 9;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 0\n    UdpClientHelper client(interfaces.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a simple NS-3 C++ program that demonstrates the creation of nodes. The program should create three nodes, assign them unique IDs, and print their count to verify successful creation. Keep it minimal and focused on node creation without additional networking components."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"NodeCreationExample\", LOG_LEVEL_INFO);\n\n    // Create a container to hold nodes\n    NodeContainer nodes;\n    \n    // Create 3 nodes\n    nodes.Create(3);\n\n    // Print node count\n    NS_LOG_INFO(\"Number of nodes created: \" << nodes.GetN());\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that involves a ring topology with 4 nodes and establishes a persistent TCP connection. Visualize the topology and packet exchanges using NetAnim. The simulation should use point-to-point links with a data rate of 5Mbps and a delay of 1ms. One node should act as the TCP client, while another node acts as the TCP server, maintaining a persistent connection. The other nodes should simply forward the traffic. Log the packet transmissions and set up NetAnim to animate the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PersistentTcpConnectionWithNetAnim\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"PersistentTcpConnectionWithNetAnim\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes for the ring topology\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Create a point-to-point link helper\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    // Create and install point-to-point links in a ring topology\n    NetDeviceContainer devices;\n    for (uint32_t i = 0; i < nodes.GetN(); ++i)\n    {\n        NetDeviceContainer temp = pointToPoint.Install(nodes.Get(i), nodes.Get((i + 1) % nodes.GetN()));\n        devices.Add(temp);\n    }\n\n    // Install Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfaces;\n    for (uint32_t i = 0; i < nodes.GetN(); ++i)\n    {\n        std::ostringstream subnet;\n        subnet << \"10.1.\" << i + 1 << \".0\";\n        address.SetBase(subnet.str().c_str(), \"255.255.255.0\");\n        interfaces.Add(address.Assign(devices.Get(i)));\n    }\n\n    // Create TCP server on node 0\n    uint16_t port = 50000;\n    Address serverAddress(InetSocketAddress(interfaces.GetAddress(0), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(0));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Create TCP client on node 2\n    OnOffHelper client(\"ns3::TcpSocketFactory\", serverAddress);\n    client.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    client.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    client.SetAttribute(\"DataRate\", StringValue(\"2Mbps\"));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = client.Install(nodes.Get(2));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Populate routing tables\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Set up NetAnim\n    AnimationInterface anim(\"tcp_ring_topology.xml\");\n\n    // Set positions for the nodes for visualization in NetAnim\n    anim.SetConstantPosition(nodes.Get(0), 10.0, 30.0); // Node 0\n    anim.SetConstantPosition(nodes.Get(1), 30.0, 50.0); // Node 1\n    anim.SetConstantPosition(nodes.Get(2), 50.0, 30.0); // Node 2\n    anim.SetConstantPosition(nodes.Get(3), 30.0, 10.0); // Node 3\n\n    // Enable packet tracing in NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using NS-3 that simulates network traffic capture between two nodes connected via a point-to-point link. Set the data transmission rate of the link to 5 Mbps and a propagation delay of 2 milliseconds. Install the Internet stack on both nodes and assign IP addresses to the devices using the range \"10.1.1.0/24\". Enable packet capture to record the traffic exchanged between the nodes into a .pcap file. Focus solely on capturing the network traffic, without configuring additional communication protocols or applications. Run and destroy the simulation afterward."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PacketCaptureExample\");\n\nint main(int argc, char *argv[]) {\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link between the two nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack (IP protocol)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Enable packet capture\n    pointToPoint.EnablePcapAll(\"simple-point-to-point\");\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that demonstrates network congestion control using TCP with Reno and Cubic variants in a bottleneck network. The simulation should include three nodes connected in a dumbbell topology, where two TCP flows share a bottleneck link, causing congestion. It should also generate a NetAnim visualization to show packet transmissions and congestion points."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpCongestionControlExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set up logging\n    LogComponentEnable(\"TcpCongestionControlExample\", LOG_LEVEL_INFO);\n\n    // Simulation time\n    double simulationTime = 10.0; // seconds\n\n    // Create nodes for the dumbbell topology\n    NodeContainer leftNodes, rightNodes, routerNodes;\n    leftNodes.Create(2);   // Two TCP sources\n    rightNodes.Create(2);  // Two TCP sinks\n    routerNodes.Create(2); // Routers (bottleneck)\n\n    // Create point-to-point link helpers\n    PointToPointHelper pointToPointLeft, pointToPointRight, pointToPointRouter;\n    pointToPointLeft.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPointLeft.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    pointToPointRight.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPointRight.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    pointToPointRouter.SetDeviceAttribute(\"DataRate\", StringValue(\"2Mbps\")); // Bottleneck link\n    pointToPointRouter.SetChannelAttribute(\"Delay\", StringValue(\"20ms\"));\n\n    // Install devices on the nodes\n    NetDeviceContainer leftDevices1 = pointToPointLeft.Install(leftNodes.Get(0), routerNodes.Get(0));\n    NetDeviceContainer leftDevices2 = pointToPointLeft.Install(leftNodes.Get(1), routerNodes.Get(0));\n\n    NetDeviceContainer rightDevices1 = pointToPointRight.Install(rightNodes.Get(0), routerNodes.Get(1));\n    NetDeviceContainer rightDevices2 = pointToPointRight.Install(rightNodes.Get(1), routerNodes.Get(1));\n\n    NetDeviceContainer routerDevices = pointToPointRouter.Install(routerNodes);\n\n    // Install internet stack on all nodes\n    InternetStackHelper internet;\n    internet.Install(leftNodes);\n    internet.Install(rightNodes);\n    internet.Install(routerNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer leftInterfaces1 = ipv4.Assign(leftDevices1);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer leftInterfaces2 = ipv4.Assign(leftDevices2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer rightInterfaces1 = ipv4.Assign(rightDevices1);\n\n    ipv4.SetBase(\"10.1.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer rightInterfaces2 = ipv4.Assign(rightDevices2);\n\n    ipv4.SetBase(\"10.1.5.0\", \"255.255.255.0\");\n    ipv4.Assign(routerDevices);\n\n    // Set up TCP applications\n    uint16_t port = 8080;\n    Address sinkAddress1(InetSocketAddress(rightInterfaces1.GetAddress(0), port));\n    PacketSinkHelper sinkHelper1(\"ns3::TcpSocketFactory\", sinkAddress1);\n    ApplicationContainer sinkApp1 = sinkHelper1.Install(rightNodes.Get(0));\n\n    Address sinkAddress2(InetSocketAddress(rightInterfaces2.GetAddress(0), port));\n    PacketSinkHelper sinkHelper2(\"ns3::TcpSocketFactory\", sinkAddress2);\n    ApplicationContainer sinkApp2 = sinkHelper2.Install(rightNodes.Get(1));\n\n    sinkApp1.Start(Seconds(0.0));\n    sinkApp1.Stop(Seconds(simulationTime));\n    sinkApp2.Start(Seconds(0.0));\n    sinkApp2.Stop(Seconds(simulationTime));\n\n    // Set TCP socket types for the flows\n    TypeId tcpRenoTypeId = TypeId::LookupByName(\"ns3::TcpReno\");\n    TypeId tcpCubicTypeId = TypeId::LookupByName(\"ns3::TcpCubic\");\n\n    // Create TCP flow 1 using TCP Reno\n    Ptr<Socket> tcpRenoSocket = Socket::CreateSocket(leftNodes.Get(0), tcpRenoTypeId);\n    Ptr<TcpSocketBase> tcpReno = DynamicCast<TcpSocketBase>(tcpRenoSocket);\n    tcpReno->Bind();\n    tcpReno->Connect(sinkAddress1);\n\n    // Create TCP flow 2 using TCP Cubic\n    Ptr<Socket> tcpCubicSocket = Socket::CreateSocket(leftNodes.Get(1), tcpCubicTypeId);\n    Ptr<TcpSocketBase> tcpCubic = DynamicCast<TcpSocketBase>(tcpCubicSocket);\n    tcpCubic->Bind();\n    tcpCubic->Connect(sinkAddress2);\n\n    // Set up the on-off application to simulate traffic generation\n    OnOffHelper onOffTcpReno(\"ns3::TcpSocketFactory\", sinkAddress1);\n    onOffTcpReno.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffTcpReno.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    onOffTcpReno.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    onOffTcpReno.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer tcpRenoApp = onOffTcpReno.Install(leftNodes.Get(0));\n    tcpRenoApp.Start(Seconds(1.0));\n    tcpRenoApp.Stop(Seconds(simulationTime));\n\n    OnOffHelper onOffTcpCubic(\"ns3::TcpSocketFactory\", sinkAddress2);\n    onOffTcpCubic.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffTcpCubic.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    onOffTcpCubic.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    onOffTcpCubic.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer tcpCubicApp = onOffTcpCubic.Install(leftNodes.Get(1));\n    tcpCubicApp.Start(Seconds(1.0));\n    tcpCubicApp.Stop(Seconds(simulationTime));\n\n    // Set up NetAnim for visualization\n    AnimationInterface anim(\"tcp_congestion_control_netanim.xml\");\n\n    // Set constant positions for NetAnim visualization\n    anim.SetConstantPosition(leftNodes.Get(0), 1.0, 2.0);  // TCP Reno source\n    anim.SetConstantPosition(leftNodes.Get(1), 1.0, 3.0);  // TCP Cubic source\n    anim.SetConstantPosition(rightNodes.Get(0), 3.0, 2.0); // TCP Reno sink\n    anim.SetConstantPosition(rightNodes.Get(1), 3.0, 3.0); // TCP Cubic sink\n    anim.SetConstantPosition(routerNodes.Get(0), 2.0, 2.5); // Router 1\n    anim.SetConstantPosition(routerNodes.Get(1), 2.0, 3.5); // Router 2\n\n    // Enable packet metadata in NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a point-to-point network in NS-3 with two nodes. Node 1 (client) sends TCP packets to Node 2 (server) using a TCP connection. Set the data rate to 5Mbps and the delay to 2ms. Run the simulation for 10 seconds, with the server starting at 1s and the client starting at 2s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpConnectionExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Set up point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up TCP server on Node 2\n    uint16_t port = 9; // Arbitrary port\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on Node 1\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using ns-3 to simulate a network with two nodes (n0 and n1) connected by a point-to-point link with 500 Kbps bandwidth and 5ms delay. Install a BulkSendApplication on node n0 to send data to node n1 over TCP, and a PacketSinkApplication on node n1 to receive the data. Set the simulation time to 10 seconds and allow the user to specify the maximum bytes to send and whether to enable tracing. If tracing is enabled, generate an ASCII trace file named 'tcp-bulk-send.tr' and a pcap file. Finally, print the total bytes received by the sink."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0 ----------- n1\n//            500 Kbps\n//             5 ms\n//\n// - Flow from n0 to n1 using BulkSendApplication.\n// - Tracing of queues and packet receptions to file \"tcp-bulk-send.tr\"\n//   and pcap tracing available when tracing is turned on.\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <fstream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpBulkSendExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    bool tracing = false;\n    uint32_t maxBytes = 0;\n\n    //\n    // Allow the user to override any of the defaults at\n    // run-time, via command-line arguments\n    //\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"tracing\", \"Flag to enable/disable tracing\", tracing);\n    cmd.AddValue(\"maxBytes\", \"Total number of bytes for application to send\", maxBytes);\n    cmd.Parse(argc, argv);\n\n    //\n    // Explicitly create the nodes required by the topology (shown above).\n    //\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    NS_LOG_INFO(\"Create channels.\");\n\n    //\n    // Explicitly create the point-to-point link required by the topology (shown above).\n    //\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"500Kbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    //\n    // Install the internet stack on the nodes\n    //\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    //\n    // We've got the \"hardware\" in place.  Now we need to add IP addresses.\n    //\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    //\n    // Create a BulkSendApplication and install it on node 0\n    //\n    uint16_t port = 9; // well-known echo port number\n\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", InetSocketAddress(i.GetAddress(1), port));\n    // Set the amount of data to send in bytes.  Zero is unlimited.\n    source.SetAttribute(\"MaxBytes\", UintegerValue(maxBytes));\n    ApplicationContainer sourceApps = source.Install(nodes.Get(0));\n    sourceApps.Start(Seconds(0.0));\n    sourceApps.Stop(Seconds(10.0));\n\n    //\n    // Create a PacketSinkApplication and install it on node 1\n    //\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApps = sink.Install(nodes.Get(1));\n    sinkApps.Start(Seconds(0.0));\n    sinkApps.Stop(Seconds(10.0));\n\n    //\n    // Set up tracing if enabled\n    //\n    if (tracing)\n    {\n        AsciiTraceHelper ascii;\n        pointToPoint.EnableAsciiAll(ascii.CreateFileStream(\"tcp-bulk-send.tr\"));\n        pointToPoint.EnablePcapAll(\"tcp-bulk-send\", false);\n    }\n\n    //\n    // Now, do the actual simulation.\n    //\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    Ptr<PacketSink> sink1 = DynamicCast<PacketSink>(sinkApps.Get(0));\n    std::cout << \"Total Bytes Received: \" << sink1->GetTotalRx() << std::endl;\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulator that creates a network topology with two L2 LANs, each with multiple interconnected L2 switches, connected by a WAN link. Name the two LANs \"top\" (192.168.1/24) and \"bottom\" (192.168.2/24), and assign each LAN its own router to act as a gateway to the WAN. Configure UDP echo clients and servers on both LANs to test connectivity. In the top LAN, connect node t2 (UDP echo client) through multiple switches to router tr, and node t3 (UDP echo server) through a single switch. In the bottom LAN, connect node b2 (UDP echo server) through multiple switches to router br, and node b3 (UDP echo client) through a single switch. Ensure the simulation can use both 100Mbit and 10Mbit Ethernet CSMA links for LAN connections, configurable via command-line arguments, and model the WAN using a point-to-point link with configurable rate and delay. Use this to test a patch that fixes global-router-interface support for bridging across multiple switches"}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/bridge-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <fstream>\n#include <iostream>\n\nusing namespace ns3;\n\n// ########################################################################\n// Main routine\n// ########################################################################\nNS_LOG_COMPONENT_DEFINE(\"GlobalRoutingMultiSwitchPlusRouter\");\n\n#define vssearch(loc, vec) std::find((vec).begin(), (vec).end(), (loc)) != (vec).end()\n\nint\nmain(int argc, char* argv[])\n{\n    // ----------------------------------------------------------------------\n    // Default values for command line arguments\n    // ----------------------------------------------------------------------\n    bool verbose = true;\n\n    int simDurationSeconds = 60;\n\n    bool enableUdpMultiSW = true;\n    bool enableUdpSingleSW = true;\n\n    std::string pcapLocations = \"\";\n    uint32_t snapLen = PcapFile::SNAPLEN_DEFAULT;\n\n    std::string csmaXLinkDataRate = \"100Mbps\";\n    std::string csmaXLinkDelay = \"500ns\";\n\n    std::string csmaYLinkDataRate = \"10Mbps\";\n    std::string csmaYLinkDelay = \"500ns\";\n\n    std::string p2pLinkDataRate = \"5Mbps\";\n    std::string p2pLinkDelay = \"50ms\";\n\n    uint16_t udpEchoPort = 9; // The well-known UDP echo port\n\n    // ----------------------------------------------------------------------\n    // Create command line options and get them\n    // ----------------------------------------------------------------------\n    CommandLine cmd(__FILE__);\n\n    cmd.Usage(\"NOTE: valid --pcap arguments are: 't2,t3,b2,b3,trlan,trwan,brlan,brwan'\");\n\n    cmd.AddValue(\"verbose\", \"Enable printing informational messages\", verbose);\n\n    cmd.AddValue(\"duration\", \"Duration of simulation.\", simDurationSeconds);\n\n    cmd.AddValue(\"udpMultiSW\", \"Enable udp over multi-switch links\", enableUdpMultiSW);\n    cmd.AddValue(\"udpSingleSW\", \"Enable udp over single-switch links\", enableUdpSingleSW);\n\n    cmd.AddValue(\"pcap\", \"Comma separated list of PCAP Locations to tap\", pcapLocations);\n    cmd.AddValue(\"snapLen\", \"PCAP packet capture length\", snapLen);\n\n    cmd.AddValue(\"csmaXRate\", \"CSMA X Link data rate\", csmaXLinkDataRate);\n    cmd.AddValue(\"csmaXDelay\", \"CSMA X Link delay\", csmaXLinkDelay);\n\n    cmd.AddValue(\"csmaYRate\", \"CSMA Y Link data rate\", csmaYLinkDataRate);\n    cmd.AddValue(\"csmaYDelay\", \"CSMA Y Link delay\", csmaYLinkDelay);\n\n    cmd.AddValue(\"p2pRate\", \"P2P Link data rate\", p2pLinkDataRate);\n    cmd.AddValue(\"p2pDelay\", \"P2P Link delay\", p2pLinkDelay);\n\n    cmd.Parse(argc, argv);\n\n    // --------------------------------------------------------------------\n    // Users may find it convenient to turn on explicit debugging\n    // for selected modules; the below lines suggest how to do this\n    // --------------------------------------------------------------------\n    if (verbose)\n    {\n        LogComponentEnable(\"GlobalRoutingMultiSwitchPlusRouter\", LOG_LEVEL_INFO);\n    }\n\n    // ======================================================================\n    // Define the list of valid PCAP taps\n    // ----------------------------------------------------------------------\n    const std::vector<std::string> pcapTaps{\n        \"t2\",    // multi-switch  UDP echo client\n        \"t3\",    // single-switch UDP echo server\n        \"b2\",    // multi-switch  UDP echo server\n        \"b3\",    // single-switch UDP echo client\n        \"trlan\", // top router    LAN side\n        \"trwan\", // top router    WAN side\n        \"brlan\", // bottom router LAN side\n        \"brwan\", // bottom router WAN side\n    };\n\n    // ----------------------------------------------------------------------\n    // Parse the pcapLocations string into pcapLocationVec\n    // ----------------------------------------------------------------------\n    std::vector<std::string> pcapLocationVec;\n    if (!pcapLocations.empty())\n    {\n        std::stringstream sStream(pcapLocations);\n\n        while (sStream.good())\n        {\n            std::string substr;\n            getline(sStream, substr, ',');\n            if (vssearch(substr, pcapTaps))\n            {\n                pcapLocationVec.push_back(substr);\n            }\n            else\n            {\n                NS_LOG_ERROR(\"WARNING: Unrecognized PCAP location: <\" + substr + \">\");\n            }\n        }\n\n        for (auto ploc = pcapLocationVec.begin(); ploc != pcapLocationVec.end(); ++ploc)\n        {\n            NS_LOG_INFO(\"PCAP capture at: <\" + *ploc + \">\");\n        }\n    }\n\n    // ======================================================================\n    // Set some simulator-wide values\n    // ======================================================================\n\n    // ----------------------------------------------------------------------\n    // Set PCAP packet capture maximum packet length\n    // ----------------------------------------------------------------------\n    if (snapLen != PcapFile::SNAPLEN_DEFAULT)\n    {\n        Config::SetDefault(\"ns3::PcapFileWrapper::CaptureSize\", UintegerValue(snapLen));\n    }\n\n    // ======================================================================\n    // Create the nodes & links required for the topology shown in comments above.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"INFO: Create nodes.\");   // - - - - - - - - - - - - - - - -\n                                          // Node IP     : Description\n                                          // - - - - - - - - - - - - - - - -\n    Ptr<Node> t2 = CreateObject<Node>();  // 192.168.1.2 : Top multi-switch udp echo client\n    Ptr<Node> t3 = CreateObject<Node>();  // 192.168.1.3 : Top single-switch   udp echo server\n                                          //             :\n    Ptr<Node> ts1 = CreateObject<Node>(); // <no IP>     : Top switch #1 (bridge)\n    Ptr<Node> ts2 = CreateObject<Node>(); // <no IP>     : Top switch #2 (bridge)\n    Ptr<Node> ts3 = CreateObject<Node>(); // <no IP>     : Top switch #3 (bridge)\n    Ptr<Node> ts4 = CreateObject<Node>(); // <no IP>     : Top switch #4 (bridge)\n                                          //             :\n    Ptr<Node> tr = CreateObject<Node>();  // 192.168.1.1 : Router connecting top LAN & WAN\n                                          // 76.1.1.1    :\n                                          //             :\n    Ptr<Node> br = CreateObject<Node>();  // 76.1.1.2    : Router connecting WAN & bottom LANs\n                                          // 192.168.2.1 :\n                                          //             :\n    Ptr<Node> bs1 = CreateObject<Node>(); // <no IP>     : Bottom switch #1 (bridge)\n    Ptr<Node> bs2 = CreateObject<Node>(); // <no IP>     : Bottom switch #2 (bridge)\n    Ptr<Node> bs3 = CreateObject<Node>(); // <no IP>     : Bottom switch #3 (bridge)\n    Ptr<Node> bs4 = CreateObject<Node>(); // <no IP>     : Bottom switch #4 (bridge)\n    Ptr<Node> bs5 = CreateObject<Node>(); // <no IP>     : Bottom switch #5 (bridge)\n                                          //             :\n    Ptr<Node> b2 = CreateObject<Node>();  // 192.168.2.2 : Bottom multi-switch udp echo server\n\n    Ptr<Node> b3 = CreateObject<Node>(); // 192.168.2.3 : Bottom single-switch   udp echo client\n                                         // - - - - - - - - - - - - - - - -\n\n    // ----------------------------------------------------------------------\n    // Give the nodes names\n    // ----------------------------------------------------------------------\n    Names::Add(\"t2\", t2);\n    Names::Add(\"t3\", t3);\n    Names::Add(\"ts1\", ts1);\n    Names::Add(\"ts2\", ts2);\n    Names::Add(\"ts3\", ts3);\n    Names::Add(\"ts4\", ts4);\n    Names::Add(\"tr\", tr);\n    Names::Add(\"br\", br);\n    Names::Add(\"bs1\", bs1);\n    Names::Add(\"bs2\", bs2);\n    Names::Add(\"bs3\", bs3);\n    Names::Add(\"bs4\", bs4);\n    Names::Add(\"bs5\", bs5);\n    Names::Add(\"b2\", b2);\n    Names::Add(\"b3\", b3);\n\n    // ======================================================================\n    // Create CSMA links to use for connecting LAN nodes together\n    // ----------------------------------------------------------------------\n\n    // ----------------------------------------\n    // CSMA [X]\n    // ----------------------------------------\n    NS_LOG_INFO(\"L2: Create a \" << csmaXLinkDataRate << \" \" << csmaXLinkDelay\n                                << \" CSMA link for csmaX for LANs.\");\n    CsmaHelper csmaX;\n    csmaX.SetChannelAttribute(\"DataRate\", StringValue(csmaXLinkDataRate));\n    csmaX.SetChannelAttribute(\"Delay\", StringValue(csmaXLinkDelay));\n\n    // ----------------------------------------\n    // CSMA [Y]\n    // ----------------------------------------\n    NS_LOG_INFO(\"L2: Create a \" << csmaYLinkDataRate << \" \" << csmaYLinkDelay\n                                << \" CSMA link for csmaY for LANs.\");\n    CsmaHelper csmaY;\n    csmaY.SetChannelAttribute(\"DataRate\", StringValue(csmaYLinkDataRate));\n    csmaY.SetChannelAttribute(\"Delay\", StringValue(csmaYLinkDelay));\n\n    // ----------------------------------------------------------------------\n    // Now, connect the top LAN nodes together with csma links.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Connect nodes on top LAN together with half-duplex CSMA links.\");\n\n    // Multi-switch top LAN chain: t2-ts4-ts3-ts2-ts1-tr\n    NetDeviceContainer link_t2_ts4 = csmaX.Install(NodeContainer(t2, ts4));\n    NetDeviceContainer link_ts4_ts3 = csmaY.Install(NodeContainer(ts4, ts3));\n    NetDeviceContainer link_ts3_ts2 = csmaX.Install(NodeContainer(ts3, ts2));\n    NetDeviceContainer link_ts2_ts1 = csmaY.Install(NodeContainer(ts2, ts1));\n\n    // Single-switch top LAN link: t3-ts1-tr\n    NetDeviceContainer link_t3_ts1 = csmaX.Install(NodeContainer(t3, ts1));\n\n    // Common link for top LAN between ts1 and tr (for t2 and t3 to get to tr)\n    NetDeviceContainer link_tr_ts1 = csmaY.Install(NodeContainer(tr, ts1));\n\n    // ----------------------------------------------------------------------\n    // And repeat above steps to connect the bottom LAN nodes together\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Connect nodes on bottom LAN together with half-duplex CSMA links.\");\n\n    // Multi-switch bottom LAN chain: b2-bs5-bs4-bs3-bs2-bs1-br\n    NetDeviceContainer link_b2_bs5 = csmaY.Install(NodeContainer(b2, bs5));\n    NetDeviceContainer link_bs5_bs4 = csmaX.Install(NodeContainer(bs5, bs4));\n    NetDeviceContainer link_bs4_bs3 = csmaY.Install(NodeContainer(bs4, bs3));\n    NetDeviceContainer link_bs3_bs2 = csmaX.Install(NodeContainer(bs3, bs2));\n    NetDeviceContainer link_bs2_bs1 = csmaY.Install(NodeContainer(bs2, bs1));\n\n    // Single-switch bottom LAN link: b3-bs1-br\n    NetDeviceContainer link_b3_bs1 = csmaY.Install(NodeContainer(b3, bs1));\n\n    // Common link for bottom LAN between bs1 and br (for b2 and b3 to get to br)\n    NetDeviceContainer link_br_bs1 = csmaX.Install(NodeContainer(br, bs1));\n\n    // ======================================================================\n    // Create a point-to-point link for connecting WAN nodes together\n    // (this type of link is full-duplex)\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Create a \" << p2pLinkDataRate << \" \" << p2pLinkDelay\n                                << \" Point-to-Point link for the WAN.\");\n\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(p2pLinkDataRate));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(p2pLinkDelay));\n\n    // ----------------------------------------------------------------------\n    // Now, connect top router to bottom router with a p2p WAN link\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Connect the routers together with the Point-to-Point WAN link.\");\n\n    NetDeviceContainer link_tr_br;\n    link_tr_br = p2p.Install(NodeContainer(tr, br));\n\n    // ======================================================================\n    // Manually create the list of NetDevices for each switch\n    // ----------------------------------------------------------------------\n\n    // Top Switch 4 NetDevices\n    NetDeviceContainer ts4nd;\n    ts4nd.Add(link_t2_ts4.Get(1));\n    ts4nd.Add(link_ts4_ts3.Get(0));\n\n    // Top Switch 3 NetDevices\n    NetDeviceContainer ts3nd;\n    ts3nd.Add(link_ts4_ts3.Get(1));\n    ts3nd.Add(link_ts3_ts2.Get(0));\n\n    // Top Switch 2 NetDevices\n    NetDeviceContainer ts2nd;\n    ts2nd.Add(link_ts3_ts2.Get(1));\n    ts2nd.Add(link_ts2_ts1.Get(0));\n\n    // Top Switch 1 NetDevices\n    NetDeviceContainer ts1nd;\n    ts1nd.Add(link_ts2_ts1.Get(1));\n    ts1nd.Add(link_t3_ts1.Get(1));\n    ts1nd.Add(link_tr_ts1.Get(1));\n\n    // Bottom Switch 1 NetDevices\n    NetDeviceContainer bs1nd;\n    bs1nd.Add(link_br_bs1.Get(1));\n    bs1nd.Add(link_bs2_bs1.Get(1));\n    bs1nd.Add(link_b3_bs1.Get(1));\n\n    // Bottom Switch 2 NetDevices\n    NetDeviceContainer bs2nd;\n    bs2nd.Add(link_bs2_bs1.Get(0));\n    bs2nd.Add(link_bs3_bs2.Get(1));\n\n    // Bottom Switch 3 NetDevices\n    NetDeviceContainer bs3nd;\n    bs3nd.Add(link_bs3_bs2.Get(0));\n    bs3nd.Add(link_bs4_bs3.Get(1));\n\n    // Bottom Switch 4 NetDevices\n    NetDeviceContainer bs4nd;\n    bs4nd.Add(link_bs4_bs3.Get(0));\n    bs4nd.Add(link_bs5_bs4.Get(1));\n\n    // Bottom Switch 5 NetDevices\n    NetDeviceContainer bs5nd;\n    bs5nd.Add(link_bs5_bs4.Get(0));\n    bs5nd.Add(link_b2_bs5.Get(1));\n\n    // ======================================================================\n    // Install bridging code on each switch\n    // ----------------------------------------------------------------------\n    BridgeHelper bridge;\n\n    bridge.Install(ts1, ts1nd);\n    bridge.Install(ts2, ts2nd);\n    bridge.Install(ts3, ts3nd);\n    bridge.Install(ts4, ts4nd);\n\n    bridge.Install(bs1, bs1nd);\n    bridge.Install(bs2, bs2nd);\n    bridge.Install(bs3, bs3nd);\n    bridge.Install(bs4, bs4nd);\n    bridge.Install(bs5, bs5nd);\n\n    // ======================================================================\n    // Install the L3 internet stack  (TCP/IP)\n    // ----------------------------------------------------------------------\n    InternetStackHelper ns3IpStack;\n\n    // ----------------------------------------------------------------------\n    // Install the L3 internet stack on UDP endpoints\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Install the ns3 IP stack on udp client and server nodes.\");\n    NodeContainer endpointNodes(t2, t3, b2, b3);\n    ns3IpStack.Install(endpointNodes);\n\n    // ----------------------------------------------------------------------\n    // Install the L3 internet stack on routers.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Install the ns3 IP stack on routers.\");\n    NodeContainer routerNodes(tr, br);\n    ns3IpStack.Install(routerNodes);\n\n    // ======================================================================\n    // Assign top LAN IP addresses\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Assign top LAN IP Addresses.\");\n\n    NetDeviceContainer topLanIpDevices;      // - - - - - -- - - - - - -\n    topLanIpDevices.Add(link_tr_ts1.Get(0)); // NOTE: order matters here\n    topLanIpDevices.Add(link_t2_ts4.Get(0)); //       for IP address\n    topLanIpDevices.Add(link_t3_ts1.Get(0)); //       assignment\n                                             // - - - - - -- - - - - - -\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    ipv4.Assign(topLanIpDevices);\n\n    // ----------------------------------------------------------------------\n    // Assign bottom LAN IP addresses\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Assign bottom LAN IP Addresses.\");\n\n    NetDeviceContainer botLanIpDevices;      // - - - - - -- - - - - - -\n    botLanIpDevices.Add(link_br_bs1.Get(0)); // NOTE: order matters here\n    botLanIpDevices.Add(link_b2_bs5.Get(0)); //       for IP address\n    botLanIpDevices.Add(link_b3_bs1.Get(0)); //       assignment\n                                             // - - - - - -- - - - - - -\n\n    ipv4.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    ipv4.Assign(botLanIpDevices);\n\n    // ----------------------------------------------------------------------\n    // Assign WAN IP addresses\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Assign WAN IP Addresses.\");\n\n    ipv4.SetBase(\"76.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(link_tr_br);\n\n    // ======================================================================\n    // Calculate and populate routing tables\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Populate routing tables.\");\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // ======================================================================\n    // Multi-Switch UDP traffic generation\n    // ----------------------------------------------------------------------\n    ApplicationContainer apps;\n\n    if (enableUdpMultiSW)\n    {\n        // ------------------------------------------------------------------\n        // Install multi-switch UDP echo server on b2\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Multi-Switch UDP server (on node b2 of bottom LAN)\");\n\n        UdpEchoServerHelper server(udpEchoPort);\n\n        ApplicationContainer serverApp = server.Install(b2);\n        serverApp.Start(Seconds(0.5));\n        serverApp.Stop(Seconds(simDurationSeconds));\n\n        // ------------------------------------------------------------------\n        // Install multi-switch UDP echo client on t2\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Multi-Switch UDP client (on node t2 of top LAN)\");\n\n        Time interPacketInterval = Seconds(0.005);\n        uint32_t packetSize = 1000;\n        uint32_t maxPacketCount = (simDurationSeconds - 2.0) / 0.005;\n\n        UdpEchoClientHelper client(Ipv4Address(\"192.168.2.2\"), udpEchoPort);\n\n        client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n        client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n        client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n        ApplicationContainer clientApp = client.Install(t2);\n        clientApp.Start(Seconds(0.5));\n        clientApp.Stop(Seconds(simDurationSeconds));\n    }\n\n    // ======================================================================\n    // Single-Switch UDP traffic generation\n    // ----------------------------------------------------------------------\n    if (enableUdpSingleSW)\n    {\n        // ------------------------------------------------------------------\n        // Install single-switch UDP echo server on t3\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Single-Switch UDP server (on node t3 of top LAN)\");\n\n        UdpEchoServerHelper server(udpEchoPort);\n\n        ApplicationContainer serverApp = server.Install(t3);\n        serverApp.Start(Seconds(0.5));\n        serverApp.Stop(Seconds(simDurationSeconds));\n\n        // ------------------------------------------------------------------\n        // Install single-switch UDP echo client on b3\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Single-Switch UDP client (on node b3 bottom LAN)\");\n\n        Time interPacketInterval = Seconds(0.005);\n        uint32_t packetSize = 1000;\n        uint32_t maxPacketCount = (simDurationSeconds - 2.0) / 0.005;\n\n        UdpEchoClientHelper client(Ipv4Address(\"192.168.1.3\"), udpEchoPort);\n\n        client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n        client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n        client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n        ApplicationContainer clientApp = client.Install(b3);\n        clientApp.Start(Seconds(0.5));\n        clientApp.Stop(Seconds(simDurationSeconds));\n    }\n\n    // ======================================================================\n    // Print routing tables at T=0.1\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    // NOTE: Node 0 and Node 13 must have non-empty tables (except for local\n    //       loopback and local LAN) if routing is operating correctly.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"Set up to print routing tables at T=0.1s\");\n\n    Ptr<OutputStreamWrapper> routingStream =\n        Create<OutputStreamWrapper>(\"global-routing-multi-switch-plus-router.routes\",\n                                    std::ios::out);\n\n    Ipv4RoutingHelper::PrintRoutingTableAllAt(Seconds(0.1), routingStream);\n\n    // ======================================================================\n    // Configure PCAP traces\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"Configure PCAP Tracing (if any configured).\");\n\n    // - - - - - - - - - - - - - -\n    // multi-switch UDP echo client\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"t2\", pcapLocationVec))\n    {\n        csmaX.EnablePcap(\"t2.pcap\", topLanIpDevices.Get(1), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // multi-switch UDP echo server\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"b2\", pcapLocationVec))\n    {\n        csmaY.EnablePcap(\"b2.pcap\", botLanIpDevices.Get(1), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // single-switch UDP echo client\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"b3\", pcapLocationVec))\n    {\n        csmaY.EnablePcap(\"b3.pcap\", botLanIpDevices.Get(2), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // single-switch UDP echo server\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"t3\", pcapLocationVec))\n    {\n        csmaX.EnablePcap(\"t3.pcap\", topLanIpDevices.Get(2), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // top router, LAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"trlan\", pcapLocationVec))\n    {\n        csmaY.EnablePcap(\"trlan.pcap\", topLanIpDevices.Get(0), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // bottom router, LAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"brlan\", pcapLocationVec))\n    {\n        csmaX.EnablePcap(\"brlan.pcap\", botLanIpDevices.Get(0), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // top router, WAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"trwan\", pcapLocationVec))\n    {\n        p2p.EnablePcap(\"trwan.pcap\", link_tr_br.Get(0), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // bottom router, WAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"brwan\", pcapLocationVec))\n    {\n        p2p.EnablePcap(\"brwan.pcap\", link_tr_br.Get(1), true, true);\n    }\n\n    // ======================================================================\n    // Now, do the actual simulation.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"Run Simulation for \" << simDurationSeconds << \" seconds.\");\n\n    Simulator::Stop(Seconds(simDurationSeconds));\n    Simulator::Run();\n\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where multiple drones (UAVs) communicate using UDP over a wireless network. The UAVs should follow a 3D mobility model and exchange data with a ground control station (GCS). Use the AODV (Ad hoc On-Demand Distance Vector) routing protocol to dynamically find routes between UAVs and the GCS. The simulation should run for 60 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpUAVNetwork\");\n\n// Function to send UDP packets from UAVs to the GCS\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address gcsAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(512); // 512-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(gcsAddr, port));\n    Simulator::Schedule(Seconds(2.0), &SendPacket, socket, gcsAddr, port); // Schedule next packet\n}\n\n// Function to receive packets at the GCS\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"GCS received a packet from a UAV!\");\n    }\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpUAVNetwork\", LOG_LEVEL_INFO);\n\n    int numUAVs = 5;\n    double simTime = 60.0;\n\n    // Create nodes (UAVs + 1 Ground Control Station)\n    NodeContainer uavs;\n    uavs.Create(numUAVs);\n\n    NodeContainer gcs;\n    gcs.Create(1);\n\n    // Configure Wi-Fi (Ad-Hoc Mode for UAV Network)\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a); // 802.11a for high-speed UAV communication\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer uavDevices = wifi.Install(phy, mac, uavs);\n    NetDeviceContainer gcsDevice = wifi.Install(phy, mac, gcs);\n\n    // Set up 3D mobility model for UAVs\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    \n    for (int i = 0; i < numUAVs; i++) {\n        positionAlloc->Add(Vector(i * 50.0, i * 50.0, 100.0 + i * 10.0)); // UAVs at different altitudes\n    }\n    positionAlloc->Add(Vector(250.0, 250.0, 0.0)); // GCS at ground level\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", StringValue(\"ns3::UniformRandomVariable[Min=10.0|Max=20.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"),\n                              \"PositionAllocator\", PointerValue(positionAlloc));\n    mobility.Install(uavs);\n    mobility.Install(gcs);\n\n    // Install Internet stack with AODV routing\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);\n    internet.Install(uavs);\n    internet.Install(gcs);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer uavInterfaces = address.Assign(uavDevices);\n    Ipv4InterfaceContainer gcsInterface = address.Assign(gcsDevice);\n\n    uint16_t port = 7070; // UDP port\n\n    // Setup UDP Server at GCS\n    Ptr<Socket> gcsSocket = Socket::CreateSocket(gcs.Get(0), UdpSocketFactory::GetTypeId());\n    gcsSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    gcsSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Clients in UAVs\n    for (int i = 0; i < numUAVs; i++) {\n        Ptr<Socket> uavSocket = Socket::CreateSocket(uavs.Get(i), UdpSocketFactory::GetTypeId());\n        Simulator::Schedule(Seconds(2.0 + i * 1.0), &SendPacket, uavSocket, gcsInterface.GetAddress(0), port);\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to create a network topology with four nodes: n0, n1, n2, and n3. In this topology, n0 and n1 connect to n2 via point-to-point links with 5 Mbps bandwidth and 2 ms delay, while n1 and n3 are also connected via a higher-cost point-to-point link with 1.5 Mbps bandwidth and 100 ms delay. An alternate path exists between n2 and n3, which has a delay of 10 ms and 1.5 Mbps bandwidth. Set a configurable metric between n1 and n3, allowing for rerouting behavior. Enable tracing of queues and packet receptions to a file, and use UDP traffic from n3 to n1, logging simulation results."}, {"role": "assistant", "content": "//\n// Network topology\n//\n//  n0\n//     \\ 5 Mb/s, 2ms\n//      \\          1.5Mb/s, 10ms\n//       n2 ------------------------n3\n//      /                          /\n//     / 5 Mb/s, 2ms              /\n//   n1--------------------------\n//          1.5 Mb/s, 100ms\n//\n// this is a modification of simple-global-routing to allow for\n// a single hop but higher-cost path between n1 and n3\n//\n// - Tracing of queues and packet receptions to file \"simple-rerouting.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleAlternateRoutingExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Users may find it convenient to turn on explicit debugging\n    // for selected modules; the below lines suggest how to do this\n#if 0\n  LogComponentEnable (\"GlobalRoutingHelper\", LOG_LOGIC);\n  LogComponentEnable (\"GlobalRouter\", LOG_LOGIC);\n#endif\n\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(210));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(\"300b/s\"));\n\n    // The below metric, if set to 3 or higher, will cause packets between\n    // n1 and n3 to take the 2-hop route through n2\n\n    CommandLine cmd(__FILE__);\n    //\n    // Additionally, we plumb this metric into the default value / command\n    // line argument system as well, for exemplary purposes.  This means\n    // that it can be resettable at the command-line to the program,\n    // rather than recompiling\n    // e.g. ns3 --run \"simple-alternate-routing --AlternateCost=5\"\n    uint16_t sampleMetric = 1;\n    cmd.AddValue(\"AlternateCost\",\n                 \"This metric is used in the example script between n3 and n1 \",\n                 sampleMetric);\n\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    cmd.Parse(argc, argv);\n\n    // Here, we will explicitly create four nodes.  In more sophisticated\n    // topologies, we could configure a node factory.\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer c;\n    c.Create(4);\n    NodeContainer n0n2 = NodeContainer(c.Get(0), c.Get(2));\n    NodeContainer n1n2 = NodeContainer(c.Get(1), c.Get(2));\n    NodeContainer n3n2 = NodeContainer(c.Get(3), c.Get(2));\n    NodeContainer n1n3 = NodeContainer(c.Get(1), c.Get(3));\n\n    // We create the channels first without any IP addressing information\n    NS_LOG_INFO(\"Create channels.\");\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d0d2 = p2p.Install(n0n2);\n\n    NetDeviceContainer d1d2 = p2p.Install(n1n2);\n\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1500kbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    NetDeviceContainer d3d2 = p2p.Install(n3n2);\n\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"100ms\"));\n    NetDeviceContainer d1d3 = p2p.Install(n1n3);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // Later, we add IP addresses.  The middle two octets correspond to\n    // the channel number.\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    ipv4.Assign(d0d2);\n\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1i2 = ipv4.Assign(d1d2);\n\n    ipv4.SetBase(\"10.2.2.0\", \"255.255.255.0\");\n    ipv4.Assign(d3d2);\n\n    ipv4.SetBase(\"10.3.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1i3 = ipv4.Assign(d1d3);\n\n    i1i3.SetMetric(0, sampleMetric);\n    i1i3.SetMetric(1, sampleMetric);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams\n    NS_LOG_INFO(\"Create Application.\");\n    uint16_t port = 9; // Discard port (RFC 863)\n\n    // Create a flow from n3 to n1, starting at time 1.1 seconds\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(i1i2.GetAddress(0), port)));\n    onoff.SetConstantRate(DataRate(\"300b/s\"));\n\n    ApplicationContainer apps = onoff.Install(c.Get(3));\n    apps.Start(Seconds(1.1));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(c.Get(1));\n    apps.Start(Seconds(1.1));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"simple-alternate-routing.tr\"));\n    p2p.EnablePcapAll(\"simple-alternate-routing\");\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Wi-Fi network with three station nodes (STAs) and one access point (AP) operating in infrastructure mode using the 802.11n standard. The STAs should have random mobility, while the AP remains stationary. Assign IP addresses in the 192.168.1.0/24 subnet. Configure a UDP echo server on the AP and a UDP echo client on one of the STAs to send five 512-byte packets at 1-second intervals. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create nodes: 3 Wi-Fi stations and 1 AP\n    NodeContainer wifiStaNodes, wifiApNode;\n    wifiStaNodes.Create(3);\n    wifiApNode.Create(1);\n\n    // Set up the Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up the Wi-Fi standard\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Configure MAC layer\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Configure STA (client) devices\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure AP (server) device\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set mobility model (stations move, AP is static)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(wifiStaNodes);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Create a UDP echo server on the AP\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(wifiApNode.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Create a UDP echo client on one of the stations\n    UdpEchoClientHelper echoClient(apInterface.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(wifiStaNodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simulation for a wireless network that validates NIST, YANS, and Table-based error rate models for OFDM (Orthogonal Frequency-Division Multiplexing) rates in NS-3. The program should iterate over different OFDM modes and compute the Frame Success Rate versus Signal-to-Noise Ratio (SNR) for each error rate model. The program should output plots using Gnuplot, with each OFDM mode represented as a separate dataset. Frame size should be configurable through command-line arguments, and the SNR range should be from -5 dB to 30 dB."}, {"role": "assistant", "content": "// This example is used to validate Nist, Yans and Table-based error rate models for OFDM rates.\n//\n// It outputs plots of the Frame Success Rate versus the Signal-to-noise ratio for\n// Nist, Yans and Table-based error rate models and for every OFDM mode.\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t frameSizeBytes = 1500;\n    std::ofstream yansfile(\"yans-frame-success-rate-ofdm.plt\");\n    std::ofstream nistfile(\"nist-frame-success-rate-ofdm.plt\");\n    std::ofstream tablefile(\"table-frame-success-rate-ofdm.plt\");\n\n    const std::vector<std::string> modes{\n        \"OfdmRate6Mbps\",\n        \"OfdmRate9Mbps\",\n        \"OfdmRate12Mbps\",\n        \"OfdmRate18Mbps\",\n        \"OfdmRate24Mbps\",\n        \"OfdmRate36Mbps\",\n        \"OfdmRate48Mbps\",\n        \"OfdmRate54Mbps\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"FrameSize\", \"The frame size in bytes\", frameSizeBytes);\n    cmd.Parse(argc, argv);\n\n    Gnuplot yansplot = Gnuplot(\"yans-frame-success-rate-ofdm.eps\");\n    Gnuplot nistplot = Gnuplot(\"nist-frame-success-rate-ofdm.eps\");\n    Gnuplot tableplot = Gnuplot(\"table-frame-success-rate-ofdm.eps\");\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n    WifiTxVector txVector;\n\n    uint32_t frameSizeBits = frameSizeBytes * 8;\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset yansdataset(mode);\n        Gnuplot2dDataset nistdataset(mode);\n        Gnuplot2dDataset tabledataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -5.0; snrDb <= 30.0; snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double ps = yans->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            yansdataset.Add(snrDb, ps);\n\n            ps = nist->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            nistdataset.Add(snrDb, ps);\n\n            ps = table->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            tabledataset.Add(snrDb, ps);\n        }\n\n        yansplot.AddDataset(yansdataset);\n        nistplot.AddDataset(nistdataset);\n        tableplot.AddDataset(tabledataset);\n    }\n\n    yansplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    yansplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    yansplot.SetExtra(\"set xrange [-5:30]\\n\\\nset yrange [0:1.2]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style increment user\");\n    yansplot.GenerateOutput(yansfile);\n    yansfile.close();\n\n    nistplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    nistplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    nistplot.SetExtra(\"set xrange [-5:30]\\n\\\nset yrange [0:1.2]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style increment user\");\n\n    nistplot.GenerateOutput(nistfile);\n    nistfile.close();\n\n    tableplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    tableplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    tableplot.SetExtra(\"set xrange [-5:30]\\n\\\nset yrange [0:1.2]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style increment user\");\n\n    tableplot.GenerateOutput(tablefile);\n    tablefile.close();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless sensor network (WSN) in ns-3 with six sensor nodes placed in a grid. The nodes should communicate using a simple CSMA protocol. One of the nodes should act as a base station, receiving data from the other sensor nodes using a UDP protocol. The sensor nodes should periodically send data to the base station. Collect and display metrics such as packet delivery ratio and end-to-end delay, and visualize the communication using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WirelessSensorNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n  LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n  LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n  // Create nodes for WSN (6 sensor nodes)\n  NodeContainer sensorNodes;\n  sensorNodes.Create(6);\n\n  // Set up CSMA (wired communication simulation for sensor network)\n  CsmaHelper csma;\n  csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n  csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n  NetDeviceContainer devices = csma.Install(sensorNodes);\n\n  // Install Internet stack\n  InternetStackHelper stack;\n  stack.Install(sensorNodes);\n\n  // Assign IP addresses\n  Ipv4AddressHelper ipv4;\n  ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer sensorInterfaces = ipv4.Assign(devices);\n\n  // Set up mobility model for sensor nodes (grid placement)\n  MobilityHelper mobility;\n  mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                \"MinX\", DoubleValue(0.0),\n                                \"MinY\", DoubleValue(0.0),\n                                \"DeltaX\", DoubleValue(20.0),\n                                \"DeltaY\", DoubleValue(20.0),\n                                \"GridWidth\", UintegerValue(3),\n                                \"LayoutType\", StringValue(\"RowFirst\"));\n  mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install(sensorNodes);\n\n  // Set up UDP server on the base station (node 0)\n  uint16_t port = 9;\n  UdpEchoServerHelper echoServer(port);\n  ApplicationContainer serverApp = echoServer.Install(sensorNodes.Get(0));\n  serverApp.Start(Seconds(1.0));\n  serverApp.Stop(Seconds(10.0));\n\n  // Set up UDP clients on sensor nodes\n  UdpEchoClientHelper echoClient(sensorInterfaces.GetAddress(0), port);\n  echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n  echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n  echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n  ApplicationContainer clientApps;\n  for (uint32_t i = 1; i < sensorNodes.GetN(); ++i)\n  {\n    clientApps.Add(echoClient.Install(sensorNodes.Get(i)));\n  }\n  clientApps.Start(Seconds(2.0));\n  clientApps.Stop(Seconds(10.0));\n\n  // Enable pcap tracing\n  csma.EnablePcapAll(\"wsn-example\");\n\n  // Set up FlowMonitor for performance analysis\n  FlowMonitorHelper flowMonitorHelper;\n  Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n  // Set up NetAnim for visualization\n  AnimationInterface anim(\"wsn-animation.xml\");\n  anim.SetConstantPosition(sensorNodes.Get(0), 0.0, 0.0);\n  anim.SetConstantPosition(sensorNodes.Get(1), 20.0, 0.0);\n  anim.SetConstantPosition(sensorNodes.Get(2), 40.0, 0.0);\n  anim.SetConstantPosition(sensorNodes.Get(3), 0.0, 20.0);\n  anim.SetConstantPosition(sensorNodes.Get(4), 20.0, 20.0);\n  anim.SetConstantPosition(sensorNodes.Get(5), 40.0, 20.0);\n\n  // Run the simulation\n  Simulator::Stop(Seconds(10.0));\n  Simulator::Run();\n\n  // Analyze FlowMonitor statistics\n  flowMonitor->CheckForLostPackets();\n  Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitorHelper.GetClassifier());\n  FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n\n  for (auto it = stats.begin(); it != stats.end(); ++it)\n  {\n    Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(it->first);\n    std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n    std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n    std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n    std::cout << \"  End-to-End Delay: \" << it->second.delaySum.GetSeconds() << \" seconds\" << std::endl;\n  }\n\n  // Clean up\n  Simulator::Destroy();\n  return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple Wi-Fi network in NS-3 with two nodes. Node 0 (sender) sends UDP packets to Node 1 (receiver) over a Wi-Fi link. The nodes are positioned using a grid layout and assigned IP addresses from the 10.1.1.0/24 network. The Wi-Fi connection uses an SSID \"wifi-ssid\" and the simulation runs for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Setup mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Setup Wi-Fi device\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"wifi-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server (Receiver) on Node 1\n    UdpServerHelper server(9);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP client (Sender) on Node 0\n    UdpClientHelper client(interfaces.GetAddress(1), 9);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(1)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 to simulate a simple Poisson Reverse setup. The program should create a point-to-point network between two nodes and utilize the Poisson Reverse method for dynamic routing. Implement a minimal routing protocol that periodically updates route costs based on the inverse of the distance to the destination. The program should also include logging of route updates and simulation statistics. Ensure that traffic flows between the nodes and that the Poisson Reverse logic is applied to adjust routes dynamically."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PoissonReverseExample\");\n\nvoid\nLogRouteTable(Ptr<Ipv4> ipv4)\n{\n    Ptr<Ipv4RoutingTableEntry> route;\n    uint32_t numRoutes = ipv4->GetRoutingTableEntryCount();\n    for (uint32_t i = 0; i < numRoutes; ++i)\n    {\n        route = ipv4->GetRoutingTableEntry(i);\n        std::cout << \"Destination: \" << route->GetDestNetwork() << \", Gateway: \" \n                  << route->GetGateway() << \", Interface: \" << route->GetInterface() \n                  << std::endl;\n    }\n}\n\nvoid\nUpdateRoutes(Ptr<Ipv4StaticRouting> staticRouting, Ipv4Address dst, Ipv4Address nextHop, uint32_t cost)\n{\n    // Update the route using Poisson Reverse logic\n    uint32_t reverseCost = 1 / cost; // Poisson reverse logic: invert cost\n\n    staticRouting->SetDefaultRoute(nextHop, reverseCost);\n    NS_LOG_UNCOND(\"Updated route with Poisson Reverse cost: \" << reverseCost);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"PoissonReverseExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Create point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install network stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Enable static routing\n    Ipv4StaticRoutingHelper staticRoutingHelper;\n    Ptr<Ipv4> ipv4_0 = nodes.Get(0)->GetObject<Ipv4>();\n    Ptr<Ipv4StaticRouting> staticRouting_0 = staticRoutingHelper.GetStaticRouting(ipv4_0);\n    \n    Ptr<Ipv4> ipv4_1 = nodes.Get(1)->GetObject<Ipv4>();\n    Ptr<Ipv4StaticRouting> staticRouting_1 = staticRoutingHelper.GetStaticRouting(ipv4_1);\n\n    // Set initial routes\n    staticRouting_0->AddHostRouteTo(Ipv4Address(\"10.1.1.2\"), Ipv4Address(\"10.1.1.1\"), 1);\n    staticRouting_1->AddHostRouteTo(Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.1.1.2\"), 1);\n\n    // Log initial routing table\n    LogRouteTable(ipv4_0);\n    LogRouteTable(ipv4_1);\n\n    // Update routes based on Poisson Reverse logic periodically\n    Simulator::Schedule(Seconds(5), &UpdateRoutes, staticRouting_0, Ipv4Address(\"10.1.1.2\"), Ipv4Address(\"10.1.1.1\"), 1);\n    Simulator::Schedule(Seconds(5), &UpdateRoutes, staticRouting_1, Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.1.1.2\"), 1);\n\n    // Create a simple TCP flow from node 0 to node 1\n    uint16_t port = 9;\n    Address sinkAddress(InetSocketAddress(interfaces.GetAddress(1), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientHelper.SetAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    clientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = clientHelper.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple TCP connection simulation between two nodes over a point-to-point link in NS-3. Set the data rate to 5Mbps, the delay to 10ms, and introduce a 0.1 packet loss. One node should act as a TCP server, and the other as a TCP client, sending packets for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up a point-to-point link with delay and packet loss\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    pointToPoint.SetChannelAttribute(\"Loss\", StringValue(\"0.1\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up TCP server (Receiver) on Node 1\n    uint16_t port = 8080;\n    TcpServerHelper server(port);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up TCP client (Sender) on Node 0\n    TcpClientHelper client(interfaces.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(20)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate C++ code for an ns-3 simulation that demonstrates energy consumption in a Wi-Fi network with two nodes. Configure nodes with basic energy sources and Wi-Fi radio energy models, and simulate packet transmission between them. Include functionality to track remaining energy and total energy consumed by the nodes, using trace sources. Use the UDP protocol to send and receive packets, and log the transmission details. Allow command-line configuration of parameters such as packet size, simulation start time, and node distance. Ensure the energy consumed remains within specified limits by the end of the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/energy-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-radio-energy-model-helper.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace ns3;\nusing namespace ns3::energy;\n\nNS_LOG_COMPONENT_DEFINE(\"EnergyExample\");\n\n/**\n * Print a received packet\n *\n * \\param from sender address\n * \\return a string with the details of the packet: dst {IP, port}, time.\n */\nstatic inline std::string\nPrintReceivedPacket(Address& from)\n{\n    InetSocketAddress iaddr = InetSocketAddress::ConvertFrom(from);\n\n    std::ostringstream oss;\n    oss << \"--\\nReceived one packet! Socket: \" << iaddr.GetIpv4() << \" port: \" << iaddr.GetPort()\n        << \" at time = \" << Simulator::Now().GetSeconds() << \"\\n--\";\n\n    return oss.str();\n}\n\n/**\n * \\param socket Pointer to socket.\n *\n * Packet receiving sink.\n */\nvoid\nReceivePacket(Ptr<Socket> socket)\n{\n    Ptr<Packet> packet;\n    Address from;\n    while ((packet = socket->RecvFrom(from)))\n    {\n        if (packet->GetSize() > 0)\n        {\n            NS_LOG_UNCOND(PrintReceivedPacket(from));\n        }\n    }\n}\n\n/**\n * \\param socket Pointer to socket.\n * \\param pktSize Packet size.\n * \\param n Pointer to node.\n * \\param pktCount Number of packets to generate.\n * \\param pktInterval Packet sending interval.\n *\n * Traffic generator.\n */\nstatic void\nGenerateTraffic(Ptr<Socket> socket,\n                uint32_t pktSize,\n                Ptr<Node> n,\n                uint32_t pktCount,\n                Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval,\n                            &GenerateTraffic,\n                            socket,\n                            pktSize,\n                            n,\n                            pktCount - 1,\n                            pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\n/**\n * Trace function for remaining energy at node.\n *\n * \\param oldValue Old value\n * \\param remainingEnergy New value\n */\nvoid\nRemainingEnergy(double oldValue, double remainingEnergy)\n{\n    NS_LOG_UNCOND(Simulator::Now().GetSeconds()\n                  << \"s Current remaining energy = \" << remainingEnergy << \"J\");\n}\n\n/**\n * \\brief Trace function for total energy consumption at node.\n *\n * \\param oldValue Old value\n * \\param totalEnergy New value\n */\nvoid\nTotalEnergy(double oldValue, double totalEnergy)\n{\n    NS_LOG_UNCOND(Simulator::Now().GetSeconds()\n                  << \"s Total energy consumed by radio = \" << totalEnergy << \"J\");\n}\n\nint\nmain(int argc, char* argv[])\n{\n    /*\n    LogComponentEnable (\"EnergySource\", LOG_LEVEL_DEBUG);\n    LogComponentEnable (\"BasicEnergySource\", LOG_LEVEL_DEBUG);\n    LogComponentEnable (\"DeviceEnergyModel\", LOG_LEVEL_DEBUG);\n    LogComponentEnable (\"WifiRadioEnergyModel\", LOG_LEVEL_DEBUG);\n     */\n\n    LogComponentEnable(\"EnergyExample\",\n                       LogLevel(LOG_PREFIX_TIME | LOG_PREFIX_NODE | LOG_LEVEL_INFO));\n\n    std::string phyMode(\"DsssRate1Mbps\");\n    double Prss = -80;          // dBm\n    uint32_t PpacketSize = 200; // bytes\n    bool verbose = false;\n\n    // simulation parameters\n    uint32_t numPackets = 10000; // number of packets to send\n    double interval = 1;         // seconds\n    double startTime = 0.0;      // seconds\n    double distanceToRx = 100.0; // meters\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"phyMode\", \"Wifi Phy mode\", phyMode);\n    cmd.AddValue(\"Prss\", \"Intended primary RSS (dBm)\", Prss);\n    cmd.AddValue(\"PpacketSize\", \"size of application packet sent\", PpacketSize);\n    cmd.AddValue(\"numPackets\", \"Total number of packets to send\", numPackets);\n    cmd.AddValue(\"startTime\", \"Simulation start time\", startTime);\n    cmd.AddValue(\"distanceToRx\", \"X-Axis distance between nodes\", distanceToRx);\n    cmd.AddValue(\"verbose\", \"Turn on all device log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    // Convert to time object\n    Time interPacketInterval = Seconds(interval);\n\n    // disable fragmentation for frames below 2200 bytes\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::FragmentationThreshold\",\n                       StringValue(\"2200\"));\n    // turn off RTS/CTS for frames below 2200 bytes\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"2200\"));\n    // Fix non-unicast data rate to be the same as that of unicast\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(phyMode));\n\n    NodeContainer c;\n    c.Create(2); // create 2 nodes\n    NodeContainer networkNodes;\n    networkNodes.Add(c.Get(0));\n    networkNodes.Add(c.Get(1));\n\n    // The below set of helpers will help us to put together the wifi NICs we want\n    WifiHelper wifi;\n    if (verbose)\n    {\n        WifiHelper::EnableLogComponents();\n    }\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    /** Wifi PHY **/\n    /***************************************************************************/\n    YansWifiPhyHelper wifiPhy;\n\n    /** wifi channel **/\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n\n    // create wifi channel\n    Ptr<YansWifiChannel> wifiChannelPtr = wifiChannel.Create();\n    wifiPhy.SetChannel(wifiChannelPtr);\n\n    /** MAC layer **/\n    // Add a MAC and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n    // Set it to ad-hoc mode\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    /** install PHY + MAC **/\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, networkNodes);\n\n    /** mobility **/\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(2 * distanceToRx, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    /** Energy Model **/\n    /***************************************************************************/\n    /* energy source */\n    BasicEnergySourceHelper basicSourceHelper;\n    // configure energy source\n    basicSourceHelper.Set(\"BasicEnergySourceInitialEnergyJ\", DoubleValue(0.1));\n    // install source\n    EnergySourceContainer sources = basicSourceHelper.Install(c);\n    /* device energy model */\n    WifiRadioEnergyModelHelper radioEnergyHelper;\n    // configure radio energy model\n    radioEnergyHelper.Set(\"TxCurrentA\", DoubleValue(0.0174));\n    // install device model\n    DeviceEnergyModelContainer deviceModels = radioEnergyHelper.Install(devices, sources);\n    /***************************************************************************/\n\n    /** Internet stack **/\n    InternetStackHelper internet;\n    internet.Install(networkNodes);\n\n    Ipv4AddressHelper ipv4;\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(networkNodes.Get(1), tid); // node 1, receiver\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 80);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    Ptr<Socket> source = Socket::CreateSocket(networkNodes.Get(0), tid); // node 0, sender\n    InetSocketAddress remote = InetSocketAddress(Ipv4Address::GetBroadcast(), 80);\n    source->SetAllowBroadcast(true);\n    source->Connect(remote);\n\n    /** connect trace sources **/\n    /***************************************************************************/\n    // all sources are connected to node 1\n    // energy source\n    Ptr<BasicEnergySource> basicSourcePtr = DynamicCast<BasicEnergySource>(sources.Get(1));\n    basicSourcePtr->TraceConnectWithoutContext(\"RemainingEnergy\", MakeCallback(&RemainingEnergy));\n    // device energy model\n    Ptr<DeviceEnergyModel> basicRadioModelPtr =\n        basicSourcePtr->FindDeviceEnergyModels(\"ns3::WifiRadioEnergyModel\").Get(0);\n    NS_ASSERT(basicRadioModelPtr);\n    basicRadioModelPtr->TraceConnectWithoutContext(\"TotalEnergyConsumption\",\n                                                   MakeCallback(&TotalEnergy));\n    /***************************************************************************/\n\n    /** simulation setup **/\n    // start traffic\n    Simulator::Schedule(Seconds(startTime),\n                        &GenerateTraffic,\n                        source,\n                        PpacketSize,\n                        networkNodes.Get(0),\n                        numPackets,\n                        interPacketInterval);\n\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    for (auto iter = deviceModels.Begin(); iter != deviceModels.End(); iter++)\n    {\n        double energyConsumed = (*iter)->GetTotalEnergyConsumption();\n        NS_LOG_UNCOND(\"End of simulation (\"\n                      << Simulator::Now().GetSeconds()\n                      << \"s) Total energy consumed by radio = \" << energyConsumed << \"J\");\n        NS_ASSERT(energyConsumed <= 0.1);\n    }\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a 5G NR network with one gNodeB (5G base station) and one User Equipment (UE). The gNodeB should be static, while the UE should be placed randomly within a 100x100 area using the Random Walk mobility model. Set up the NR network with appropriate devices and assign IP addresses. Create a TCP server on the gNodeB and a TCP client on the UE. The UE should send five 512-byte packets at 1-second intervals to the gNodeB. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    // Set the simulation time resolution\n    Time::SetResolution(Time::NS);\n\n    // Create nodes: one gNB (evolved NodeB) and one UE (User Equipment)\n    NodeContainer gnbNode, ueNode;\n    gnbNode.Create(1);\n    ueNode.Create(1);\n\n    // Set up the mobility model (static gNB and random UE)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(50.0),\n                                  \"DeltaY\", DoubleValue(50.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(gnbNode);\n\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(ueNode);\n\n    // Set up the 5G NR module (gNB and UE)\n    NrHelper nrHelper;\n    Ptr<NrNetDevice> gnbDevice = nrHelper.Install(gnbNode.Get(0));\n    Ptr<NrNetDevice> ueDevice = nrHelper.Install(ueNode.Get(0));\n\n    // Install IP stack for routing\n    InternetStackHelper internet;\n    internet.Install(gnbNode);\n    internet.Install(ueNode);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface, gnbIpIface;\n    ueIpIface = ipv4.Assign(ueDevice->GetObject<NetDevice>());\n    gnbIpIface = ipv4.Assign(gnbDevice->GetObject<NetDevice>());\n\n    // Set up TCP server on the gNB\n    uint16_t port = 9;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(gnbNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on the UE\n    TcpClientHelper tcpClient(gnbIpIface.GetAddress(0), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp = tcpClient.Install(ueNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ simulation script using NS-3 to test TCP performance over an 802.11n wireless network with MPDU aggregation enabled. The topology consists of one access point (AP) and one station (STA). The STA sends TCP packets to the AP, and the simulation reports the total throughput every 100ms. The simulation should allow for command-line configuration of parameters such as the TCP congestion control algorithm, application data rate, payload size, physical layer bitrate, simulation duration, and whether PCAP tracing is enabled. Use NS-3's YansWifiHelper for configuring the Wi-Fi channel and mobility models."}, {"role": "assistant", "content": "/*\n * This is a simple example to test TCP over 802.11n (with MPDU aggregation enabled).\n *\n * Network topology:\n *\n *   Ap    STA\n *   *      *\n *   |      |\n *   n1     n2\n *\n * In this example, an HT station sends TCP packets to the access point.\n * We report the total throughput received during a window of 100ms.\n * The user can specify the application data rate and choose the variant\n * of TCP i.e. congestion control algorithm to use.\n */\n\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/tcp-westwood-plus.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nNS_LOG_COMPONENT_DEFINE(\"wifi-tcp\");\n\nusing namespace ns3;\n\nPtr<PacketSink> sink;     //!< Pointer to the packet sink application\nuint64_t lastTotalRx = 0; //!< The value of the last total received bytes\n\n/**\n * Calculate the throughput\n */\nvoid\nCalculateThroughput()\n{\n    Time now = Simulator::Now(); /* Return the simulator's virtual time. */\n    double cur = (sink->GetTotalRx() - lastTotalRx) * 8.0 /\n                 1e5; /* Convert Application RX Packets to MBits. */\n    std::cout << now.GetSeconds() << \"s: \\t\" << cur << \" Mbit/s\" << std::endl;\n    lastTotalRx = sink->GetTotalRx();\n    Simulator::Schedule(MilliSeconds(100), &CalculateThroughput);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t payloadSize{1472};           /* Transport layer payload size in bytes. */\n    DataRate dataRate{\"100Mb/s\"};         /* Application layer datarate. */\n    std::string tcpVariant{\"TcpNewReno\"}; /* TCP variant type. */\n    std::string phyRate{\"HtMcs7\"};        /* Physical layer bitrate. */\n    Time simulationTime{\"10s\"};           /* Simulation time. */\n    bool pcapTracing{false};              /* PCAP Tracing is enabled or not. */\n\n    /* Command line argument parser setup. */\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"payloadSize\", \"Payload size in bytes\", payloadSize);\n    cmd.AddValue(\"dataRate\", \"Application data ate\", dataRate);\n    cmd.AddValue(\"tcpVariant\",\n                 \"Transport protocol to use: TcpNewReno, \"\n                 \"TcpHybla, TcpHighSpeed, TcpHtcp, TcpVegas, TcpScalable, TcpVeno, \"\n                 \"TcpBic, TcpYeah, TcpIllinois, TcpWestwood, TcpWestwoodPlus, TcpLedbat \",\n                 tcpVariant);\n    cmd.AddValue(\"phyRate\", \"Physical layer bitrate\", phyRate);\n    cmd.AddValue(\"simulationTime\", \"Simulation time in seconds\", simulationTime);\n    cmd.AddValue(\"pcap\", \"Enable/disable PCAP Tracing\", pcapTracing);\n    cmd.Parse(argc, argv);\n\n    tcpVariant = std::string(\"ns3::\") + tcpVariant;\n    // Select TCP variant\n    TypeId tcpTid;\n    NS_ABORT_MSG_UNLESS(TypeId::LookupByNameFailSafe(tcpVariant, &tcpTid),\n                        \"TypeId \" << tcpVariant << \" not found\");\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\",\n                       TypeIdValue(TypeId::LookupByName(tcpVariant)));\n\n    /* Configure TCP Options */\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n\n    WifiMacHelper wifiMac;\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_STANDARD_80211n);\n\n    /* Set up Legacy Channel */\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\", \"Frequency\", DoubleValue(5e9));\n\n    /* Setup Physical Layer */\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.SetChannel(wifiChannel.Create());\n    wifiPhy.SetErrorRateModel(\"ns3::YansErrorRateModel\");\n    wifiHelper.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                       \"DataMode\",\n                                       StringValue(phyRate),\n                                       \"ControlMode\",\n                                       StringValue(\"HtMcs0\"));\n\n    NodeContainer networkNodes;\n    networkNodes.Create(2);\n    Ptr<Node> apWifiNode = networkNodes.Get(0);\n    Ptr<Node> staWifiNode = networkNodes.Get(1);\n\n    /* Configure AP */\n    Ssid ssid = Ssid(\"network\");\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifiHelper.Install(wifiPhy, wifiMac, apWifiNode);\n\n    /* Configure STA */\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifiHelper.Install(wifiPhy, wifiMac, staWifiNode);\n\n    /* Mobility model */\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(1.0, 1.0, 0.0));\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(apWifiNode);\n    mobility.Install(staWifiNode);\n\n    /* Internet stack */\n    InternetStackHelper stack;\n    stack.Install(networkNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apInterface;\n    apInterface = address.Assign(apDevice);\n    Ipv4InterfaceContainer staInterface;\n    staInterface = address.Assign(staDevices);\n\n    /* Populate routing table */\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    /* Install TCP Receiver on the access point */\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\",\n                                InetSocketAddress(Ipv4Address::GetAny(), 9));\n    ApplicationContainer sinkApp = sinkHelper.Install(apWifiNode);\n    sink = StaticCast<PacketSink>(sinkApp.Get(0));\n\n    /* Install TCP/UDP Transmitter on the station */\n    OnOffHelper server(\"ns3::TcpSocketFactory\", (InetSocketAddress(apInterface.GetAddress(0), 9)));\n    server.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n    server.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    server.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    server.SetAttribute(\"DataRate\", DataRateValue(DataRate(dataRate)));\n    ApplicationContainer serverApp = server.Install(staWifiNode);\n\n    /* Start Applications */\n    sinkApp.Start(Seconds(0.0));\n    serverApp.Start(Seconds(1.0));\n    Simulator::Schedule(Seconds(1.1), &CalculateThroughput);\n\n    /* Enable Traces */\n    if (pcapTracing)\n    {\n        wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n        wifiPhy.EnablePcap(\"AccessPoint\", apDevice);\n        wifiPhy.EnablePcap(\"Station\", staDevices);\n    }\n\n    /* Start Simulation */\n    Simulator::Stop(simulationTime + Seconds(1.0));\n    Simulator::Run();\n\n    auto averageThroughput =\n        (static_cast<double>(sink->GetTotalRx() * 8) / simulationTime.GetMicroSeconds());\n\n    Simulator::Destroy();\n\n    if (averageThroughput < 50)\n    {\n        NS_LOG_ERROR(\"Obtained throughput is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"\\nAverage throughput: \" << averageThroughput << \" Mbit/s\" << std::endl;\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 to simulate a star network topology with 9 nodes, where 8 \"arm\" nodes are connected to a central \"hub\" node. The nodes on the arms will send Constant Bit Rate (CBR) traffic to the hub using TCP. Enable packet tracing and output trace files in pcap format, with filenames of the format \"tcp-star-server-\\$n-\\$i.pcap\", where `n` and `i` represent node and interface numbers. The command line should allow users to specify the number of nodes and modify the packet size and data rate of the traffic. Output should include queue and packet reception traces in the file \"tcp-star-server.tr\"."}, {"role": "assistant", "content": "// Default Network topology, 9 nodes in a star\n/*\n          n2 n3 n4\n           \\ | /\n            \\|/\n       n1---n0---n5\n            /| \\\n           / | \\\n          n8 n7 n6\n*/\n// - CBR Traffic goes from the star \"arms\" to the \"hub\"\n// - Tracing of queues and packet receptions to file\n//   \"tcp-star-server.tr\"\n// - pcap traces also generated in the following files\n//   \"tcp-star-server-$n-$i.pcap\" where n and i represent node and interface\n//   numbers respectively\n// Usage examples for things you might want to tweak:\n//       ./ns3 run \"tcp-star-server\"\n//       ./ns3 run \"tcp-star-server --nNodes=25\"\n//       ./ns3 run \"tcp-star-server --ns3::OnOffApplication::DataRate=10000\"\n//       ./ns3 run \"tcp-star-server --ns3::OnOffApplication::PacketSize=500\"\n// See the ns-3 tutorial for more info on the command line:\n// https://www.nsnam.org/docs/tutorial/html/index.html\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpServer\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Users may find it convenient to turn on explicit debugging\n    // for selected modules; the below lines suggest how to do this\n\n    // LogComponentEnable (\"TcpServer\", LOG_LEVEL_INFO);\n    // LogComponentEnable (\"TcpL4Protocol\", LOG_LEVEL_ALL);\n    // LogComponentEnable (\"TcpSocketImpl\", LOG_LEVEL_ALL);\n    // LogComponentEnable (\"PacketSink\", LOG_LEVEL_ALL);\n\n    // Set up some default values for the simulation.\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(250));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(\"5kb/s\"));\n    uint32_t N = 9; // number of nodes in the star\n\n    // Allow the user to override any of the defaults and the above\n    // Config::SetDefault()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nNodes\", \"Number of nodes to place in the star\", N);\n    cmd.Parse(argc, argv);\n\n    // Here, we will create N nodes in a star.\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer serverNode;\n    NodeContainer clientNodes;\n    serverNode.Create(1);\n    clientNodes.Create(N - 1);\n    NodeContainer allNodes = NodeContainer(serverNode, clientNodes);\n\n    // Install network stacks on the nodes\n    InternetStackHelper internet;\n    internet.Install(allNodes);\n\n    // Collect an adjacency list of nodes for the p2p topology\n    std::vector<NodeContainer> nodeAdjacencyList(N - 1);\n    for (uint32_t i = 0; i < nodeAdjacencyList.size(); ++i)\n    {\n        nodeAdjacencyList[i] = NodeContainer(serverNode, clientNodes.Get(i));\n    }\n\n    // We create the channels first without any IP addressing information\n    NS_LOG_INFO(\"Create channels.\");\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    std::vector<NetDeviceContainer> deviceAdjacencyList(N - 1);\n    for (uint32_t i = 0; i < deviceAdjacencyList.size(); ++i)\n    {\n        deviceAdjacencyList[i] = p2p.Install(nodeAdjacencyList[i]);\n    }\n\n    // Later, we add IP addresses.\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    std::vector<Ipv4InterfaceContainer> interfaceAdjacencyList(N - 1);\n    for (uint32_t i = 0; i < interfaceAdjacencyList.size(); ++i)\n    {\n        std::ostringstream subnet;\n        subnet << \"10.1.\" << i + 1 << \".0\";\n        ipv4.SetBase(subnet.str().c_str(), \"255.255.255.0\");\n        interfaceAdjacencyList[i] = ipv4.Assign(deviceAdjacencyList[i]);\n    }\n\n    // Turn on global static routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create a packet sink on the star \"hub\" to receive these packets\n    uint16_t port = 50000;\n    Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n    ApplicationContainer sinkApp = sinkHelper.Install(serverNode);\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Create the OnOff applications to send TCP to the server\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", Address());\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    // normally wouldn't need a loop here but the server IP address is different\n    // on each p2p subnet\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < clientNodes.GetN(); ++i)\n    {\n        AddressValue remoteAddress(\n            InetSocketAddress(interfaceAdjacencyList[i].GetAddress(0), port));\n        clientHelper.SetAttribute(\"Remote\", remoteAddress);\n        clientApps.Add(clientHelper.Install(clientNodes.Get(i)));\n    }\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // configure tracing\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"tcp-star-server.tr\"));\n    p2p.EnablePcapAll(\"tcp-star-server\");\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a node acts as a relay between a client and a server using a simple UDP forwarding mechanism. The client sends a UDP message to the relay, and the relay forwards it to the server. The server logs received messages. Keep the setup minimal with point-to-point links."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpRelayExample\");\n\n// Relay function: Forward received packets to the server\nvoid RelayPacket(Ptr<Socket> relaySocket, Address serverAddress) {\n    Ptr<Packet> packet;\n    while ((packet = relaySocket->Recv())) {\n        NS_LOG_INFO(\"Relay received a packet, forwarding to server...\");\n        relaySocket->SendTo(packet, 0, serverAddress);\n    }\n}\n\nint main() {\n    LogComponentEnable(\"UdpRelayExample\", LOG_LEVEL_INFO);\n\n    uint16_t clientPort = 4000, serverPort = 5000;\n\n    // Create nodes (client, relay, server)\n    NodeContainer nodes;\n    nodes.Create(3);\n    NodeContainer client = NodeContainer(nodes.Get(0));\n    NodeContainer relay = NodeContainer(nodes.Get(1));\n    NodeContainer server = NodeContainer(nodes.Get(2));\n\n    // Create point-to-point links\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer clientToRelay = pointToPoint.Install(client.Get(0), relay.Get(0));\n    NetDeviceContainer relayToServer = pointToPoint.Install(relay.Get(0), server.Get(0));\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer clientIface = address.Assign(clientToRelay);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer serverIface = address.Assign(relayToServer);\n\n    // Setup UDP Server\n    Ptr<Socket> serverSocket = Socket::CreateSocket(server.Get(0), UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), serverPort));\n    serverSocket->SetRecvCallback([](Ptr<Socket> socket) {\n        while (socket->Recv()) {\n            NS_LOG_INFO(\"Server received a forwarded packet!\");\n        }\n    });\n\n    // Setup UDP Relay\n    Ptr<Socket> relaySocket = Socket::CreateSocket(relay.Get(0), UdpSocketFactory::GetTypeId());\n    relaySocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), clientPort));\n    relaySocket->SetRecvCallback(MakeBoundCallback(&RelayPacket, relaySocket, InetSocketAddress(serverIface.GetAddress(1), serverPort)));\n\n    // Setup UDP Client\n    Ptr<Socket> clientSocket = Socket::CreateSocket(client.Get(0), UdpSocketFactory::GetTypeId());\n    InetSocketAddress relayAddress(clientIface.GetAddress(1), clientPort);\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, clientSocket, Create<Packet>(128), 0, relayAddress);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(3.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Wi-Fi network in infrastructure mode. The network should have one access point (AP) and two station (STA) nodes using the 802.11n standard. The AP and STAs should have unique IPv4 addresses in the 192.168.1.0/24 subnet. The AP should run a UDP echo server on port 9, while one STA should act as a client sending five packets of 512 bytes each. The nodes should be placed in a grid layout, and the simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create nodes: one AP and two stations\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Configure Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n\n    // Set up Wi-Fi PHY and channel\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Configure MAC layer\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Configure station devices\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure access point (AP) device\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set mobility\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Set up UDP echo server on the AP\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(wifiApNode.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP echo client on one of the stations\n    UdpEchoClientHelper echoClient(apInterface.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(wifiStaNodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Point-to-Point (P2P) wired network between two nodes. The link should have a data rate of 5 Mbps and a propagation delay of 2 ms. Node 0 should send TCP traffic using a BulkSend application, transmitting unlimited data to Node 1, which runs a PacketSink application to receive the packets. The simulation should run from 1 second to 10 seconds, using the 10.1.1.0/24 subnet."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleP2PTCPExample\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"BulkSendApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"PacketSink\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up a Point-to-Point (P2P) link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a TCP BulkSend application on Node 0\n    uint16_t port = 9;\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    source.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n    ApplicationContainer sourceApp = source.Install(nodes.Get(0));\n    sourceApp.Start(Seconds(1.0));\n    sourceApp.Stop(Seconds(10.0));\n\n    // Set up a PacketSink application on Node 1 to receive the TCP data\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sink.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 simulation library to set up an ad hoc wireless network with six nodes. Configure these nodes to operate in ad hoc mode using IEEE 802.11 and implement a grid mobility model that arranges them in a grid layout while allowing for random movement within a specified rectangular area. Install the Internet stack on each node and assign them IPv4 addresses from the 192.9.39.0/24 subnet. Establish UDP echo server applications on each node to facilitate communication in a ring topology where each node sends echo requests to the next. Limit each client to a maximum of 20 packets sent at half-second intervals. Integrate a flow monitor to collect statistics, including packet delivery ratios, end-to-end delays, and throughput for all communications. Generate an animation file to visualize the network activity during the simulation. After running the simulation, output the flow statistics and performance metrics to the console."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/propagation-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"AdhocNetworkExample\");\n\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable (\"AdhocNetworkExample\", LOG_LEVEL_INFO);\n\n  // Create two wireless nodes\n  NodeContainer nodes;\n  nodes.Create (6);\n\n  // Configure wireless parameters\n  WifiHelper wifi;\n\n  WifiMacHelper mac;\n  mac.SetType (\"ns3::AdhocWifiMac\");\n  \n\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default(); //define channel default configuration\n  YansWifiPhyHelper phy; //configure wifiPHY\n  phy.SetChannel(channel.Create());\n\n  \n\n  NetDeviceContainer devices = wifi.Install (phy, mac, nodes); //create wifiNetDevice\n  \n\n  // Set up mobility model\n  MobilityHelper mobility; //to set position of nodes\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0), //starting node x axis\n                                 \"MinY\", DoubleValue (0.0), //starting node y axis\n                                 \"DeltaX\", DoubleValue (2.0), //gap before next node in row\n                                 \"DeltaY\", DoubleValue (2.0), //gap before next node in column\n                                 \"GridWidth\", UintegerValue (5), // max number of nodes based on the layout type\n                                 \"LayoutType\", StringValue (\"RowFirst\")); //nodes will first fill up the rows then columns\n                                 \n                                \n  mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue(Rectangle(-100, 100, -100,100))); //nodes over randomly in 2D\n                                                                                          //nodes movement bound in rectangle   (Xmin,Xmax,Ymin,Ymax)        \n  mobility.Install (nodes); //install the nodes\n  \n  // Set up network stack\n  InternetStackHelper stack;\n  stack.Install (nodes);\n\n  // Assign IPv4 addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"192.9.39.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  UdpEchoServerHelper server01(10);\n\n  ApplicationContainer serverApps01 = server01.Install (nodes.Get (0));\n  serverApps01.Start (Seconds (1.0));\n  serverApps01.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client01 (interfaces.GetAddress (0), 10);\n  client01.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client01.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client01.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps01 = client01.Install (nodes.Get (1));\n  clientApps01.Start (Seconds (2.0));\n  clientApps01.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server12(21);\n\n  ApplicationContainer serverApps12 = server12.Install (nodes.Get (1));\n  serverApps12.Start (Seconds (1.0));\n  serverApps12.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client12 (interfaces.GetAddress (1), 21);\n  client12.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client12.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client12.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps12 = client12.Install (nodes.Get (2));\n  clientApps12.Start (Seconds (2.0));\n  clientApps12.Stop (Seconds (100.0));\n\n    UdpEchoServerHelper server23(27);\n\n  ApplicationContainer serverApps23 = server23.Install (nodes.Get (2));\n  serverApps23.Start (Seconds (1.0));\n  serverApps23.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client23 (interfaces.GetAddress (2), 27);\n  client23.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client23.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client23.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps23 = client23.Install (nodes.Get (3));\n  clientApps23.Start (Seconds (2.0));\n  clientApps23.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server34(33);\n\n  ApplicationContainer serverApps34 = server34.Install (nodes.Get (3));\n  serverApps34.Start (Seconds (1.0));\n  serverApps34.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client34 (interfaces.GetAddress (3), 33);\n  client34.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client34.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client34.SetAttribute (\"PacketSize\", UintegerValue (1024));\n\n  ApplicationContainer clientApps34 = client34.Install (nodes.Get (4));\n  clientApps34.Start (Seconds (2.0));\n  clientApps34.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server45(39);\n\n  ApplicationContainer serverApps45 = server45.Install (nodes.Get (4));\n  serverApps45.Start (Seconds (1.0));\n  serverApps45.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client45 (interfaces.GetAddress (4), 39);\n  client45.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client45.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client45.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps45 = client45.Install (nodes.Get (5));\n  clientApps45.Start (Seconds (2.0));\n  clientApps45.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server50(17);\n\n  ApplicationContainer serverApps50 = server50.Install (nodes.Get (5));\n  serverApps50.Start (Seconds (1.0));\n  serverApps50.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client50 (interfaces.GetAddress (5), 17);\n  client50.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client50.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client50.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps50 = client50.Install (nodes.Get (0));\n  clientApps50.Start (Seconds (2.0));\n  clientApps50.Stop (Seconds (100.0));\n\n\n\n  // Define a flow monitor object\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();\n  Simulator::Stop(Seconds(100.0));\n  \n  \n  // Animation\n  AnimationInterface anim(\"239_task5_6nodes.xml\");\n  \n\n  // Run simulation\n  Simulator::Run ();\n  \n \n  \n Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());\n std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats ();\nfor (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n{\n // Calculate packet delivery ratio and end to end delay and throughput\n  uint32_t packetsDelivered = 0;\n  uint32_t totalPackets = 0;\n  double totalDelay = 0;\n Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);\nstd::cout << \"FlowId: \" << i->first << \"\\n\";\nstd::cout << \"Sender: \"<< t.sourceAddress << \"\\n\"; \nstd::cout << \"Receiver: \"<< t.destinationAddress << \"\\n\"; \nstd::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\nstd::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n\nstd::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\nstd::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\nif(i->second.rxPackets > 0)\n  \t{\n  \t\tpacketsDelivered += i->second.rxPackets;\n  \t\ttotalPackets += i->second.txPackets;\n  \t\ttotalDelay += (i->second.delaySum.ToDouble(ns3::Time::S) / i->second.rxPackets);\n  \t}\n       \n  double packetDeliveryRatio = (double) packetsDelivered / totalPackets;\n  double averageEndToEndDelay = totalDelay / packetsDelivered;\n  double throughput = (double) packetsDelivered * 1024 * 8 / (100.0 - 0.0) / 1000000;\n  \n  // Printing the results\n  std::cout << \"Packets Delivered Ratio: \" << packetDeliveryRatio << std::endl;\n  std::cout << \"Average End-to-End Delay: \" << averageEndToEndDelay << std::endl;\n  std::cout << \"Throughput: \" << throughput << std::endl;\n   }\n  \n \n  \n  Simulator::Destroy ();\n\n  return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulator that sets up a three-router network topology where routers A, B, and C are interconnected by point-to-point links. The topology is as follows: router A has an IP address in the range a.a.a.a/32, router B connects A and C over subnet x.x.x.0/30 and y.y.y.0/30, and router C has an IP address in the range c.c.c.c/32. Install an OnOff UDP application on router A to send datagrams to router C, and set up a packet sink on router C to receive the traffic. Use the Ipv4GlobalRoutingHelper to populate routing tables, configure packet tracing, and run the simulation for 10 seconds."}, {"role": "assistant", "content": "// Test program for this 3-router scenario, using global routing\n//\n// (a.a.a.a/32)A<--x.x.x.0/30-->B<--y.y.y.0/30-->C(c.c.c.c/32)\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-net-device.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"GlobalRouterSlash32Test\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Ptr<Node> nA = CreateObject<Node>();\n    Ptr<Node> nB = CreateObject<Node>();\n    Ptr<Node> nC = CreateObject<Node>();\n\n    NodeContainer c = NodeContainer(nA, nB, nC);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // Point-to-point links\n    NodeContainer nAnB = NodeContainer(nA, nB);\n    NodeContainer nBnC = NodeContainer(nB, nC);\n\n    // We create the channels first without any IP addressing information\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer dAdB = p2p.Install(nAnB);\n\n    NetDeviceContainer dBdC = p2p.Install(nBnC);\n\n    Ptr<CsmaNetDevice> deviceA = CreateObject<CsmaNetDevice>();\n    deviceA->SetAddress(Mac48Address::Allocate());\n    nA->AddDevice(deviceA);\n    deviceA->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    Ptr<CsmaNetDevice> deviceC = CreateObject<CsmaNetDevice>();\n    deviceC->SetAddress(Mac48Address::Allocate());\n    nC->AddDevice(deviceC);\n    deviceC->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    // Later, we add IP addresses.\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iAiB = ipv4.Assign(dAdB);\n\n    ipv4.SetBase(\"10.1.1.4\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iBiC = ipv4.Assign(dBdC);\n\n    Ptr<Ipv4> ipv4A = nA->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4C = nC->GetObject<Ipv4>();\n\n    int32_t ifIndexA = ipv4A->AddInterface(deviceA);\n    int32_t ifIndexC = ipv4C->AddInterface(deviceC);\n\n    Ipv4InterfaceAddress ifInAddrA =\n        Ipv4InterfaceAddress(Ipv4Address(\"172.16.1.1\"), Ipv4Mask(\"255.255.255.255\"));\n    ipv4A->AddAddress(ifIndexA, ifInAddrA);\n    ipv4A->SetMetric(ifIndexA, 1);\n    ipv4A->SetUp(ifIndexA);\n\n    Ipv4InterfaceAddress ifInAddrC =\n        Ipv4InterfaceAddress(Ipv4Address(\"192.168.1.1\"), Ipv4Mask(\"255.255.255.255\"));\n    ipv4C->AddAddress(ifIndexC, ifInAddrC);\n    ipv4C->SetMetric(ifIndexC, 1);\n    ipv4C->SetUp(ifIndexC);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(ifInAddrC.GetLocal(), port)));\n    onoff.SetConstantRate(DataRate(6000));\n    ApplicationContainer apps = onoff.Install(nA);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(nC);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"global-routing-slash32.tr\"));\n    p2p.EnablePcapAll(\"global-routing-slash32\");\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an NS-3 simulation in C++ that sets up a network with two nodes. Install the Internet stack on these nodes and establish a point-to-point link between them with a transmission rate of 5 Mbps and a propagation delay of 2 milliseconds. Assign IP addresses from the range \"10.1.1.0/24\" to the devices on each node. The goal is to ensure that the Internet Protocol (IP) addresses are correctly assigned to the nodes, but no communication between the nodes is required in this simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"NodeIpAddressAssignment\");\n\nint main(int argc, char *argv[]) {\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link between the two nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack (IP protocol)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 to simulate a bus topology with 4 nodes. All nodes are connected to a shared bus network using a CSMA (Carrier Sense Multiple Access) channel. Set up a UDP Echo server on node 3 and configure node 0 to send traffic to node 3 via the shared bus. Assign IP addresses and enable PCAP tracing to capture traffic. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BusTopology4Nodes\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"BusTopology4Nodes\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes: node 0, node 1, node 2, and node 3\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Set up CSMA (bus) channel between nodes\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install CSMA devices on the nodes\n    NetDeviceContainer devices = csma.Install(nodes);\n\n    // Install the internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a UDP Echo server on node 3\n    UdpEchoServerHelper echoServer(9);  // Port number\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(3));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 0 to send packets to node 3\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(3), 9);  // Address of node 3\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));  // Client on node 0\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing to capture packet transmissions\n    csma.EnablePcapAll(\"bus-topology-4-nodes\");\n\n    // Run the simulation\n    Simulator::Run();\n\n    // End the simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the NS-3 simulation framework to simulate a network topology with two nodes (n0 and n1) connected via a CSMA LAN. The program should simulate a UDP flow from node n0 to node n1, where the client on n0 sends packets based on the data read from a trace file. The user should be able to select between IPv4 and IPv6 addressing via command-line arguments and also have the option to enable or disable logging statements. When logging is enabled, it should provide detailed logs for both the UDP client and server. Configure the CSMA channel with a data rate of 5 Mbps, a delay of 2 ms, and an MTU of 1500 bytes. The UDP server should run on port 4000 and be installed on node n1, starting at 1 second and stopping at 10 seconds. The UDP client should back off 28 bytes (20 for IP and 8 for UDP) from the MTU to set the maximum packet size at 1472 bytes and start sending packets at 2 seconds, stopping at 10 seconds. Use the required NS-3 modules (applications, core, csma, and internet), and ensure the program runs with appropriate logging and simulation outputs."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1\n//       |     |\n//       =======\n//         LAN (CSMA)\n//\n// - UDP flow from n0 to n1 of packets drawn from a trace file\n//  -- option to use IPv4 or IPv6 addressing\n//  -- option to disable logging statements\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpTraceClientServerExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Declare variables used in command-line arguments\n    bool useV6 = false;\n    bool logging = true;\n    Address serverAddress;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"useIpv6\", \"Use Ipv6\", useV6);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.Parse(argc, argv);\n\n    if (logging)\n    {\n        LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n    }\n\n    NS_LOG_INFO(\"Create nodes in above topology.\");\n    NodeContainer n;\n    n.Create(2);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    NS_LOG_INFO(\"Create channel between the two nodes.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1500));\n    NetDeviceContainer d = csma.Install(n);\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    if (!useV6)\n    {\n        Ipv4AddressHelper ipv4;\n        ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer i = ipv4.Assign(d);\n        serverAddress = Address(i.GetAddress(1));\n    }\n    else\n    {\n        Ipv6AddressHelper ipv6;\n        ipv6.SetBase(\"2001:0000:f00d:cafe::\", Ipv6Prefix(64));\n        Ipv6InterfaceContainer i6 = ipv6.Assign(d);\n        serverAddress = Address(i6.GetAddress(1, 1));\n    }\n\n    NS_LOG_INFO(\"Create UdpServer application on node 1.\");\n    uint16_t port = 4000;\n    UdpServerHelper server(port);\n    ApplicationContainer apps = server.Install(n.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Create UdpClient application on node 0 to send to node 1.\");\n    uint32_t MaxPacketSize = 1472; // Back off 20 (IP) + 8 (UDP) bytes from MTU\n    UdpTraceClientHelper client(serverAddress, port, \"\");\n    client.SetAttribute(\"MaxPacketSize\", UintegerValue(MaxPacketSize));\n    apps = client.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 that simulates a network with a hub and trunk ports. The hub connects four nodes, where three nodes belong to different subnets (acting as separate VLANs) and communicate with each other via a central hub node. The hub node acts as a router, routing traffic between the subnets. Use the CSMA helper to simulate the shared medium, assign different subnets to each node, and set up routing tables. Enable packet tracing to capture the traffic and generate a pcap trace file."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TrunkPortSimulation\");\n\nint main(int argc, char *argv[])\n{\n    // Step 1: Create nodes\n    NodeContainer hubNode; // Central hub node\n    hubNode.Create(1);\n\n    NodeContainer clientNodes;\n    clientNodes.Create(3); // Three client nodes representing VLANs\n\n    // Step 2: Create a CSMA network (shared medium like a hub)\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install CSMA devices to the nodes\n    NodeContainer allNodes = NodeContainer(hubNode, clientNodes);\n    NetDeviceContainer devices = csma.Install(allNodes);\n\n    // Step 3: Install the internet stack\n    InternetStackHelper internet;\n    internet.Install(allNodes);\n\n    // Step 4: Assign IP addresses to different VLANs (subnets)\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vlan1Interfaces = ipv4.Assign(devices.Get(0)); // Hub side\n    vlan1Interfaces.Add(ipv4.Assign(devices.Get(1)));                     // Client 1\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vlan2Interfaces = ipv4.Assign(devices.Get(2)); // Client 2\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vlan3Interfaces = ipv4.Assign(devices.Get(3)); // Client 3\n\n    // Step 5: Set up routing between the VLANs\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Step 6: Create applications to simulate communication between VLANs\n    // UDP Echo Server on node 1 (Client 1 in VLAN 1)\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(clientNodes.Get(0)); // Client 1\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // UDP Echo Client on node 2 (Client 2 in VLAN 2), sending to Client 1\n    UdpEchoClientHelper echoClient(vlan1Interfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(clientNodes.Get(1)); // Client 2\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Step 7: Enable packet tracing (pcap tracing)\n    csma.EnablePcap(\"trunk-port-simulation\", devices);\n\n    // Step 8: Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ simulation script using NS-3 to demonstrate how to modify Wi-Fi timing parameters, such as slot time, SIFS, and PIFS, through command-line arguments. The simulation features a simple network topology with an access point (AP) and a station (STA) using 802.11n over a 2.4 GHz channel. The AP runs a UDP client that sends packets to a UDP server on the STA, and the throughput is calculated at the end of the simulation. Implement the required wireless channel, PHY, MAC, mobility, and internet stacks, while adjusting Wi-Fi timing attributes like slot, SIFS, and PIFS dynamically."}, {"role": "assistant", "content": "#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This example shows how to set Wi-Fi timing parameters through WifiMac attributes.\n//\n// Example: set slot time to 20 microseconds, while keeping other values as defined in the\n// simulation script:\n//\n//          ./ns3 run \"wifi-timing-attributes --slot=20us\"\n//\n// Network topology:\n//\n//  Wifi 192.168.1.0\n//\n//       AP\n//  *    *\n//  |    |\n//  n1   n2\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"wifi-timing-attributes\");\n\nint\nmain(int argc, char* argv[])\n{\n    Time slot{\"9us\"};           // slot time\n    Time sifs{\"10us\"};          // SIFS duration\n    Time pifs{\"19us\"};          // PIFS duration\n    Time simulationTime{\"10s\"}; // Simulation time\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"slot\", \"Slot time\", slot);\n    cmd.AddValue(\"sifs\", \"SIFS duration\", sifs);\n    cmd.AddValue(\"pifs\", \"PIFS duration\", pifs);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.Parse(argc, argv);\n\n    // Since default reference loss is defined for 5 GHz, it needs to be changed when operating\n    // at 2.4 GHz\n    Config::SetDefault(\"ns3::LogDistancePropagationLossModel::ReferenceLoss\", DoubleValue(40.046));\n\n    // Create nodes\n    NodeContainer wifiStaNode;\n    wifiStaNode.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Create wireless channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    // Default IEEE 802.11n (2.4 GHz)\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"HtMcs7\"),\n                                 \"ControlMode\",\n                                 StringValue(\"HtMcs0\"));\n    WifiMacHelper mac;\n\n    // Install PHY and MAC\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevice;\n    staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Once install is done, we overwrite the standard timing values\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/Slot\", TimeValue(slot));\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/Sifs\", TimeValue(sifs));\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/Pifs\", TimeValue(pifs));\n\n    // Mobility\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(1.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNode);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNode);\n\n    Ipv4AddressHelper address;\n\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staNodeInterface;\n    Ipv4InterfaceContainer apNodeInterface;\n\n    staNodeInterface = address.Assign(staDevice);\n    apNodeInterface = address.Assign(apDevice);\n\n    // Setting applications\n    uint16_t port = 9;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiStaNode.Get(0));\n    serverApp.Start(Seconds(0.0));\n    serverApp.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper client(staNodeInterface.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    client.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    client.SetAttribute(\"PacketSize\", UintegerValue(1472));     // bytes\n\n    ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(simulationTime + Seconds(1.0));\n\n    // Populate routing table\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Set simulation time and launch simulation\n    Simulator::Stop(simulationTime + Seconds(1.0));\n    Simulator::Run();\n\n    // Get and print results\n    double totalPacketsThrough = DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n    auto throughput = totalPacketsThrough * 1472 * 8 / simulationTime.GetMicroSeconds(); // Mbit/s\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s\" << std::endl;\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Wi-Fi network with two mobile devices (STA) and a single access point (AP). Both devices exchange UDP packets (1024 bytes each) with the access point on port 9, with a 1-second interval between each packet. The mobile devices are using a random walk mobility model in a 100m x 100m area, while the access point is stationary. Use the Wi-Fi 802.11n 5GHz standard and assign IP addresses in the 10.1.1.0/24 range."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MobileWifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"MobileWifiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: two mobile devices and one access point (AP)\n    NodeContainer wifiStaNodes, wifiApNode;\n    wifiStaNodes.Create(2); // Two mobile devices\n    wifiApNode.Create(1);   // One access point\n\n    // Install Wi-Fi devices on the nodes\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n\n    WifiMacHelper mac;\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-ssid\")));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-ssid\")));\n    NetDeviceContainer apDevices = wifi.Install(phy, mac, wifiApNode);\n\n    // Set mobility for the sender and receiver (random walk in a 100m x 100m area)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(wifiStaNodes); // Install mobility on the mobile devices\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode); // Install constant position for AP\n\n    // Install the internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterfaces = address.Assign(apDevices);\n\n    // Set up UDP server on the access point\n    UdpServerHelper udpServer(9); // Listening on port 9\n    ApplicationContainer serverApp = udpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the mobile devices\n    UdpClientHelper udpClient(apInterfaces.GetAddress(0), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // Send 10 packets\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // 1-second interval\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // 1024 byte packets\n\n    ApplicationContainer clientApp1 = udpClient.Install(wifiStaNodes.Get(0)); // First mobile device\n    ApplicationContainer clientApp2 = udpClient.Install(wifiStaNodes.Get(1)); // Second mobile device\n    clientApp1.Start(Seconds(2.0));\n    clientApp1.Stop(Seconds(10.0));\n    clientApp2.Start(Seconds(2.0));\n    clientApp2.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a Wi-Fi network in NS-3 with two nodes: one as an access point (AP) and the other as a station (STA). The station sends UDP packets to the access point. Use the SSID ns3-wifi for both devices. Set the link data rate to 54Mbps, and run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Wi-Fi settings\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, nodes.Get(1));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\", SsidValue(ssid));\n    devices.Add(wifi.Install(phy, mac, nodes.Get(0)));\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP application on node 1 (server)\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on node 0 (station)\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a sensor node periodically transmits data using UDP to a sink node over a wireless LoRaWAN network. The sink node logs the received data. Keep the setup minimal, with a single sensor node and one sink."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lorawan-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LoRaSensorExample\");\n\n// Function to log received packets\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Sink received data from sensor!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"LoRaSensorExample\", LOG_LEVEL_INFO);\n\n    uint16_t port = 6000;\n\n    // Create nodes (sensor and sink)\n    NodeContainer nodes;\n    nodes.Create(2);\n    Ptr<Node> sensor = nodes.Get(0);\n    Ptr<Node> sink = nodes.Get(1);\n\n    // LoRaWAN setup\n    LoraHelper lora;\n    LoraPhyHelper phy = LoraPhyHelper::Default();\n    LorawanMacHelper mac;\n    LorawanHelper lorawan;\n    \n    NetDeviceContainer devices = lorawan.Install(lora, phy, mac, nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Setup UDP Sink (Receiver)\n    Ptr<Socket> sinkSocket = Socket::CreateSocket(sink, UdpSocketFactory::GetTypeId());\n    sinkSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    sinkSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Sensor (Sender)\n    Ptr<Socket> sensorSocket = Socket::CreateSocket(sensor, UdpSocketFactory::GetTypeId());\n    InetSocketAddress sinkAddress(interfaces.GetAddress(1), port);\n\n    // Send periodic packets (every 5 seconds)\n    for (double time = 1.0; time <= 10.0; time += 5.0) {\n        Simulator::Schedule(Seconds(time), &Socket::SendTo, sensorSocket, Create<Packet>(64), 0, sinkAddress);\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(12.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate TCP communication between two nodes in a point-to-point network. One node should act as a TCP server and the other as a TCP client. The client should send 10 packets of size 1024 bytes at a 1-second interval. The server should be installed on Node 0, and the client on Node 1. The nodes should be connected via a point-to-point link with a 5 Mbps data rate and 2 ms delay. The simulation should run for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpClientServerExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"TcpClientServerExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link between the nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install the internet stack (IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create and install the TCP server on Node 0\n    uint16_t port = 9; // Port number for TCP connection\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create and install the TCP client on Node 1\n    TcpClientHelper tcpClient(interfaces.GetAddress(0), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // Send 10 packets\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // Interval between packets\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // Packet size\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and organizes them in a tree topology. The program should have a single root node, a set of intermediate nodes, and leaf nodes, with each parent connecting to its children using Point-to-Point links. The program should then print confirmation of the established connections. Keep the example simple, focusing only on node creation and topology setup."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"TreeTopologyExample\", LOG_LEVEL_INFO);\n\n    // Define tree structure\n    uint32_t numLevels = 2;  // Number of levels in the tree\n    uint32_t branchingFactor = 2;  // Number of children per node\n    uint32_t numNodes = 1 + branchingFactor + (branchingFactor * branchingFactor); // Root + Level 1 + Level 2\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(numNodes);\n\n    // Point-to-Point Helper\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Connect root to first level nodes\n    uint32_t nodeIndex = 1;  // Start from the first child node\n    for (uint32_t i = 0; i < branchingFactor; ++i) {\n        NodeContainer link(nodes.Get(0), nodes.Get(nodeIndex));\n        p2p.Install(link);\n        NS_LOG_INFO(\"Connected Root Node 0 to Node \" << nodeIndex);\n        nodeIndex++;\n    }\n\n    // Connect first level nodes to second level nodes\n    uint32_t parentIndex = 1;\n    for (uint32_t i = 0; i < branchingFactor; ++i) {\n        for (uint32_t j = 0; j < branchingFactor; ++j) {\n            NodeContainer link(nodes.Get(parentIndex), nodes.Get(nodeIndex));\n            p2p.Install(link);\n            NS_LOG_INFO(\"Connected Node \" << parentIndex << \" to Node \" << nodeIndex);\n            nodeIndex++;\n        }\n        parentIndex++;\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Point-to-Point (P2P) network with two nodes. One node acts as a TCP server on port 8080, and the other node acts as a TCP client. The client sends 1,000 TCP packets of 1024 bytes each with an interval of 0.01 seconds. The server starts at 1 second, and the client starts at 2 seconds. The point-to-point link has a data rate of 5 Mbps and a delay of 2 ms. The simulation runs for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleP2PExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleP2PExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link between nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install internet stack (IP, TCP, etc.)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfaces = ipv4.Assign(devices);\n\n    // Set up TCP server on node 1\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on node 0\n    TcpClientHelper tcpClient(ipInterfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program that simulates an ad-hoc WiFi network using NS-3. The program should include the necessary NS-3 libraries like command-line parsing, logging, gnuplot generation, mobility models, packet sockets, and WiFi helpers. Define a class `Experiment` that handles the creation and running of the experiment, with methods to set and get the position of nodes, move them, receive packets, and set up packet reception sockets. In the `Run` method, configure two nodes with WiFi devices, assign constant mobility, and configure an `OnOffHelper` to send packets. For each experiment, the nodes should move and log throughput data in a 2D dataset to generate gnuplot graphs. The main function should simulate the experiment for different WiFi rates and managers, generating output graphs for each experiment run."}, {"role": "assistant", "content": "#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-socket-address.h\"\n#include \"ns3/packet-socket-helper.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Wifi-Adhoc\");\n\n/**\n * WiFi adhoc experiment class.\n *\n * It handles the creation and run of an experiment.\n */\nclass Experiment\n{\n  public:\n    Experiment();\n    /**\n     * Constructor.\n     * \\param name The name of the experiment.\n     */\n    Experiment(std::string name);\n\n    /**\n     * Run an experiment.\n     * \\param wifi      //!< The WifiHelper class.\n     * \\param wifiPhy   //!< The YansWifiPhyHelper class.\n     * \\param wifiMac   //!< The WifiMacHelper class.\n     * \\param wifiChannel //!< The YansWifiChannelHelper class.\n     * \\return a 2D dataset of the experiment data.\n     */\n    Gnuplot2dDataset Run(const WifiHelper& wifi,\n                         const YansWifiPhyHelper& wifiPhy,\n                         const WifiMacHelper& wifiMac,\n                         const YansWifiChannelHelper& wifiChannel);\n\n  private:\n    /**\n     * Receive a packet.\n     * \\param socket The receiving socket.\n     */\n    void ReceivePacket(Ptr<Socket> socket);\n    /**\n     * Set the position of a node.\n     * \\param node The node.\n     * \\param position The position of the node.\n     */\n    void SetPosition(Ptr<Node> node, Vector position);\n    /**\n     * Get the position of a node.\n     * \\param node The node.\n     * \\return the position of the node.\n     */\n    Vector GetPosition(Ptr<Node> node);\n    /**\n     * Move a node by 1m on the x axis, stops at 210m.\n     * \\param node The node.\n     */\n    void AdvancePosition(Ptr<Node> node);\n    /**\n     * Setup the receiving socket.\n     * \\param node The receiving node.\n     * \\return the socket.\n     */\n    Ptr<Socket> SetupPacketReceive(Ptr<Node> node);\n\n    uint32_t m_bytesTotal;     //!< The number of received bytes.\n    Gnuplot2dDataset m_output; //!< The output dataset.\n};\n\nExperiment::Experiment()\n{\n}\n\nExperiment::Experiment(std::string name)\n    : m_output(name)\n{\n    m_output.SetStyle(Gnuplot2dDataset::LINES);\n}\n\nvoid\nExperiment::SetPosition(Ptr<Node> node, Vector position)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    mobility->SetPosition(position);\n}\n\nVector\nExperiment::GetPosition(Ptr<Node> node)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    return mobility->GetPosition();\n}\n\nvoid\nExperiment::AdvancePosition(Ptr<Node> node)\n{\n    Vector pos = GetPosition(node);\n    double mbs = ((m_bytesTotal * 8.0) / 1000000);\n    m_bytesTotal = 0;\n    m_output.Add(pos.x, mbs);\n    pos.x += 1.0;\n    if (pos.x >= 210.0)\n    {\n        return;\n    }\n    SetPosition(node, pos);\n    Simulator::Schedule(Seconds(1.0), &Experiment::AdvancePosition, this, node);\n}\n\nvoid\nExperiment::ReceivePacket(Ptr<Socket> socket)\n{\n    Ptr<Packet> packet;\n    while ((packet = socket->Recv()))\n    {\n        m_bytesTotal += packet->GetSize();\n    }\n}\n\nPtr<Socket>\nExperiment::SetupPacketReceive(Ptr<Node> node)\n{\n    TypeId tid = TypeId::LookupByName(\"ns3::PacketSocketFactory\");\n    Ptr<Socket> sink = Socket::CreateSocket(node, tid);\n    sink->Bind();\n    sink->SetRecvCallback(MakeCallback(&Experiment::ReceivePacket, this));\n    return sink;\n}\n\nGnuplot2dDataset\nExperiment::Run(const WifiHelper& wifi,\n                const YansWifiPhyHelper& wifiPhy,\n                const WifiMacHelper& wifiMac,\n                const YansWifiChannelHelper& wifiChannel)\n{\n    m_bytesTotal = 0;\n\n    NodeContainer c;\n    c.Create(2);\n\n    PacketSocketHelper packetSocket;\n    packetSocket.Install(c);\n\n    YansWifiPhyHelper phy = wifiPhy;\n    phy.SetChannel(wifiChannel.Create());\n\n    NetDeviceContainer devices = wifi.Install(phy, wifiMac, c);\n\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(c);\n\n    PacketSocketAddress socket;\n    socket.SetSingleDevice(devices.Get(0)->GetIfIndex());\n    socket.SetPhysicalAddress(devices.Get(1)->GetAddress());\n    socket.SetProtocol(1);\n\n    OnOffHelper onoff(\"ns3::PacketSocketFactory\", Address(socket));\n    onoff.SetConstantRate(DataRate(60000000));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(2000));\n\n    ApplicationContainer apps = onoff.Install(c.Get(0));\n    apps.Start(Seconds(0.5));\n    apps.Stop(Seconds(250.0));\n\n    Simulator::Schedule(Seconds(1.5), &Experiment::AdvancePosition, this, c.Get(1));\n    Ptr<Socket> recvSink = SetupPacketReceive(c.Get(1));\n\n    Simulator::Run();\n\n    Simulator::Destroy();\n\n    return m_output;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Gnuplot gnuplot = Gnuplot(\"reference-rates.png\");\n\n    Experiment experiment;\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n    WifiMacHelper wifiMac;\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    Gnuplot2dDataset dataset;\n\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NS_LOG_DEBUG(\"54\");\n    experiment = Experiment(\"54mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate54Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"48\");\n    experiment = Experiment(\"48mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate48Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"36\");\n    experiment = Experiment(\"36mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate36Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"24\");\n    experiment = Experiment(\"24mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate24Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"18\");\n    experiment = Experiment(\"18mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate18Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"12\");\n    experiment = Experiment(\"12mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate12Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"9\");\n    experiment = Experiment(\"9mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate9Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"6\");\n    experiment = Experiment(\"6mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate6Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    gnuplot.GenerateOutput(std::cout);\n\n    gnuplot = Gnuplot(\"rate-control.png\");\n\n    NS_LOG_DEBUG(\"arf\");\n    experiment = Experiment(\"arf\");\n    wifi.SetRemoteStationManager(\"ns3::ArfWifiManager\");\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"aarf\");\n    experiment = Experiment(\"aarf\");\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"aarf-cd\");\n    experiment = Experiment(\"aarf-cd\");\n    wifi.SetRemoteStationManager(\"ns3::AarfcdWifiManager\");\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"cara\");\n    experiment = Experiment(\"cara\");\n    wifi.SetRemoteStationManager(\"ns3::CaraWifiManager\");\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"rraa\");\n    experiment = Experiment(\"rraa\");\n    wifi.SetRemoteStationManager(\"ns3::RraaWifiManager\");\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"ideal\");\n    experiment = Experiment(\"ideal\");\n    wifi.SetRemoteStationManager(\"ns3::IdealWifiManager\");\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    gnuplot.GenerateOutput(std::cout);\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Point-to-Point network with two nodes communicating using UDP. The link between the nodes should have a bandwidth of 5Mbps and a delay of 2ms. The client node (node 0) sends 10 UDP packets of 1024 bytes every 1 second to the server node (node 1) on port 9. The server (node 1) should be running an UDP echo server on port 9. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"P2PUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"P2PUdpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the Point-to-Point link with a bandwidth of 5Mbps and delay of 2ms\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install the devices on the nodes\n    NetDeviceContainer devices = p2p.Install(nodes);\n\n    // Set up the Internet stack (IP/TCP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Install a UDP echo server on node 1 (server side)\n    UdpEchoServerHelper echoServer(9); // Port 9\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Install a UDP client on node 0 (client side)\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1), 9); // Server address and port 9\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024)); // 1024 bytes packet\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a WiFi network in NS-3 with two nodes using the 802.11n standard at 5GHz. Set up a UDP application where Node 1 sends packets to Node 2. Start the server on Node 2 at 1s and the client on Node 1 at 2s. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the WiFi PHY and MAC layer\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::StaWifiMac\");\n\n    // Set up WiFi channel and PHY\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Install devices on nodes\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, nodes);\n\n    // Install internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 2\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(1), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the NS-3 simulation framework to simulate a network topology where four nodes (n0, n1, n2, n3) are connected to a LAN using CSMA. The program should simulate UDP flows from node n0 to node n1 and back, with a UDP echo server on n1 (port 9) and a UDP echo client on n0. The client sends one 1024-byte packet at 1-second intervals, starting at 2 seconds and stopping at 10 seconds. Include both IPv4 and IPv6 options, allowing the user to choose via command-line arguments. Configure the CSMA channel with a 5 Mbps data rate, 2 ms delay, and 1400-byte MTU. Enable tracing of queue events and packet receptions, saving the results in a file called \"udp-echo.tr\", and also enable pcap tracing. Allow for additional logging for specific sections. Use the required NS-3 modules (applications, core, csma, and internet), and ensure the program runs the simulation with appropriate log outputs."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1   n2   n3\n//       |     |    |    |\n//       =================\n//              LAN\n//\n// - UDP flows from n0 to n1 and back\n// - DropTail queues\n// - Tracing of queues and packet receptions to file \"udp-echo.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpEchoExample\");\n\nint\nmain(int argc, char* argv[])\n{\n//\n// Users may find it convenient to turn on explicit debugging\n// for selected modules; the below lines suggest how to do this\n//\n#if 0\n  LogComponentEnable (\"UdpEchoExample\", LOG_LEVEL_INFO);\n  LogComponentEnable (\"UdpEchoClientApplication\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"UdpEchoServerApplication\", LOG_LEVEL_ALL);\n#endif\n    //\n    // Allow the user to override any of the defaults and the above Bind() at\n    // run-time, via command-line arguments\n    //\n    bool useV6 = false;\n    Address serverAddress;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"useIpv6\", \"Use Ipv6\", useV6);\n    cmd.Parse(argc, argv);\n    //\n    // Explicitly create the nodes required by the topology (shown above).\n    //\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer n;\n    n.Create(4);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    NS_LOG_INFO(\"Create channels.\");\n    //\n    // Explicitly create the channels required by the topology (shown above).\n    //\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    //\n    // We've got the \"hardware\" in place.  Now we need to add IP addresses.\n    //\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    if (!useV6)\n    {\n        Ipv4AddressHelper ipv4;\n        ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer i = ipv4.Assign(d);\n        serverAddress = Address(i.GetAddress(1));\n    }\n    else\n    {\n        Ipv6AddressHelper ipv6;\n        ipv6.SetBase(\"2001:0000:f00d:cafe::\", Ipv6Prefix(64));\n        Ipv6InterfaceContainer i6 = ipv6.Assign(d);\n        serverAddress = Address(i6.GetAddress(1, 1));\n    }\n\n    NS_LOG_INFO(\"Create Applications.\");\n    //\n    // Create a UdpEchoServer application on node one.\n    //\n    uint16_t port = 9; // well-known echo port number\n    UdpEchoServerHelper server(port);\n    ApplicationContainer apps = server.Install(n.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    //\n    // Create a UdpEchoClient application to send UDP datagrams from node zero to\n    // node one.\n    //\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 1;\n    Time interPacketInterval = Seconds(1.);\n    UdpEchoClientHelper client(serverAddress, port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n    apps = client.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n#if 0\n//\n// Users may find it convenient to initialize echo packets with actual data;\n// the below lines suggest how to do this\n//\n  client.SetFill (apps.Get (0), \"Hello World\");\n\n  client.SetFill (apps.Get (0), 0xa5, 1024);\n\n  uint8_t fill[] = { 0, 1, 2, 3, 4, 5, 6};\n  client.SetFill (apps.Get (0), fill, sizeof(fill), 1024);\n#endif\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"udp-echo.tr\"));\n    csma.EnablePcapAll(\"udp-echo\", false);\n\n    //\n    // Now, do the actual simulation.\n    //\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a data center network in ns-3 using Fat-Tree topology. Create a scenario where servers send data to each other across the network using TCP connections. Simulate the transmission of traffic and observe the packet flow across different layers of the topology. Use NetAnim for visualization."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"FatTreeDataCenter\");\n\nint main(int argc, char *argv[])\n{\n    // Simulation parameters\n    uint32_t numServers = 4;\n    double simulationTime = 10.0; // seconds\n\n    // Create nodes\n    NodeContainer coreSwitch;\n    coreSwitch.Create(1); // Single core switch\n\n    NodeContainer aggregationSwitches;\n    aggregationSwitches.Create(2); // Two aggregation switches\n\n    NodeContainer edgeSwitches;\n    edgeSwitches.Create(2); // Two edge switches\n\n    NodeContainer servers;\n    servers.Create(numServers); // Four servers\n\n    // Point-to-Point link attributes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Gbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Connect core to aggregation switches\n    NetDeviceContainer coreToAggDevices;\n    coreToAggDevices.Add(pointToPoint.Install(coreSwitch.Get(0), aggregationSwitches.Get(0)));\n    coreToAggDevices.Add(pointToPoint.Install(coreSwitch.Get(0), aggregationSwitches.Get(1)));\n\n    // Connect aggregation switches to edge switches\n    NetDeviceContainer aggToEdgeDevices;\n    aggToEdgeDevices.Add(pointToPoint.Install(aggregationSwitches.Get(0), edgeSwitches.Get(0)));\n    aggToEdgeDevices.Add(pointToPoint.Install(aggregationSwitches.Get(0), edgeSwitches.Get(1)));\n    aggToEdgeDevices.Add(pointToPoint.Install(aggregationSwitches.Get(1), edgeSwitches.Get(0)));\n    aggToEdgeDevices.Add(pointToPoint.Install(aggregationSwitches.Get(1), edgeSwitches.Get(1)));\n\n    // Connect edge switches to servers\n    NetDeviceContainer edgeToServerDevices;\n    for (uint32_t i = 0; i < numServers / 2; ++i)\n    {\n        edgeToServerDevices.Add(pointToPoint.Install(edgeSwitches.Get(0), servers.Get(i)));\n        edgeToServerDevices.Add(pointToPoint.Install(edgeSwitches.Get(1), servers.Get(i + 2)));\n    }\n\n    // Install Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(coreSwitch);\n    stack.Install(aggregationSwitches);\n    stack.Install(edgeSwitches);\n    stack.Install(servers);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces;\n    interfaces.Add(ipv4.Assign(coreToAggDevices));\n    interfaces.Add(ipv4.Assign(aggToEdgeDevices));\n    interfaces.Add(ipv4.Assign(edgeToServerDevices));\n\n    // Install applications (TCP traffic)\n    uint16_t port = 9; // TCP port\n\n    // Create server applications\n    ApplicationContainer serverApps;\n    for (uint32_t i = 0; i < numServers; ++i)\n    {\n        Address serverAddress(InetSocketAddress(interfaces.GetAddress(i + 6), port));\n        PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n        serverApps.Add(packetSinkHelper.Install(servers.Get(i)));\n    }\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(simulationTime));\n\n    // Create client applications to generate TCP traffic\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < numServers; ++i)\n    {\n        OnOffHelper onoff(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(i + 6), port));\n        onoff.SetAttribute(\"DataRate\", StringValue(\"1Gbps\"));\n        onoff.SetAttribute(\"PacketSize\", UintegerValue(1024));\n        onoff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        onoff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n        clientApps.Add(onoff.Install(servers.Get((i + 1) % numServers)));\n    }\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(simulationTime));\n\n    // Enable NetAnim visualization\n    AnimationInterface anim(\"fat_tree_datacenter.xml\");\n    anim.SetConstantPosition(coreSwitch.Get(0), 50.0, 50.0);\n    anim.SetConstantPosition(aggregationSwitches.Get(0), 30.0, 30.0);\n    anim.SetConstantPosition(aggregationSwitches.Get(1), 70.0, 30.0);\n    anim.SetConstantPosition(edgeSwitches.Get(0), 20.0, 10.0);\n    anim.SetConstantPosition(edgeSwitches.Get(1), 80.0, 10.0);\n    anim.SetConstantPosition(servers.Get(0), 10.0, 0.0);\n    anim.SetConstantPosition(servers.Get(1), 30.0, 0.0);\n    anim.SetConstantPosition(servers.Get(2), 70.0, 0.0);\n    anim.SetConstantPosition(servers.Get(3), 90.0, 0.0);\n\n    // Run simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and assigns them unique node IDs. The program should iterate over the nodes and print their assigned node IDs. Keep it simple and avoid additional network configurations."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"NodeIDExample\", LOG_LEVEL_INFO);\n\n    // Create a NodeContainer and generate 5 nodes\n    NodeContainer nodes;\n    nodes.Create(5);\n\n    // Iterate through the nodes and print their IDs\n    for (uint32_t i = 0; i < nodes.GetN(); ++i) {\n        Ptr<Node> node = nodes.Get(i);\n        NS_LOG_INFO(\"Node \" << i << \" has ID: \" << node->GetId());\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ script using the ns-3 simulation library to create a mixed point-to-point and CSMA/CD network topology. The network should include seven nodes, where n0 and n1 connect to n2 via point-to-point links, and n2, n3, n4, and n5 are connected through a shared CSMA/CD bus. Additionally, n5 and n6 are connected via a point-to-point link. Set up Constant Bit Rate (CBR) UDP traffic from n0 to n6, with packet sizes of 210 bytes and a data rate of 448 Kb/s. Enable tracing of queues and packet receptions to a trace file."}, {"role": "assistant", "content": "// This script exercises global routing code in a mixed point-to-point\n// and csma/cd environment\n//\n// Network topology\n//\n//  n0\n//     \\ p-p\n//      \\          (shared csma/cd)\n//       n2 -------------------------n3\n//      /            |        |\n//     / p-p        n4        n5 ---------- n6\n//   n1                             p-p\n//\n// - CBR/UDP flows from n0 to n6\n// - Tracing of queues and packet receptions to file \"mixed-global-routing.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MixedGlobalRoutingExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(210));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(\"448kb/s\"));\n\n    // Allow the user to override any of the defaults and the above\n    // Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer c;\n    c.Create(7);\n    NodeContainer n0n2 = NodeContainer(c.Get(0), c.Get(2));\n    NodeContainer n1n2 = NodeContainer(c.Get(1), c.Get(2));\n    NodeContainer n5n6 = NodeContainer(c.Get(5), c.Get(6));\n    NodeContainer n2345 = NodeContainer(c.Get(2), c.Get(3), c.Get(4), c.Get(5));\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // We create the channels first without any IP addressing information\n    NS_LOG_INFO(\"Create channels.\");\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d0d2 = p2p.Install(n0n2);\n\n    NetDeviceContainer d1d2 = p2p.Install(n1n2);\n\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1500kbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    NetDeviceContainer d5d6 = p2p.Install(n5n6);\n\n    // We create the channels first without any IP addressing information\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d2345 = csma.Install(n2345);\n\n    // Later, we add IP addresses.\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(d0d2);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    ipv4.Assign(d1d2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i5i6 = ipv4.Assign(d5d6);\n\n    ipv4.SetBase(\"10.250.1.0\", \"255.255.255.0\");\n    ipv4.Assign(d2345);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    NS_LOG_INFO(\"Create Applications.\");\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(i5i6.GetAddress(1), port));\n    onoff.SetConstantRate(DataRate(\"300bps\"));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(50));\n\n    ApplicationContainer apps = onoff.Install(c.Get(0));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    Ptr<OutputStreamWrapper> stream = ascii.CreateFileStream(\"mixed-global-routing.tr\");\n    p2p.EnableAsciiAll(stream);\n    csma.EnableAsciiAll(stream);\n\n    p2p.EnablePcapAll(\"mixed-global-routing\");\n    csma.EnablePcapAll(\"mixed-global-routing\", false);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that establishes a non-persistent TCP connection in a simple topology using NetAnim. Set up a point-to-point link between a client and a server, and ensure that after completing a single data transfer, the TCP connection terminates. Visualize the packet flow using NetAnim, and configure the connection to have a bandwidth of 5Mbps and a delay of 1ms."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"NonPersistentTcpWithNetAnim\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"NonPersistentTcpWithNetAnim\", LOG_LEVEL_INFO);\n\n    // Create 2 nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Create a point-to-point link with 5Mbps bandwidth and 1ms delay\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    // Install the link between the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack on the nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP server on node 0\n    uint16_t port = 50000;\n    Address serverAddress(InetSocketAddress(interfaces.GetAddress(0), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(0));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(5.0));  // Stop after 5 seconds\n\n    // Create a TCP client on node 1 for a non-persistent connection\n    OnOffHelper client(\"ns3::TcpSocketFactory\", serverAddress);\n    client.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    client.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\")); // Non-persistent connection\n    client.SetAttribute(\"DataRate\", StringValue(\"2Mbps\"));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = client.Install(nodes.Get(1));\n    clientApp.Start(Seconds(2.0));  // Start client 1 second after the server\n    clientApp.Stop(Seconds(4.0));   // Stop client after the connection finishes\n\n    // Populate routing tables\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Set up NetAnim\n    AnimationInterface anim(\"non_persistent_tcp_netanim.xml\");\n\n    // Set node positions for visualization\n    anim.SetConstantPosition(nodes.Get(0), 10.0, 20.0); // Server (Node 0)\n    anim.SetConstantPosition(nodes.Get(1), 30.0, 20.0); // Client (Node 1)\n\n    // Enable packet metadata for NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ LTE network simulation with one eNB and one UE. The UE should send UDP packets to the eNB, and the eNB should respond. Use the IP range 10.0.0.0/24, install the Internet stack, and attach the UE to the eNB. The server should run from 1s to 10s, and the client starts at 2s, sending packets at 0.1s intervals. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleLteExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create LTE nodes\n    NodeContainer enbNode, ueNode;\n    enbNode.Create(1);\n    ueNode.Create(1);\n\n    // Set up LTE devices\n    LteHelper lteHelper;\n    NetDeviceContainer enbLteDevice = lteHelper.InstallEnbDevice(enbNode);\n    NetDeviceContainer ueLteDevice = lteHelper.InstallUeDevice(ueNode);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(ueNode);\n    internet.Install(enbNode);\n\n    // Assign IP addresses\n    Ipv4InterfaceContainer ueIpIfaces;\n    ueIpIfaces = lteHelper.AssignUeIpv4Address(ueLteDevice);\n\n    // Attach UE to eNB\n    lteHelper.Attach(ueLteDevice, enbLteDevice.Get(0));\n\n    // Set up the UDP server on the UE\n    uint16_t port = 12345;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ueNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the UDP client on the eNB (simulating data transmission)\n    UdpClientHelper udpClient(ueIpIfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(enbNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a basic LTE network using ns-3 where two User Equipment (UE) nodes communicate through a single eNodeB (Base Station) using the LTE EPC (Evolved Packet Core). Configure the UEs to exchange data over TCP and visualize the results using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteSimulationExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set the simulation time\n    double simulationTime = 10.0;\n\n    // Create LTE nodes: 1 eNodeB (base station) and 2 UEs (User Equipments)\n    NodeContainer ueNodes;\n    ueNodes.Create(2);\n    NodeContainer enbNodes;\n    enbNodes.Create(1);\n\n    // Set up the LTE modules\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    // Create a remote host to act as the internet backbone\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // Set up a point-to-point link between the PGW and the remote host\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2p.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.01)));\n    NetDeviceContainer internetDevices = p2p.Install(pgw, remoteHost);\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetInterfaces = ipv4.Assign(internetDevices);\n\n    // Assign IP addresses to the remote host\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting = ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n\n    // Install LTE devices to UEs and eNodeB\n    NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueLteDevs = lteHelper->InstallUeDevice(ueNodes);\n\n    // Install IP stack on the UEs\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpInterfaces = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLteDevs));\n\n    // Attach UEs to the eNodeB\n    lteHelper->Attach(ueLteDevs, enbLteDevs.Get(0));\n\n    // Set mobility for UEs and eNodeB\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(enbNodes);\n    mobility.Install(ueNodes);\n\n    // Set positions for eNodeB and UEs\n    Ptr<ConstantPositionMobilityModel> enbMobility = enbNodes.Get(0)->GetObject<ConstantPositionMobilityModel>();\n    enbMobility->SetPosition(Vector(0.0, 0.0, 0.0)); // eNodeB at origin\n\n    Ptr<ConstantPositionMobilityModel> ueMobility1 = ueNodes.Get(0)->GetObject<ConstantPositionMobilityModel>();\n    ueMobility1->SetPosition(Vector(10.0, 0.0, 0.0)); // UE 1 at 10 meters away from eNodeB\n\n    Ptr<ConstantPositionMobilityModel> ueMobility2 = ueNodes.Get(1)->GetObject<ConstantPositionMobilityModel>();\n    ueMobility2->SetPosition(Vector(20.0, 0.0, 0.0)); // UE 2 at 20 meters away from eNodeB\n\n    // Set up applications to send and receive data\n    uint16_t dlPort = 1234;\n    OnOffHelper onoff(\"ns3::TcpSocketFactory\", Address(InetSocketAddress(ueIpInterfaces.GetAddress(1), dlPort)));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    onoff.SetAttribute(\"DataRate\", StringValue(\"50Mbps\"));\n    ApplicationContainer clientApps = onoff.Install(remoteHost);\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(simulationTime));\n\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", Address(InetSocketAddress(Ipv4Address::GetAny(), dlPort)));\n    ApplicationContainer serverApps = sink.Install(ueNodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(simulationTime));\n\n    // Enable NetAnim\n    AnimationInterface anim(\"lte_netanim.xml\");\n\n    // Set positions in NetAnim\n    anim.SetConstantPosition(enbNodes.Get(0), 0.0, 0.0);   // eNodeB at origin\n    anim.SetConstantPosition(ueNodes.Get(0), 10.0, 0.0);   // UE 1 at 10m\n    anim.SetConstantPosition(ueNodes.Get(1), 20.0, 0.0);   // UE 2 at 20m\n\n    anim.EnablePacketMetadata(true);  // Enable packet tracking in NetAnim\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 simulation library to model an ad hoc wireless network consisting of two nodes. Configure the nodes to operate with IEEE 802.11 in ad hoc mode and set the transmission power for both nodes to 50.0 dBm. Implement a mobility model where the nodes move randomly within defined rectangular boundaries. Install the Internet stack and assign IPv4 addresses from the subnet 192.9.39.0/24 to the nodes. Establish UDP echo server applications on both nodes, enabling bidirectional communication where each node sends echo requests to the other with a maximum of 50 packets sent at half-second intervals. Integrate a flow monitor to capture network statistics, including packet delivery ratios, end-to-end delays, and throughput. Generate an animation file to visualize the network activity during the simulation. Finally, output the collected flow statistics and performance metrics after running the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/propagation-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"AdhocNetworkExample\");\n\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable (\"AdhocNetworkExample\", LOG_LEVEL_INFO);\n\n  // Create two wireless nodes\n  NodeContainer nodes;\n  nodes.Create (2);\n\n  // Configure wireless parameters\n  WifiHelper wifi;\n\n  WifiMacHelper mac;\n  mac.SetType (\"ns3::AdhocWifiMac\");\n  \n\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default(); //define channel default configuration\n  YansWifiPhyHelper phy; //configure wifiPHY\n  phy.SetChannel(channel.Create());\n\n  //lower pvalues means more power andmore pckets sent\n  phy.Set(\"TxPowerStart\", DoubleValue(50.0)); //starts trandmission power\n  phy.Set(\"TxPowerEnd\", DoubleValue(50.0));//ends transmission power\n  \n\n  NetDeviceContainer devices = wifi.Install (phy, mac, nodes); //create wifiNetDevice\n  \n\n  // Set up mobility model\n  MobilityHelper mobility; //to set position of nodes\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0), //starting node x axis\n                                 \"MinY\", DoubleValue (0.0), //starting node y axis\n                                 \"DeltaX\", DoubleValue (5.0), //gap before next node in row\n                                 \"DeltaY\", DoubleValue (5.0), //gap before next node in column\n                                 \"GridWidth\", UintegerValue (2), // max number of nodes based on the layout type\n                                 \"LayoutType\", StringValue (\"RowFirst\")); //nodes will first fill up the rows then columns\n                                 \n                                \n  mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue(Rectangle(-25, 25, -25, 25))); //nodes over randomly in 2D\n                                                                                          //nodes movement bound in rectangle   (Xmin,Xmax,Ymin,Ymax)        \n  mobility.Install (nodes); //install the nodes\n  \n  // Set up network stack\n  InternetStackHelper stack;\n  stack.Install (nodes);\n\n  // Assign IPv4 addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"192.9.39.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  UdpEchoServerHelper server10(9);\n  ApplicationContainer serverApps10 = server10.Install (nodes.Get (1));\n  serverApps10.Start (Seconds (1.0));\n  serverApps10.Stop (Seconds (100.0));\n\n  // Create a UDP echo client application on node 0\n  UdpEchoClientHelper client10 (interfaces.GetAddress (1), 9);\n  client10.SetAttribute (\"MaxPackets\", UintegerValue (50));\n  client10.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client10.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps10 = client10.Install (nodes.Get (0));\n  clientApps10.Start (Seconds (2.0));\n  clientApps10.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server01(10);\n  ApplicationContainer serverApps01 = server01.Install (nodes.Get (0));\n  serverApps10.Start (Seconds (1.0));\n  serverApps10.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client01 (interfaces.GetAddress (0), 10);\n  client01.SetAttribute (\"MaxPackets\", UintegerValue (50));\n  client01.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client01.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps01 = client01.Install (nodes.Get (1));\n  clientApps01.Start (Seconds (2.0));\n  clientApps01.Stop (Seconds (100.0));\n  \n  // Define a flow monitor object\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();\n  Simulator::Stop(Seconds(100.0));\n  \n  \n  // Animation\n  AnimationInterface anim(\"239_task2.xml\");\n  \n\n  // Run simulation\n  Simulator::Run ();\n  \n \n  \n Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());\n std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats ();\nfor (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n{\n // Calculate packet delivery ratio and end to end delay and throughput\n  uint32_t packetsDelivered = 0;\n  uint32_t totalPackets = 0;\n  double totalDelay = 0;\n Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);\nstd::cout << \"FlowId: \" << i->first << \"\\n\";\nstd::cout << \"Sender: \"<< t.sourceAddress << \"\\n\"; \nstd::cout << \"Receiver: \"<< t.destinationAddress << \"\\n\"; \nstd::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\nstd::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n\nstd::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\nstd::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\nif(i->second.rxPackets > 0)\n  \t{\n  \t\tpacketsDelivered += i->second.rxPackets;\n  \t\ttotalPackets += i->second.txPackets;\n  \t\ttotalDelay += (i->second.delaySum.ToDouble(ns3::Time::S) / i->second.rxPackets);\n  \t}\n       \n  double packetDeliveryRatio = (double) packetsDelivered / totalPackets;\n  double averageEndToEndDelay = totalDelay / packetsDelivered;\n  double throughput = (double) packetsDelivered * 1024 * 8 / (100.0 - 0.0) / 1000000;\n  \n  // Printing the results\n  std::cout << \"Packets Delivered Ratio: \" << packetDeliveryRatio << std::endl;\n  std::cout << \"Average End-to-End Delay: \" << averageEndToEndDelay << std::endl;\n  std::cout << \"Throughput: \" << throughput << std::endl;\n   }\n  \n \n  \n  Simulator::Destroy ();\n\n  return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the NS-3 simulator that sets up a simple point-to-point network topology with two nodes, `n0` and `n1`, connected by a 500 Kbps link with a 5 ms delay. The application on node `n0` should use a `BulkSendApplication` to send data to node `n1`, which uses a `PacketSinkApplication` to receive the data. The user should be able to enable packet tracing and choose whether to use nanosecond timestamps for the pcap trace file via command-line options. The pcap trace should be written to a file named \"tcp-pcap-nanosec-example.pcap\". Ensure that IP addresses are assigned, the internet stack is installed, and the simulation runs for 10 seconds."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0 ----------- n1\n//            500 Kbps\n//             5 ms\n//\n// - Flow from n0 to n1 using BulkSendApplication.\n// - Tracing of queues and packet receptions to file \"tcp-pcap-nanosec-example.pcap\"\n//     when tracing is turned on.\n// - Trace file timestamps are recorded in nanoseconds, when requested\n//\n\n// ============================================================ //\n// NOTE: You can check the \"magic\" number of a pcap file with   //\n//       the following command:                                 //\n//                                                              //\n//                    od -N4 -tx1 filename.pcap                 //\n//                                                              //\n// ============================================================ //\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <fstream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpPcapNanosecExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    bool tracing = false;\n    bool nanosec = false;\n    uint32_t maxBytes = 0;\n\n    //\n    // Allow the user to override any of the defaults at\n    // run-time, via command-line arguments\n    //\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"tracing\", \"Flag to enable tracing\", tracing);\n    cmd.AddValue(\"nanosec\", \"Flag to use nanosecond timestamps for pcap as default\", nanosec);\n    cmd.AddValue(\"maxBytes\", \"Total number of bytes for application to send\", maxBytes);\n    cmd.Parse(argc, argv);\n\n    //\n    // If requested via the --nanosec cmdline flag, generate nanosecond timestamp for pcap traces\n    //\n    if (nanosec)\n    {\n        Config::SetDefault(\"ns3::PcapFileWrapper::NanosecMode\", BooleanValue(true));\n    }\n\n    //\n    // Explicitly create the nodes required by the topology (shown above).\n    //\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    NS_LOG_INFO(\"Create channels.\");\n\n    //\n    // Explicitly create the point-to-point link required by the topology (shown above).\n    //\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"500Kbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    //\n    // Install the internet stack on the nodes\n    //\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    //\n    // We've got the \"hardware\" in place.  Now we need to add IP addresses.\n    //\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    //\n    // Create a BulkSendApplication and install it on node 0\n    //\n    uint16_t port = 9; // well-known echo port number\n\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", InetSocketAddress(i.GetAddress(1), port));\n    // Set the amount of data to send in bytes.  Zero is unlimited.\n    source.SetAttribute(\"MaxBytes\", UintegerValue(maxBytes));\n    ApplicationContainer sourceApps = source.Install(nodes.Get(0));\n    sourceApps.Start(Seconds(0.0));\n    sourceApps.Stop(Seconds(10.0));\n\n    //\n    // Create a PacketSinkApplication and install it on node 1\n    //\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApps = sink.Install(nodes.Get(1));\n    sinkApps.Start(Seconds(0.0));\n    sinkApps.Stop(Seconds(10.0));\n\n    //\n    // Set up tracing if enabled\n    //\n    if (tracing)\n    {\n        AsciiTraceHelper ascii;\n        pointToPoint.EnablePcapAll(\"tcp-pcap-nanosec-example\", false);\n    }\n\n    //\n    // Now, do the actual simulation.\n    //\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    Ptr<PacketSink> sink1 = DynamicCast<PacketSink>(sinkApps.Get(0));\n    std::cout << \"Total Bytes Received: \" << sink1->GetTotalRx() << std::endl;\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Mobile Ad Hoc Network (MANET) in ns-3 with four nodes using AODV (Ad hoc On-Demand Distance Vector) routing. The nodes move randomly within a defined boundary, and one node sends UDP packets to another node. Capture packet traces and monitor the performance in terms of throughput and packet loss."}, {"role": "assistant", "content": "#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ManetSimulationExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set default time resolution\n    Time::SetResolution(Time::NS);\n\n    // Create four nodes\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Set up the Wi-Fi network (Ad Hoc mode)\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\", \"DataMode\", StringValue(\"DsssRate2Mbps\"));\n\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer wifiDevices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Install the Internet stack and AODV routing protocol\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);  // Use AODV for routing\n    internet.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(wifiDevices);\n\n    // Set up random mobility for the nodes\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(nodes);\n\n    // Create a UDP server on node 1\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create a UDP client on node 0\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable pcap tracing\n    wifiPhy.EnablePcap(\"manet\", wifiDevices);\n\n    // Set up flow monitoring\n    FlowMonitorHelper flowmonHelper;\n    Ptr<FlowMonitor> monitor = flowmonHelper.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(11.0));\n    Simulator::Run();\n\n    // Print flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 /\n                                            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n                                            1024 / 1024 << \" Mbps\");\n    }\n\n    // Clean up and exit\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSet up a simple TCP connection in NS-3 with two nodes using the TCP NewReno protocol. One node (server) listens on port 9, and the other node (client) sends TCP packets to the server. Set the link data rate to 5Mbps, and run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpNewRenoExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Point-to-Point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP server application on node 1 (server)\n    uint16_t port = 9;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client application on node 0 (client)\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple TCP connection in NS-3 between two nodes using a point-to-point link with a data rate of 10Mbps and a delay of 5ms. Set up a TCP server on Node 2 and a TCP client on Node 1. The client should start sending data at 1s and stop at 10s. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    // Install devices on nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack on nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up TCP server on Node 2\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on Node 1\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to model a Wireless Sensor Network (WSN) with two nodes communicating over an IEEE 802.15.4 network. Implement ICMPv6 echo requests and replies between the nodes, utilizing DropTail queues. Create a simulation environment where both nodes are stationary, and assign them specific IPv6 addresses within a defined prefix. Log the details of the packet flows and create a trace file named 'wsn-ping6.tr' for analyzing queue behavior and packet receptions. Include necessary headers and enable verbose logging for debugging the simulation process."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1\n//       |     |\n//       =================\n//        WSN (802.15.4)\n//\n// - ICMPv6 echo request flows from n0 to n1 and back with ICMPv6 echo reply\n// - DropTail queues\n// - Tracing of queues and packet receptions to file \"wsn-ping6.tr\"\n//\n// This example is based on the \"ping6.cc\" example.\n\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lr-wpan-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/sixlowpan-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Ping6WsnExample\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Ping6WsnExample\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"Ipv6EndPointDemux\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6ListRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ping\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"NdiscCache\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"SixLowPanNetDevice\", LOG_LEVEL_ALL);\n    }\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set seed for random numbers\n    SeedManager::SetSeed(167);\n\n    // Install mobility\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    Ptr<ListPositionAllocator> nodesPositionAlloc = CreateObject<ListPositionAllocator>();\n    nodesPositionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    nodesPositionAlloc->Add(Vector(50.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(nodesPositionAlloc);\n    mobility.Install(nodes);\n\n    NS_LOG_INFO(\"Create channels.\");\n    LrWpanHelper lrWpanHelper;\n    // Add and install the LrWpanNetDevice for each node\n    // lrWpanHelper.EnableLogComponents();\n    NetDeviceContainer devContainer = lrWpanHelper.Install(nodes);\n    lrWpanHelper.CreateAssociatedPan(devContainer, 10);\n\n    std::cout << \"Created \" << devContainer.GetN() << \" devices\" << std::endl;\n    std::cout << \"There are \" << nodes.GetN() << \" nodes\" << std::endl;\n\n    /* Install IPv4/IPv6 stack */\n    NS_LOG_INFO(\"Install Internet stack.\");\n    InternetStackHelper internetv6;\n    internetv6.SetIpv4StackInstall(false);\n    internetv6.Install(nodes);\n\n    // Install 6LowPan layer\n    NS_LOG_INFO(\"Install 6LoWPAN.\");\n    SixLowPanHelper sixlowpan;\n    NetDeviceContainer six1 = sixlowpan.Install(devContainer);\n\n    NS_LOG_INFO(\"Assign addresses.\");\n    Ipv6AddressHelper ipv6;\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i = ipv6.Assign(six1);\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    /* Create a Ping application to send ICMPv6 echo request from node zero to\n     * all-nodes (ff02::1).\n     */\n    uint32_t packetSize = 16;\n    uint32_t maxPacketCount = 5;\n    Time interPacketInterval = Seconds(1.);\n    PingHelper ping(i.GetAddress(1, 1));\n\n    ping.SetAttribute(\"Count\", UintegerValue(maxPacketCount));\n    ping.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    ApplicationContainer apps = ping.Install(nodes.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    lrWpanHelper.EnableAsciiAll(ascii.CreateFileStream(\"ping6wsn.tr\"));\n    lrWpanHelper.EnablePcapAll(std::string(\"ping6wsn\"), true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that generates a dataset for a simple star topology network with 5 nodes, where one central node (node 0) communicates with four peripheral nodes (nodes 1 to 4) using TCP. The dataset should capture the source node, destination node, packet size, transmission time, and reception time for each packet. Save the information to a CSV file."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"StarTopologyDataset\");\n\nvoid RecordTcpData(Ptr<FlowMonitor> flowMonitor, std::string filename)\n{\n    std::ofstream outFile;\n    outFile.open(filename, std::ios::out | std::ios::app);\n    outFile << \"FlowID,SrcAddr,DestAddr,PacketSize,TxTime,RxTime\\n\"; // CSV headers\n\n    // Retrieve statistics from flow monitor\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n    for (auto &flow : stats)\n    {\n        FlowId id = flow.first;\n        FlowMonitor::FlowStats flowStats = flow.second;\n        Ipv4FlowClassifier::FiveTuple t = flowMonitor->GetClassifier()->FindFlow(id);\n\n        for (uint32_t i = 0; i < flowStats.txPackets; i++)\n        {\n            outFile << id << \",\"\n                    << t.sourceAddress << \",\"\n                    << t.destinationAddress << \",\"\n                    << flowStats.txBytes << \",\"\n                    << flowStats.timeFirstTxPacket.GetSeconds() << \",\"\n                    << flowStats.timeLastRxPacket.GetSeconds() << \"\\n\";\n        }\n    }\n    outFile.close();\n}\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"StarTopologyDataset\", LOG_LEVEL_INFO);\n\n    // Create 5 nodes (1 central node and 4 peripheral nodes)\n    NodeContainer centralNode;\n    centralNode.Create(1);\n\n    NodeContainer peripheralNodes;\n    peripheralNodes.Create(4);\n\n    NodeContainer allNodes;\n    allNodes.Add(centralNode);\n    allNodes.Add(peripheralNodes);\n\n    // Set up point-to-point links between central node and peripheral nodes\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    for (uint32_t i = 0; i < peripheralNodes.GetN(); ++i)\n    {\n        devices.Add(p2p.Install(centralNode.Get(0), peripheralNodes.Get(i)));\n    }\n\n    // Install Internet stack on nodes\n    InternetStackHelper internet;\n    internet.Install(allNodes);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Setup TCP server on central node (node 0)\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(interfaces.GetAddress(0), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = packetSinkHelper.Install(centralNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup TCP clients on peripheral nodes (nodes 1-4)\n    OnOffHelper onOffHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    onOffHelper.SetAttribute(\"DataRate\", StringValue(\"500kbps\"));\n    onOffHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    onOffHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < peripheralNodes.GetN(); ++i)\n    {\n        onOffHelper.SetAttribute(\"Remote\", AddressValue(InetSocketAddress(interfaces.GetAddress(0), port)));\n        clientApps.Add(onOffHelper.Install(peripheralNodes.Get(i)));\n    }\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(9.0));\n\n    // Enable flow monitor\n    FlowMonitorHelper flowHelper;\n    Ptr<FlowMonitor> flowMonitor = flowHelper.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Record TCP data to a CSV file\n    RecordTcpData(flowMonitor, \"tcp_dataset.csv\");\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating an LTE network with one eNodeB (base station) and one UE (User Equipment). The UE should be randomly moving within a 100x100 area, while the eNodeB remains stationary. The UE should act as a UDP server on port 5000, and the eNodeB should act as a UDP client sending 1024-byte packets every 200ms. The simulation should run for 10 seconds, with LTE PHY, MAC, and RLC tracing enabled."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteBasicExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"LteBasicExample\", LOG_LEVEL_INFO);\n\n    // Create LTE components: eNodeB and UE\n    NodeContainer ueNode, enbNode;\n    ueNode.Create(1);\n    enbNode.Create(1);\n\n    // Configure LTE module\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n\n    // Install LTE devices on UE and eNodeB\n    NetDeviceContainer enbDevice = lteHelper->InstallEnbDevice(enbNode);\n    NetDeviceContainer ueDevice = lteHelper->InstallUeDevice(ueNode);\n\n    // Configure mobility for eNodeB (fixed) and UE (mobile)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(enbNode);\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-100, 100, -100, 100)));\n    mobility.Install(ueNode);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(ueNode);\n\n    // Assign IP addresses\n    Ipv4InterfaceContainer ueIpIface = lteHelper->AssignUeIpv4Address(NetDeviceContainer(ueDevice));\n\n    // Attach UE to eNodeB\n    lteHelper->Attach(ueDevice, enbDevice.Get(0));\n\n    // Setup UDP server on UE\n    uint16_t port = 5000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ueNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup UDP client on eNodeB\n    UdpClientHelper udpClient(ueIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(200)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(enbNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing\n    lteHelper->EnablePhyTraces();\n    lteHelper->EnableMacTraces();\n    lteHelper->EnableRlcTraces();\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a complete NS-3 simulation script in C++ that models a WiFi network with two Access Points (APs) and two Station (STA) nodes, where positions of APs and STAs are configurable via command-line arguments. The nodes should be positioned using a `ListPositionAllocator`. Configure the WiFi network using `WifiHelper`, `YansWifiPhyHelper`, and `YansWifiChannelHelper` with the 802.11a standard, different SSIDs for each AP-STA pair, and allow adjustment of RTS/CTS thresholds and transmission power levels. Use `ns3::ParfWifiManager` as the default WiFi manager, with an option to change it through the command line. Install a `PacketSink` on each STA to receive UDP traffic, and generate constant bit rate (CBR) UDP streams from each AP to its STA using `OnOffHelper`, with traffic rate set to 54 Mbps for a simulation duration of 100 seconds. Implement a `NodeStatistics` class to track WiFi state times (`CCA_BUSY`, `IDLE`, `TX`, `RX`), total bytes received, average transmit power, and calculate throughput and other metrics, printing results every second. Plot results using Gnuplot to show throughput, average transmit power, and time spent in various WiFi states. Additionally, utilize `FlowMonitor` to calculate and display flow statistics such as throughput, delay, and jitter for each AP-STA pair. Ensure the script is modular, with appropriate helper functions, and accepts command-line arguments to modify parameters like WiFi manager, RTS/CTS threshold, transmission power levels, and simulation time. Run the simulation for 100 seconds and stop execution at the end."}, {"role": "assistant", "content": "/**\n * This example program is designed to illustrate the behavior of three\n * power/rate-adaptive WiFi rate controls; namely, ns3::ParfWifiManager,\n * ns3::AparfWifiManager and ns3::RrpaaWifiManager.\n *\n * This simulation consist of 4 nodes, two APs and two STAs.\n * The APs generates UDP traffic with a CBR of 54 Mbps to the STAs.\n * The APa use any power and rate control mechanism, and the STAs use only\n * Minstrel rate control.\n * The STAs can be configured to be at any distance from the APs.\n *\n * The objective is to test power and rate control in the links with\n * interference from the other link.\n *\n * The output consists of:\n * - A plot of average throughput vs. time.\n * - A plot of average transmit power vs. time.\n * - Plots for the percentage of time the APs are in each MAC state (IDLE, TX, RX, BUSY)\n * - If enabled, the changes of power and rate to standard output.\n * - If enabled, the average throughput, delay, jitter and tx opportunity for the total simulation\n * time.\n *\n * Example usage:\n * \\code{.sh}\n *   ./ns3 run \"wifi-power-adaptation-interference --manager=ns3::AparfWifiManager\n * --outputFileName=aparf\" \\endcode\n *\n * Another example (changing STAs position):\n * \\code{.sh}\n *   ./ns3 run \"wifi-power-adaptation-interference --manager=ns3::AparfWifiManager\n * --outputFileName=aparf --STA1_x=5 --STA2_x=205\" \\endcode\n *\n * To enable the log of rate and power changes:\n * \\code{.sh}\n *   export NS_LOG=PowerAdaptationInterference=level_info\n * \\endcode\n */\n\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-flow-classifier.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/wifi-mac-header.h\"\n#include \"ns3/wifi-mac.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PowerAdaptationInterference\");\n\n/// Packet size generated at the AP.\nstatic const uint32_t packetSize = 1420;\n\n/**\n * \\brief Class to collect node statistics.\n */\nclass NodeStatistics\n{\n  public:\n    /**\n     * \\brief Constructor.\n     *\n     * \\param aps Access points\n     * \\param stas WiFi Stations.\n     */\n    NodeStatistics(NetDeviceContainer aps, NetDeviceContainer stas);\n\n    /**\n     * \\brief Collects the statistics at a given time.\n     *\n     * \\param time Time at which the statistics are collected.\n     */\n    void CheckStatistics(double time);\n\n    /**\n     * \\brief Callback called by WifiNetDevice/Phy/PhyTxBegin.\n     *\n     * \\param path The trace path.\n     * \\param packet The sent packet.\n     * \\param powerW The Tx power.\n     */\n    void PhyCallback(std::string path, Ptr<const Packet> packet, double powerW);\n    /**\n     * \\brief Callback called by PacketSink/Rx.\n     *\n     * \\param path The trace path.\n     * \\param packet The received packet.\n     * \\param from The sender address.\n     */\n    void RxCallback(std::string path, Ptr<const Packet> packet, const Address& from);\n    /**\n     * \\brief Callback called by WifiNetDevice/RemoteStationManager/x/PowerChange.\n     *\n     * \\param path The trace path.\n     * \\param oldPower Old Tx power.\n     * \\param newPower Actual Tx power.\n     * \\param dest Destination of the transmission.\n     */\n    void PowerCallback(std::string path, double oldPower, double newPower, Mac48Address dest);\n    /**\n     * \\brief Callback called by WifiNetDevice/RemoteStationManager/x/RateChange.\n     *\n     * \\param path The trace path.\n     * \\param oldRate Old rate.\n     * \\param newRate Actual rate.\n     * \\param dest Destination of the transmission.\n     */\n    void RateCallback(std::string path, DataRate oldRate, DataRate newRate, Mac48Address dest);\n    /**\n     * \\brief Callback called by YansWifiPhy/State/State.\n     *\n     * \\param path The trace path.\n     * \\param init Time when the state started.\n     * \\param duration Amount of time we've been in (or will be in) the state.\n     * \\param state The state.\n     */\n    void StateCallback(std::string path, Time init, Time duration, WifiPhyState state);\n\n    /**\n     * \\brief Get the Throughput output data\n     *\n     * \\return the Throughput output data.\n     */\n    Gnuplot2dDataset GetDatafile();\n    /**\n     * \\brief Get the Power output data.\n     *\n     * \\return the Power output data.\n     */\n    Gnuplot2dDataset GetPowerDatafile();\n    /**\n     * \\brief Get the IDLE state output data.\n     *\n     * \\return the IDLE state output data.\n     */\n    Gnuplot2dDataset GetIdleDatafile();\n    /**\n     * \\brief Get the BUSY state output data.\n     *\n     * \\return the BUSY state output data.\n     */\n    Gnuplot2dDataset GetBusyDatafile();\n    /**\n     * \\brief Get the TX state output data.\n     *\n     * \\return the TX state output data.\n     */\n    Gnuplot2dDataset GetTxDatafile();\n    /**\n     * \\brief Get the RX state output data.\n     *\n     * \\return the RX state output data.\n     */\n    Gnuplot2dDataset GetRxDatafile();\n\n    /**\n     * \\brief Get the Busy time.\n     *\n     * \\return the busy time.\n     */\n    double GetBusyTime() const;\n\n  private:\n    /// Time, DataRate pair vector.\n    typedef std::vector<std::pair<Time, DataRate>> TxTime;\n    /**\n     * \\brief Setup the WifiPhy object.\n     *\n     * \\param phy The WifiPhy to setup.\n     */\n    void SetupPhy(Ptr<WifiPhy> phy);\n    /**\n     * \\brief Get the time at which a given datarate has been recorded.\n     *\n     * \\param rate The datarate to search.\n     * \\return the time.\n     */\n    Time GetCalcTxTime(DataRate rate);\n\n    std::map<Mac48Address, dBm_u> m_currentPower;   //!< Current Tx power for each sender.\n    std::map<Mac48Address, DataRate> m_currentRate; //!< Current Tx rate for each sender.\n    uint32_t m_bytesTotal;                          //!< Number of received bytes.\n    double m_totalEnergy;                           //!< Energy used.\n    double m_totalTime;                             //!< Time spent.\n    double busyTime;                                //!< BUSY time.\n    double idleTime;                                //!< IDLE time.\n    double txTime;                                  //!< TX time.\n    double rxTime;                                  //!< RX time.\n    double m_totalBusyTime;                         //!< Total time in BUSY state.\n    double m_totalIdleTime;                         //!< Total time in IDLE state.\n    double m_totalTxTime;                           //!< Total time in TX state.\n    double m_totalRxTime;                           //!< Total time in RX state.\n    TxTime m_timeTable;                             //!< Time, DataRate table.\n    Gnuplot2dDataset m_output;                      //!< Throughput output data.\n    Gnuplot2dDataset m_output_power;                //!< Power output data.\n    Gnuplot2dDataset m_output_idle;                 //!< IDLE output data.\n    Gnuplot2dDataset m_output_busy;                 //!< BUSY output data.\n    Gnuplot2dDataset m_output_rx;                   //!< RX output data.\n    Gnuplot2dDataset m_output_tx;                   //!< TX output data.\n};\n\nNodeStatistics::NodeStatistics(NetDeviceContainer aps, NetDeviceContainer stas)\n{\n    Ptr<NetDevice> device = aps.Get(0);\n    Ptr<WifiNetDevice> wifiDevice = DynamicCast<WifiNetDevice>(device);\n    Ptr<WifiPhy> phy = wifiDevice->GetPhy();\n    SetupPhy(phy);\n    DataRate dataRate = DataRate(phy->GetDefaultMode().GetDataRate(phy->GetChannelWidth()));\n    const auto power = phy->GetTxPowerEnd();\n    for (uint32_t j = 0; j < stas.GetN(); j++)\n    {\n        Ptr<NetDevice> staDevice = stas.Get(j);\n        Ptr<WifiNetDevice> wifiStaDevice = DynamicCast<WifiNetDevice>(staDevice);\n        Mac48Address addr = wifiStaDevice->GetMac()->GetAddress();\n        m_currentPower[addr] = power;\n        m_currentRate[addr] = dataRate;\n    }\n    m_currentRate[Mac48Address(\"ff:ff:ff:ff:ff:ff\")] = dataRate;\n    m_totalEnergy = 0;\n    m_totalTime = 0;\n    busyTime = 0;\n    idleTime = 0;\n    txTime = 0;\n    rxTime = 0;\n    m_totalBusyTime = 0;\n    m_totalIdleTime = 0;\n    m_totalTxTime = 0;\n    m_totalRxTime = 0;\n    m_bytesTotal = 0;\n    m_output.SetTitle(\"Throughput Mbits/s\");\n    m_output_idle.SetTitle(\"Idle Time\");\n    m_output_busy.SetTitle(\"Busy Time\");\n    m_output_rx.SetTitle(\"RX Time\");\n    m_output_tx.SetTitle(\"TX Time\");\n}\n\nvoid\nNodeStatistics::SetupPhy(Ptr<WifiPhy> phy)\n{\n    for (const auto& mode : phy->GetModeList())\n    {\n        WifiTxVector txVector;\n        txVector.SetMode(mode);\n        txVector.SetPreambleType(WIFI_PREAMBLE_LONG);\n        txVector.SetChannelWidth(phy->GetChannelWidth());\n        DataRate dataRate(mode.GetDataRate(phy->GetChannelWidth()));\n        Time time = phy->CalculateTxDuration(packetSize, txVector, phy->GetPhyBand());\n        NS_LOG_DEBUG(mode.GetUniqueName() << \" \" << time.GetSeconds() << \" \" << dataRate);\n        m_timeTable.emplace_back(time, dataRate);\n    }\n}\n\nTime\nNodeStatistics::GetCalcTxTime(DataRate rate)\n{\n    for (auto i = m_timeTable.begin(); i != m_timeTable.end(); i++)\n    {\n        if (rate == i->second)\n        {\n            return i->first;\n        }\n    }\n    NS_ASSERT(false);\n    return Seconds(0);\n}\n\nvoid\nNodeStatistics::PhyCallback(std::string path, Ptr<const Packet> packet, double powerW)\n{\n    WifiMacHeader head;\n    packet->PeekHeader(head);\n    Mac48Address dest = head.GetAddr1();\n\n    if (head.GetType() == WIFI_MAC_DATA)\n    {\n        m_totalEnergy += pow(10.0, m_currentPower[dest] / 10.0) *\n                         GetCalcTxTime(m_currentRate[dest]).GetSeconds();\n        m_totalTime += GetCalcTxTime(m_currentRate[dest]).GetSeconds();\n    }\n}\n\nvoid\nNodeStatistics::PowerCallback(std::string path, double oldPower, double newPower, Mac48Address dest)\n{\n    m_currentPower[dest] = newPower;\n}\n\nvoid\nNodeStatistics::RateCallback(std::string path,\n                             DataRate oldRate,\n                             DataRate newRate,\n                             Mac48Address dest)\n{\n    m_currentRate[dest] = newRate;\n}\n\nvoid\nNodeStatistics::StateCallback(std::string path, Time init, Time duration, WifiPhyState state)\n{\n    if (state == WifiPhyState::CCA_BUSY)\n    {\n        busyTime += duration.GetSeconds();\n        m_totalBusyTime += duration.GetSeconds();\n    }\n    else if (state == WifiPhyState::IDLE)\n    {\n        idleTime += duration.GetSeconds();\n        m_totalIdleTime += duration.GetSeconds();\n    }\n    else if (state == WifiPhyState::TX)\n    {\n        txTime += duration.GetSeconds();\n        m_totalTxTime += duration.GetSeconds();\n    }\n    else if (state == WifiPhyState::RX)\n    {\n        rxTime += duration.GetSeconds();\n        m_totalRxTime += duration.GetSeconds();\n    }\n}\n\nvoid\nNodeStatistics::RxCallback(std::string path, Ptr<const Packet> packet, const Address& from)\n{\n    m_bytesTotal += packet->GetSize();\n}\n\nvoid\nNodeStatistics::CheckStatistics(double time)\n{\n    double mbs = ((m_bytesTotal * 8.0) / (1000000 * time));\n    m_bytesTotal = 0;\n    double atp = m_totalEnergy / time;\n    m_totalEnergy = 0;\n    m_totalTime = 0;\n    m_output_power.Add((Simulator::Now()).GetSeconds(), atp);\n    m_output.Add((Simulator::Now()).GetSeconds(), mbs);\n\n    m_output_idle.Add((Simulator::Now()).GetSeconds(), idleTime * 100);\n    m_output_busy.Add((Simulator::Now()).GetSeconds(), busyTime * 100);\n    m_output_tx.Add((Simulator::Now()).GetSeconds(), txTime * 100);\n    m_output_rx.Add((Simulator::Now()).GetSeconds(), rxTime * 100);\n    busyTime = 0;\n    idleTime = 0;\n    txTime = 0;\n    rxTime = 0;\n\n    Simulator::Schedule(Seconds(time), &NodeStatistics::CheckStatistics, this, time);\n}\n\nGnuplot2dDataset\nNodeStatistics::GetDatafile()\n{\n    return m_output;\n}\n\nGnuplot2dDataset\nNodeStatistics::GetPowerDatafile()\n{\n    return m_output_power;\n}\n\nGnuplot2dDataset\nNodeStatistics::GetIdleDatafile()\n{\n    return m_output_idle;\n}\n\nGnuplot2dDataset\nNodeStatistics::GetBusyDatafile()\n{\n    return m_output_busy;\n}\n\nGnuplot2dDataset\nNodeStatistics::GetRxDatafile()\n{\n    return m_output_rx;\n}\n\nGnuplot2dDataset\nNodeStatistics::GetTxDatafile()\n{\n    return m_output_tx;\n}\n\ndouble\nNodeStatistics::GetBusyTime() const\n{\n    return m_totalBusyTime + m_totalRxTime;\n}\n\n/**\n * Callback called by WifiNetDevice/RemoteStationManager/x/PowerChange.\n *\n * \\param path The trace path.\n * \\param oldPower Old Tx power.\n * \\param newPower Actual Tx power.\n * \\param dest Destination of the transmission.\n */\nvoid\nPowerCallback(std::string path, double oldPower, double newPower, Mac48Address dest)\n{\n    NS_LOG_INFO((Simulator::Now()).GetSeconds()\n                << \" \" << dest << \" Old power=\" << oldPower << \" New power=\" << newPower);\n}\n\n/**\n * \\brief Callback called by WifiNetDevice/RemoteStationManager/x/RateChange.\n *\n * \\param path The trace path.\n * \\param oldRate Old rate.\n * \\param newRate Actual rate.\n * \\param dest Destination of the transmission.\n */\nvoid\nRateCallback(std::string path, DataRate oldRate, DataRate newRate, Mac48Address dest)\n{\n    NS_LOG_INFO((Simulator::Now()).GetSeconds()\n                << \" \" << dest << \" Old rate=\" << oldRate << \" New rate=\" << newRate);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    // LogComponentEnable(\"ConstantRateWifiManager\", LOG_LEVEL_FUNCTION);\n\n    dBm_u maxPower{17};\n    dBm_u minPower{0};\n    uint32_t powerLevels{18};\n\n    uint32_t rtsThreshold{2346};\n    std::string manager{\"ns3::ParfWifiManager\"};\n    std::string outputFileName{\"parf\"};\n    int ap1_x{0};\n    int ap1_y{0};\n    int sta1_x{10};\n    int sta1_y{0};\n    int ap2_x{200};\n    int ap2_y{0};\n    int sta2_x{180};\n    int sta2_y{0};\n    Time simuTime{\"100s\"};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"manager\", \"PRC Manager\", manager);\n    cmd.AddValue(\"rtsThreshold\", \"RTS threshold\", rtsThreshold);\n    cmd.AddValue(\"outputFileName\", \"Output filename\", outputFileName);\n    cmd.AddValue(\"simuTime\", \"Total simulation time (sec)\", simuTime);\n    cmd.AddValue(\"maxPower\", \"Maximum available transmission level (dbm).\", maxPower);\n    cmd.AddValue(\"minPower\", \"Minimum available transmission level (dbm).\", minPower);\n    cmd.AddValue(\"powerLevels\",\n                 \"Number of transmission power levels available between \"\n                 \"TxPowerStart and TxPowerEnd included.\",\n                 powerLevels);\n    cmd.AddValue(\"AP1_x\", \"Position of AP1 in x coordinate\", ap1_x);\n    cmd.AddValue(\"AP1_y\", \"Position of AP1 in y coordinate\", ap1_y);\n    cmd.AddValue(\"STA1_x\", \"Position of STA1 in x coordinate\", sta1_x);\n    cmd.AddValue(\"STA1_y\", \"Position of STA1 in y coordinate\", sta1_y);\n    cmd.AddValue(\"AP2_x\", \"Position of AP2 in x coordinate\", ap2_x);\n    cmd.AddValue(\"AP2_y\", \"Position of AP2 in y coordinate\", ap2_y);\n    cmd.AddValue(\"STA2_x\", \"Position of STA2 in x coordinate\", sta2_x);\n    cmd.AddValue(\"STA2_y\", \"Position of STA2 in y coordinate\", sta2_y);\n    cmd.Parse(argc, argv);\n\n    // Define the APs\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(2);\n\n    // Define the STAs\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n    WifiMacHelper wifiMac;\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    NetDeviceContainer wifiApDevices;\n    NetDeviceContainer wifiStaDevices;\n    NetDeviceContainer wifiDevices;\n\n    // Configure the STA nodes\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\",\n                                 \"RtsCtsThreshold\",\n                                 UintegerValue(rtsThreshold));\n    wifiPhy.Set(\"TxPowerStart\", DoubleValue(maxPower));\n    wifiPhy.Set(\"TxPowerEnd\", DoubleValue(maxPower));\n\n    Ssid ssid = Ssid(\"AP0\");\n    wifiMac.SetType(\"ns3::StaWifiMac\",\n                    \"Ssid\",\n                    SsidValue(ssid),\n                    \"MaxMissedBeacons\",\n                    UintegerValue(1000));\n    wifiStaDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiStaNodes.Get(0)));\n\n    ssid = Ssid(\"AP1\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    wifiStaDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiStaNodes.Get(1)));\n\n    // Configure the AP nodes\n    wifi.SetRemoteStationManager(manager,\n                                 \"DefaultTxPowerLevel\",\n                                 UintegerValue(powerLevels - 1),\n                                 \"RtsCtsThreshold\",\n                                 UintegerValue(rtsThreshold));\n    wifiPhy.Set(\"TxPowerStart\", DoubleValue(minPower));\n    wifiPhy.Set(\"TxPowerEnd\", DoubleValue(maxPower));\n    wifiPhy.Set(\"TxPowerLevels\", UintegerValue(powerLevels));\n\n    ssid = Ssid(\"AP0\");\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    wifiApDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiApNodes.Get(0)));\n\n    ssid = Ssid(\"AP1\");\n    wifiMac.SetType(\"ns3::ApWifiMac\",\n                    \"Ssid\",\n                    SsidValue(ssid),\n                    \"BeaconInterval\",\n                    TimeValue(MicroSeconds(103424))); // for avoiding collisions);\n    wifiApDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiApNodes.Get(1)));\n\n    wifiDevices.Add(wifiStaDevices);\n    wifiDevices.Add(wifiApDevices);\n\n    // Configure the mobility.\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(ap1_x, ap1_y, 0.0));\n    positionAlloc->Add(Vector(sta1_x, sta1_y, 0.0));\n    positionAlloc->Add(Vector(ap2_x, ap2_y, 0.0));\n    positionAlloc->Add(Vector(sta2_x, sta2_y, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNodes.Get(0));\n    mobility.Install(wifiStaNodes.Get(0));\n    mobility.Install(wifiApNodes.Get(1));\n    mobility.Install(wifiStaNodes.Get(1));\n\n    // Configure the IP stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes);\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = address.Assign(wifiDevices);\n    Ipv4Address sinkAddress = i.GetAddress(0);\n    Ipv4Address sinkAddress1 = i.GetAddress(1);\n    uint16_t port = 9;\n\n    // Configure the CBR generator\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress, port));\n    ApplicationContainer apps_sink = sink.Install(wifiStaNodes.Get(0));\n\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress, port));\n    onoff.SetConstantRate(DataRate(\"54Mb/s\"), packetSize);\n    onoff.SetAttribute(\"StartTime\", TimeValue(Seconds(0.0)));\n    onoff.SetAttribute(\"StopTime\", TimeValue(Seconds(100.0)));\n    ApplicationContainer apps_source = onoff.Install(wifiApNodes.Get(0));\n\n    PacketSinkHelper sink1(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress1, port));\n    apps_sink.Add(sink1.Install(wifiStaNodes.Get(1)));\n\n    OnOffHelper onoff1(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress1, port));\n    onoff1.SetConstantRate(DataRate(\"54Mb/s\"), packetSize);\n    onoff1.SetAttribute(\"StartTime\", TimeValue(Seconds(0.0)));\n    onoff1.SetAttribute(\"StopTime\", TimeValue(Seconds(100.0)));\n    apps_source.Add(onoff1.Install(wifiApNodes.Get(1)));\n\n    apps_sink.Start(Seconds(0.5));\n    apps_sink.Stop(simuTime);\n\n    //------------------------------------------------------------\n    //-- Setup stats and data collection\n    //--------------------------------------------\n\n    // Statistics counters\n    NodeStatistics statisticsAp0 = NodeStatistics(wifiApDevices, wifiStaDevices);\n    NodeStatistics statisticsAp1 = NodeStatistics(wifiApDevices, wifiStaDevices);\n\n    // Register packet receptions to calculate throughput\n    Config::Connect(\"/NodeList/2/ApplicationList/*/$ns3::PacketSink/Rx\",\n                    MakeCallback(&NodeStatistics::RxCallback, &statisticsAp0));\n    Config::Connect(\"/NodeList/3/ApplicationList/*/$ns3::PacketSink/Rx\",\n                    MakeCallback(&NodeStatistics::RxCallback, &statisticsAp1));\n\n    // Register power and rate changes to calculate the Average Transmit Power\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/PowerChange\",\n                    MakeCallback(&NodeStatistics::PowerCallback, &statisticsAp0));\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/RateChange\",\n                    MakeCallback(&NodeStatistics::RateCallback, &statisticsAp0));\n    Config::Connect(\"/NodeList/1/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/PowerChange\",\n                    MakeCallback(&NodeStatistics::PowerCallback, &statisticsAp1));\n    Config::Connect(\"/NodeList/1/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/RateChange\",\n                    MakeCallback(&NodeStatistics::RateCallback, &statisticsAp1));\n\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/Phy/PhyTxBegin\",\n                    MakeCallback(&NodeStatistics::PhyCallback, &statisticsAp0));\n    Config::Connect(\"/NodeList/1/DeviceList/*/$ns3::WifiNetDevice/Phy/PhyTxBegin\",\n                    MakeCallback(&NodeStatistics::PhyCallback, &statisticsAp1));\n\n    // Register States\n    Config::Connect(\n        \"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::YansWifiPhy/State/State\",\n        MakeCallback(&NodeStatistics::StateCallback, &statisticsAp0));\n    Config::Connect(\n        \"/NodeList/1/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::YansWifiPhy/State/State\",\n        MakeCallback(&NodeStatistics::StateCallback, &statisticsAp1));\n\n    statisticsAp0.CheckStatistics(1);\n    statisticsAp1.CheckStatistics(1);\n\n    // Callbacks to print every change of power and rate\n    Config::Connect(\"/NodeList/[0-1]/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/PowerChange\",\n                    MakeCallback(PowerCallback));\n    Config::Connect(\"/NodeList/[0-1]/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/RateChange\",\n                    MakeCallback(RateCallback));\n\n    // Calculate Throughput using Flowmonitor\n\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    Simulator::Stop(simuTime);\n    Simulator::Run();\n\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    for (auto i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        if (t.sourceAddress == \"10.1.1.3\" && t.destinationAddress == \"10.1.1.1\")\n        {\n            NS_LOG_INFO(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \"\n                                << t.destinationAddress << \")\\n\");\n            NS_LOG_INFO(\"  Tx Bytes:   \" << i->second.txBytes << \"\\n\");\n            NS_LOG_INFO(\"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\");\n            NS_LOG_UNCOND(\"  Throughput to 10.1.1.1: \"\n                          << i->second.rxBytes * 8.0 /\n                                 (i->second.timeLastRxPacket.GetSeconds() -\n                                  i->second.timeFirstTxPacket.GetSeconds()) /\n                                 1024 / 1024\n                          << \" Mbps\\n\");\n            NS_LOG_INFO(\"  Mean delay:   \" << i->second.delaySum.GetSeconds() / i->second.rxPackets\n                                           << \"\\n\");\n            NS_LOG_INFO(\"  Mean jitter:   \"\n                        << i->second.jitterSum.GetSeconds() / (i->second.rxPackets - 1) << \"\\n\");\n            NS_LOG_INFO(\"  Tx Opp: \" << 1 - (statisticsAp0.GetBusyTime() / simuTime.GetSeconds()));\n        }\n        if (t.sourceAddress == \"10.1.1.4\" && t.destinationAddress == \"10.1.1.2\")\n        {\n            NS_LOG_INFO(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \"\n                                << t.destinationAddress << \")\\n\");\n            NS_LOG_INFO(\"  Tx Bytes:   \" << i->second.txBytes << \"\\n\");\n            NS_LOG_INFO(\"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\");\n            NS_LOG_UNCOND(\"  Throughput to 10.1.1.2: \"\n                          << i->second.rxBytes * 8.0 /\n                                 (i->second.timeLastRxPacket.GetSeconds() -\n                                  i->second.timeFirstTxPacket.GetSeconds()) /\n                                 1024 / 1024\n                          << \" Mbps\\n\");\n            NS_LOG_INFO(\"  Mean delay:   \" << i->second.delaySum.GetSeconds() / i->second.rxPackets\n                                           << \"\\n\");\n            NS_LOG_INFO(\"  Mean jitter:   \"\n                        << i->second.jitterSum.GetSeconds() / (i->second.rxPackets - 1) << \"\\n\");\n            NS_LOG_INFO(\"  Tx Opp: \" << 1 - (statisticsAp1.GetBusyTime() / simuTime.GetSeconds()));\n        }\n    }\n\n    // Plots for AP0\n    std::ofstream outfileTh0(\"throughput-\" + outputFileName + \"-0.plt\");\n    Gnuplot gnuplot = Gnuplot(\"throughput-\" + outputFileName + \"-0.eps\", \"Throughput\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Throughput (Mb/s)\");\n    gnuplot.SetTitle(\"Throughput (AP0 to STA) vs time\");\n    gnuplot.AddDataset(statisticsAp0.GetDatafile());\n    gnuplot.GenerateOutput(outfileTh0);\n\n    if (manager == \"ns3::ParfWifiManager\" || manager == \"ns3::AparfWifiManager\" ||\n        manager == \"ns3::RrpaaWifiManager\")\n    {\n        std::ofstream outfilePower0(\"power-\" + outputFileName + \"-0.plt\");\n        gnuplot = Gnuplot(\"power-\" + outputFileName + \"-0.eps\", \"Average Transmit Power\");\n        gnuplot.SetTerminal(\"post eps color enhanced\");\n        gnuplot.SetLegend(\"Time (seconds)\", \"Power (mW)\");\n        gnuplot.SetTitle(\"Average transmit power (AP0 to STA) vs time\");\n        gnuplot.AddDataset(statisticsAp0.GetPowerDatafile());\n        gnuplot.GenerateOutput(outfilePower0);\n    }\n\n    std::ofstream outfileTx0(\"tx-\" + outputFileName + \"-0.plt\");\n    gnuplot = Gnuplot(\"tx-\" + outputFileName + \"-0.eps\", \"Time in TX State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP0 in TX state vs time\");\n    gnuplot.AddDataset(statisticsAp0.GetTxDatafile());\n    gnuplot.GenerateOutput(outfileTx0);\n\n    std::ofstream outfileRx0(\"rx-\" + outputFileName + \"-0.plt\");\n    gnuplot = Gnuplot(\"rx-\" + outputFileName + \"-0.eps\", \"Time in RX State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP0 in RX state vs time\");\n    gnuplot.AddDataset(statisticsAp0.GetRxDatafile());\n    gnuplot.GenerateOutput(outfileRx0);\n\n    std::ofstream outfileBusy0(\"busy-\" + outputFileName + \"-0.plt\");\n    gnuplot = Gnuplot(\"busy-\" + outputFileName + \"-0.eps\", \"Time in Busy State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP0 in Busy state vs time\");\n    gnuplot.AddDataset(statisticsAp0.GetBusyDatafile());\n    gnuplot.GenerateOutput(outfileBusy0);\n\n    std::ofstream outfileIdle0(\"idle-\" + outputFileName + \"-0.plt\");\n    gnuplot = Gnuplot(\"idle-\" + outputFileName + \"-0.eps\", \"Time in Idle State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP0 in Idle state vs time\");\n    gnuplot.AddDataset(statisticsAp0.GetIdleDatafile());\n    gnuplot.GenerateOutput(outfileIdle0);\n\n    // Plots for AP1\n    std::ofstream outfileTh1(\"throughput-\" + outputFileName + \"-1.plt\");\n    gnuplot = Gnuplot(\"throughput-\" + outputFileName + \"-1.eps\", \"Throughput\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Throughput (Mb/s)\");\n    gnuplot.SetTitle(\"Throughput (AP1 to STA) vs time\");\n    gnuplot.AddDataset(statisticsAp1.GetDatafile());\n    gnuplot.GenerateOutput(outfileTh1);\n\n    if (manager == \"ns3::ParfWifiManager\" || manager == \"ns3::AparfWifiManager\" ||\n        manager == \"ns3::RrpaaWifiManager\")\n    {\n        std::ofstream outfilePower1(\"power-\" + outputFileName + \"-1.plt\");\n        gnuplot = Gnuplot(\"power-\" + outputFileName + \"-1.eps\", \"Average Transmit Power\");\n        gnuplot.SetTerminal(\"post eps color enhanced\");\n        gnuplot.SetLegend(\"Time (seconds)\", \"Power (mW)\");\n        gnuplot.SetTitle(\"Average transmit power (AP1 to STA) vs time\");\n        gnuplot.AddDataset(statisticsAp1.GetPowerDatafile());\n        gnuplot.GenerateOutput(outfilePower1);\n    }\n\n    std::ofstream outfileTx1(\"tx-\" + outputFileName + \"-1.plt\");\n    gnuplot = Gnuplot(\"tx-\" + outputFileName + \"-1.eps\", \"Time in TX State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP1 in TX state vs time\");\n    gnuplot.AddDataset(statisticsAp1.GetTxDatafile());\n    gnuplot.GenerateOutput(outfileTx1);\n\n    std::ofstream outfileRx1(\"rx-\" + outputFileName + \"-1.plt\");\n    gnuplot = Gnuplot(\"rx-\" + outputFileName + \"-1.eps\", \"Time in RX State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP1 in RX state vs time\");\n    gnuplot.AddDataset(statisticsAp1.GetRxDatafile());\n    gnuplot.GenerateOutput(outfileRx1);\n\n    std::ofstream outfileBusy1(\"busy-\" + outputFileName + \"-1.plt\");\n    gnuplot = Gnuplot(\"busy-\" + outputFileName + \"-1.eps\", \"Time in Busy State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP1 in Busy state vs time\");\n    gnuplot.AddDataset(statisticsAp1.GetBusyDatafile());\n    gnuplot.GenerateOutput(outfileBusy1);\n\n    std::ofstream outfileIdle1(\"idle-\" + outputFileName + \"-1.plt\");\n    gnuplot = Gnuplot(\"idle-\" + outputFileName + \"-1.eps\", \"Time in Idle State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP1 in Idle state vs time\");\n    gnuplot.AddDataset(statisticsAp1.GetIdleDatafile());\n    gnuplot.GenerateOutput(outfileIdle1);\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nProvide a C++ example code for NS-3 that demonstrates the configuration of a mixed network with b/g and HT/non-HT stations, compares their performance under various scenarios such as ERP protection mode, short PPDU format, short slot time, and different payload sizes, and supports both UDP and TCP traffic, while outputting throughput results for each configuration."}, {"role": "assistant", "content": "#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/ht-configuration.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/pointer.h\"\n#include \"ns3/qos-txop.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/wifi-mac.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This example shows how to configure mixed networks (i.e. mixed b/g and HT/non-HT) and how are\n// performance in several scenarios.\n//\n// The example compares first g only and mixed b/g cases with various configurations depending on\n// the following parameters:\n// - protection mode that is configured on the AP;\n// - whether short PPDU format is supported by the 802.11b station;\n// - whether short slot time is supported by both the 802.11g station and the AP.\n//\n// The example then compares HT only and mixed HT/non-HT cases.\n//\n// The output results show that the presence of an 802.11b station strongly affects 802.11g\n// performance. Protection mechanisms ensure that the NAV value of 802.11b stations is set correctly\n// in case of 802.11g transmissions. In practice, those protection mechanism add a lot of overhead,\n// resulting in reduced performance. CTS-To-Self introduces less overhead than Rts-Cts, but is not\n// heard by hidden stations (and is thus generally only recommended as a protection mechanism for\n// access points). Since short slot time is disabled once an 802.11b station enters the network,\n// benefits from short slot time are only observed in a g only configuration.\n//\n// The user can also select the payload size and can choose either an UDP or a TCP connection.\n// Example: ./ns3 run \"wifi-mixed-network --isUdp=1\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MixedNetwork\");\n\n/** Parameters */\nstruct Parameters\n{\n    std::string testName;          //!< Test name\n    bool enableErpProtection;      //!< True to enable ERP protection\n    std::string erpProtectionMode; //!< ERP protection mode\n    bool enableShortSlotTime;      //!< True to enable short slot time\n    bool enableShortPhyPreamble;   //!< True to enable short PHY preamble\n    WifiStandard apType;           //!< Wifi standard for AP\n    uint32_t nWifiB;               //!< Number of 802.11b stations\n    bool bHasTraffic;              //!< True if 802.11b stations generate traffic\n    uint32_t nWifiG;               //!< Number of 802.11g stations\n    bool gHasTraffic;              //!< True if 802.11g stations generate traffic\n    uint32_t nWifiN;               //!< Number of 802.11n stations\n    bool nHasTraffic;              //!< True if 802.11n stations generate traffic\n    bool isUdp;                    //!< True to generate UDP traffic\n    uint32_t payloadSize;          //!< Payload size in bytes\n    Time simulationTime;           //!< Simulation time\n};\n\nclass Experiment\n{\n  public:\n    Experiment();\n    /**\n     * Run an experiment with the given parameters\n     * \\param params the given parameters\n     * \\return the throughput\n     */\n    double Run(Parameters params);\n};\n\nExperiment::Experiment()\n{\n}\n\ndouble\nExperiment::Run(Parameters params)\n{\n    std::string apTypeString;\n    if (params.apType == WIFI_STANDARD_80211g)\n    {\n        apTypeString = \"WIFI_STANDARD_80211g\";\n    }\n    else if (params.apType == WIFI_STANDARD_80211n)\n    {\n        apTypeString = \"WIFI_STANDARD_80211n_2_4GHZ\";\n    }\n\n    std::cout << \"Run: \" << params.testName\n              << \"\\n\\t enableErpProtection=\" << params.enableErpProtection\n              << \"\\n\\t erpProtectionMode=\" << params.erpProtectionMode\n              << \"\\n\\t enableShortSlotTime=\" << params.enableShortSlotTime\n              << \"\\n\\t enableShortPhyPreamble=\" << params.enableShortPhyPreamble\n              << \"\\n\\t apType=\" << apTypeString << \"\\n\\t nWifiB=\" << params.nWifiB\n              << \"\\n\\t bHasTraffic=\" << params.bHasTraffic << \"\\n\\t nWifiG=\" << params.nWifiG\n              << \"\\n\\t gHasTraffic=\" << params.gHasTraffic << \"\\n\\t nWifiN=\" << params.nWifiN\n              << \"\\n\\t nHasTraffic=\" << params.nHasTraffic << std::endl;\n\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::ErpProtectionMode\",\n                       StringValue(params.erpProtectionMode));\n\n    double throughput = 0;\n    uint32_t nWifiB = params.nWifiB;\n    uint32_t nWifiG = params.nWifiG;\n    uint32_t nWifiN = params.nWifiN;\n    auto simulationTime = params.simulationTime;\n    uint32_t payloadSize = params.payloadSize;\n\n    NodeContainer wifiBStaNodes;\n    wifiBStaNodes.Create(nWifiB);\n    NodeContainer wifiGStaNodes;\n    wifiGStaNodes.Create(nWifiG);\n    NodeContainer wifiNStaNodes;\n    wifiNStaNodes.Create(nWifiN);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    channel.AddPropagationLoss(\"ns3::RangePropagationLossModel\");\n\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::IdealWifiManager\");\n\n    // 802.11b STA\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"ShortSlotTimeSupported\",\n                BooleanValue(params.enableShortSlotTime));\n\n    // Configure the PHY preamble type: long or short\n    phy.Set(\"ShortPlcpPreambleSupported\", BooleanValue(params.enableShortPhyPreamble));\n\n    NetDeviceContainer bStaDevice;\n    bStaDevice = wifi.Install(phy, mac, wifiBStaNodes);\n\n    // 802.11b/g STA\n    wifi.SetStandard(WIFI_STANDARD_80211g);\n    NetDeviceContainer gStaDevice;\n    gStaDevice = wifi.Install(phy, mac, wifiGStaNodes);\n\n    // 802.11b/g/n STA\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    NetDeviceContainer nStaDevice;\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"BE_BlockAckThreshold\",\n                UintegerValue(2),\n                \"ShortSlotTimeSupported\",\n                BooleanValue(params.enableShortSlotTime));\n    nStaDevice = wifi.Install(phy, mac, wifiNStaNodes);\n\n    // AP\n    NetDeviceContainer apDevice;\n    wifi.SetStandard(params.apType);\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false),\n                \"BE_BlockAckThreshold\",\n                UintegerValue(2),\n                \"EnableNonErpProtection\",\n                BooleanValue(params.enableErpProtection),\n                \"ShortSlotTimeSupported\",\n                BooleanValue(params.enableShortSlotTime));\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set TXOP limit\n    if (params.apType == WIFI_STANDARD_80211n)\n    {\n        Ptr<NetDevice> dev = wifiApNode.Get(0)->GetDevice(0);\n        Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n        Ptr<WifiMac> wifi_mac = wifi_dev->GetMac();\n        PointerValue ptr;\n        wifi_mac->GetAttribute(\"BE_Txop\", ptr);\n        Ptr<QosTxop> edca = ptr.Get<QosTxop>();\n        edca->SetTxopLimit(MicroSeconds(3008));\n    }\n    if (nWifiN > 0)\n    {\n        Ptr<NetDevice> dev = wifiNStaNodes.Get(0)->GetDevice(0);\n        Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n        Ptr<WifiMac> wifi_mac = wifi_dev->GetMac();\n        PointerValue ptr;\n        wifi_mac->GetAttribute(\"BE_Txop\", ptr);\n        Ptr<QosTxop> edca = ptr.Get<QosTxop>();\n        edca->SetTxopLimit(MicroSeconds(3008));\n    }\n\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/BE_MaxAmpduSize\",\n                UintegerValue(0)); // Disable A-MPDU\n\n    // Define mobility model\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    for (uint32_t i = 0; i < nWifiB; i++)\n    {\n        positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    }\n    for (uint32_t i = 0; i < nWifiG; i++)\n    {\n        positionAlloc->Add(Vector(0.0, 5.0, 0.0));\n    }\n    for (uint32_t i = 0; i < nWifiN; i++)\n    {\n        positionAlloc->Add(Vector(0.0, 0.0, 5.0));\n    }\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiBStaNodes);\n    mobility.Install(wifiGStaNodes);\n    mobility.Install(wifiNStaNodes);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiBStaNodes);\n    stack.Install(wifiGStaNodes);\n    stack.Install(wifiNStaNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer bStaInterface;\n    bStaInterface = address.Assign(bStaDevice);\n    Ipv4InterfaceContainer gStaInterface;\n    gStaInterface = address.Assign(gStaDevice);\n    Ipv4InterfaceContainer nStaInterface;\n    nStaInterface = address.Assign(nStaDevice);\n    Ipv4InterfaceContainer ApInterface;\n    ApInterface = address.Assign(apDevice);\n\n    // Setting applications\n    if (params.isUdp)\n    {\n        uint16_t port = 9;\n        UdpServerHelper server(port);\n        ApplicationContainer serverApp = server.Install(wifiApNode);\n        serverApp.Start(Seconds(0.0));\n        serverApp.Stop(simulationTime + Seconds(1.0));\n\n        UdpClientHelper client(ApInterface.GetAddress(0), port);\n        client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n        client.SetAttribute(\"Interval\", TimeValue(Time(\"0.0002\"))); // packets/s\n        client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n        ApplicationContainer clientApps;\n        if (params.bHasTraffic)\n        {\n            clientApps.Add(client.Install(wifiBStaNodes));\n        }\n        if (params.gHasTraffic)\n        {\n            clientApps.Add(client.Install(wifiGStaNodes));\n        }\n        if (params.nHasTraffic)\n        {\n            clientApps.Add(client.Install(wifiNStaNodes));\n        }\n        clientApps.Start(Seconds(1.0));\n        clientApps.Stop(simulationTime + Seconds(1.0));\n\n        Simulator::Stop(simulationTime + Seconds(1.0));\n        Simulator::Run();\n\n        double totalPacketsThrough = DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n        throughput = totalPacketsThrough * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    }\n    else\n    {\n        uint16_t port = 50000;\n        Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n        PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n\n        ApplicationContainer serverApp = packetSinkHelper.Install(wifiApNode.Get(0));\n        serverApp.Start(Seconds(0.0));\n        serverApp.Stop(simulationTime + Seconds(1.0));\n\n        OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n        onoff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        onoff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n        onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n        onoff.SetAttribute(\"DataRate\", DataRateValue(150000000)); // bit/s\n\n        AddressValue remoteAddress(InetSocketAddress(ApInterface.GetAddress(0), port));\n        onoff.SetAttribute(\"Remote\", remoteAddress);\n\n        ApplicationContainer clientApps;\n        if (params.bHasTraffic)\n        {\n            clientApps.Add(onoff.Install(wifiBStaNodes));\n        }\n        if (params.gHasTraffic)\n        {\n            clientApps.Add(onoff.Install(wifiGStaNodes));\n        }\n        if (params.nHasTraffic)\n        {\n            clientApps.Add(onoff.Install(wifiNStaNodes));\n        }\n        clientApps.Start(Seconds(1.0));\n        clientApps.Stop(simulationTime + Seconds(1.0));\n\n        Simulator::Stop(simulationTime + Seconds(1.0));\n        Simulator::Run();\n\n        double totalPacketsThrough = DynamicCast<PacketSink>(serverApp.Get(0))->GetTotalRx();\n        throughput += totalPacketsThrough * 8 / simulationTime.GetMicroSeconds();\n    }\n    Simulator::Destroy();\n    return throughput;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    Parameters params;\n    params.testName = \"\";\n    params.enableErpProtection = false;\n    params.erpProtectionMode = \"Cts-To-Self\";\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = false;\n    params.apType = WIFI_STANDARD_80211g;\n    params.nWifiB = 0;\n    params.bHasTraffic = false;\n    params.nWifiG = 1;\n    params.gHasTraffic = true;\n    params.nWifiN = 0;\n    params.nHasTraffic = false;\n    params.isUdp = true;\n    params.payloadSize = 1472; // bytes\n    params.simulationTime = Seconds(10);\n\n    bool verifyResults = false; // used for regression\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"payloadSize\", \"Payload size in bytes\", params.payloadSize);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", params.simulationTime);\n    cmd.AddValue(\"isUdp\", \"UDP if set to 1, TCP otherwise\", params.isUdp);\n    cmd.AddValue(\"verifyResults\",\n                 \"Enable/disable results verification at the end of the simulation\",\n                 verifyResults);\n    cmd.Parse(argc, argv);\n\n    Experiment experiment;\n    double throughput = 0;\n\n    params.testName = \"g only with all g features disabled\";\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 22.5 || throughput > 23.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"g only with short slot time enabled\";\n    params.enableErpProtection = false;\n    params.enableShortSlotTime = true;\n    params.enableShortPhyPreamble = false;\n    params.nWifiB = 0;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 29 || throughput > 30))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"Mixed b/g with all g features disabled\";\n    params.enableErpProtection = false;\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = false;\n    params.nWifiB = 1;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 22.5 || throughput > 23.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"Mixed b/g with short plcp preamble enabled\";\n    params.enableErpProtection = false;\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = true;\n    params.nWifiB = 1;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 22.5 || throughput > 23.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"Mixed b/g with short slot time enabled using RTS-CTS protection\";\n    params.enableErpProtection = true;\n    params.erpProtectionMode = \"Rts-Cts\";\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = false;\n    params.nWifiB = 1;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 19 || throughput > 20))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"Mixed b/g with short plcp preamble enabled using RTS-CTS protection\";\n    params.enableErpProtection = true;\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = true;\n    params.nWifiB = 1;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 19 || throughput > 20))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"Mixed b/g with short slot time enabled using CTS-TO-SELF protection\";\n    params.enableErpProtection = true;\n    params.erpProtectionMode = \"Cts-To-Self\";\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = false;\n    params.nWifiB = 1;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 20.5 || throughput > 21.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"Mixed b/g with short plcp preamble enabled using CTS-TO-SELF protection\";\n    params.enableErpProtection = true;\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = true;\n    params.nWifiB = 1;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 20.5 || throughput > 21.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"HT only\";\n    params.enableErpProtection = false;\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = false;\n    params.apType = WIFI_STANDARD_80211n;\n    params.nWifiB = 0;\n    params.bHasTraffic = false;\n    params.nWifiG = 0;\n    params.gHasTraffic = false;\n    params.nWifiN = 1;\n    params.nHasTraffic = true;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 44 || throughput > 45))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"Mixed HT/non-HT\";\n    params.enableErpProtection = false;\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = false;\n    params.apType = WIFI_STANDARD_80211n;\n    params.nWifiB = 0;\n    params.bHasTraffic = false;\n    params.nWifiG = 1;\n    params.gHasTraffic = false;\n    params.nWifiN = 1;\n    params.nHasTraffic = true;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 44 || throughput > 45))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless network using the IEEE 802.11 WiFi standard in ns-3. Create a network with one Access Point (AP) and two WiFi stations (STA). Configure the stations to communicate with the AP using UDP traffic. Track the number of packets transmitted, the total received bytes, and the throughput for each station. Enable pcap tracing to capture the wireless traffic."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/packet-sink-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    double simulationTime = 10.0; // Simulation time in seconds\n    std::string dataRate = \"10Mbps\"; // UDP application data rate\n\n    // Enable logging\n    LogComponentEnable(\"WifiNetworkExample\", LOG_LEVEL_INFO);\n\n    // Create a WiFi network with one AP and two stations\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Configure the WiFi PHY and MAC\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Configure STA nodes\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure AP node\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Configure mobility for the stations and AP\n    MobilityHelper mobility;\n\n    // Set up station mobility\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n\n    // Set up AP mobility (static)\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n\n    // Set up UDP applications on STA nodes to send data to the AP\n    uint16_t port = 9;\n    UdpClientHelper udpClient(apInterface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05))); // Packet interval\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));    // Packet size\n\n    ApplicationContainer clientApps = udpClient.Install(wifiStaNodes);\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(simulationTime));\n\n    // Set up a packet sink on the AP to receive the UDP traffic\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Enable pcap tracing\n    phy.EnablePcap(\"wifi-network\", apDevice.Get(0));\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n\n    // Log the total number of packets received by the AP\n    Ptr<UdpServer> server = DynamicCast<UdpServer>(serverApp.Get(0));\n    NS_LOG_INFO(\"Total Packets Received by AP: \" << server->GetReceived());\n    NS_LOG_INFO(\"Total Bytes Received by AP: \" << server->GetReceivedBytes());\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for an LTE network with one eNodeB (LTE base station) and three UEs. The eNodeB should have a UDP server running on port 9, and the UEs should act as UDP clients, sending 10 packets at 1-second intervals. The simulation should run for 10 seconds, and the UEs should move randomly in a 50x50 area using the random walk mobility model."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time resolution\n    Time::SetResolution(Time::NS);\n\n    // Create nodes: one eNodeB and three UEs\n    NodeContainer eNodeBNode, ueNodes;\n    eNodeBNode.Create(1);\n    ueNodes.Create(3);\n\n    // Set up LTE helper\n    LteHelper lteHelper;\n    Ptr<LteEnbNetDevice> enbDevice = lteHelper.InstallEnbDevice(eNodeBNode.Get(0));\n    Ptr<LteUeNetDevice> ueDevice1 = lteHelper.InstallUeDevice(ueNodes.Get(0));\n    Ptr<LteUeNetDevice> ueDevice2 = lteHelper.InstallUeDevice(ueNodes.Get(1));\n    Ptr<LteUeNetDevice> ueDevice3 = lteHelper.InstallUeDevice(ueNodes.Get(2));\n\n    // Install IP stack for routing\n    InternetStackHelper internet;\n    internet.Install(eNodeBNode);\n    internet.Install(ueNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer enbIpIface, ueIpIface;\n    enbIpIface = ipv4.Assign(enbDevice);\n    ueIpIface = ipv4.Assign(ueDevice1);\n    ipv4.SetBase(\"10.0.1.0\", \"255.255.255.0\");\n    ipv4.Assign(ueDevice2);\n    ipv4.SetBase(\"10.0.2.0\", \"255.255.255.0\");\n    ipv4.Assign(ueDevice3);\n\n    // Set up the UDP server on eNodeB\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(eNodeBNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP clients on the UEs\n    UdpClientHelper udpClient(enbIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps;\n    clientApps.Add(udpClient.Install(ueNodes.Get(0)));\n    clientApps.Add(udpClient.Install(ueNodes.Get(1)));\n    clientApps.Add(udpClient.Install(ueNodes.Get(2)));\n\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Set mobility model for eNodeB and UEs\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(eNodeBNode);\n\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 50, 0, 50)));\n    mobility.Install(ueNodes);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a simple point-to-point network with two nodes. The link should have a 5 Mbps data rate and a 2 ms delay. Node 0 should send TCP traffic to Node 1 using the BulkSendApplication. The receiver (Node 1) should use a TCP Packet Sink on port 8080. The TCP sender should start at 1 second and continue sending unlimited data until 10 seconds. The network should use the 192.168.1.x subnet."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP sink on Node 1\n    uint16_t port = 8080;\n    Address sinkAddress(InetSocketAddress(interfaces.GetAddress(1), port));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    ApplicationContainer sinkApp = sinkHelper.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(0.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Create a TCP sender on Node 0\n    BulkSendHelper sender(\"ns3::TcpSocketFactory\", sinkAddress);\n    sender.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n    ApplicationContainer senderApp = sender.Install(nodes.Get(0));\n    senderApp.Start(Seconds(1.0));\n    senderApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network with two nodes: a sender (AP) and a receiver (STA). Use UDP communication with the sender sending 1000 packets at intervals of 20ms to the receiver. Configure the nodes with static mobility and assign them IP addresses. The receiver should run a UDP server on port 9."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set up logging\n    LogComponentEnable(\"WifiSimpleExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Set up Wi-Fi\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up the physical layer\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up MAC layer\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    // Install Wi-Fi devices on nodes\n    NetDeviceContainer staDevice;\n    staDevice = wifi.Install(phy, mac, wifiStaNodes);\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces;\n    staInterfaces = address.Assign(staDevice);\n    Ipv4InterfaceContainer apInterfaces;\n    apInterfaces = address.Assign(apDevice);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0), \"DeltaY\", DoubleValue(5.0), \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Set up UDP server on STA\n    UdpServerHelper server(9);\n    ApplicationContainer serverApp = server.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on AP\n    UdpClientHelper client(staInterfaces.GetAddress(0), 9);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(20)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a private network using Network Address Translation (NAT) in NS-3. The private network contains two hosts using private IP addresses. A NAT router connects this private network to a public network, where an external server is located. The hosts in the private network send UDP packets to the public server, and the NAT router translates their private IP addresses to a public IP for outbound traffic. Capture and verify that the public server responds to the NAT router's public IP, and the NAT router translates the responses back to the correct private IP addresses."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/nat-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"NatExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer natRouter, privateHosts, publicServer;\n    natRouter.Create(1);         // NAT router\n    privateHosts.Create(2);      // Two hosts behind the NAT\n    publicServer.Create(1);      // Public server\n\n    // Create point-to-point links\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Link between the private network and the NAT router\n    NetDeviceContainer privateDevices;\n    privateDevices = p2p.Install(NodeContainer(privateHosts, natRouter));\n\n    // Link between the NAT router and the public server\n    NetDeviceContainer publicDevices;\n    publicDevices = p2p.Install(NodeContainer(natRouter, publicServer));\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(privateHosts);\n    internet.Install(natRouter);\n    internet.Install(publicServer);\n\n    // Assign IP addresses\n    Ipv4AddressHelper privateNetwork;\n    privateNetwork.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer privateInterfaces = privateNetwork.Assign(privateDevices.Get(0));\n\n    Ipv4AddressHelper publicNetwork;\n    publicNetwork.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer publicInterfaces = publicNetwork.Assign(publicDevices.Get(1));\n\n    // Assign public IP to the NAT router's public interface\n    publicNetwork.Assign(publicDevices.Get(0));\n\n    // Configure NAT\n    NatHelper natHelper;\n    natHelper.Install(natRouter.Get(0), publicDevices.Get(0));\n\n    // Install UDP Echo server on the public server\n    UdpEchoServerHelper echoServer(9);  // Listening on port 9\n    ApplicationContainer serverApp = echoServer.Install(publicServer.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Install UDP Echo client on the private network hosts\n    UdpEchoClientHelper echoClient(publicInterfaces.GetAddress(1), 9);  // Destination: public server\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp1 = echoClient.Install(privateHosts.Get(0));\n    clientApp1.Start(Seconds(2.0));\n    clientApp1.Stop(Seconds(10.0));\n\n    ApplicationContainer clientApp2 = echoClient.Install(privateHosts.Get(1));\n    clientApp2.Start(Seconds(2.0));\n    clientApp2.Stop(Seconds(10.0));\n\n    // Enable pcap tracing\n    p2p.EnablePcapAll(\"nat-example\");\n\n    // Start simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a code in C++ using the ns-3 simulation framework to model a vehicular environment, simulating the channel conditions and pathloss based on 3GPP TR 37.885 and TR 38.901 standards. The code should include the following elements: configure nodes to simulate vehicles, setup mobility models for urban and highway scenarios, assign antennas using uniform planar arrays, and calculate beamforming using DFT methods. The simulation should log average SNR and pathloss values over time and output these to a file, which can be used to generate figures representing the scenario."}, {"role": "assistant", "content": "/**\n * This is an example on how to configure the channel model classes to simulate\n * a vehicular environment.\n * The channel condition is determined using the model specified in [1], Table 6.2-1.\n * The pathloss is determined using the model specified in [1], Table 6.2.1-1.\n * The model for the fast fading is the one described in 3GPP TR 38.901 v15.0.0,\n * the model parameters are those specified in [1], Table 6.2.3-1.\n *\n * This example generates the output file 'example-output.txt'. Each row of the\n * file is organized as follows:\n * Time[s] TxPosX[m] TxPosY[m] RxPosX[m] RxPosY[m] ChannelState SNR[dB] Pathloss[dB]\n * We also provide a bash script which reads the output file and generates two\n * figures:\n * (i) map.gif, a GIF representing the simulation scenario and vehicle mobility;\n * (ii) snr.png, which represents the behavior of the SNR.\n *\n * [1] 3GPP TR 37.885, v15.3.0\n */\n\n#include \"ns3/buildings-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/spectrum-signal-parameters.h\"\n#include \"ns3/three-gpp-channel-model.h\"\n#include \"ns3/three-gpp-spectrum-propagation-loss-model.h\"\n#include \"ns3/three-gpp-v2v-propagation-loss-model.h\"\n#include \"ns3/uniform-planar-array.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ThreeGppV2vChannelExample\");\n\nstatic Ptr<ThreeGppPropagationLossModel>\n    m_propagationLossModel; //!< the PropagationLossModel object\nstatic Ptr<ThreeGppSpectrumPropagationLossModel>\n    m_spectrumLossModel;                       //!< the SpectrumPropagationLossModel object\nstatic Ptr<ChannelConditionModel> m_condModel; //!< the ChannelConditionModel object\n\n/*\n * \\brief A structure that holds the parameters for the ComputeSnr\n * function. In this way the problem with the limited\n * number of parameters of method Schedule is avoided.\n */\nstruct ComputeSnrParams\n{\n    Ptr<MobilityModel> txMob;               //!< the tx mobility model\n    Ptr<MobilityModel> rxMob;               //!< the rx mobility model\n    Ptr<SpectrumSignalParameters> txParams; //!< the params of the tx signal\n    double noiseFigure;                     //!< the noise figure in dB\n    Ptr<PhasedArrayModel> txAntenna;        //!< the tx antenna array\n    Ptr<PhasedArrayModel> rxAntenna;        //!< the rx antenna array\n};\n\n/**\n * Perform the beamforming using the DFT beamforming method\n * \\param thisDevice the device performing the beamforming\n * \\param thisAntenna the antenna object associated to thisDevice\n * \\param otherDevice the device towards which point the beam\n */\nstatic void\nDoBeamforming(Ptr<NetDevice> thisDevice,\n              Ptr<PhasedArrayModel> thisAntenna,\n              Ptr<NetDevice> otherDevice)\n{\n    PhasedArrayModel::ComplexVector antennaWeights;\n\n    // retrieve the position of the two devices\n    Vector aPos = thisDevice->GetNode()->GetObject<MobilityModel>()->GetPosition();\n    Vector bPos = otherDevice->GetNode()->GetObject<MobilityModel>()->GetPosition();\n\n    // compute the azimuth and the elevation angles\n    Angles completeAngle(bPos, aPos);\n\n    PhasedArrayModel::ComplexVector bf = thisAntenna->GetBeamformingVector(completeAngle);\n    thisAntenna->SetBeamformingVector(bf);\n}\n\n/**\n * Compute the average SNR\n * \\param params A structure that holds a bunch of parameters needed by ComputSnr function to\n * calculate the average SNR\n */\nstatic void\nComputeSnr(const ComputeSnrParams& params)\n{\n    // check the channel condition\n    Ptr<ChannelCondition> cond = m_condModel->GetChannelCondition(params.txMob, params.rxMob);\n\n    // apply the pathloss\n    double propagationGainDb = m_propagationLossModel->CalcRxPower(0, params.txMob, params.rxMob);\n    NS_LOG_DEBUG(\"Pathloss \" << -propagationGainDb << \" dB\");\n    double propagationGainLinear = std::pow(10.0, (propagationGainDb) / 10.0);\n    *(params.txParams->psd) *= propagationGainLinear;\n\n    // apply the fast fading and the beamforming gain\n    auto rxParams = m_spectrumLossModel->CalcRxPowerSpectralDensity(params.txParams,\n                                                                    params.txMob,\n                                                                    params.rxMob,\n                                                                    params.txAntenna,\n                                                                    params.rxAntenna);\n    Ptr<SpectrumValue> rxPsd = rxParams->psd;\n    NS_LOG_DEBUG(\"Average rx power \" << 10 * log10(Sum(*rxPsd) * 180e3) << \" dB\");\n\n    // create the noise psd\n    // taken from lte-spectrum-value-helper\n    const double kT_dBm_Hz = -174.0; // dBm/Hz\n    double kT_W_Hz = std::pow(10.0, (kT_dBm_Hz - 30) / 10.0);\n    double noiseFigureLinear = std::pow(10.0, params.noiseFigure / 10.0);\n    double noisePowerSpectralDensity = kT_W_Hz * noiseFigureLinear;\n    Ptr<SpectrumValue> noisePsd = Create<SpectrumValue>(params.txParams->psd->GetSpectrumModel());\n    (*noisePsd) = noisePowerSpectralDensity;\n\n    // compute the SNR\n    NS_LOG_DEBUG(\"Average SNR \" << 10 * log10(Sum(*rxPsd) / Sum(*noisePsd)) << \" dB\");\n\n    // print the SNR and pathloss values in the snr-trace.txt file\n    std::ofstream f;\n    f.open(\"example-output.txt\", std::ios::out | std::ios::app);\n    f << Simulator::Now().GetSeconds() << \" \" // time [s]\n      << params.txMob->GetPosition().x << \" \" << params.txMob->GetPosition().y << \" \"\n      << params.rxMob->GetPosition().x << \" \" << params.rxMob->GetPosition().y << \" \"\n      << cond->GetLosCondition() << \" \"                  // channel state\n      << 10 * log10(Sum(*rxPsd) / Sum(*noisePsd)) << \" \" // SNR [dB]\n      << -propagationGainDb << std::endl;                // pathloss [dB]\n    f.close();\n}\n\n/**\n * Generates a GNU-plottable file representing the buildings deployed in the\n * scenario\n * \\param filename the name of the output file\n */\nvoid\nPrintGnuplottableBuildingListToFile(std::string filename)\n{\n    std::ofstream outFile;\n    outFile.open(filename, std::ios_base::out | std::ios_base::trunc);\n    if (!outFile.is_open())\n    {\n        NS_LOG_ERROR(\"Can't open file \" << filename);\n        return;\n    }\n    uint32_t index = 0;\n    for (auto it = BuildingList::Begin(); it != BuildingList::End(); ++it)\n    {\n        ++index;\n        Box box = (*it)->GetBoundaries();\n        outFile << \"set object \" << index << \" rect from \" << box.xMin << \",\" << box.yMin << \" to \"\n                << box.xMax << \",\" << box.yMax << std::endl;\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double frequency = 28.0e9;          // operating frequency in Hz\n    double txPow_dbm = 30.0;            // tx power in dBm\n    double noiseFigure = 9.0;           // noise figure in dB\n    Time simTime = Seconds(40);         // simulation time\n    Time timeRes = MilliSeconds(10);    // time resolution\n    std::string scenario = \"V2V-Urban\"; // 3GPP propagation scenario, V2V-Urban or V2V-Highway\n    double vScatt = 0;                  // maximum speed of the vehicles in the scenario [m/s]\n    double subCarrierSpacing = 60e3;    // subcarrier spacing in kHz\n    uint32_t numRb = 275;               // number of resource blocks\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"frequency\", \"operating frequency in Hz\", frequency);\n    cmd.AddValue(\"txPow\", \"tx power in dBm\", txPow_dbm);\n    cmd.AddValue(\"noiseFigure\", \"noise figure in dB\", noiseFigure);\n    cmd.AddValue(\"scenario\", \"3GPP propagation scenario, V2V-Urban or V2V-Highway\", scenario);\n    cmd.Parse(argc, argv);\n\n    // create the nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // create the tx and rx devices\n    Ptr<SimpleNetDevice> txDev = CreateObject<SimpleNetDevice>();\n    Ptr<SimpleNetDevice> rxDev = CreateObject<SimpleNetDevice>();\n\n    // associate the nodes and the devices\n    nodes.Get(0)->AddDevice(txDev);\n    txDev->SetNode(nodes.Get(0));\n    nodes.Get(1)->AddDevice(rxDev);\n    rxDev->SetNode(nodes.Get(1));\n\n    // create the antenna objects and set their dimensions\n    Ptr<PhasedArrayModel> txAntenna =\n        CreateObjectWithAttributes<UniformPlanarArray>(\"NumColumns\",\n                                                       UintegerValue(2),\n                                                       \"NumRows\",\n                                                       UintegerValue(2),\n                                                       \"BearingAngle\",\n                                                       DoubleValue(-M_PI / 2));\n    Ptr<PhasedArrayModel> rxAntenna =\n        CreateObjectWithAttributes<UniformPlanarArray>(\"NumColumns\",\n                                                       UintegerValue(2),\n                                                       \"NumRows\",\n                                                       UintegerValue(2),\n                                                       \"BearingAngle\",\n                                                       DoubleValue(M_PI / 2));\n\n    Ptr<MobilityModel> txMob;\n    Ptr<MobilityModel> rxMob;\n    if (scenario == \"V2V-Urban\")\n    {\n        // 3GPP defines that the maximum speed in urban scenario is 60 km/h\n        vScatt = 60 / 3.6;\n\n        // create a grid of buildings\n        double buildingSizeX = 250 - 3.5 * 2 - 3; // m\n        double buildingSizeY = 433 - 3.5 * 2 - 3; // m\n        double streetWidth = 20;                  // m\n        double buildingHeight = 10;               // m\n        uint32_t numBuildingsX = 2;\n        uint32_t numBuildingsY = 2;\n        double maxAxisX = (buildingSizeX + streetWidth) * numBuildingsX;\n        double maxAxisY = (buildingSizeY + streetWidth) * numBuildingsY;\n\n        std::vector<Ptr<Building>> buildingVector;\n        for (uint32_t buildingIdX = 0; buildingIdX < numBuildingsX; ++buildingIdX)\n        {\n            for (uint32_t buildingIdY = 0; buildingIdY < numBuildingsY; ++buildingIdY)\n            {\n                Ptr<Building> building;\n                building = CreateObject<Building>();\n\n                building->SetBoundaries(\n                    Box(buildingIdX * (buildingSizeX + streetWidth),\n                        buildingIdX * (buildingSizeX + streetWidth) + buildingSizeX,\n                        buildingIdY * (buildingSizeY + streetWidth),\n                        buildingIdY * (buildingSizeY + streetWidth) + buildingSizeY,\n                        0.0,\n                        buildingHeight));\n                building->SetNRoomsX(1);\n                building->SetNRoomsY(1);\n                building->SetNFloors(1);\n                buildingVector.push_back(building);\n            }\n        }\n\n        // set the mobility model\n        double vTx = vScatt;\n        double vRx = vScatt / 2;\n        txMob = CreateObject<WaypointMobilityModel>();\n        rxMob = CreateObject<WaypointMobilityModel>();\n        Time nextWaypoint = Seconds(0.0);\n        txMob->GetObject<WaypointMobilityModel>()->AddWaypoint(\n            Waypoint(nextWaypoint, Vector(maxAxisX / 2 - streetWidth / 2, 1.0, 1.5)));\n        nextWaypoint += Seconds((maxAxisY - streetWidth) / 2 / vTx);\n        txMob->GetObject<WaypointMobilityModel>()->AddWaypoint(\n            Waypoint(nextWaypoint,\n                     Vector(maxAxisX / 2 - streetWidth / 2, maxAxisY / 2 - streetWidth / 2, 1.5)));\n        nextWaypoint += Seconds((maxAxisX - streetWidth) / 2 / vTx);\n        txMob->GetObject<WaypointMobilityModel>()->AddWaypoint(\n            Waypoint(nextWaypoint, Vector(0.0, maxAxisY / 2 - streetWidth / 2, 1.5)));\n        nextWaypoint = Seconds(0.0);\n        rxMob->GetObject<WaypointMobilityModel>()->AddWaypoint(\n            Waypoint(nextWaypoint, Vector(maxAxisX / 2 - streetWidth / 2, 0.0, 1.5)));\n        nextWaypoint += Seconds(maxAxisY / vRx);\n        rxMob->GetObject<WaypointMobilityModel>()->AddWaypoint(\n            Waypoint(nextWaypoint, Vector(maxAxisX / 2 - streetWidth / 2, maxAxisY, 1.5)));\n\n        nodes.Get(0)->AggregateObject(txMob);\n        nodes.Get(1)->AggregateObject(rxMob);\n\n        // create the channel condition model\n        m_condModel = CreateObject<ThreeGppV2vUrbanChannelConditionModel>();\n\n        // create the propagation loss model\n        m_propagationLossModel = CreateObject<ThreeGppV2vUrbanPropagationLossModel>();\n    }\n    else if (scenario == \"V2V-Highway\")\n    {\n        // Two vehicles are travelling one behid the other with constant velocity\n        // along the y axis. The distance between the two vehicles is 20 meters.\n\n        // 3GPP defines that the maximum speed in urban scenario is 140 km/h\n        vScatt = 140 / 3.6;\n        double vTx = vScatt;\n        double vRx = vScatt / 2;\n\n        txMob = CreateObject<ConstantVelocityMobilityModel>();\n        rxMob = CreateObject<ConstantVelocityMobilityModel>();\n        txMob->GetObject<ConstantVelocityMobilityModel>()->SetPosition(Vector(300.0, 20.0, 1.5));\n        txMob->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(0.0, vTx, 0.0));\n        rxMob->GetObject<ConstantVelocityMobilityModel>()->SetPosition(Vector(300.0, 0.0, 1.5));\n        rxMob->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(0.0, vRx, 0.0));\n\n        nodes.Get(0)->AggregateObject(txMob);\n        nodes.Get(1)->AggregateObject(rxMob);\n\n        // create the channel condition model\n        m_condModel = CreateObject<ThreeGppV2vHighwayChannelConditionModel>();\n\n        // create the propagation loss model\n        m_propagationLossModel = CreateObject<ThreeGppV2vHighwayPropagationLossModel>();\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Unknown scenario\");\n    }\n\n    m_condModel->SetAttribute(\"UpdatePeriod\", TimeValue(MilliSeconds(100)));\n\n    m_propagationLossModel->SetAttribute(\"Frequency\", DoubleValue(frequency));\n    m_propagationLossModel->SetAttribute(\"ShadowingEnabled\", BooleanValue(false));\n    m_propagationLossModel->SetAttribute(\"ChannelConditionModel\", PointerValue(m_condModel));\n\n    // create the channel model\n    Ptr<ThreeGppChannelModel> channelModel = CreateObject<ThreeGppChannelModel>();\n    channelModel->SetAttribute(\"Scenario\", StringValue(scenario));\n    channelModel->SetAttribute(\"Frequency\", DoubleValue(frequency));\n    channelModel->SetAttribute(\"ChannelConditionModel\", PointerValue(m_condModel));\n    channelModel->SetAttribute(\"vScatt\", DoubleValue(vScatt));\n\n    // create the spectrum propagation loss model\n    m_spectrumLossModel = CreateObjectWithAttributes<ThreeGppSpectrumPropagationLossModel>(\n        \"ChannelModel\",\n        PointerValue(channelModel));\n\n    BuildingsHelper::Install(nodes);\n\n    // set the beamforming vectors\n    DoBeamforming(txDev, txAntenna, rxDev);\n    DoBeamforming(rxDev, rxAntenna, txDev);\n\n    // create the tx power spectral density\n    Bands rbs;\n    double freqSubBand = frequency;\n    for (uint32_t n = 0; n < numRb; ++n)\n    {\n        BandInfo rb;\n        rb.fl = freqSubBand;\n        freqSubBand += subCarrierSpacing / 2;\n        rb.fc = freqSubBand;\n        freqSubBand += subCarrierSpacing / 2;\n        rb.fh = freqSubBand;\n        rbs.push_back(rb);\n    }\n    Ptr<SpectrumModel> spectrumModel = Create<SpectrumModel>(rbs);\n    Ptr<SpectrumValue> txPsd = Create<SpectrumValue>(spectrumModel);\n    Ptr<SpectrumSignalParameters> txParams = Create<SpectrumSignalParameters>();\n    double txPow_w = std::pow(10., (txPow_dbm - 30) / 10);\n    double txPowDens = (txPow_w / (numRb * subCarrierSpacing));\n    (*txPsd) = txPowDens;\n    txParams->psd = txPsd->Copy();\n\n    for (int i = 0; i < simTime / timeRes; i++)\n    {\n        ComputeSnrParams params{txMob, rxMob, txParams, noiseFigure, txAntenna, rxAntenna};\n        Simulator::Schedule(timeRes * i, &ComputeSnr, params);\n    }\n\n    // initialize the output file\n    std::ofstream f;\n    f.open(\"example-output.txt\", std::ios::out);\n    f << \"Time[s] TxPosX[m] TxPosY[m] RxPosX[m] RxPosY[m] ChannelState SNR[dB] Pathloss[dB]\"\n      << std::endl;\n    f.close();\n\n    // print the list of buildings to file\n    PrintGnuplottableBuildingListToFile(\"buildings.txt\");\n\n    Simulator::Run();\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nProvide code that validates NIST and YANS error rate models for EHT rates in NS-3. The program should output plots of Frame Success Rate versus Signal-to-Noise Ratio (SNR) for Nist, Yans, and Table-based error rate models, iterating over every HT MCS value. The simulation should use Gnuplot to generate visual outputs and include configurations for frame size and range of SNR values."}, {"role": "assistant", "content": "// This example is used to validate NIST and YANS error rate models for EHT rates.\n//\n// It outputs plots of the Frame Success Rate versus the Signal-to-noise ratio for\n// Nist, Yans and Table-based error rate models and for every HT MCS value.\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t frameSizeBytes = 1500;\n    std::ofstream yansfile(\"yans-frame-success-rate-be.plt\");\n    std::ofstream nistfile(\"nist-frame-success-rate-be.plt\");\n    std::ofstream tablefile(\"table-frame-success-rate-be.plt\");\n\n    const std::vector<std::string> modes{\n        \"EhtMcs0\",\n        \"EhtMcs1\",\n        \"EhtMcs2\",\n        \"EhtMcs3\",\n        \"EhtMcs4\",\n        \"EhtMcs5\",\n        \"EhtMcs6\",\n        \"EhtMcs7\",\n        \"EhtMcs8\",\n        \"EhtMcs9\",\n        \"EhtMcs10\",\n        \"EhtMcs11\",\n        \"EhtMcs12\",\n        \"EhtMcs13\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"FrameSize\", \"The frame size\", frameSizeBytes);\n    cmd.Parse(argc, argv);\n\n    Gnuplot yansplot = Gnuplot(\"yans-frame-success-rate-be.eps\");\n    Gnuplot nistplot = Gnuplot(\"nist-frame-success-rate-be.eps\");\n    Gnuplot tableplot = Gnuplot(\"table-frame-success-rate-be.eps\");\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n    WifiTxVector txVector;\n\n    uint32_t frameSizeBits = frameSizeBytes * 8;\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset yansdataset(mode);\n        Gnuplot2dDataset nistdataset(mode);\n        Gnuplot2dDataset tabledataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -5.0; snrDb <= 55.0; snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double ps = yans->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            yansdataset.Add(snrDb, ps);\n\n            ps = nist->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            nistdataset.Add(snrDb, ps);\n\n            ps = table->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            tabledataset.Add(snrDb, ps);\n        }\n\n        yansplot.AddDataset(yansdataset);\n        nistplot.AddDataset(nistdataset);\n        tableplot.AddDataset(tabledataset);\n    }\n\n    std::stringstream plotExtra;\n    plotExtra << \"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\";\n\n    const std::vector<std::string> colors{\n        \"green\",\n        \"blue\",\n        \"red\",\n        \"black\",\n        \"orange\",\n        \"purple\",\n        \"yellow\",\n        \"pink\",\n        \"grey\",\n        \"magenta\",\n        \"brown\",\n        \"turquoise\",\n        \"olive\",\n        \"beige\",\n    };\n\n    NS_ASSERT_MSG(colors.size() == modes.size(), \"Colors and modes vectors have different sizes\");\n\n    for (std::size_t i = 0; i < modes.size(); i++)\n    {\n        plotExtra << \"set style line \" << (i + 1) << \" linewidth 5 linecolor rgb \\\"\" << colors[i]\n                  << \"\\\" \\n\";\n    }\n    plotExtra << \"set style increment user\";\n\n    yansplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    yansplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    yansplot.SetExtra(plotExtra.str());\n    yansplot.GenerateOutput(yansfile);\n    yansfile.close();\n\n    nistplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    nistplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    nistplot.SetExtra(plotExtra.str());\n    nistplot.GenerateOutput(nistfile);\n    nistfile.close();\n\n    tableplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    tableplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    tableplot.SetExtra(plotExtra.str());\n    tableplot.GenerateOutput(tablefile);\n    tablefile.close();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library that simulates a simple IPv6 network topology with three nodes: two end nodes (n0 and n1) connected via a router (r). Configure CSMA channels between the nodes with specified data rate and delay. Install an IPv6 Internet stack on all nodes and assign IPv6 addresses with appropriate forwarding and default routes. Create a UDP echo client-server application where n0 sends fragmented packets to n1 through the router. Enable logging for key components, and save traces of queue and packet reception events to a file named 'fragmentation-ipv6.tr'. Additionally, capture packet traces using pcap."}, {"role": "assistant", "content": "// Network topology\n// //\n// //             n0   r    n1\n// //             |    _    |\n// //             ====|_|====\n// //                router\n// //\n// // - Tracing of queues and packet receptions to file \"fragmentation-ipv6.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"FragmentationIpv6Example\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_ALL);\n    }\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> n0 = CreateObject<Node>();\n    Ptr<Node> r = CreateObject<Node>();\n    Ptr<Node> n1 = CreateObject<Node>();\n\n    NodeContainer net1(n0, r);\n    NodeContainer net2(r, n1);\n    NodeContainer all(n0, r, n1);\n\n    NS_LOG_INFO(\"Create IPv6 Internet Stack\");\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d1 = csma.Install(net1);\n    NetDeviceContainer d2 = csma.Install(net2);\n\n    NS_LOG_INFO(\"Create networks and assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i1 = ipv6.Assign(d1);\n    i1.SetForwarding(1, true);\n    i1.SetDefaultRouteInAllNodes(1);\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i2 = ipv6.Assign(d2);\n    i2.SetForwarding(0, true);\n    i2.SetDefaultRouteInAllNodes(0);\n\n    Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);\n    Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(0), n0, routingStream);\n\n    /* Create a UdpEchoClient and UdpEchoServer application to send packets from n0 to n1 via r */\n    uint32_t packetSize = 4096;\n    uint32_t maxPacketCount = 5;\n\n    UdpEchoClientHelper echoClient(i2.GetAddress(1, 1), 42);\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    ApplicationContainer clientApps = echoClient.Install(net1.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(20.0));\n\n    UdpEchoServerHelper echoServer(42);\n    ApplicationContainer serverApps = echoServer.Install(net2.Get(1));\n    serverApps.Start(Seconds(0.0));\n    serverApps.Stop(Seconds(30.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"fragmentation-ipv6.tr\"));\n    csma.EnablePcapAll(std::string(\"fragmentation-ipv6\"), true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation with a star topology consisting of five nodes. The central node acts as a hub that connects to four peripheral nodes through point-to-point links, each with a data rate of 10 Mbps and a delay of 1 ms. Install a UDP echo server on the central node and configure UDP echo clients on each of the peripheral nodes to send packets to the central node. Collect metrics using FlowMonitor, including packet delivery ratio, delay, and throughput, and log them. Additionally, enable pcap tracing for analysis and simulate for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"StarTopologyExample\");\n\nint main (int argc, char *argv[])\n{\n    // Set up the nodes\n    NodeContainer centralNode;\n    centralNode.Create(1);\n\n    NodeContainer peripheralNodes;\n    peripheralNodes.Create(4);\n\n    // Install point-to-point links\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    NetDeviceContainer devices[4];\n    for (int i = 0; i < 4; ++i)\n    {\n        devices[i] = pointToPoint.Install(centralNode.Get(0), peripheralNodes.Get(i));\n    }\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(centralNode);\n    stack.Install(peripheralNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfaces[4];\n    for (int i = 0; i < 4; ++i)\n    {\n        std::ostringstream subnet;\n        subnet << \"10.1.\" << i+1 << \".0\";\n        address.SetBase(subnet.str().c_str(), \"255.255.255.0\");\n        interfaces[i] = address.Assign(devices[i]);\n    }\n\n    // UDP Echo Server on the central node\n    uint16_t port = 9; // UDP Echo server port\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApps = echoServer.Install(centralNode.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // UDP Echo Clients on peripheral nodes\n    ApplicationContainer clientApps[4];\n    for (int i = 0; i < 4; ++i)\n    {\n        UdpEchoClientHelper echoClient(interfaces[i].GetAddress(1), port);\n        echoClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n        echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n        echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n        clientApps[i] = echoClient.Install(peripheralNodes.Get(i));\n        clientApps[i].Start(Seconds(2.0));\n        clientApps[i].Stop(Seconds(10.0));\n    }\n\n    // Enable packet tracing\n    pointToPoint.EnablePcapAll(\"star_topology\");\n\n    // Set up FlowMonitor for performance metrics\n    FlowMonitorHelper flowMonitorHelper;\n    Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // FlowMonitor statistics\n    flowMonitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitorHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n\n    for (auto it = stats.begin(); it != stats.end(); ++it)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(it->first);\n        std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n        std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n        std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n        std::cout << \"  Throughput: \" << it->second.rxBytes * 8.0 / 10.0 / 1000 / 1000 << \" Mbps\" << std::endl;\n        std::cout << \"  End-to-End Delay: \" << it->second.delaySum.GetSeconds() << \" seconds\" << std::endl;\n    }\n\n    // Clean up and exit\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a point-to-point network in NS-3 where Node A acts as a TCP server and Node B acts as a TCP client. Node A and Node B are connected via a point-to-point link. Enable pcap and ASCII tracing to monitor the packet exchanges. Measure the throughput and ensure that the TCP traffic flows over the link without errors. Configure a delay of 2ms and a data rate of 5 Mbps for the point-to-point link."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpPointToPointExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set default parameters for simulation\n    Time::SetResolution(Time::NS);\n\n    // Create 2 nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point connection between the nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack (TCP/IP protocols)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP server (Packet Sink) on Node 1 (server)\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(interfaces.GetAddress(1), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = packetSinkHelper.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client (OnOff application) on Node 0 (client)\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientHelper.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"5Mbps\")));\n    clientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = clientHelper.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable packet tracing\n    pointToPoint.EnablePcapAll(\"tcp-point-to-point\");\n    AsciiTraceHelper ascii;\n    pointToPoint.EnableAsciiAll(ascii.CreateFileStream(\"tcp-point-to-point.tr\"));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ code that uses the ns-3 network simulator to demonstrate the use of TrafficControlHelper for installing a RedQueueDisc on a point-to-point link between two nodes. The simulation should track and print statistics about the queue lengths at the traffic control and device layers, as well as the sojourn time of packets. Additionally, configure TCP as the transport protocol, simulate packet transmission, and report flow statistics such as throughput, mean delay, and jitter using FlowMonitor."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n// This simple example shows how to use TrafficControlHelper to install a\n// QueueDisc on a device.\n//\n// The default QueueDisc is a pfifo_fast with a capacity of 1000 packets (as in\n// Linux). However, in this example, we install a RedQueueDisc with a capacity\n// of 10000 packets.\n//\n// Network topology\n//\n//       10.1.1.0\n// n0 -------------- n1\n//    point-to-point\n//\n// The output will consist of all the traced changes in the length of the RED\n// internal queue and in the length of the netdevice queue:\n//\n//    DevicePacketsInQueue 0 to 1\n//    TcPacketsInQueue 7 to 8\n//    TcPacketsInQueue 8 to 9\n//    DevicePacketsInQueue 1 to 0\n//    TcPacketsInQueue 9 to 8\n//\n// plus some statistics collected at the network layer (by the flow monitor)\n// and the application layer. Finally, the number of packets dropped by the\n// queuing discipline, the number of packets dropped by the netdevice and\n// the number of packets requeued by the queuing discipline are reported.\n//\n// If the size of the DropTail queue of the netdevice were increased from 1\n// to a large number (e.g. 1000), one would observe that the number of dropped\n// packets goes to zero, but the latency grows in an uncontrolled manner. This\n// is the so-called bufferbloat problem, and illustrates the importance of\n// having a small device queue, so that the standing queues build in the traffic\n// control layer where they can be managed by advanced queue discs rather than\n// in the device layer.\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TrafficControlExample\");\n\n/**\n * Number of packets in TX queue trace.\n *\n * \\param oldValue Old velue.\n * \\param newValue New value.\n */\nvoid\nTcPacketsInQueueTrace(uint32_t oldValue, uint32_t newValue)\n{\n    std::cout << \"TcPacketsInQueue \" << oldValue << \" to \" << newValue << std::endl;\n}\n\n/**\n * Packets in the device queue trace.\n *\n * \\param oldValue Old velue.\n * \\param newValue New value.\n */\nvoid\nDevicePacketsInQueueTrace(uint32_t oldValue, uint32_t newValue)\n{\n    std::cout << \"DevicePacketsInQueue \" << oldValue << \" to \" << newValue << std::endl;\n}\n\n/**\n * TC Soujoun time trace.\n *\n * \\param sojournTime The soujourn time.\n */\nvoid\nSojournTimeTrace(Time sojournTime)\n{\n    std::cout << \"Sojourn time \" << sojournTime.ToDouble(Time::MS) << \"ms\" << std::endl;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double simulationTime = 10; // seconds\n    std::string transportProt = \"Tcp\";\n    std::string socketType;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"transportProt\", \"Transport protocol to use: Tcp, Udp\", transportProt);\n    cmd.Parse(argc, argv);\n\n    if (transportProt == \"Tcp\")\n    {\n        socketType = \"ns3::TcpSocketFactory\";\n    }\n    else\n    {\n        socketType = \"ns3::UdpSocketFactory\";\n    }\n\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    pointToPoint.SetQueue(\"ns3::DropTailQueue\", \"MaxSize\", StringValue(\"1p\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    TrafficControlHelper tch;\n    tch.SetRootQueueDisc(\"ns3::RedQueueDisc\");\n    QueueDiscContainer qdiscs = tch.Install(devices);\n\n    Ptr<QueueDisc> q = qdiscs.Get(1);\n    q->TraceConnectWithoutContext(\"PacketsInQueue\", MakeCallback(&TcPacketsInQueueTrace));\n    Config::ConnectWithoutContext(\n        \"/NodeList/1/$ns3::TrafficControlLayer/RootQueueDiscList/0/SojournTime\",\n        MakeCallback(&SojournTimeTrace));\n\n    Ptr<NetDevice> nd = devices.Get(1);\n    Ptr<PointToPointNetDevice> ptpnd = DynamicCast<PointToPointNetDevice>(nd);\n    Ptr<Queue<Packet>> queue = ptpnd->GetQueue();\n    queue->TraceConnectWithoutContext(\"PacketsInQueue\", MakeCallback(&DevicePacketsInQueueTrace));\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Flow\n    uint16_t port = 7;\n    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(socketType, localAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(0));\n\n    sinkApp.Start(Seconds(0.0));\n    sinkApp.Stop(Seconds(simulationTime + 0.1));\n\n    uint32_t payloadSize = 1448;\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n\n    OnOffHelper onoff(socketType, Ipv4Address::GetAny());\n    onoff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onoff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n    onoff.SetAttribute(\"DataRate\", StringValue(\"50Mbps\")); // bit/s\n    ApplicationContainer apps;\n\n    InetSocketAddress rmt(interfaces.GetAddress(0), port);\n    onoff.SetAttribute(\"Remote\", AddressValue(rmt));\n    onoff.SetAttribute(\"Tos\", UintegerValue(0xb8));\n    apps.Add(onoff.Install(nodes.Get(1)));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(simulationTime + 0.1));\n\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    Simulator::Stop(Seconds(simulationTime + 5));\n    Simulator::Run();\n\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    std::cout << std::endl << \"*** Flow monitor statistics ***\" << std::endl;\n    std::cout << \"  Tx Packets/Bytes:   \" << stats[1].txPackets << \" / \" << stats[1].txBytes\n              << std::endl;\n    std::cout << \"  Offered Load: \"\n              << stats[1].txBytes * 8.0 /\n                     (stats[1].timeLastTxPacket.GetSeconds() -\n                      stats[1].timeFirstTxPacket.GetSeconds()) /\n                     1000000\n              << \" Mbps\" << std::endl;\n    std::cout << \"  Rx Packets/Bytes:   \" << stats[1].rxPackets << \" / \" << stats[1].rxBytes\n              << std::endl;\n    uint32_t packetsDroppedByQueueDisc = 0;\n    uint64_t bytesDroppedByQueueDisc = 0;\n    if (stats[1].packetsDropped.size() > Ipv4FlowProbe::DROP_QUEUE_DISC)\n    {\n        packetsDroppedByQueueDisc = stats[1].packetsDropped[Ipv4FlowProbe::DROP_QUEUE_DISC];\n        bytesDroppedByQueueDisc = stats[1].bytesDropped[Ipv4FlowProbe::DROP_QUEUE_DISC];\n    }\n    std::cout << \"  Packets/Bytes Dropped by Queue Disc:   \" << packetsDroppedByQueueDisc << \" / \"\n              << bytesDroppedByQueueDisc << std::endl;\n    uint32_t packetsDroppedByNetDevice = 0;\n    uint64_t bytesDroppedByNetDevice = 0;\n    if (stats[1].packetsDropped.size() > Ipv4FlowProbe::DROP_QUEUE)\n    {\n        packetsDroppedByNetDevice = stats[1].packetsDropped[Ipv4FlowProbe::DROP_QUEUE];\n        bytesDroppedByNetDevice = stats[1].bytesDropped[Ipv4FlowProbe::DROP_QUEUE];\n    }\n    std::cout << \"  Packets/Bytes Dropped by NetDevice:   \" << packetsDroppedByNetDevice << \" / \"\n              << bytesDroppedByNetDevice << std::endl;\n    std::cout << \"  Throughput: \"\n              << stats[1].rxBytes * 8.0 /\n                     (stats[1].timeLastRxPacket.GetSeconds() -\n                      stats[1].timeFirstRxPacket.GetSeconds()) /\n                     1000000\n              << \" Mbps\" << std::endl;\n    std::cout << \"  Mean delay:   \" << stats[1].delaySum.GetSeconds() / stats[1].rxPackets\n              << std::endl;\n    std::cout << \"  Mean jitter:   \" << stats[1].jitterSum.GetSeconds() / (stats[1].rxPackets - 1)\n              << std::endl;\n    auto dscpVec = classifier->GetDscpCounts(1);\n    for (auto p : dscpVec)\n    {\n        std::cout << \"  DSCP value:   0x\" << std::hex << static_cast<uint32_t>(p.first) << std::dec\n                  << \"  count:   \" << p.second << std::endl;\n    }\n\n    Simulator::Destroy();\n\n    std::cout << std::endl << \"*** Application statistics ***\" << std::endl;\n    double thr = 0;\n    uint64_t totalPacketsThr = DynamicCast<PacketSink>(sinkApp.Get(0))->GetTotalRx();\n    thr = totalPacketsThr * 8 / (simulationTime * 1000000.0); // Mbit/s\n    std::cout << \"  Rx Bytes: \" << totalPacketsThr << std::endl;\n    std::cout << \"  Average Goodput: \" << thr << \" Mbit/s\" << std::endl;\n    std::cout << std::endl << \"*** TC Layer statistics ***\" << std::endl;\n    std::cout << q->GetStats() << std::endl;\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a network of three nodes is connected using a CSMA (Ethernet) network. One node acts as a UDP client, another as a UDP server, and the third acts as a passive relay node (forwarding traffic). The client sends data to the server via the relay node. The server logs the received packets"}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CsmaUdpRelayExample\");\n\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a UDP packet!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"CsmaUdpRelayExample\", LOG_LEVEL_INFO);\n\n    uint16_t port = 4000;\n\n    // Create nodes (client, relay, server)\n    NodeContainer nodes;\n    nodes.Create(3);\n    Ptr<Node> client = nodes.Get(0);\n    Ptr<Node> relay = nodes.Get(1);\n    Ptr<Node> server = nodes.Get(2);\n\n    // Setup CSMA network\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices = csma.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Setup UDP Server (Server Node)\n    Ptr<Socket> serverSocket = Socket::CreateSocket(server, UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client (Client Node)\n    Ptr<Socket> clientSocket = Socket::CreateSocket(client, UdpSocketFactory::GetTypeId());\n    InetSocketAddress serverAddress(interfaces.GetAddress(2), port);\n\n    // Send packets at scheduled times\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, clientSocket, Create<Packet>(128), 0, serverAddress);\n    Simulator::Schedule(Seconds(2.0), &Socket::SendTo, clientSocket, Create<Packet>(128), 0, serverAddress);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(3.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a VANET (Vehicular Ad-hoc Network) scenario using ns-3 with two vehicles communicating using DSRC/WAVE (Dedicated Short-Range Communication). Configure the vehicles to move along a straight path with constant speeds, exchange packets over UDP, and visualize the simulation using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/wave-helper.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"VANETExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time in seconds\n    double simulationTime = 10.0;\n    \n    // Create 2 nodes representing vehicles\n    NodeContainer vehicles;\n    vehicles.Create(2);\n\n    // Set up WAVE (802.11p) PHY and MAC for VANET\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    NqosWaveMacHelper wifiMac = NqosWaveMacHelper::Default();\n    Wifi80211pHelper waveHelper = Wifi80211pHelper::Default();\n    NetDeviceContainer devices = waveHelper.Install(wifiPhy, wifiMac, vehicles);\n\n    // Set mobility model for the vehicles\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(vehicles);\n\n    // Set initial positions and constant speeds for vehicles\n    Ptr<ConstantVelocityMobilityModel> mobility1 = vehicles.Get(0)->GetObject<ConstantVelocityMobilityModel>();\n    mobility1->SetPosition(Vector(0.0, 0.0, 0.0));\n    mobility1->SetVelocity(Vector(20.0, 0.0, 0.0)); // Vehicle 1 moves at 20 m/s\n\n    Ptr<ConstantVelocityMobilityModel> mobility2 = vehicles.Get(1)->GetObject<ConstantVelocityMobilityModel>();\n    mobility2->SetPosition(Vector(100.0, 0.0, 0.0));\n    mobility2->SetVelocity(Vector(20.0, 0.0, 0.0)); // Vehicle 2 moves at 20 m/s\n\n    // Install Internet stack on vehicles\n    InternetStackHelper internet;\n    internet.Install(vehicles);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Install UDP server on vehicle 1\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(vehicles.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Install UDP client on vehicle 2, sending packets to vehicle 1\n    UdpClientHelper udpClient(interfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(vehicles.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Set up NetAnim\n    AnimationInterface anim(\"vanet_netanim.xml\");\n\n    // Set positions for visualization in NetAnim\n    anim.SetConstantPosition(vehicles.Get(0), 0.0, 0.0);  // Vehicle 1\n    anim.SetConstantPosition(vehicles.Get(1), 100.0, 0.0); // Vehicle 2\n\n    // Enable packet metadata for NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library to simulate a simple network topology with four nodes connected via a CSMA LAN. The program should establish a UDP echo server on node 1 and a UDP echo client on node 0, which sends datagrams to node 1 and receives responses. Set DropTail queues for the LAN and configure tracing of queue and packet reception events. The simulation should run in real-time mode, log tracing information to a file named \"udp-echo.tr\", and also generate pcap traces."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1   n2   n3\n//       |     |    |    |\n//       =================\n//              LAN\n//\n// - UDP flows from n0 to n1 and back\n// - DropTail queues\n// - Tracing of queues and packet receptions to file \"udp-echo.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RealtimeUdpEchoExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    //\n    // Allow the user to override any of the defaults and the above Bind() at\n    // run-time, via command-line arguments\n    //\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    //\n    // But since this is a realtime script, don't allow the user to mess with\n    // that.\n    //\n    GlobalValue::Bind(\"SimulatorImplementationType\", StringValue(\"ns3::RealtimeSimulatorImpl\"));\n\n    //\n    // Explicitly create the nodes required by the topology (shown above).\n    //\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer n;\n    n.Create(4);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    //\n    // Explicitly create the channels required by the topology (shown above).\n    //\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    //\n    // We've got the \"hardware\" in place.  Now we need to add IP addresses.\n    //\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(d);\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    //\n    // Create a UdpEchoServer application on node one.\n    //\n    uint16_t port = 9; // well-known echo port number\n    UdpEchoServerHelper server(port);\n    ApplicationContainer apps = server.Install(n.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    //\n    // Create a UdpEchoClient application to send UDP datagrams from node zero to\n    // node one.\n    //\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 500;\n    Time interPacketInterval = Seconds(0.01);\n    UdpEchoClientHelper client(i.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n    apps = client.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"realtime-udp-echo.tr\"));\n    csma.EnablePcapAll(\"realtime-udp-echo\", false);\n\n    //\n    // Now, do the actual simulation.\n    //\n    Simulator::Stop(Seconds(11.0));\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where multiple client nodes communicate with a single server using TCP over a shared Wi-Fi network. Each client should send a small amount of data to the server, which logs the reception. Keep the setup simple with basic Wi-Fi configuration and minimal mobility."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpWifiExample\");\n\nint main() {\n    LogComponentEnable(\"TcpWifiExample\", LOG_LEVEL_INFO);\n\n    int numClients = 3;\n    uint16_t port = 5000;\n\n    // Create nodes (clients + 1 server)\n    NodeContainer wifiNodes;\n    wifiNodes.Create(numClients + 1);\n\n    NodeContainer serverNode = wifiNodes.Get(numClients); // Last node is the server\n\n    // Set up Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"tcp-wifi-network\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer clientDevices = wifi.Install(phy, mac, wifiNodes.Get(0, numClients));\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer serverDevice = wifi.Install(phy, mac, serverNode);\n\n    // Mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(clientDevices);\n    Ipv4InterfaceContainer serverInterface = address.Assign(serverDevice);\n\n    // Setup TCP Server\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = sink.Install(serverNode);\n    serverApp.Start(Seconds(0.0));\n    serverApp.Stop(Seconds(5.0));\n\n    // Setup TCP Clients\n    for (int i = 0; i < numClients; i++) {\n        OnOffHelper client(\"ns3::TcpSocketFactory\", InetSocketAddress(serverInterface.GetAddress(0), port));\n        client.SetConstantRate(DataRate(\"1Mbps\"), 512); // Send 512-byte packets\n        ApplicationContainer clientApp = client.Install(wifiNodes.Get(i));\n        clientApp.Start(Seconds(1.0 + i));\n        clientApp.Stop(Seconds(5.0));\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(5.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 to simulate a small network running Link State Routing. Create a topology of four routers connected by point-to-point links, where OSPF (Open Shortest Path First) is used to simulate Link State Routing. The program should allow dynamic route discovery using the OSPF protocol, include traffic generation from one end of the network to another, and generate pcap tracing files to observe routing behavior and data traffic."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/ospf-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LinkStateRoutingExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Command-line options\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Step 1: Create 4 routers\n    NodeContainer routers;\n    routers.Create(4);\n\n    // Step 2: Create point-to-point links between routers\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create the links between the routers\n    NetDeviceContainer link1 = p2p.Install(routers.Get(0), routers.Get(1)); // Link between router 0 and 1\n    NetDeviceContainer link2 = p2p.Install(routers.Get(1), routers.Get(2)); // Link between router 1 and 2\n    NetDeviceContainer link3 = p2p.Install(routers.Get(2), routers.Get(3)); // Link between router 2 and 3\n    NetDeviceContainer link4 = p2p.Install(routers.Get(0), routers.Get(3)); // Link between router 0 and 3\n\n    // Step 3: Install internet stacks with OSPF (Link State Routing) on the routers\n    OspfHelper ospfRouting;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(ospfRouting);\n    internet.Install(routers);\n\n    // Step 4: Assign IP addresses to the links\n    Ipv4AddressHelper ipv4;\n\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1 = ipv4.Assign(link1);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i2 = ipv4.Assign(link2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i3 = ipv4.Assign(link3);\n\n    ipv4.SetBase(\"10.1.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i4 = ipv4.Assign(link4);\n\n    // Step 5: Enable OSPF (Link State Routing) on all routers\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Step 6: Create a UDP echo server on router 3\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(routers.Get(3)); // Server on router 3\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Step 7: Create a UDP echo client on router 0\n    UdpEchoClientHelper echoClient(i3.GetAddress(1), 9); // Send to router 3 IP\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(routers.Get(0)); // Client on router 0\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Step 8: Enable tracing (pcap files)\n    p2p.EnablePcapAll(\"ospf-linkstate\");\n\n    // Step 9: Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a client communicates with a server using a raw UDP socket. The client should send packets to the server at regular intervals, and the server should log the received packets. Set up a simple point-to-point network with an IP address configuration. Implement custom UDP socket applications for both client and server instead of using NS-3’s built-in UdpEchoClient and UdpEchoServer. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpSocketExample\");\n\n// Server function to receive packets\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a packet!\");\n    }\n}\n\n// Client function to send packets\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address dstAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(1024); // 1024-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(dstAddr, port));\n    Simulator::Schedule(Seconds(1.0), &SendPacket, socket, dstAddr, port); // Schedule next packet\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpSocketExample\", LOG_LEVEL_INFO);\n\n    // Create nodes (Client and Server)\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    uint16_t port = 8080; // UDP port\n\n    // Setup UDP Server\n    Ptr<Socket> serverSocket = Socket::CreateSocket(nodes.Get(1), UdpSocketFactory::GetTypeId());\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), port);\n    serverSocket->Bind(local);\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client\n    Ptr<Socket> clientSocket = Socket::CreateSocket(nodes.Get(0), UdpSocketFactory::GetTypeId());\n    Simulator::Schedule(Seconds(2.0), &SendPacket, clientSocket, interfaces.GetAddress(1), port);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Wi-Fi network with two nodes. One node acts as a HTTP server on port 80, and the other node acts as a HTTP client. The client requests a web page from the server. The nodes are stationary and have static positions in a grid layout with a 5m x 5m grid. The Wi-Fi channel is based on the 802.11b standard. The simulation runs for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-routing-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleWiFiExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Wi-Fi devices (STA and AP)\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_PHY_STANDARD_80211b);\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns-3-wifi\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices = wifiHelper.Install(wifiPhy, wifiMac, nodes);\n\n    // Set up internet stack (IP, TCP, etc.)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfaces = ipv4.Assign(devices);\n\n    // Set up HTTP server on node 1\n    uint16_t port = 80;\n    HttpServerHelper httpServer(port);\n    ApplicationContainer serverApp = httpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up HTTP client on node 0\n    HttpClientHelper httpClient(ipInterfaces.GetAddress(1), port);\n    ApplicationContainer clientApp = httpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up mobility model for nodes (static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\n\"Generate a simple NS-3 C++ simulation script that sets up a basic point-to-point network with two nodes. The connection should have a bandwidth of 5 Mbps and a delay of 2 ms. Configure the nodes with an IPv4 address range of 192.168.1.0/24. One node should run a UDP echo server on port 9, while the other node should send a single packet of 1024 bytes to the server. The simulation should run for 10 seconds.\""}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a four-node wired LAN network using the CSMA protocol. The nodes should be connected via a CSMA switch with a data rate of 100 Mbps and a propagation delay of 6.56 microseconds. Each node should have a unique IPv4 address in the 192.168.1.0/24 subnet. The last node should run a UDP echo server on port 9, while the first node should act as a client sending ten packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create four nodes\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Configure CSMA network\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install CSMA devices on nodes\n    NetDeviceContainer devices;\n    devices = csma.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP echo server on the last node\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(3));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP echo client on the first node\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(3), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a basic wired network using ns-3, where three nodes are connected in a simple point-to-point (P2P) topology. The first node sends TCP traffic to the third node, while the second node acts as a router forwarding packets between them. Implement packet tracing to log the number of transmitted and received packets on each node. Capture and analyze the packets in a pcap file for deeper analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"P2PNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Log level settings\n    LogComponentEnable(\"P2PNetworkExample\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Create point-to-point links between nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install the P2P devices and channels between node0-node1 and node1-node2\n    NetDeviceContainer devices0 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));\n    NetDeviceContainer devices1 = pointToPoint.Install(nodes.Get(1), nodes.Get(2));\n\n    // Install the internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces0 = address.Assign(devices0);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces1 = address.Assign(devices1);\n\n    // Enable routing on the middle node (node1)\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create a TCP server on node2 to receive traffic\n    uint16_t port = 9;\n    Address serverAddress(InetSocketAddress(interfaces1.GetAddress(1), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(2));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Create a TCP client on node0 to send traffic to node2\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", Address());\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientHelper.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    clientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps;\n    clientHelper.SetAttribute(\"Remote\", AddressValue(serverAddress));\n    clientApps.Add(clientHelper.Install(nodes.Get(0)));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable packet tracing (pcap)\n    pointToPoint.EnablePcapAll(\"p2p-network\");\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Output received packets\n    Ptr<PacketSink> sink1 = DynamicCast<PacketSink>(sinkApp.Get(0));\n    NS_LOG_INFO(\"Total Packets Received by Node 2: \" << sink1->GetTotalRx());\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ simulation using ns-3 to simulate a tree topology with 4 nodes. In this configuration, one root node connects to two child nodes, and one of the child nodes connects to a leaf node. Use point-to-point links with a data rate of 5Mbps and a delay of 2ms. Install the Internet stack, assign IP addresses, and simulate packet transmission from the leaf node to the root node. Use logging to track packet transmissions."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TreeTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"TreeTopologyExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer rootNode;\n    rootNode.Create(1);\n    \n    NodeContainer childNodes;\n    childNodes.Create(2);\n\n    NodeContainer leafNode;\n    leafNode.Create(1);\n\n    // Create a point-to-point link helper\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices and set up point-to-point links\n    NetDeviceContainer devicesRootToChild1, devicesRootToChild2, devicesChildToLeaf;\n\n    // Link from root to child 1\n    devicesRootToChild1 = pointToPoint.Install(rootNode.Get(0), childNodes.Get(0));\n\n    // Link from root to child 2\n    devicesRootToChild2 = pointToPoint.Install(rootNode.Get(0), childNodes.Get(1));\n\n    // Link from child 1 to leaf node\n    devicesChildToLeaf = pointToPoint.Install(childNodes.Get(0), leafNode.Get(0));\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(rootNode);\n    stack.Install(childNodes);\n    stack.Install(leafNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfacesRootToChild1, interfacesRootToChild2, interfacesChildToLeaf;\n\n    // IP addresses for the root to child 1 link\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    interfacesRootToChild1 = address.Assign(devicesRootToChild1);\n\n    // IP addresses for the root to child 2 link\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    interfacesRootToChild2 = address.Assign(devicesRootToChild2);\n\n    // IP addresses for the child 1 to leaf link\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    interfacesChildToLeaf = address.Assign(devicesChildToLeaf);\n\n    // Application: Sending packets from the leaf node to the root node\n    uint16_t port = 9; // Port for communication\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(interfacesRootToChild1.GetAddress(0), port));\n    onoff.SetConstantRate(DataRate(\"1Mbps\"), 1024); // 1Mbps data rate, 1024-byte packets\n    ApplicationContainer app = onoff.Install(leafNode.Get(0)); // Install on the leaf node\n    app.Start(Seconds(1.0)); // Start at 1 second\n    app.Stop(Seconds(10.0)); // Stop at 10 seconds\n\n    // Set up a PacketSink on the root node to receive packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sink.Install(rootNode.Get(0)); // Install sink on the root node\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Enable routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a wireless network with UDP communication between a sender (STA) and a receiver (AP). The sender sends 10 UDP packets (each 1024 bytes) to the receiver on port 9. The sender moves randomly within a 100x100 m² area using a random walk mobility model, while the receiver is stationary. Use the Wi-Fi 802.11n 5GHz standard, with IP addressing in the 10.1.1.0/24 range."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the sender (STA) and receiver (AP)\n    NodeContainer wifiStaNode, wifiApNode;\n    wifiStaNode.Create(1); // Sender (STA)\n    wifiApNode.Create(1);  // Receiver (AP)\n\n    // Install Wi-Fi devices on both the sender and receiver\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n\n    WifiMacHelper mac;\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-ssid\")));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNode);\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-ssid\")));\n    NetDeviceContainer apDevices = wifi.Install(phy, mac, wifiApNode);\n\n    // Set up the mobility model for the sender\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(wifiStaNode); // Install mobility on the sender node\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode); // Install stationary receiver\n\n    // Install the internet stack (UDP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(wifiStaNode);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterfaces = address.Assign(apDevices);\n\n    // Set up UDP server on the receiver (AP)\n    UdpServerHelper udpServer(9); // Listening on port 9\n    ApplicationContainer serverApp = udpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the sender (STA)\n    UdpClientHelper udpClient(apInterfaces.GetAddress(0), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // Send 10 packets\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // 1-second interval\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // 1024 byte packets\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Mobile Ad Hoc Network (MANET) with two nodes. The nodes communicate via UDP: one node acts as a server on port 9, and the other node acts as a client. The client sends 1,000 UDP packets of 1024 bytes each with an interval of 0.01 seconds. The nodes are configured with random waypoint mobility and move within a 100m x 100m area at a constant speed of 20 m/s. The simulation runs for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-routing-helper.h\"\n#include \"ns3/olsr-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleManetExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleManetExample\", LOG_LEVEL_INFO);\n\n    // Create mobile nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Wi-Fi devices (STA and AP)\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_PHY_STANDARD_80211b);\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns-3-manet\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices = wifiHelper.Install(wifiPhy, wifiMac, nodes);\n\n    // Set up internet stack (IP, UDP, etc.)\n    InternetStackHelper stack;\n    OlsrHelper olsr;\n    stack.SetRoutingHelper(olsr);\n    stack.Install(nodes);\n\n    // Assign IP addresses to nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on node 1\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on node 0\n    UdpClientHelper udpClient(ipInterfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up random waypoint mobility model\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"MinX\", DoubleValue(0.0),\n                              \"MaxX\", DoubleValue(100.0),\n                              \"MinY\", DoubleValue(0.0),\n                              \"MaxY\", DoubleValue(100.0),\n                              \"Speed\", StringValue(\"ns3::ConstantRandomVariable[Constant=20.0]\"));\n    mobility.Install(nodes);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation of a wired network using a Point-to-Point (P2P) connection between two nodes. The simulation should involve the TCP NewReno congestion control algorithm and use a BulkSendApplication to generate large data transfers. Visualize the traffic using NetAnim and display packet exchanges between the nodes."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpNewRenoExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set TCP NewReno as the default congestion control algorithm\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\", StringValue(\"ns3::TcpNewReno\"));\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP sink at node 1 (server)\n    uint16_t port = 9;\n    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", localAddress);\n    ApplicationContainer sinkApp = sink.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(0.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Create a BulkSendApplication at node 0 (client) to send large amounts of data\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    source.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n    ApplicationContainer sourceApp = source.Install(nodes.Get(0));\n    sourceApp.Start(Seconds(1.0));\n    sourceApp.Stop(Seconds(10.0));\n\n    // Set up NetAnim for visualization\n    AnimationInterface anim(\"tcp_newreno_netanim.xml\");\n\n    // Assign positions to the nodes in NetAnim\n    anim.SetConstantPosition(nodes.Get(0), 1.0, 2.0);  // Node 0 (client)\n    anim.SetConstantPosition(nodes.Get(1), 5.0, 2.0);  // Node 1 (server)\n\n    // Enable packet metadata in NetAnim for visualization\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 to simulate a line topology with 4 nodes. Node 0 connects to node 1, node 1 connects to node 2, and node 2 connects to node 3 via point-to-point links. Configure UDP traffic where node 0 sends traffic to node 3 through nodes 1 and 2. Assign IP addresses to each network segment, and enable PCAP tracing to capture traffic. The simulation should run for 10 seconds"}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LineTopology4Nodes\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"LineTopology4Nodes\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes: node 0, node 1, node 2, and node 3\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Set up point-to-point links between consecutive nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install point-to-point links between the nodes\n    NetDeviceContainer device01, device12, device23;\n    device01 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));  // Link between node 0 and node 1\n    device12 = pointToPoint.Install(nodes.Get(1), nodes.Get(2));  // Link between node 1 and node 2\n    device23 = pointToPoint.Install(nodes.Get(2), nodes.Get(3));  // Link between node 2 and node 3\n\n    // Install internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces01 = address.Assign(device01);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces12 = address.Assign(device12);\n\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces23 = address.Assign(device23);\n\n    // Set up a UDP Echo server on node 3\n    UdpEchoServerHelper echoServer(9);  // Port number\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(3));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 0 to send packets to node 3\n    UdpEchoClientHelper echoClient(interfaces23.GetAddress(1), 9);  // Address of node 3\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));  // Client on node 0\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing to capture packet transmissions\n    pointToPoint.EnablePcapAll(\"line-topology-4-nodes\");\n\n    // Run the simulation\n    Simulator::Run();\n\n    // End the simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a Wi-Fi client sends UDP packets to a Wi-Fi access point (AP). The AP acts as a server and logs the received packets. Keep the setup minimal, with one client and one AP using the default 802.11n standard."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpClientServer\");\n\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"AP received a UDP packet!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"WifiUdpClientServer\", LOG_LEVEL_INFO);\n\n    uint16_t port = 5000;\n\n    // Create nodes (client and access point)\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n    Ptr<Node> client = wifiNodes.Get(0);\n    Ptr<Node> ap = wifiNodes.Get(1);\n\n    // Set up Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"wifi-network\");\n\n    // Configure AP\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(wifiPhy, wifiMac, ap);\n\n    // Configure Client\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer clientDevice = wifi.Install(wifiPhy, wifiMac, client);\n\n    // Mobility (static positions)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(NetDeviceContainer(clientDevice, apDevice));\n\n    // Setup UDP Server (AP)\n    Ptr<Socket> apSocket = Socket::CreateSocket(ap, UdpSocketFactory::GetTypeId());\n    apSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    apSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client\n    Ptr<Socket> clientSocket = Socket::CreateSocket(client, UdpSocketFactory::GetTypeId());\n    InetSocketAddress apAddress(interfaces.GetAddress(1), port);\n\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, clientSocket, Create<Packet>(64), 0, apAddress);\n    Simulator::Schedule(Seconds(2.0), &Socket::SendTo, clientSocket, Create<Packet>(64), 0, apAddress);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(3.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ script for an NS-3 network simulation where the topology consists of four nodes: n0, n1, n2, and n3. Nodes n0 and n1 are connected to n2 with point-to-point links (5 Mbps, 2 ms delay), and n3 is connected to n2 with a point-to-point link (1.5 Mbps, 10 ms delay). There are two CBR/UDP flows: one from n0 to n3 and another from n3 to n1. Additionally, an FTP/TCP flow runs from n0 to n3, starting at 1.2 seconds and stopping at 1.35 seconds. The UDP packet size is 210 bytes, with a transmission interval of 0.00375 seconds, resulting in a data rate of 448 Kbps. Implement DropTail queues, and trace both queue behaviors and packet receptions to the file 'simple-error-model.tr'. Add error models: a rate error model with a 0.001 packet error rate and a burst error model with a 0.01 error rate, along with a list error model that drops packets with UIDs 11 and 17"}, {"role": "assistant", "content": "// Network topology\n//\n//  n0\n//     \\ 5 Mb/s, 2ms\n//      \\          1.5Mb/s, 10ms\n//       n2 -------------------------n3\n//      /\n//     / 5 Mb/s, 2ms\n//   n1\n//\n// - all links are point-to-point links with indicated one-way BW/delay\n// - CBR/UDP flows from n0 to n3, and from n3 to n1\n// - FTP/TCP flow from n0 to n3, starting at time 1.2 to time 1.35 sec.\n// - UDP packet size of 210 bytes, with per-packet interval 0.00375 sec.\n//   (i.e., DataRate of 448,000 bps)\n// - DropTail queues\n// - Tracing of queues and packet receptions to file\n//   \"simple-error-model.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleErrorModelExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Users may find it convenient to turn on explicit debugging\n    // for selected modules; the below lines suggest how to do this\n#if 0\n  LogComponentEnable (\"SimplePointToPointExample\", LOG_LEVEL_INFO);\n#endif\n\n    // Set a few attributes\n    Config::SetDefault(\"ns3::RateErrorModel::ErrorRate\", DoubleValue(0.001));\n    Config::SetDefault(\"ns3::RateErrorModel::ErrorUnit\", StringValue(\"ERROR_UNIT_PACKET\"));\n\n    Config::SetDefault(\"ns3::BurstErrorModel::ErrorRate\", DoubleValue(0.01));\n    Config::SetDefault(\"ns3::BurstErrorModel::BurstSize\",\n                       StringValue(\"ns3::UniformRandomVariable[Min=1|Max=3]\"));\n\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(210));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", DataRateValue(DataRate(\"448kb/s\")));\n\n    std::string errorModelType = \"ns3::RateErrorModel\";\n\n    // Allow the user to override any of the defaults and the above\n    // Bind()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"errorModelType\", \"TypeId of the error model to use\", errorModelType);\n    cmd.Parse(argc, argv);\n\n    // Here, we will explicitly create four nodes.  In more sophisticated\n    // topologies, we could configure a node factory.\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer c;\n    c.Create(4);\n    NodeContainer n0n2 = NodeContainer(c.Get(0), c.Get(2));\n    NodeContainer n1n2 = NodeContainer(c.Get(1), c.Get(2));\n    NodeContainer n3n2 = NodeContainer(c.Get(3), c.Get(2));\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // We create the channels first without any IP addressing information\n    NS_LOG_INFO(\"Create channels.\");\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    p2p.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d0d2 = p2p.Install(n0n2);\n\n    NetDeviceContainer d1d2 = p2p.Install(n1n2);\n\n    p2p.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(1500000)));\n    p2p.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(10)));\n    NetDeviceContainer d3d2 = p2p.Install(n3n2);\n\n    // Later, we add IP addresses.\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(d0d2);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1i2 = ipv4.Assign(d1d2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i3i2 = ipv4.Assign(d3d2);\n\n    NS_LOG_INFO(\"Use global routing.\");\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    NS_LOG_INFO(\"Create Applications.\");\n    uint16_t port = 9; // Discard port (RFC 863)\n\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(i3i2.GetAddress(1), port)));\n    onoff.SetConstantRate(DataRate(\"448kb/s\"));\n    ApplicationContainer apps = onoff.Install(c.Get(0));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create an optional packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(c.Get(2));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a similar flow from n3 to n1, starting at time 1.1 seconds\n    onoff.SetAttribute(\"Remote\", AddressValue(InetSocketAddress(i1i2.GetAddress(0), port)));\n    apps = onoff.Install(c.Get(3));\n    apps.Start(Seconds(1.1));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    sink.SetAttribute(\"Local\", AddressValue(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(c.Get(1));\n    apps.Start(Seconds(1.1));\n    apps.Stop(Seconds(10.0));\n\n    //\n    // Error model\n    //\n    // Create an ErrorModel based on the implementation (constructor)\n    // specified by the default TypeId\n\n    ObjectFactory factory;\n    factory.SetTypeId(errorModelType);\n    Ptr<ErrorModel> em = factory.Create<ErrorModel>();\n    d3d2.Get(0)->SetAttribute(\"ReceiveErrorModel\", PointerValue(em));\n\n    // Now, let's use the ListErrorModel and explicitly force a loss\n    // of the packets with pkt-uids = 11 and 17 on node 2, device 0\n    std::list<uint64_t> sampleList;\n    sampleList.push_back(11);\n    sampleList.push_back(17);\n    // This time, we'll explicitly create the error model we want\n    Ptr<ListErrorModel> pem = CreateObject<ListErrorModel>();\n    pem->SetList(sampleList);\n    d0d2.Get(1)->SetAttribute(\"ReceiveErrorModel\", PointerValue(pem));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"simple-error-model.tr\"));\n    p2p.EnablePcapAll(\"simple-error-model\");\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an LTE mobile network in NS-3 with two nodes: Node 1 is the eNB, and Node 2 is the UE. Node 2 sends UDP packets to Node 1 using LTE communication. Simulate mobility with random walk for Node 2 and constant position for Node 1. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteMobileNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer eNodeB, ue;\n    eNodeB.Create(1);\n    ue.Create(1);\n\n    // Install LTE model\n    LteHelper lte;\n    InternetStackHelper internet;\n\n    // Install LTE devices on the nodes\n    NetDeviceContainer enbLteDevs, ueLteDevs;\n    enbLteDevs = lte.InstallEnbDevice(eNodeB);\n    ueLteDevs = lte.InstallUeDevice(ue);\n\n    // Install Internet stack\n    internet.Install(eNodeB);\n    internet.Install(ue);\n\n    // Set up mobility model for nodes\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(ue);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(eNodeB);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper ipv4Address;\n    ipv4Address.SetBase(\"7.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface = ipv4Address.Assign(ueLteDevs);\n    Ipv4InterfaceContainer enbIpIface = ipv4Address.Assign(enbLteDevs);\n\n    // Set up UDP client application on Node 2 (UE)\n    uint16_t port = 1234;\n    UdpClientHelper udpClient(ueIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(eNodeB.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on Node 1 (eNB)\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ue.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a simulation program for ns-3 to illustrate rate-adaptive Wi-Fi controls like Minstrel in a scenario with two nodes: an AP and a STA. The AP sends UDP traffic to the STA using a CBR of 400 Mbps. The AP can use any power or rate control, while the STA uses Minstrel for rate adaptation. The simulation should allow the STA to move away from the AP, with distance steps and time intervals adjustable via command-line arguments. Collect statistics such as throughput and distance, and log rate changes if logging is enabled. Output a Gnuplot file showing throughput versus distance."}, {"role": "assistant", "content": "/**\n * This example program is designed to illustrate the behavior of\n * rate-adaptive WiFi rate controls such as Minstrel.  Power-adaptive\n * rate controls can be illustrated also, but separate examples exist for\n * highlighting the power adaptation.\n *\n * This simulation consist of 2 nodes, one AP and one STA.\n * The AP generates UDP traffic with a CBR of 400 Mbps to the STA.\n * The AP can use any power and rate control mechanism and the STA uses\n * only Minstrel rate control.\n * The STA can be configured to move away from (or towards to) the AP.\n * By default, the AP is at coordinate (0,0,0) and the STA starts at\n * coordinate (5,0,0) (meters) and moves away on the x axis by 1 meter every\n * second.\n *\n * The output consists of:\n * - A plot of average throughput vs. distance.\n * - (if logging is enabled) the changes of rate to standard output.\n *\n * Example usage:\n * ./ns3 run \"wifi-rate-adaptation-distance --standard=802.11a --staManager=ns3::MinstrelWifiManager\n * --apManager=ns3::MinstrelWifiManager --outputFileName=minstrel\"\n *\n * Another example (moving towards the AP):\n * ./ns3 run \"wifi-rate-adaptation-distance --standard=802.11a --staManager=ns3::MinstrelWifiManager\n * --apManager=ns3::MinstrelWifiManager --outputFileName=minstrel --stepsSize=1 --STA1_x=-200\"\n *\n * Example for HT rates with SGI and channel width of 40MHz:\n * ./ns3 run \"wifi-rate-adaptation-distance --staManager=ns3::MinstrelHtWifiManager\n * --apManager=ns3::MinstrelHtWifiManager --outputFileName=minstrelHt --shortGuardInterval=true\n * --channelWidth=40\"\n *\n * To enable the log of rate changes:\n * export NS_LOG=RateAdaptationDistance=level_info\n */\n\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RateAdaptationDistance\");\n\n/** Node statistics */\nclass NodeStatistics\n{\n  public:\n    /**\n     * Constructor\n     * \\param aps AP devices\n     * \\param stas STA devices\n     */\n    NodeStatistics(NetDeviceContainer aps, NetDeviceContainer stas);\n\n    /**\n     * RX callback\n     * \\param path path\n     * \\param packet received packet\n     * \\param from sender\n     */\n    void RxCallback(std::string path, Ptr<const Packet> packet, const Address& from);\n    /**\n     * Set node position\n     * \\param node the node\n     * \\param position the position\n     */\n    void SetPosition(Ptr<Node> node, Vector position);\n    /**\n     * Advance node position\n     * \\param node the node\n     * \\param stepsSize the size of a step\n     * \\param stepsTime the time interval between steps\n     */\n    void AdvancePosition(Ptr<Node> node, int stepsSize, int stepsTime);\n    /**\n     * Get node position\n     * \\param node the node\n     * \\return the position\n     */\n    Vector GetPosition(Ptr<Node> node);\n    /**\n     * \\return the gnuplot 2d dataset\n     */\n    Gnuplot2dDataset GetDatafile();\n\n  private:\n    uint32_t m_bytesTotal;     //!< total bytes\n    Gnuplot2dDataset m_output; //!< gnuplot 2d dataset\n};\n\nNodeStatistics::NodeStatistics(NetDeviceContainer aps, NetDeviceContainer stas)\n{\n    m_bytesTotal = 0;\n}\n\nvoid\nNodeStatistics::RxCallback(std::string path, Ptr<const Packet> packet, const Address& from)\n{\n    m_bytesTotal += packet->GetSize();\n}\n\nvoid\nNodeStatistics::SetPosition(Ptr<Node> node, Vector position)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    mobility->SetPosition(position);\n}\n\nVector\nNodeStatistics::GetPosition(Ptr<Node> node)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    return mobility->GetPosition();\n}\n\nvoid\nNodeStatistics::AdvancePosition(Ptr<Node> node, int stepsSize, int stepsTime)\n{\n    Vector pos = GetPosition(node);\n    double mbs = ((m_bytesTotal * 8.0) / (1000000 * stepsTime));\n    m_bytesTotal = 0;\n    m_output.Add(pos.x, mbs);\n    pos.x += stepsSize;\n    SetPosition(node, pos);\n    Simulator::Schedule(Seconds(stepsTime),\n                        &NodeStatistics::AdvancePosition,\n                        this,\n                        node,\n                        stepsSize,\n                        stepsTime);\n}\n\nGnuplot2dDataset\nNodeStatistics::GetDatafile()\n{\n    return m_output;\n}\n\n/**\n * Callback for 'Rate' trace source\n *\n * \\param oldRate old MCS rate (bits/sec)\n * \\param newRate new MCS rate (bits/sec)\n */\nvoid\nRateCallback(uint64_t oldRate, uint64_t newRate)\n{\n    NS_LOG_INFO(\"Rate \" << newRate / 1000000.0 << \" Mbps\");\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t rtsThreshold{65535};\n    std::string staManager{\"ns3::MinstrelHtWifiManager\"};\n    std::string apManager{\"ns3::MinstrelHtWifiManager\"};\n    std::string standard{\"802.11n-5GHz\"};\n    std::string outputFileName{\"minstrelHT\"};\n    uint32_t BeMaxAmpduSize{65535};\n    bool shortGuardInterval{false};\n    uint32_t chWidth{20};\n    int ap1_x{0};\n    int ap1_y{0};\n    int sta1_x{5};\n    int sta1_y{0};\n    int steps{100};\n    int stepsSize{1};\n    int stepsTime{1};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"staManager\", \"Rate adaptation manager of the STA\", staManager);\n    cmd.AddValue(\"apManager\", \"Rate adaptation manager of the AP\", apManager);\n    cmd.AddValue(\"standard\", \"Wifi standard (a/b/g/n/ac only)\", standard);\n    cmd.AddValue(\"shortGuardInterval\",\n                 \"Enable Short Guard Interval in all stations\",\n                 shortGuardInterval);\n    cmd.AddValue(\"channelWidth\", \"Channel width of all the stations\", chWidth);\n    cmd.AddValue(\"rtsThreshold\", \"RTS threshold\", rtsThreshold);\n    cmd.AddValue(\"BeMaxAmpduSize\", \"BE Mac A-MPDU size\", BeMaxAmpduSize);\n    cmd.AddValue(\"outputFileName\", \"Output filename\", outputFileName);\n    cmd.AddValue(\"steps\", \"How many different distances to try\", steps);\n    cmd.AddValue(\"stepsTime\", \"Time on each step\", stepsTime);\n    cmd.AddValue(\"stepsSize\", \"Distance between steps\", stepsSize);\n    cmd.AddValue(\"AP1_x\", \"Position of AP1 in x coordinate\", ap1_x);\n    cmd.AddValue(\"AP1_y\", \"Position of AP1 in y coordinate\", ap1_y);\n    cmd.AddValue(\"STA1_x\", \"Position of STA1 in x coordinate\", sta1_x);\n    cmd.AddValue(\"STA1_y\", \"Position of STA1 in y coordinate\", sta1_y);\n    cmd.Parse(argc, argv);\n\n    int simuTime = steps * stepsTime;\n\n    if (standard != \"802.11a\" && standard != \"802.11b\" && standard != \"802.11g\" &&\n        standard != \"802.11n-2.4GHz\" && standard != \"802.11n-5GHz\" && standard != \"802.11ac\")\n    {\n        NS_FATAL_ERROR(\"Standard \" << standard << \" is not supported by this program\");\n    }\n\n    // Define the APs\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(1);\n\n    // Define the STAs\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(1);\n\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n    // Channel configuration via ChannelSettings attribute can be performed here\n    std::string frequencyBand;\n    if (standard == \"802.11b\" || standard == \"802.11g\" || standard == \"802.11n-2.4GHz\")\n    {\n        frequencyBand = \"BAND_2_4GHZ\";\n    }\n    else\n    {\n        frequencyBand = \"BAND_5GHZ\";\n    }\n    wifiPhy.Set(\"ChannelSettings\",\n                StringValue(\"{0, \" + std::to_string(chWidth) + \", \" + frequencyBand + \", 0}\"));\n\n    // By default, the CCA sensitivity is -82 dBm, meaning if the RSS is\n    // below this value, the receiver will reject the Wi-Fi frame.\n    // However, we want to allow the rate adaptation to work down to low\n    // SNR values.  To allow this, we need to do three things:  1) disable\n    // the noise figure (set it to 0 dB) so that the noise level in 20 MHz\n    // is around -101 dBm, 2) lower the CCA sensitivity to a value that\n    // disables it (e.g. -110 dBm), and 3) disable the Wi-Fi preamble\n    // detection model.\n    wifiPhy.Set(\"CcaSensitivity\", DoubleValue(-110));\n    wifiPhy.Set(\"RxNoiseFigure\", DoubleValue(0));\n    wifiPhy.DisablePreambleDetectionModel();\n\n    NetDeviceContainer wifiApDevices;\n    NetDeviceContainer wifiStaDevices;\n    NetDeviceContainer wifiDevices;\n\n    WifiHelper wifi;\n    if (standard == \"802.11a\" || standard == \"802.11b\" || standard == \"802.11g\")\n    {\n        if (standard == \"802.11a\")\n        {\n            wifi.SetStandard(WIFI_STANDARD_80211a);\n        }\n        else if (standard == \"802.11b\")\n        {\n            wifi.SetStandard(WIFI_STANDARD_80211b);\n        }\n        else if (standard == \"802.11g\")\n        {\n            wifi.SetStandard(WIFI_STANDARD_80211g);\n        }\n        WifiMacHelper wifiMac;\n\n        // Configure the STA node\n        wifi.SetRemoteStationManager(staManager, \"RtsCtsThreshold\", UintegerValue(rtsThreshold));\n\n        Ssid ssid = Ssid(\"AP\");\n        wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n        wifiStaDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiStaNodes.Get(0)));\n\n        // Configure the AP node\n        wifi.SetRemoteStationManager(apManager, \"RtsCtsThreshold\", UintegerValue(rtsThreshold));\n\n        ssid = Ssid(\"AP\");\n        wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n        wifiApDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiApNodes.Get(0)));\n    }\n    else if (standard == \"802.11n-2.4GHz\" || standard == \"802.11n-5GHz\" || standard == \"802.11ac\")\n    {\n        if (standard == \"802.11n-2.4GHz\" || standard == \"802.11n-5GHz\")\n        {\n            wifi.SetStandard(WIFI_STANDARD_80211n);\n        }\n        else if (standard == \"802.11ac\")\n        {\n            wifi.SetStandard(WIFI_STANDARD_80211ac);\n        }\n\n        WifiMacHelper wifiMac;\n\n        // Configure the STA node\n        wifi.SetRemoteStationManager(staManager, \"RtsCtsThreshold\", UintegerValue(rtsThreshold));\n\n        Ssid ssid = Ssid(\"AP\");\n        wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n        wifiStaDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiStaNodes.Get(0)));\n\n        // Configure the AP node\n        wifi.SetRemoteStationManager(apManager, \"RtsCtsThreshold\", UintegerValue(rtsThreshold));\n\n        ssid = Ssid(\"AP\");\n        wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n        wifiApDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiApNodes.Get(0)));\n\n        Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/BE_MaxAmpduSize\",\n                    UintegerValue(BeMaxAmpduSize));\n    }\n\n    wifiDevices.Add(wifiStaDevices);\n    wifiDevices.Add(wifiApDevices);\n\n    // Set guard interval\n    Config::Set(\n        \"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/ShortGuardIntervalSupported\",\n        BooleanValue(shortGuardInterval));\n\n    // Configure the mobility.\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    // Initial position of AP and STA\n    positionAlloc->Add(Vector(ap1_x, ap1_y, 0.0));\n    positionAlloc->Add(Vector(sta1_x, sta1_y, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNodes.Get(0));\n    mobility.Install(wifiStaNodes.Get(0));\n\n    // Statistics counter\n    NodeStatistics atpCounter = NodeStatistics(wifiApDevices, wifiStaDevices);\n\n    // Move the STA by stepsSize meters every stepsTime seconds\n    Simulator::Schedule(Seconds(0.5 + stepsTime),\n                        &NodeStatistics::AdvancePosition,\n                        &atpCounter,\n                        wifiStaNodes.Get(0),\n                        stepsSize,\n                        stepsTime);\n\n    // Configure the IP stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes);\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = address.Assign(wifiDevices);\n    Ipv4Address sinkAddress = i.GetAddress(0);\n    uint16_t port = 9;\n\n    // Configure the CBR generator\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress, port));\n    ApplicationContainer apps_sink = sink.Install(wifiStaNodes.Get(0));\n\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress, port));\n    onoff.SetConstantRate(DataRate(\"400Mb/s\"), 1420);\n    onoff.SetAttribute(\"StartTime\", TimeValue(Seconds(0.5)));\n    onoff.SetAttribute(\"StopTime\", TimeValue(Seconds(simuTime)));\n    ApplicationContainer apps_source = onoff.Install(wifiApNodes.Get(0));\n\n    apps_sink.Start(Seconds(0.5));\n    apps_sink.Stop(Seconds(simuTime));\n\n    //------------------------------------------------------------\n    //-- Setup stats and data collection\n    //--------------------------------------------\n\n    // Register packet receptions to calculate throughput\n    Config::Connect(\"/NodeList/1/ApplicationList/*/$ns3::PacketSink/Rx\",\n                    MakeCallback(&NodeStatistics::RxCallback, &atpCounter));\n\n    // Callbacks to print every change of rate\n    Config::ConnectWithoutContextFailSafe(\n        \"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" + apManager + \"/Rate\",\n        MakeCallback(RateCallback));\n\n    Simulator::Stop(Seconds(simuTime));\n    Simulator::Run();\n\n    std::ofstream outfile(\"throughput-\" + outputFileName + \".plt\");\n    Gnuplot gnuplot = Gnuplot(\"throughput-\" + outputFileName + \".eps\", \"Throughput\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Distance (meters)\", \"Throughput (Mb/s)\");\n    gnuplot.SetTitle(\"Throughput (AP to STA) vs distance\");\n    gnuplot.AddDataset(atpCounter.GetDatafile());\n    gnuplot.GenerateOutput(outfile);\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Wi-Fi network with one Access Point (AP) and three Client Stations (STA). The AP should be static, and the STAs should move randomly within a 50x50 area using the Random Walk mobility model. Set up the Wi-Fi devices with a common SSID and assign IP addresses. The AP should have a UDP server running on port 9, and the STAs should act as UDP clients, sending 5 packets at 1-second intervals. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    // Set the simulation time resolution\n    Time::SetResolution(Time::NS);\n\n    // Create nodes: one Access Point (AP) and three Client Stations (STA)\n    NodeContainer apNode, staNodes;\n    apNode.Create(1);\n    staNodes.Create(3);\n\n    // Set up the Wi-Fi helper\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    // Install Wi-Fi devices on the AP and STAs\n    NetDeviceContainer apDevice, staDevices;\n    apDevice = wifiHelper.Install(phy, mac, apNode);\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    staDevices = wifiHelper.Install(phy, mac, staNodes);\n\n    // Install IP stack for routing\n    InternetStackHelper internet;\n    internet.Install(apNode);\n    internet.Install(staNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apIpIface, staIpIface;\n    apIpIface = ipv4.Assign(apDevice);\n    staIpIface = ipv4.Assign(staDevices);\n\n    // Set up a UDP server on the Access Point (AP)\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(apNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP clients on the Stations (STA)\n    UdpClientHelper udpClient(apIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < 3; ++i)\n    {\n        clientApps.Add(udpClient.Install(staNodes.Get(i)));\n    }\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Set mobility model for AP and STAs\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(apNode);\n\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 50, 0, 50)));\n    mobility.Install(staNodes);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script for a Wi-Fi network with two nodes, using 802.11b. The nodes should have a fixed position. One node should send UDP packets to the other using a UDP client-server model. The sender should send 1000 packets of 512 bytes each at a rate of 100 packets per second (10 ms interval). The UDP server should listen on port 8080. The simulation should run for 10 seconds, with the sender starting at 2 seconds and the receiver at 1 second."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two Wi-Fi nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Set up Wi-Fi channel\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"wifi-network\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, wifiNodes);\n\n    // Set mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP sink on Node 1\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP sender on Node 0\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10))); // 100 packets/sec\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Mobile Ad-Hoc Network (MANET) with 6 nodes using the OLSR routing protocol. The nodes are mobile and use the RandomWaypointMobilityModel for movement within a 100x100m area. Nodes have speeds between 5m/s and 15m/s, and the simulation runs for 10 seconds. A UDP packet is sent from node 0 to node 5. The simulation should print the routing behavior as nodes move and adjust the network topology."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/olsr-helper.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OlsrExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"OlsrExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the MANET\n    NodeContainer nodes;\n    nodes.Create(6);\n\n    // Set up mobility model for nodes (random movement)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"MinX\", DoubleValue(0.0),\n                              \"MinY\", DoubleValue(0.0),\n                              \"MaxX\", DoubleValue(100.0),\n                              \"MaxY\", DoubleValue(100.0),\n                              \"Speed\", StringValue(\"ns3::UniformRandomVariable[Min=5.0|Max=15.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"));\n    mobility.Install(nodes);\n\n    // Install OLSR routing protocol\n    OlsrHelper olsr;\n    InternetStackHelper stack;\n    stack.SetRoutingHelper(olsr); // Use OLSR as the routing protocol\n    stack.Install(nodes);\n\n    // Set up point-to-point devices (Wi-Fi or similar)\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_PHY_STANDARD_80211b);\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns-3-olsr\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices = wifiHelper.Install(wifiPhy, wifiMac, nodes);\n\n    // Install the internet stack and assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfaces = ipv4.Assign(devices);\n\n    // Set up UDP application on node 0 (sending data)\n    OnOffHelper onOffHelper(\"ns3::UdpSocketFactory\", Address(InetSocketAddress(ipInterfaces.GetAddress(5), 9))); // Send to node 5\n    onOffHelper.SetConstantRate(DataRate(\"500kb/s\"));\n    ApplicationContainer senderApp = onOffHelper.Install(nodes.Get(0));\n    senderApp.Start(Seconds(2.0));\n    senderApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on node 5 (receiving data)\n    UdpServerHelper udpServer(9);\n    ApplicationContainer receiverApp = udpServer.Install(nodes.Get(5));\n    receiverApp.Start(Seconds(2.0));\n    receiverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using ns-3 that configures a grid of nodes with 802.11b NICs operating in adhoc mode. The grid is by default 5x5, and each node is positioned using the GridPositionAllocator. The program should allow command-line options to modify parameters such as the physical layer mode, grid distance, packet size, number of packets, source and sink nodes, and enable verbose logging. By default, one 1000-byte packet is sent from the highest-numbered node (node 24) to node 0, and OLSR routing is enabled to determine the packet forwarding path. Include options to enable packet tracing using pcap and ASCII trace files, and allow customization of the source and sink nodes. The script should also simulate wireless transmission effects, including distance-based RSSI cutoff."}, {"role": "assistant", "content": "// This program configures a grid (default 5x5) of nodes on an\n// 802.11b physical layer, with\n// 802.11b NICs in adhoc mode, and by default, sends one packet of 1000\n// (application) bytes to node 1.\n//\n// The default layout is like this, on a 2-D grid.\n//\n// n20  n21  n22  n23  n24\n// n15  n16  n17  n18  n19\n// n10  n11  n12  n13  n14\n// n5   n6   n7   n8   n9\n// n0   n1   n2   n3   n4\n//\n// the layout is affected by the parameters given to GridPositionAllocator;\n// by default, GridWidth is 5 (nodes per row) and numNodes is 25..\n//\n// There are a number of command-line options available to control\n// the default behavior.  The list of available command-line options\n// can be listed with the following command:\n// ./ns3 run \"wifi-simple-adhoc-grid --help\"\n//\n// Note that all ns-3 attributes (not just the ones exposed in the below\n// script) can be changed at command line; see the ns-3 documentation.\n//\n// For instance, for this configuration, the physical layer will\n// stop successfully receiving packets when distance increases beyond\n// the default of 100m.  The cutoff is around 116m; below that value, the\n// received signal strength falls below the (default) RSSI limit of -82 dBm\n// used by Wi-Fi's threshold preamble detection running.\n//\n// To see this effect, try running at a larger distance, and no packet\n// reception will be reported:\n//\n// ./ns3 run \"wifi-simple-adhoc-grid --distance=200\"\n//\n// The default path through the topology will follow the following node\n// numbers:  24->23->18->13->12->11->10->5->0\n//\n// To see this, the following Bash commands will list the UDP packet\n// transmissions hop-by-hop, if tracing is enabled:\n//\n// ./ns3 run \"wifi-simple-adhoc-grid --tracing=1\"\n// grep ^t wifi-simple-adhoc-grid.tr  | grep Udp | grep -v olsr | less\n//\n// By changing the distance to a smaller value, more nodes can be reached\n// by each transmission, and the number of forwarding hops will decrease.\n//\n// The source node and sink node can be changed like this:\n//\n// ./ns3 run \"wifi-simple-adhoc-grid --sourceNode=20 --sinkNode=10\"\n//\n// This script can also be helpful to put the Wifi layer into verbose\n// logging mode; this command will turn on all wifi logging:\n//\n// ./ns3 run \"wifi-simple-adhoc-grid --verbose=1\"\n//\n// By default, trace file writing is off-- to enable it, try:\n// ./ns3 run \"wifi-simple-adhoc-grid --tracing=1\"\n//\n// When you are done tracing, you will notice many pcap trace files\n// in your directory.  If you have tcpdump installed, you can try this:\n//\n// tcpdump -r wifi-simple-adhoc-grid-0-0.pcap -nn -tt\n//\n// or you can examine the text-based trace wifi-simple-adhoc-grid.tr with\n// an editor.\n//\n\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/olsr-helper.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleAdhocGrid\");\n\n/**\n * Function called when a packet is received.\n *\n * \\param socket The receiving socket.\n */\nvoid\nReceivePacket(Ptr<Socket> socket)\n{\n    while (socket->Recv())\n    {\n        NS_LOG_UNCOND(\"Received one packet!\");\n    }\n}\n\n/**\n * Generate traffic.\n *\n * \\param socket The sending socket.\n * \\param pktSize The packet size.\n * \\param pktCount The packet count.\n * \\param pktInterval The interval between two packets.\n */\nstatic void\nGenerateTraffic(Ptr<Socket> socket, uint32_t pktSize, uint32_t pktCount, Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval,\n                            &GenerateTraffic,\n                            socket,\n                            pktSize,\n                            pktCount - 1,\n                            pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string phyMode{\"DsssRate1Mbps\"};\n    meter_u distance{100};\n    uint32_t packetSize{1000}; // bytes\n    uint32_t numPackets{1};\n    uint32_t numNodes{25}; // by default, 5x5\n    uint32_t sinkNode{0};\n    uint32_t sourceNode{24};\n    Time interPacketInterval{\"1s\"};\n    bool verbose{false};\n    bool tracing{false};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"phyMode\", \"Wifi Phy mode\", phyMode);\n    cmd.AddValue(\"distance\", \"distance (m)\", distance);\n    cmd.AddValue(\"packetSize\", \"size of application packet sent\", packetSize);\n    cmd.AddValue(\"numPackets\", \"number of packets generated\", numPackets);\n    cmd.AddValue(\"interval\", \"interval (seconds) between packets\", interPacketInterval);\n    cmd.AddValue(\"verbose\", \"turn on all WifiNetDevice log components\", verbose);\n    cmd.AddValue(\"tracing\", \"turn on ascii and pcap tracing\", tracing);\n    cmd.AddValue(\"numNodes\", \"number of nodes\", numNodes);\n    cmd.AddValue(\"sinkNode\", \"Receiver node number\", sinkNode);\n    cmd.AddValue(\"sourceNode\", \"Sender node number\", sourceNode);\n    cmd.Parse(argc, argv);\n\n    // Fix non-unicast data rate to be the same as that of unicast\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(phyMode));\n\n    NodeContainer c;\n    c.Create(numNodes);\n\n    // The below set of helpers will help us to put together the wifi NICs we want\n    WifiHelper wifi;\n    if (verbose)\n    {\n        WifiHelper::EnableLogComponents(); // Turn on all Wifi logging\n    }\n\n    YansWifiPhyHelper wifiPhy;\n    // set it to zero; otherwise, gain will be added\n    wifiPhy.Set(\"RxGain\", DoubleValue(-10));\n    // ns-3 supports RadioTap and Prism tracing extensions for 802.11b\n    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Add an upper mac and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n    // Set it to adhoc mode\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, c);\n\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\",\n                                  DoubleValue(0.0),\n                                  \"MinY\",\n                                  DoubleValue(0.0),\n                                  \"DeltaX\",\n                                  DoubleValue(distance),\n                                  \"DeltaY\",\n                                  DoubleValue(distance),\n                                  \"GridWidth\",\n                                  UintegerValue(5),\n                                  \"LayoutType\",\n                                  StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    // Enable OLSR\n    OlsrHelper olsr;\n    Ipv4StaticRoutingHelper staticRouting;\n\n    Ipv4ListRoutingHelper list;\n    list.Add(staticRouting, 0);\n    list.Add(olsr, 10);\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(list); // has effect on the next Install ()\n    internet.Install(c);\n\n    Ipv4AddressHelper ipv4;\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(c.Get(sinkNode), tid);\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 80);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    Ptr<Socket> source = Socket::CreateSocket(c.Get(sourceNode), tid);\n    InetSocketAddress remote = InetSocketAddress(i.GetAddress(sinkNode, 0), 80);\n    source->Connect(remote);\n\n    if (tracing)\n    {\n        AsciiTraceHelper ascii;\n        wifiPhy.EnableAsciiAll(ascii.CreateFileStream(\"wifi-simple-adhoc-grid.tr\"));\n        wifiPhy.EnablePcap(\"wifi-simple-adhoc-grid\", devices);\n        // Trace routing tables\n        Ptr<OutputStreamWrapper> routingStream =\n            Create<OutputStreamWrapper>(\"wifi-simple-adhoc-grid.routes\", std::ios::out);\n        Ipv4RoutingHelper::PrintRoutingTableAllEvery(Seconds(2), routingStream);\n        Ptr<OutputStreamWrapper> neighborStream =\n            Create<OutputStreamWrapper>(\"wifi-simple-adhoc-grid.neighbors\", std::ios::out);\n        Ipv4RoutingHelper::PrintNeighborCacheAllEvery(Seconds(2), neighborStream);\n\n        // To do-- enable an IP-level trace that shows forwarding events only\n    }\n\n    // Give OLSR time to converge-- 30 seconds perhaps\n    Simulator::Schedule(Seconds(30.0),\n                        &GenerateTraffic,\n                        source,\n                        packetSize,\n                        numPackets,\n                        interPacketInterval);\n\n    // Output what we are doing\n    NS_LOG_UNCOND(\"Testing from node \" << sourceNode << \" to \" << sinkNode << \" with grid distance \"\n                                       << distance);\n\n    Simulator::Stop(Seconds(33.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library that simulates a multi-router IPv6 network with three segments. The network consists of five nodes (Src, n0, r1, n1, r2, n2) connected via routers with varying MTU sizes (5000, 2000, 1500). Use CSMA and Point-to-Point channels, setting the respective MTU values for each link. Install IPv6 internet stacks, configure forwarding and default routes, and set up UDP echo client-server applications between the nodes. Ensure that packet fragmentation occurs due to varying MTUs. Enable logging and tracing of packet receptions to the file 'fragmentation-ipv6-PMTU.tr'."}, {"role": "assistant", "content": "// Network topology\n// //\n// //      Src  n0        r1     n1      r2        n2\n// //           |         _      |       _         |\n// //           =========|_|============|_|=========\n// //      MTU   5000           2000          1500\n// //\n// // - Tracing of queues and packet receptions to file \"fragmentation-ipv6-PMTU.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"FragmentationIpv6PmtuExample\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_ALL);\n    }\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> n0 = CreateObject<Node>();\n    Ptr<Node> r1 = CreateObject<Node>();\n    Ptr<Node> n1 = CreateObject<Node>();\n    Ptr<Node> r2 = CreateObject<Node>();\n    Ptr<Node> n2 = CreateObject<Node>();\n\n    NodeContainer net1(n0, r1);\n    NodeContainer net2(r1, n1, r2);\n    NodeContainer net3(r2, n2);\n    NodeContainer all(n0, r1, n1, r2, n2);\n\n    NS_LOG_INFO(\"Create IPv6 Internet Stack\");\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(2000));\n    NetDeviceContainer d2 = csma.Install(net2); // CSMA Network with MTU 2000\n\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(5000));\n    NetDeviceContainer d1 = csma.Install(net1); // CSMA Network with MTU 5000\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", DataRateValue(5000000));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    pointToPoint.SetDeviceAttribute(\"Mtu\", UintegerValue(1500));\n    NetDeviceContainer d3 = pointToPoint.Install(net3); // P2P Network with MTU 1500\n\n    NS_LOG_INFO(\"Create networks and assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i1 = ipv6.Assign(d1);\n    i1.SetForwarding(1, true);\n    i1.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i2 = ipv6.Assign(d2);\n    i2.SetForwarding(0, true);\n    i2.SetDefaultRouteInAllNodes(0);\n    i2.SetForwarding(1, true);\n    i2.SetDefaultRouteInAllNodes(0);\n    i2.SetForwarding(2, true);\n    i2.SetDefaultRouteInAllNodes(2);\n\n    ipv6.SetBase(Ipv6Address(\"2001:3::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i3 = ipv6.Assign(d3);\n    i3.SetForwarding(0, true);\n    i3.SetDefaultRouteInAllNodes(0);\n\n    Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);\n    Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(0), r1, routingStream);\n\n    // Create an UDP Echo server on n2\n    UdpEchoServerHelper echoServer(42);\n    ApplicationContainer serverApps = echoServer.Install(n2);\n    serverApps.Start(Seconds(0.0));\n    serverApps.Stop(Seconds(30.0));\n\n    uint32_t maxPacketCount = 5;\n\n    // Create an UDP Echo client on n1 to send UDP packets to n2 via r1\n    uint32_t packetSizeN1 = 1600; // Packet should fragment as intermediate link MTU is 1500\n    UdpEchoClientHelper echoClient(i3.GetAddress(1, 1), 42);\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSizeN1));\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    ApplicationContainer clientAppsN1 = echoClient.Install(n1);\n    clientAppsN1.Start(Seconds(2.0));\n    clientAppsN1.Stop(Seconds(10.0));\n\n    // Create an UDP Echo client on n0 to send UDP packets to n2 via r0 and r1\n    uint32_t packetSizeN2 = 4000; // Packet should fragment as intermediate link MTU is 1500\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSizeN2));\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    ApplicationContainer clientAppsN2 = echoClient.Install(n1);\n    clientAppsN2.Start(Seconds(11.0));\n    clientAppsN2.Stop(Seconds(20.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"fragmentation-ipv6-PMTU.tr\"));\n    csma.EnablePcapAll(std::string(\"fragmentation-ipv6-PMTU\"), true);\n    pointToPoint.EnablePcapAll(std::string(\"fragmentation-ipv6-PMTU\"), true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
