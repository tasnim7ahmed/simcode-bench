{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a point-to-point network in NS-3 with two nodes. Node 0 sends TCP packets to Node 1 starting at 2s and stopping at 5s. Use a data rate of 5Mbps, a delay of 2ms, and assign IP addresses starting with 10.1.1.0/24. The server should start at 1s, and the simulation should run for 5 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install point-to-point devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up TCP server on Node 1 (Receiver)\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(5.0));\n\n    // Set up TCP client on Node 0 (Sender)\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(5.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a program that simulates a network topology based on the description in Figure 17 of the paper \"Data Center TCP (DCTCP)\" by Mohammad Alizadeh et al. The topology should include two bottlenecks: the interface between switches T1 and T2 (30 senders over a 10 Gbps link) and the T2-R1 link (20 senders over a 1 Gbps link). Use RED queues configured for ECN marking at the bottlenecks. The program should stagger 40 TCP flows during a one-second startup window, and measure throughput during a one-second interval after a three-second convergence time. It should output throughput per flow, aggregate fairness, and queue statistics, as described."}, {"role": "assistant", "content": "// The network topology used in this example is based on Fig. 17 described in\n// Mohammad Alizadeh, Albert Greenberg, David A. Maltz, Jitendra Padhye,\n// Parveen Patel, Balaji Prabhakar, Sudipta Sengupta, and Murari Sridharan.\n// \"Data Center TCP (DCTCP).\" In ACM SIGCOMM Computer Communication Review,\n// Vol. 40, No. 4, pp. 63-74. ACM, 2010.\n\n// The topology is roughly as follows\n//\n//  S1         S3\n//  |           |  (1 Gbps)\n//  T1 ------- T2 -- R1\n//  |           |  (1 Gbps)\n//  S2         R2\n//\n// The link between switch T1 and T2 is 10 Gbps.  All other\n// links are 1 Gbps.  In the SIGCOMM paper, there is a Scorpion switch\n// between T1 and T2, but it doesn't contribute another bottleneck.\n//\n// S1 and S3 each have 10 senders sending to receiver R1 (20 total)\n// S2 (20 senders) sends traffic to R2 (20 receivers)\n//\n// This sets up two bottlenecks: 1) T1 -> T2 interface (30 senders\n// using the 10 Gbps link) and 2) T2 -> R1 (20 senders using 1 Gbps link)\n//\n// RED queues configured for ECN marking are used at the bottlenecks.\n//\n// Figure 17 published results are that each sender in S1 gets 46 Mbps\n// and each in S3 gets 54 Mbps, while each S2 sender gets 475 Mbps, and\n// that these are within 10% of their fair-share throughputs (Jain index\n// of 0.99).\n//\n// This program runs the program by default for five seconds.  The first\n// second is devoted to flow startup (all 40 TCP flows are stagger started\n// during this period).  There is a three second convergence time where\n// no measurement data is taken, and then there is a one second measurement\n// interval to gather raw throughput for each flow.  These time intervals\n// can be changed at the command line.\n//\n// The program outputs six files.  The first three:\n// * dctcp-example-s1-r1-throughput.dat\n// * dctcp-example-s2-r2-throughput.dat\n// * dctcp-example-s3-r1-throughput.dat\n// provide per-flow throughputs (in Mb/s) for each of the forty flows, summed\n// over the measurement window.  The fourth file,\n// * dctcp-example-fairness.dat\n// provides average throughputs for the three flow paths, and computes\n// Jain's fairness index for each flow group (i.e. across each group of\n// 10, 20, and 10 flows).  It also sums the throughputs across each bottleneck.\n// The fifth and sixth:\n// * dctcp-example-t1-length.dat\n// * dctcp-example-t2-length.dat\n// report on the bottleneck queue length (in packets and microseconds\n// of delay) at 10 ms intervals during the measurement window.\n//\n// By default, the throughput averages are 23 Mbps for S1 senders, 471 Mbps\n// for S2 senders, and 74 Mbps for S3 senders, and the Jain index is greater\n// than 0.99 for each group of flows.  The average queue delay is about 1ms\n// for the T2->R2 bottleneck, and about 200us for the T1->T2 bottleneck.\n//\n// The RED parameters (min_th and max_th) are set to the same values as\n// reported in the paper, but we observed that throughput distributions\n// and queue delays are very sensitive to these parameters, as was also\n// observed in the paper; it is likely that the paper's throughput results\n// could be achieved by further tuning of the RED parameters.  However,\n// the default results show that DCTCP is able to achieve high link\n// utilization and low queueing delay and fairness across competing flows\n// sharing the same path.\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <iomanip>\n#include <iostream>\n\nusing namespace ns3;\n\nstd::stringstream filePlotQueue1;\nstd::stringstream filePlotQueue2;\nstd::ofstream rxS1R1Throughput;\nstd::ofstream rxS2R2Throughput;\nstd::ofstream rxS3R1Throughput;\nstd::ofstream fairnessIndex;\nstd::ofstream t1QueueLength;\nstd::ofstream t2QueueLength;\nstd::vector<uint64_t> rxS1R1Bytes;\nstd::vector<uint64_t> rxS2R2Bytes;\nstd::vector<uint64_t> rxS3R1Bytes;\n\nvoid\nPrintProgress(Time interval)\n{\n    std::cout << \"Progress to \" << std::fixed << std::setprecision(1)\n              << Simulator::Now().GetSeconds() << \" seconds simulation time\" << std::endl;\n    Simulator::Schedule(interval, &PrintProgress, interval);\n}\n\nvoid\nTraceS1R1Sink(std::size_t index, Ptr<const Packet> p, const Address& a)\n{\n    rxS1R1Bytes[index] += p->GetSize();\n}\n\nvoid\nTraceS2R2Sink(std::size_t index, Ptr<const Packet> p, const Address& a)\n{\n    rxS2R2Bytes[index] += p->GetSize();\n}\n\nvoid\nTraceS3R1Sink(std::size_t index, Ptr<const Packet> p, const Address& a)\n{\n    rxS3R1Bytes[index] += p->GetSize();\n}\n\nvoid\nInitializeCounters()\n{\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        rxS1R1Bytes[i] = 0;\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        rxS2R2Bytes[i] = 0;\n    }\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        rxS3R1Bytes[i] = 0;\n    }\n}\n\nvoid\nPrintThroughput(Time measurementWindow)\n{\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        rxS1R1Throughput << measurementWindow.GetSeconds() << \"s \" << i << \" \"\n                         << (rxS1R1Bytes[i] * 8) / (measurementWindow.GetSeconds()) / 1e6\n                         << std::endl;\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        rxS2R2Throughput << Simulator::Now().GetSeconds() << \"s \" << i << \" \"\n                         << (rxS2R2Bytes[i] * 8) / (measurementWindow.GetSeconds()) / 1e6\n                         << std::endl;\n    }\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        rxS3R1Throughput << Simulator::Now().GetSeconds() << \"s \" << i << \" \"\n                         << (rxS3R1Bytes[i] * 8) / (measurementWindow.GetSeconds()) / 1e6\n                         << std::endl;\n    }\n}\n\n// Jain's fairness index:  https://en.wikipedia.org/wiki/Fairness_measure\nvoid\nPrintFairness(Time measurementWindow)\n{\n    double average = 0;\n    uint64_t sumSquares = 0;\n    uint64_t sum = 0;\n    double fairness = 0;\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        sum += rxS1R1Bytes[i];\n        sumSquares += (rxS1R1Bytes[i] * rxS1R1Bytes[i]);\n    }\n    average = ((sum / 10) * 8 / measurementWindow.GetSeconds()) / 1e6;\n    fairness = static_cast<double>(sum * sum) / (10 * sumSquares);\n    fairnessIndex << \"Average throughput for S1-R1 flows: \" << std::fixed << std::setprecision(2)\n                  << average << \" Mbps; fairness: \" << std::fixed << std::setprecision(3)\n                  << fairness << std::endl;\n    average = 0;\n    sumSquares = 0;\n    sum = 0;\n    fairness = 0;\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        sum += rxS2R2Bytes[i];\n        sumSquares += (rxS2R2Bytes[i] * rxS2R2Bytes[i]);\n    }\n    average = ((sum / 20) * 8 / measurementWindow.GetSeconds()) / 1e6;\n    fairness = static_cast<double>(sum * sum) / (20 * sumSquares);\n    fairnessIndex << \"Average throughput for S2-R2 flows: \" << std::fixed << std::setprecision(2)\n                  << average << \" Mbps; fairness: \" << std::fixed << std::setprecision(3)\n                  << fairness << std::endl;\n    average = 0;\n    sumSquares = 0;\n    sum = 0;\n    fairness = 0;\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        sum += rxS3R1Bytes[i];\n        sumSquares += (rxS3R1Bytes[i] * rxS3R1Bytes[i]);\n    }\n    average = ((sum / 10) * 8 / measurementWindow.GetSeconds()) / 1e6;\n    fairness = static_cast<double>(sum * sum) / (10 * sumSquares);\n    fairnessIndex << \"Average throughput for S3-R1 flows: \" << std::fixed << std::setprecision(2)\n                  << average << \" Mbps; fairness: \" << std::fixed << std::setprecision(3)\n                  << fairness << std::endl;\n    sum = 0;\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        sum += rxS1R1Bytes[i];\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        sum += rxS2R2Bytes[i];\n    }\n    fairnessIndex << \"Aggregate user-level throughput for flows through T1: \"\n                  << static_cast<double>(sum * 8) / 1e9 << \" Gbps\" << std::endl;\n    sum = 0;\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        sum += rxS3R1Bytes[i];\n    }\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        sum += rxS1R1Bytes[i];\n    }\n    fairnessIndex << \"Aggregate user-level throughput for flows to R1: \"\n                  << static_cast<double>(sum * 8) / 1e9 << \" Gbps\" << std::endl;\n}\n\nvoid\nCheckT1QueueSize(Ptr<QueueDisc> queue)\n{\n    // 1500 byte packets\n    uint32_t qSize = queue->GetNPackets();\n    Time backlog = Seconds(static_cast<double>(qSize * 1500 * 8) / 1e10); // 10 Gb/s\n    // report size in units of packets and ms\n    t1QueueLength << std::fixed << std::setprecision(2) << Simulator::Now().GetSeconds() << \" \"\n                  << qSize << \" \" << backlog.GetMicroSeconds() << std::endl;\n    // check queue size every 1/100 of a second\n    Simulator::Schedule(MilliSeconds(10), &CheckT1QueueSize, queue);\n}\n\nvoid\nCheckT2QueueSize(Ptr<QueueDisc> queue)\n{\n    uint32_t qSize = queue->GetNPackets();\n    Time backlog = Seconds(static_cast<double>(qSize * 1500 * 8) / 1e9); // 1 Gb/s\n    // report size in units of packets and ms\n    t2QueueLength << std::fixed << std::setprecision(2) << Simulator::Now().GetSeconds() << \" \"\n                  << qSize << \" \" << backlog.GetMicroSeconds() << std::endl;\n    // check queue size every 1/100 of a second\n    Simulator::Schedule(MilliSeconds(10), &CheckT2QueueSize, queue);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string outputFilePath = \".\";\n    std::string tcpTypeId = \"TcpDctcp\";\n    Time flowStartupWindow = Seconds(1);\n    Time convergenceTime = Seconds(3);\n    Time measurementWindow = Seconds(1);\n    bool enableSwitchEcn = true;\n    Time progressInterval = MilliSeconds(100);\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"tcpTypeId\", \"ns-3 TCP TypeId\", tcpTypeId);\n    cmd.AddValue(\"flowStartupWindow\",\n                 \"startup time window (TCP staggered starts)\",\n                 flowStartupWindow);\n    cmd.AddValue(\"convergenceTime\", \"convergence time\", convergenceTime);\n    cmd.AddValue(\"measurementWindow\", \"measurement window\", measurementWindow);\n    cmd.AddValue(\"enableSwitchEcn\", \"enable ECN at switches\", enableSwitchEcn);\n    cmd.Parse(argc, argv);\n\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\", StringValue(\"ns3::\" + tcpTypeId));\n\n    Time startTime = Seconds(0);\n    Time stopTime = flowStartupWindow + convergenceTime + measurementWindow;\n\n    rxS1R1Bytes.reserve(10);\n    rxS2R2Bytes.reserve(20);\n    rxS3R1Bytes.reserve(10);\n\n    NodeContainer S1;\n    NodeContainer S2;\n    NodeContainer S3;\n    NodeContainer R2;\n    Ptr<Node> T1 = CreateObject<Node>();\n    Ptr<Node> T2 = CreateObject<Node>();\n    Ptr<Node> R1 = CreateObject<Node>();\n    S1.Create(10);\n    S2.Create(20);\n    S3.Create(10);\n    R2.Create(20);\n\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(1448));\n    Config::SetDefault(\"ns3::TcpSocket::DelAckCount\", UintegerValue(2));\n    GlobalValue::Bind(\"ChecksumEnabled\", BooleanValue(false));\n\n    // Set default parameters for RED queue disc\n    Config::SetDefault(\"ns3::RedQueueDisc::UseEcn\", BooleanValue(enableSwitchEcn));\n    // ARED may be used but the queueing delays will increase; it is disabled\n    // here because the SIGCOMM paper did not mention it\n    // Config::SetDefault (\"ns3::RedQueueDisc::ARED\", BooleanValue (true));\n    // Config::SetDefault (\"ns3::RedQueueDisc::Gentle\", BooleanValue (true));\n    Config::SetDefault(\"ns3::RedQueueDisc::UseHardDrop\", BooleanValue(false));\n    Config::SetDefault(\"ns3::RedQueueDisc::MeanPktSize\", UintegerValue(1500));\n    // Triumph and Scorpion switches used in DCTCP Paper have 4 MB of buffer\n    // If every packet is 1500 bytes, 2666 packets can be stored in 4 MB\n    Config::SetDefault(\"ns3::RedQueueDisc::MaxSize\", QueueSizeValue(QueueSize(\"2666p\")));\n    // DCTCP tracks instantaneous queue length only; so set QW = 1\n    Config::SetDefault(\"ns3::RedQueueDisc::QW\", DoubleValue(1));\n    Config::SetDefault(\"ns3::RedQueueDisc::MinTh\", DoubleValue(20));\n    Config::SetDefault(\"ns3::RedQueueDisc::MaxTh\", DoubleValue(60));\n\n    PointToPointHelper pointToPointSR;\n    pointToPointSR.SetDeviceAttribute(\"DataRate\", StringValue(\"1Gbps\"));\n    pointToPointSR.SetChannelAttribute(\"Delay\", StringValue(\"10us\"));\n\n    PointToPointHelper pointToPointT;\n    pointToPointT.SetDeviceAttribute(\"DataRate\", StringValue(\"10Gbps\"));\n    pointToPointT.SetChannelAttribute(\"Delay\", StringValue(\"10us\"));\n\n    // Create a total of 62 links.\n    std::vector<NetDeviceContainer> S1T1;\n    S1T1.reserve(10);\n    std::vector<NetDeviceContainer> S2T1;\n    S2T1.reserve(20);\n    std::vector<NetDeviceContainer> S3T2;\n    S3T2.reserve(10);\n    std::vector<NetDeviceContainer> R2T2;\n    R2T2.reserve(20);\n    NetDeviceContainer T1T2 = pointToPointT.Install(T1, T2);\n    NetDeviceContainer R1T2 = pointToPointSR.Install(R1, T2);\n\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        Ptr<Node> n = S1.Get(i);\n        S1T1.push_back(pointToPointSR.Install(n, T1));\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        Ptr<Node> n = S2.Get(i);\n        S2T1.push_back(pointToPointSR.Install(n, T1));\n    }\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        Ptr<Node> n = S3.Get(i);\n        S3T2.push_back(pointToPointSR.Install(n, T2));\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        Ptr<Node> n = R2.Get(i);\n        R2T2.push_back(pointToPointSR.Install(n, T2));\n    }\n\n    InternetStackHelper stack;\n    stack.InstallAll();\n\n    TrafficControlHelper tchRed10;\n    // MinTh = 50, MaxTh = 150 recommended in ACM SIGCOMM 2010 DCTCP Paper\n    // This yields a target (MinTh) queue depth of 60us at 10 Gb/s\n    tchRed10.SetRootQueueDisc(\"ns3::RedQueueDisc\",\n                              \"LinkBandwidth\",\n                              StringValue(\"10Gbps\"),\n                              \"LinkDelay\",\n                              StringValue(\"10us\"),\n                              \"MinTh\",\n                              DoubleValue(50),\n                              \"MaxTh\",\n                              DoubleValue(150));\n    QueueDiscContainer queueDiscs1 = tchRed10.Install(T1T2);\n\n    TrafficControlHelper tchRed1;\n    // MinTh = 20, MaxTh = 60 recommended in ACM SIGCOMM 2010 DCTCP Paper\n    // This yields a target queue depth of 250us at 1 Gb/s\n    tchRed1.SetRootQueueDisc(\"ns3::RedQueueDisc\",\n                             \"LinkBandwidth\",\n                             StringValue(\"1Gbps\"),\n                             \"LinkDelay\",\n                             StringValue(\"10us\"),\n                             \"MinTh\",\n                             DoubleValue(20),\n                             \"MaxTh\",\n                             DoubleValue(60));\n    QueueDiscContainer queueDiscs2 = tchRed1.Install(R1T2.Get(1));\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        tchRed1.Install(S1T1[i].Get(1));\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        tchRed1.Install(S2T1[i].Get(1));\n    }\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        tchRed1.Install(S3T2[i].Get(1));\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        tchRed1.Install(R2T2[i].Get(1));\n    }\n\n    Ipv4AddressHelper address;\n    std::vector<Ipv4InterfaceContainer> ipS1T1;\n    ipS1T1.reserve(10);\n    std::vector<Ipv4InterfaceContainer> ipS2T1;\n    ipS2T1.reserve(20);\n    std::vector<Ipv4InterfaceContainer> ipS3T2;\n    ipS3T2.reserve(10);\n    std::vector<Ipv4InterfaceContainer> ipR2T2;\n    ipR2T2.reserve(20);\n    address.SetBase(\"172.16.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipT1T2 = address.Assign(T1T2);\n    address.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipR1T2 = address.Assign(R1T2);\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        ipS1T1.push_back(address.Assign(S1T1[i]));\n        address.NewNetwork();\n    }\n    address.SetBase(\"10.2.1.0\", \"255.255.255.0\");\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        ipS2T1.push_back(address.Assign(S2T1[i]));\n        address.NewNetwork();\n    }\n    address.SetBase(\"10.3.1.0\", \"255.255.255.0\");\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        ipS3T2.push_back(address.Assign(S3T2[i]));\n        address.NewNetwork();\n    }\n    address.SetBase(\"10.4.1.0\", \"255.255.255.0\");\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        ipR2T2.push_back(address.Assign(R2T2[i]));\n        address.NewNetwork();\n    }\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Each sender in S2 sends to a receiver in R2\n    std::vector<Ptr<PacketSink>> r2Sinks;\n    r2Sinks.reserve(20);\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        uint16_t port = 50000 + i;\n        Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n        PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n        ApplicationContainer sinkApp = sinkHelper.Install(R2.Get(i));\n        Ptr<PacketSink> packetSink = sinkApp.Get(0)->GetObject<PacketSink>();\n        r2Sinks.push_back(packetSink);\n        sinkApp.Start(startTime);\n        sinkApp.Stop(stopTime);\n\n        OnOffHelper clientHelper1(\"ns3::TcpSocketFactory\", Address());\n        clientHelper1.SetAttribute(\"OnTime\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        clientHelper1.SetAttribute(\"OffTime\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n        clientHelper1.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"1Gbps\")));\n        clientHelper1.SetAttribute(\"PacketSize\", UintegerValue(1000));\n\n        ApplicationContainer clientApps1;\n        AddressValue remoteAddress(InetSocketAddress(ipR2T2[i].GetAddress(0), port));\n        clientHelper1.SetAttribute(\"Remote\", remoteAddress);\n        clientApps1.Add(clientHelper1.Install(S2.Get(i)));\n        clientApps1.Start(i * flowStartupWindow / 20 + startTime + MilliSeconds(i * 5));\n        clientApps1.Stop(stopTime);\n    }\n\n    // Each sender in S1 and S3 sends to R1\n    std::vector<Ptr<PacketSink>> s1r1Sinks;\n    std::vector<Ptr<PacketSink>> s3r1Sinks;\n    s1r1Sinks.reserve(10);\n    s3r1Sinks.reserve(10);\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        uint16_t port = 50000 + i;\n        Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n        PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n        ApplicationContainer sinkApp = sinkHelper.Install(R1);\n        Ptr<PacketSink> packetSink = sinkApp.Get(0)->GetObject<PacketSink>();\n        if (i < 10)\n        {\n            s1r1Sinks.push_back(packetSink);\n        }\n        else\n        {\n            s3r1Sinks.push_back(packetSink);\n        }\n        sinkApp.Start(startTime);\n        sinkApp.Stop(stopTime);\n\n        OnOffHelper clientHelper1(\"ns3::TcpSocketFactory\", Address());\n        clientHelper1.SetAttribute(\"OnTime\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        clientHelper1.SetAttribute(\"OffTime\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n        clientHelper1.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"1Gbps\")));\n        clientHelper1.SetAttribute(\"PacketSize\", UintegerValue(1000));\n\n        ApplicationContainer clientApps1;\n        AddressValue remoteAddress(InetSocketAddress(ipR1T2.GetAddress(0), port));\n        clientHelper1.SetAttribute(\"Remote\", remoteAddress);\n        if (i < 10)\n        {\n            clientApps1.Add(clientHelper1.Install(S1.Get(i)));\n            clientApps1.Start(i * flowStartupWindow / 10 + startTime + MilliSeconds(i * 5));\n        }\n        else\n        {\n            clientApps1.Add(clientHelper1.Install(S3.Get(i - 10)));\n            clientApps1.Start((i - 10) * flowStartupWindow / 10 + startTime + MilliSeconds(i * 5));\n        }\n\n        clientApps1.Stop(stopTime);\n    }\n\n    rxS1R1Throughput.open(\"dctcp-example-s1-r1-throughput.dat\", std::ios::out);\n    rxS1R1Throughput << \"#Time(s) flow thruput(Mb/s)\" << std::endl;\n    rxS2R2Throughput.open(\"dctcp-example-s2-r2-throughput.dat\", std::ios::out);\n    rxS2R2Throughput << \"#Time(s) flow thruput(Mb/s)\" << std::endl;\n    rxS3R1Throughput.open(\"dctcp-example-s3-r1-throughput.dat\", std::ios::out);\n    rxS3R1Throughput << \"#Time(s) flow thruput(Mb/s)\" << std::endl;\n    fairnessIndex.open(\"dctcp-example-fairness.dat\", std::ios::out);\n    t1QueueLength.open(\"dctcp-example-t1-length.dat\", std::ios::out);\n    t1QueueLength << \"#Time(s) qlen(pkts) qlen(us)\" << std::endl;\n    t2QueueLength.open(\"dctcp-example-t2-length.dat\", std::ios::out);\n    t2QueueLength << \"#Time(s) qlen(pkts) qlen(us)\" << std::endl;\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        s1r1Sinks[i]->TraceConnectWithoutContext(\"Rx\", MakeBoundCallback(&TraceS1R1Sink, i));\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        r2Sinks[i]->TraceConnectWithoutContext(\"Rx\", MakeBoundCallback(&TraceS2R2Sink, i));\n    }\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        s3r1Sinks[i]->TraceConnectWithoutContext(\"Rx\", MakeBoundCallback(&TraceS3R1Sink, i));\n    }\n    Simulator::Schedule(flowStartupWindow + convergenceTime, &InitializeCounters);\n    Simulator::Schedule(flowStartupWindow + convergenceTime + measurementWindow,\n                        &PrintThroughput,\n                        measurementWindow);\n    Simulator::Schedule(flowStartupWindow + convergenceTime + measurementWindow,\n                        &PrintFairness,\n                        measurementWindow);\n    Simulator::Schedule(progressInterval, &PrintProgress, progressInterval);\n    Simulator::Schedule(flowStartupWindow + convergenceTime, &CheckT1QueueSize, queueDiscs1.Get(0));\n    Simulator::Schedule(flowStartupWindow + convergenceTime, &CheckT2QueueSize, queueDiscs2.Get(0));\n    Simulator::Stop(stopTime + TimeStep(1));\n\n    Simulator::Run();\n\n    rxS1R1Throughput.close();\n    rxS2R2Throughput.close();\n    rxS3R1Throughput.close();\n    fairnessIndex.close();\n    t1QueueLength.close();\n    t2QueueLength.close();\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 that generates a dataset of packet transmissions between nodes in a network. The program should simulate a wireless network with 5 nodes, where each node sends UDP traffic to a central server (node 4). The dataset should record the source node, destination node, packet size, transmission time, and reception time for each packet, and write this information into a CSV file."}, {"role": "assistant", "content": "I\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"DatasetExample\");\n\nvoid RecordPacketData(Ptr<FlowMonitor> flowMonitor, std::string filename)\n{\n    std::ofstream outFile;\n    outFile.open(filename, std::ios::out | std::ios::app);\n    outFile << \"FlowID,SrcAddr,DestAddr,PacketSize,TxTime,RxTime\\n\";  // CSV headers\n\n    // Retrieve statistics from flow monitor\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n    for (auto &flow : stats)\n    {\n        FlowId id = flow.first;\n        FlowMonitor::FlowStats flowStats = flow.second;\n        Ipv4FlowClassifier::FiveTuple t = flowMonitor->GetClassifier()->FindFlow(id);\n\n        for (uint32_t i = 0; i < flowStats.txPackets; i++)\n        {\n            outFile << id << \",\"\n                    << t.sourceAddress << \",\"\n                    << t.destinationAddress << \",\"\n                    << flowStats.txBytes << \",\"\n                    << flowStats.timeFirstTxPacket.GetSeconds() << \",\"\n                    << flowStats.timeLastRxPacket.GetSeconds() << \"\\n\";\n        }\n    }\n    outFile.close();\n}\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"DatasetExample\", LOG_LEVEL_INFO);\n\n    // Create 5 nodes\n    NodeContainer nodes;\n    nodes.Create(5);\n\n    // Configure WiFi channel and physical layer\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up the WiFi MAC layer for Ad-hoc networking\n    WifiHelper wifi;\n    WifiMacHelper mac;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the internet stack and assign IP addresses\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Setup UDP Echo server on node 4 (central server)\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(4));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup UDP Echo client on nodes 0, 1, 2, and 3 to send traffic to node 4\n    for (int i = 0; i < 4; i++)\n    {\n        UdpEchoClientHelper echoClient(interfaces.GetAddress(4), 9);\n        echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n        echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n        echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n        ApplicationContainer clientApp = echoClient.Install(nodes.Get(i));\n        clientApp.Start(Seconds(2.0));\n        clientApp.Stop(Seconds(10.0));\n    }\n\n    // Enable PCAP tracing\n    phy.EnablePcapAll(\"dataset-example\");\n\n    // Flow monitor to capture packet statistics\n    Ptr<FlowMonitor> flowMonitor;\n    FlowMonitorHelper flowHelper;\n    flowMonitor = flowHelper.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Record the dataset to a CSV file\n    RecordPacketData(flowMonitor, \"packet_dataset.csv\");\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite C++ code for a network simulation using ns-3 that builds a dumbbell topology with 7 senders and 1 receiver. The script should simulate both TCP and UDP traffic over a Point-to-Point link with different queue disciplines (COBALT and CoDel). Implement a congestion window trace for TCP and a queue size trace for each queue disc, saving the results in separate files. Ensure the simulation stops after a specified time and use helper classes for devices, links, and addressing. The code should include necessary ns-3 modules and implement the `experiment` function to run the simulation twice with the different queue discs."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/tcp-header.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <fstream>\n#include <string>\n\n// Dumbbell topology with 7 senders and 1 receiver\n// is used for this example. On successful completion,\n// the Congestion window and Queue size traces get stored\n// in MixTraffic/ directory, inside cwndTraces and\n// queueTraces sub-directories, respectively.\n\nusing namespace ns3;\n\nstd::string dir = \"MixTraffic/\";\n\nvoid\nCheckQueueSize(Ptr<QueueDisc> queue, std::string queue_disc_type)\n{\n    double qSize = queue->GetCurrentSize().GetValue();\n    // check queue size every 1/10 of a second\n    Simulator::Schedule(Seconds(0.1), &CheckQueueSize, queue, queue_disc_type);\n\n    std::ofstream fPlotQueue(dir + queue_disc_type + \"/queueTraces/queue.plotme\",\n                             std::ios::out | std::ios::app);\n    fPlotQueue << Simulator::Now().GetSeconds() << \" \" << qSize << std::endl;\n    fPlotQueue.close();\n}\n\nstatic void\nCwndTrace(Ptr<OutputStreamWrapper> stream, uint32_t oldCwnd, uint32_t newCwnd)\n{\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << newCwnd / 1446.0 << std::endl;\n}\n\nstatic void\nTraceCwnd(std::string queue_disc_type)\n{\n    for (uint8_t i = 0; i < 5; i++)\n    {\n        AsciiTraceHelper asciiTraceHelper;\n        Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream(\n            dir + queue_disc_type + \"/cwndTraces/S1-\" + std::to_string(i + 1) + \".plotme\");\n        Config::ConnectWithoutContext(\"/NodeList/\" + std::to_string(i) +\n                                          \"/$ns3::TcpL4Protocol/SocketList/0/CongestionWindow\",\n                                      MakeBoundCallback(&CwndTrace, stream));\n    }\n}\n\nvoid\nexperiment(std::string queue_disc_type)\n{\n    // Set the simulation stop time in seconds\n    double stopTime = 101;\n    std::string queue_disc = std::string(\"ns3::\") + queue_disc_type;\n\n    std::string bottleneckBandwidth = \"10Mbps\";\n    std::string bottleneckDelay = \"50ms\";\n\n    std::string accessBandwidth = \"10Mbps\";\n    std::string accessDelay = \"5ms\";\n\n    // Create sender\n    NodeContainer tcpSender;\n    tcpSender.Create(5);\n\n    NodeContainer udpSender;\n    udpSender.Create(2);\n\n    // Create gateway\n    NodeContainer gateway;\n    gateway.Create(2);\n\n    // Create sink\n    NodeContainer sink;\n    sink.Create(1);\n\n    Config::SetDefault(\"ns3::TcpSocket::SndBufSize\", UintegerValue(1 << 20));\n    Config::SetDefault(\"ns3::TcpSocket::RcvBufSize\", UintegerValue(1 << 20));\n    Config::SetDefault(\"ns3::TcpSocket::DelAckTimeout\", TimeValue(Seconds(0)));\n    Config::SetDefault(\"ns3::TcpSocket::InitialCwnd\", UintegerValue(1));\n    Config::SetDefault(\"ns3::TcpSocketBase::LimitedTransmit\", BooleanValue(false));\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(1446));\n    Config::SetDefault(\"ns3::TcpSocketBase::WindowScaling\", BooleanValue(true));\n    Config::SetDefault(queue_disc + \"::MaxSize\", QueueSizeValue(QueueSize(\"200p\")));\n\n    InternetStackHelper internet;\n    internet.InstallAll();\n\n    TrafficControlHelper tchPfifo;\n    uint16_t handle = tchPfifo.SetRootQueueDisc(\"ns3::PfifoFastQueueDisc\");\n    tchPfifo.AddInternalQueues(handle, 3, \"ns3::DropTailQueue\", \"MaxSize\", StringValue(\"1000p\"));\n\n    TrafficControlHelper tch;\n    tch.SetRootQueueDisc(queue_disc);\n\n    PointToPointHelper accessLink;\n    accessLink.SetDeviceAttribute(\"DataRate\", StringValue(accessBandwidth));\n    accessLink.SetChannelAttribute(\"Delay\", StringValue(accessDelay));\n\n    // Configure the senders and sinks net devices\n    // and the channels between the senders/sinks and the gateways\n    NetDeviceContainer devices[5];\n    for (uint8_t i = 0; i < 5; i++)\n    {\n        devices[i] = accessLink.Install(tcpSender.Get(i), gateway.Get(0));\n        tchPfifo.Install(devices[i]);\n    }\n\n    NetDeviceContainer devices_sink;\n    devices_sink = accessLink.Install(gateway.Get(1), sink.Get(0));\n    tchPfifo.Install(devices_sink);\n\n    PointToPointHelper bottleneckLink;\n    bottleneckLink.SetDeviceAttribute(\"DataRate\", StringValue(bottleneckBandwidth));\n    bottleneckLink.SetChannelAttribute(\"Delay\", StringValue(bottleneckDelay));\n\n    NetDeviceContainer devices_gateway;\n    devices_gateway = bottleneckLink.Install(gateway.Get(0), gateway.Get(1));\n    // Install QueueDisc at gateway\n    QueueDiscContainer queueDiscs = tch.Install(devices_gateway);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer interfaces[5];\n    Ipv4InterfaceContainer interfaces_sink;\n    Ipv4InterfaceContainer interfaces_gateway;\n    Ipv4InterfaceContainer udpinterfaces[2];\n\n    NetDeviceContainer udpdevices[2];\n\n    for (uint8_t i = 0; i < 5; i++)\n    {\n        address.NewNetwork();\n        interfaces[i] = address.Assign(devices[i]);\n    }\n\n    for (uint8_t i = 0; i < 2; i++)\n    {\n        udpdevices[i] = accessLink.Install(udpSender.Get(i), gateway.Get(0));\n        address.NewNetwork();\n        udpinterfaces[i] = address.Assign(udpdevices[i]);\n    }\n\n    address.NewNetwork();\n    interfaces_gateway = address.Assign(devices_gateway);\n\n    address.NewNetwork();\n    interfaces_sink = address.Assign(devices_sink);\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    uint16_t port = 50000;\n    uint16_t port1 = 50001;\n    Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    Address sinkLocalAddress1(InetSocketAddress(Ipv4Address::GetAny(), port1));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n    PacketSinkHelper sinkHelper1(\"ns3::UdpSocketFactory\", sinkLocalAddress1);\n\n    AddressValue remoteAddress(InetSocketAddress(interfaces_sink.GetAddress(1), port));\n    AddressValue remoteAddress1(InetSocketAddress(interfaces_sink.GetAddress(1), port1));\n\n    BulkSendHelper ftp(\"ns3::TcpSocketFactory\", Address());\n    ftp.SetAttribute(\"Remote\", remoteAddress);\n    ftp.SetAttribute(\"SendSize\", UintegerValue(1000));\n\n    ApplicationContainer sourceApp = ftp.Install(tcpSender);\n    sourceApp.Start(Seconds(0));\n    sourceApp.Stop(Seconds(stopTime - 1));\n\n    sinkHelper.SetAttribute(\"Protocol\", TypeIdValue(TcpSocketFactory::GetTypeId()));\n    ApplicationContainer sinkApp = sinkHelper.Install(sink);\n    sinkApp.Start(Seconds(0));\n    sinkApp.Stop(Seconds(stopTime));\n\n    OnOffHelper clientHelper6(\"ns3::UdpSocketFactory\", Address());\n    clientHelper6.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper6.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientHelper6.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"10Mb/s\")));\n    clientHelper6.SetAttribute(\"PacketSize\", UintegerValue(1000));\n\n    ApplicationContainer clientApps6;\n    clientHelper6.SetAttribute(\"Remote\", remoteAddress1);\n    clientApps6.Add(clientHelper6.Install(udpSender.Get(0)));\n    clientApps6.Start(Seconds(0));\n    clientApps6.Stop(Seconds(stopTime - 1));\n\n    OnOffHelper clientHelper7(\"ns3::UdpSocketFactory\", Address());\n    clientHelper7.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper7.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientHelper7.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"10Mb/s\")));\n    clientHelper7.SetAttribute(\"PacketSize\", UintegerValue(1000));\n\n    ApplicationContainer clientApps7;\n    clientHelper7.SetAttribute(\"Remote\", remoteAddress1);\n    clientApps7.Add(clientHelper7.Install(udpSender.Get(1)));\n    clientApps7.Start(Seconds(0));\n    clientApps7.Stop(Seconds(stopTime - 1));\n\n    sinkHelper1.SetAttribute(\"Protocol\", TypeIdValue(UdpSocketFactory::GetTypeId()));\n    ApplicationContainer sinkApp1 = sinkHelper1.Install(sink);\n    sinkApp1.Start(Seconds(0));\n    sinkApp1.Stop(Seconds(stopTime));\n\n    Ptr<QueueDisc> queue = queueDiscs.Get(0);\n    Simulator::ScheduleNow(&CheckQueueSize, queue, queue_disc_type);\n\n    std::string dirToSave = \"mkdir -p \" + dir + queue_disc_type;\n    if (system((dirToSave + \"/cwndTraces/\").c_str()) == -1 ||\n        system((dirToSave + \"/queueTraces/\").c_str()) == -1)\n    {\n        exit(1);\n    }\n\n    Simulator::Schedule(Seconds(0.1), &TraceCwnd, queue_disc_type);\n\n    Simulator::Stop(Seconds(stopTime));\n    Simulator::Run();\n    Simulator::Destroy();\n}\n\nint\nmain(int argc, char** argv)\n{\n    std::cout << \"Simulation with COBALT QueueDisc: Start\\n\" << std::flush;\n    experiment(\"CobaltQueueDisc\");\n    std::cout << \"Simulation with COBALT QueueDisc: End\\n\" << std::flush;\n    std::cout << \"------------------------------------------------\\n\";\n    std::cout << \"Simulation with CoDel QueueDisc: Start\\n\";\n    experiment(\"CoDelQueueDisc\");\n    std::cout << \"Simulation with CoDel QueueDisc: End\\n\";\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple simulation of an IEEE 802.11n Wi-Fi network using ns-3 with the ability to test different Wi-Fi PHY models like SpectrumWifiPhy and YansWifiPhy, configure various parameters such as simulation time, distance between nodes, and modulation and coding scheme (MCS) index, and log signal and noise information. It should also explain how to toggle between UDP and TCP traffic, capture packets if needed, and iterate through different MCS, channel widths, and guard intervals, reporting throughput, signal strength, noise, and SNR for each configuration."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/propagation-loss-model.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <iomanip>\n\n// This is a simple example of an IEEE 802.11n Wi-Fi network.\n//\n// The main use case is to enable and test SpectrumWifiPhy vs YansWifiPhy\n// for packet error ratio\n//\n// Network topology:\n//\n//  Wi-Fi 192.168.1.0\n//\n//   STA                  AP\n//    * <-- distance -->  *\n//    |                   |\n//    n1                  n2\n//\n// Users may vary the following command-line arguments in addition to the\n// attributes, global values, and default values typically available:\n//\n//    --simulationTime:  Simulation time [10s]\n//    --udp:             UDP if set to 1, TCP otherwise [true]\n//    --distance:        meters separation between nodes [50]\n//    --index:           restrict index to single value between 0 and 31 [256]\n//    --wifiType:        select ns3::SpectrumWifiPhy or ns3::YansWifiPhy [ns3::SpectrumWifiPhy]\n//    --errorModelType:  select ns3::NistErrorRateModel or ns3::YansErrorRateModel\n//    [ns3::NistErrorRateModel]\n//    --enablePcap:      enable pcap output [false]\n//\n// By default, the program will step through 32 index values, corresponding\n// to the following MCS, channel width, and guard interval combinations:\n//   index 0-7:    MCS 0-7, long guard interval, 20 MHz channel\n//   index 8-15:   MCS 0-7, short guard interval, 20 MHz channel\n//   index 16-23:  MCS 0-7, long guard interval, 40 MHz channel\n//   index 24-31:  MCS 0-7, short guard interval, 40 MHz channel\n// and send UDP for 10 seconds using each MCS, using the SpectrumWifiPhy and the\n// NistErrorRateModel, at a distance of 50 meters.  The program outputs\n// results such as:\n//\n// wifiType: ns3::SpectrumWifiPhy distance: 50m; time: 10; TxPower: 1 dBm (1.3 mW)\n// index   MCS  Rate (Mb/s) Tput (Mb/s) Received Signal (dBm) Noise (dBm) SNR (dB)\n//     0     0      6.50        5.77    7414      -79.71      -93.97       14.25\n//     1     1     13.00       11.58   14892      -79.71      -93.97       14.25\n//     2     2     19.50       17.39   22358      -79.71      -93.97       14.25\n//     3     3     26.00       22.96   29521      -79.71      -93.97       14.25\n//   ...\n//\n\nusing namespace ns3;\n\n// Global variables for use in callbacks.\ndouble g_signalDbmAvg; //!< Average signal power [dBm]\ndouble g_noiseDbmAvg;  //!< Average noise power [dBm]\nuint32_t g_samples;    //!< Number of samples\n\n/**\n * Monitor sniffer Rx trace\n *\n * \\param packet The sensed packet.\n * \\param channelFreqMhz The channel frequency [MHz].\n * \\param txVector The Tx vector.\n * \\param aMpdu The aMPDU.\n * \\param signalNoise The signal and noise dBm.\n * \\param staId The STA ID.\n */\nvoid\nMonitorSniffRx(Ptr<const Packet> packet,\n               uint16_t channelFreqMhz,\n               WifiTxVector txVector,\n               MpduInfo aMpdu,\n               SignalNoiseDbm signalNoise,\n               uint16_t staId)\n\n{\n    g_samples++;\n    g_signalDbmAvg += ((signalNoise.signal - g_signalDbmAvg) / g_samples);\n    g_noiseDbmAvg += ((signalNoise.noise - g_noiseDbmAvg) / g_samples);\n}\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSpectrumPerExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    bool udp{true};\n    meter_u distance{50};\n    Time simulationTime{\"10s\"};\n    uint16_t index{256};\n    std::string wifiType{\"ns3::SpectrumWifiPhy\"};\n    std::string errorModelType{\"ns3::NistErrorRateModel\"};\n    bool enablePcap{false};\n    const uint32_t tcpPacketSize{1448};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"udp\", \"UDP if set to 1, TCP otherwise\", udp);\n    cmd.AddValue(\"distance\", \"meters separation between nodes\", distance);\n    cmd.AddValue(\"index\", \"restrict index to single value between 0 and 31\", index);\n    cmd.AddValue(\"wifiType\", \"select ns3::SpectrumWifiPhy or ns3::YansWifiPhy\", wifiType);\n    cmd.AddValue(\"errorModelType\",\n                 \"select ns3::NistErrorRateModel or ns3::YansErrorRateModel\",\n                 errorModelType);\n    cmd.AddValue(\"enablePcap\", \"enable pcap output\", enablePcap);\n    cmd.Parse(argc, argv);\n\n    uint16_t startIndex = 0;\n    uint16_t stopIndex = 31;\n    if (index < 32)\n    {\n        startIndex = index;\n        stopIndex = index;\n    }\n\n    std::cout << \"wifiType: \" << wifiType << \" distance: \" << distance\n              << \"m; time: \" << simulationTime << \"; TxPower: 1 dBm (1.3 mW)\" << std::endl;\n    std::cout << std::setw(5) << \"index\" << std::setw(6) << \"MCS\" << std::setw(13) << \"Rate (Mb/s)\"\n              << std::setw(12) << \"Tput (Mb/s)\" << std::setw(10) << \"Received \" << std::setw(12)\n              << \"Signal (dBm)\" << std::setw(12) << \"Noise (dBm)\" << std::setw(9) << \"SNR (dB)\"\n              << std::endl;\n    for (uint16_t i = startIndex; i <= stopIndex; i++)\n    {\n        uint32_t payloadSize;\n        if (udp)\n        {\n            payloadSize = 972; // 1000 bytes IPv4\n        }\n        else\n        {\n            payloadSize = 1448; // 1500 bytes IPv6\n            Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n        }\n\n        NodeContainer wifiStaNode;\n        wifiStaNode.Create(1);\n        NodeContainer wifiApNode;\n        wifiApNode.Create(1);\n\n        YansWifiPhyHelper yansPhy;\n        SpectrumWifiPhyHelper spectrumPhy;\n        if (wifiType == \"ns3::YansWifiPhy\")\n        {\n            YansWifiChannelHelper channel;\n            channel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\",\n                                       \"Frequency\",\n                                       DoubleValue(5.180e9));\n            channel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n            yansPhy.SetChannel(channel.Create());\n            yansPhy.Set(\"TxPowerStart\", DoubleValue(1)); // dBm (1.26 mW)\n            yansPhy.Set(\"TxPowerEnd\", DoubleValue(1));\n        }\n        else if (wifiType == \"ns3::SpectrumWifiPhy\")\n        {\n            Ptr<MultiModelSpectrumChannel> spectrumChannel =\n                CreateObject<MultiModelSpectrumChannel>();\n            Ptr<FriisPropagationLossModel> lossModel = CreateObject<FriisPropagationLossModel>();\n            lossModel->SetFrequency(5.180e9);\n            spectrumChannel->AddPropagationLossModel(lossModel);\n\n            Ptr<ConstantSpeedPropagationDelayModel> delayModel =\n                CreateObject<ConstantSpeedPropagationDelayModel>();\n            spectrumChannel->SetPropagationDelayModel(delayModel);\n\n            spectrumPhy.SetChannel(spectrumChannel);\n            spectrumPhy.SetErrorRateModel(errorModelType);\n            spectrumPhy.Set(\"TxPowerStart\", DoubleValue(1)); // dBm  (1.26 mW)\n            spectrumPhy.Set(\"TxPowerEnd\", DoubleValue(1));\n        }\n        else\n        {\n            NS_FATAL_ERROR(\"Unsupported WiFi type \" << wifiType);\n        }\n\n        WifiHelper wifi;\n        wifi.SetStandard(WIFI_STANDARD_80211n);\n        WifiMacHelper mac;\n\n        Ssid ssid = Ssid(\"ns380211n\");\n\n        double datarate = 0;\n        StringValue DataRate;\n        if (i == 0)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 6.5;\n        }\n        else if (i == 1)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 13;\n        }\n        else if (i == 2)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 19.5;\n        }\n        else if (i == 3)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 26;\n        }\n        else if (i == 4)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 39;\n        }\n        else if (i == 5)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 52;\n        }\n        else if (i == 6)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 58.5;\n        }\n        else if (i == 7)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 65;\n        }\n        else if (i == 8)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 7.2;\n        }\n        else if (i == 9)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 14.4;\n        }\n        else if (i == 10)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 21.7;\n        }\n        else if (i == 11)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 28.9;\n        }\n        else if (i == 12)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 43.3;\n        }\n        else if (i == 13)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 57.8;\n        }\n        else if (i == 14)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 65;\n        }\n        else if (i == 15)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 72.2;\n        }\n        else if (i == 16)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 13.5;\n        }\n        else if (i == 17)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 27;\n        }\n        else if (i == 18)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 40.5;\n        }\n        else if (i == 19)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 54;\n        }\n        else if (i == 20)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 81;\n        }\n        else if (i == 21)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 108;\n        }\n        else if (i == 22)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 121.5;\n        }\n        else if (i == 23)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 135;\n        }\n        else if (i == 24)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 15;\n        }\n        else if (i == 25)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 30;\n        }\n        else if (i == 26)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 45;\n        }\n        else if (i == 27)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 60;\n        }\n        else if (i == 28)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 90;\n        }\n        else if (i == 29)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 120;\n        }\n        else if (i == 30)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 135;\n        }\n        else\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 150;\n        }\n\n        wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                     \"DataMode\",\n                                     DataRate,\n                                     \"ControlMode\",\n                                     DataRate);\n\n        NetDeviceContainer staDevice;\n        NetDeviceContainer apDevice;\n\n        if (wifiType == \"ns3::YansWifiPhy\")\n        {\n            mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n            yansPhy.Set(\n                \"ChannelSettings\",\n                StringValue(std::string(\"{0, \") + (i <= 15 ? \"20\" : \"40\") + \", BAND_5GHZ, 0}\"));\n            staDevice = wifi.Install(yansPhy, mac, wifiStaNode);\n            mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n            apDevice = wifi.Install(yansPhy, mac, wifiApNode);\n        }\n        else if (wifiType == \"ns3::SpectrumWifiPhy\")\n        {\n            mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n            spectrumPhy.Set(\n                \"ChannelSettings\",\n                StringValue(std::string(\"{0, \") + (i <= 15 ? \"20\" : \"40\") + \", BAND_5GHZ, 0}\"));\n            staDevice = wifi.Install(spectrumPhy, mac, wifiStaNode);\n            mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n            apDevice = wifi.Install(spectrumPhy, mac, wifiApNode);\n        }\n\n        bool shortGuardIntervalSupported = (i > 7 && i <= 15) || (i > 23);\n        Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/\"\n                    \"ShortGuardIntervalSupported\",\n                    BooleanValue(shortGuardIntervalSupported));\n\n        // mobility.\n        MobilityHelper mobility;\n        Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n        positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n        positionAlloc->Add(Vector(distance, 0.0, 0.0));\n        mobility.SetPositionAllocator(positionAlloc);\n\n        mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n        mobility.Install(wifiApNode);\n        mobility.Install(wifiStaNode);\n\n        /* Internet stack*/\n        InternetStackHelper stack;\n        stack.Install(wifiApNode);\n        stack.Install(wifiStaNode);\n\n        Ipv4AddressHelper address;\n        address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer staNodeInterface;\n        Ipv4InterfaceContainer apNodeInterface;\n\n        staNodeInterface = address.Assign(staDevice);\n        apNodeInterface = address.Assign(apDevice);\n\n        /* Setting applications */\n        ApplicationContainer serverApp;\n        if (udp)\n        {\n            // UDP flow\n            uint16_t port = 9;\n            UdpServerHelper server(port);\n            serverApp = server.Install(wifiStaNode.Get(0));\n            serverApp.Start(Seconds(0.0));\n            serverApp.Stop(simulationTime + Seconds(1.0));\n            const auto packetInterval = payloadSize * 8.0 / (datarate * 1e6);\n\n            UdpClientHelper client(staNodeInterface.GetAddress(0), port);\n            client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n            client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n            client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n            ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n            clientApp.Start(Seconds(1.0));\n            clientApp.Stop(simulationTime + Seconds(1.0));\n        }\n        else\n        {\n            // TCP flow\n            uint16_t port = 50000;\n            Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n            PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n            serverApp = packetSinkHelper.Install(wifiStaNode.Get(0));\n            serverApp.Start(Seconds(0.0));\n            serverApp.Stop(simulationTime + Seconds(1.0));\n\n            OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n            onoff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n            onoff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n            onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n            onoff.SetAttribute(\"DataRate\", DataRateValue(datarate * 1e6));\n            AddressValue remoteAddress(InetSocketAddress(staNodeInterface.GetAddress(0), port));\n            onoff.SetAttribute(\"Remote\", remoteAddress);\n            ApplicationContainer clientApp = onoff.Install(wifiApNode.Get(0));\n            clientApp.Start(Seconds(1.0));\n            clientApp.Stop(simulationTime + Seconds(1.0));\n        }\n\n        Config::ConnectWithoutContext(\"/NodeList/0/DeviceList/*/Phy/MonitorSnifferRx\",\n                                      MakeCallback(&MonitorSniffRx));\n\n        if (enablePcap)\n        {\n            auto& phy = wifiType == \"ns3::YansWifiPhy\" ? dynamic_cast<WifiPhyHelper&>(yansPhy)\n                                                       : dynamic_cast<WifiPhyHelper&>(spectrumPhy);\n\n            phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n            std::stringstream ss;\n            ss << \"wifi-spectrum-per-example-\" << i;\n            phy.EnablePcap(ss.str(), apDevice);\n        }\n\n        g_signalDbmAvg = 0;\n        g_noiseDbmAvg = 0;\n        g_samples = 0;\n\n        Simulator::Stop(simulationTime + Seconds(1.0));\n        Simulator::Run();\n\n        auto throughput = 0.0;\n        uint64_t totalPacketsThrough = 0;\n        if (udp)\n        {\n            // UDP\n            totalPacketsThrough = DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n            throughput =\n                totalPacketsThrough * payloadSize * 8 / simulationTime.GetMicroSeconds(); // Mbit/s\n        }\n        else\n        {\n            // TCP\n            auto totalBytesRx = DynamicCast<PacketSink>(serverApp.Get(0))->GetTotalRx();\n            totalPacketsThrough = static_cast<uint64_t>(totalBytesRx / tcpPacketSize);\n            throughput = totalBytesRx * 8 / simulationTime.GetMicroSeconds(); // Mbit/s\n        }\n        std::cout << std::setw(5) << i << std::setw(6) << (i % 8) << std::setprecision(2)\n                  << std::fixed << std::setw(10) << datarate << std::setw(12) << throughput\n                  << std::setw(8) << totalPacketsThrough;\n        if (totalPacketsThrough > 0)\n        {\n            std::cout << std::setw(12) << g_signalDbmAvg << std::setw(12) << g_noiseDbmAvg\n                      << std::setw(12) << (g_signalDbmAvg - g_noiseDbmAvg) << std::endl;\n        }\n        else\n        {\n            std::cout << std::setw(12) << \"N/A\" << std::setw(12) << \"N/A\" << std::setw(12) << \"N/A\"\n                      << std::endl;\n        }\n        Simulator::Destroy();\n    }\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library that simulates an IPv6 network topology with two segments. The network consists of three nodes (Src, n0, r, n1, Dst), where the link between `n0` and `r` has an MTU of 5000, and the link between `r` and `n1` has an MTU of 1500. Set up a CSMA network, install IPv6 internet stacks, assign IPv6 addresses, and enable forwarding and routing. Implement UDP echo client-server applications, sending packets from `n0` to `n1` through the router. Enable tracing of queues and packet receptions to a file named 'fragmentation-ipv6-two-mtu.tr'."}, {"role": "assistant", "content": "// Network topology\n// //\n// //     Src     n0   r    n1    Dst\n// //             |    _    |\n// //     MTU     ====|_|====     MTU\n// //     5000       router       1500\n// //\n// // - Tracing of queues and packet receptions to file \"fragmentation-ipv6-two-mtu.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"FragmentationIpv6TwoMtuExample\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_ALL);\n    }\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> n0 = CreateObject<Node>();\n    Ptr<Node> r = CreateObject<Node>();\n    Ptr<Node> n1 = CreateObject<Node>();\n\n    NodeContainer net1(n0, r);\n    NodeContainer net2(r, n1);\n    NodeContainer all(n0, r, n1);\n\n    NS_LOG_INFO(\"Create IPv6 Internet Stack\");\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d2 = csma.Install(net2);\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(5000));\n    NetDeviceContainer d1 = csma.Install(net1);\n\n    NS_LOG_INFO(\"Create networks and assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i1 = ipv6.Assign(d1);\n    i1.SetForwarding(1, true);\n    i1.SetDefaultRouteInAllNodes(1);\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i2 = ipv6.Assign(d2);\n    i2.SetForwarding(0, true);\n    i2.SetDefaultRouteInAllNodes(0);\n\n    Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);\n    Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(0), n0, routingStream);\n\n    /* Create a UdpEchoClient and UdpEchoServer application to send packets from n0 to n1 via r */\n    uint32_t packetSize = 4096;\n    uint32_t maxPacketCount = 5;\n\n    UdpEchoClientHelper echoClient(i2.GetAddress(1, 1), 42);\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    ApplicationContainer clientApps = echoClient.Install(net1.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(20.0));\n\n    UdpEchoServerHelper echoServer(42);\n    ApplicationContainer serverApps = echoServer.Install(net2.Get(1));\n    serverApps.Start(Seconds(0.0));\n    serverApps.Stop(Seconds(30.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"fragmentation-ipv6-two-mtu.tr\"));\n    csma.EnablePcapAll(std::string(\"fragmentation-ipv6-two-mtu\"), true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple Wi-Fi network. The network should have one station (STA) and one access point (AP). Use the AARF Wi-Fi manager and configure the STA to associate with an SSID named 'ns3-wifi'. The nodes should be placed on a grid using a position allocator. Assign an IPv4 address range of 192.168.1.0/24. The AP should run a UDP echo server on port 9, and the STA should send a single packet of 1024 bytes. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    NodeContainer wifiStaNode, wifiApNode;\n    wifiStaNode.Create(1);\n    wifiApNode.Create(1);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNode);\n    mobility.Install(wifiApNode);\n\n    InternetStackHelper stack;\n    stack.Install(wifiStaNode);\n    stack.Install(wifiApNode);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer staInterface = address.Assign(staDevice);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(wifiApNode.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(apInterface.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(wifiStaNode.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate code that validates NIST, YANS, and Table-based error rate models for VHT (Very High Throughput) rates in NS-3. The program should calculate and plot the Frame Success Rate versus Signal-to-Noise Ratio (SNR) for all VHT MCS values, excluding MCS 9 for 20 MHz channels, for each error rate model. The output should include separate plots using Gnuplot for each mode, and the frame size should be configurable through command-line input. SNR should range from -5 dB to 30 dB."}, {"role": "assistant", "content": "// This example is used to validate Nist, Yans and Table-based error rate models for VHT rates.\n//\n// It outputs plots of the Frame Success Rate versus the Signal-to-noise ratio for\n// Nist, Yans and Table-based error rate models and for every VHT MCS value (MCS 9 is not\n// included since it is forbidden for 20 MHz channels).\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t frameSizeBytes = 1500;\n    std::ofstream yansfile(\"yans-frame-success-rate-ac.plt\");\n    std::ofstream nistfile(\"nist-frame-success-rate-ac.plt\");\n    std::ofstream tablefile(\"table-frame-success-rate-ac.plt\");\n\n    const std::vector<std::string> modes{\n        \"VhtMcs0\",\n        \"VhtMcs1\",\n        \"VhtMcs2\",\n        \"VhtMcs3\",\n        \"VhtMcs4\",\n        \"VhtMcs5\",\n        \"VhtMcs6\",\n        \"VhtMcs7\",\n        \"VhtMcs8\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"FrameSize\", \"The frame size in bytes\", frameSizeBytes);\n    cmd.Parse(argc, argv);\n\n    Gnuplot yansplot = Gnuplot(\"yans-frame-success-rate-ac.eps\");\n    Gnuplot nistplot = Gnuplot(\"nist-frame-success-rate-ac.eps\");\n    Gnuplot tableplot = Gnuplot(\"table-frame-success-rate-ac.eps\");\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n    WifiTxVector txVector;\n\n    uint32_t frameSizeBits = frameSizeBytes * 8;\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset yansdataset(mode);\n        Gnuplot2dDataset nistdataset(mode);\n        Gnuplot2dDataset tabledataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -5.0; snrDb <= 30.0; snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double ps = yans->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            yansdataset.Add(snrDb, ps);\n\n            ps = nist->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            nistdataset.Add(snrDb, ps);\n\n            ps = table->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            tabledataset.Add(snrDb, ps);\n        }\n\n        yansplot.AddDataset(yansdataset);\n        nistplot.AddDataset(nistdataset);\n        tableplot.AddDataset(tabledataset);\n    }\n\n    yansplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    yansplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    yansplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style increment user\");\n    yansplot.GenerateOutput(yansfile);\n    yansfile.close();\n\n    nistplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    nistplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    nistplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style increment user\");\n\n    nistplot.GenerateOutput(nistfile);\n    nistfile.close();\n\n    tableplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    tableplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    tableplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style increment user\");\n\n    tableplot.GenerateOutput(tablefile);\n    tablefile.close();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and organizes them in a mesh topology. Each node should be connected to every other node using Point-to-Point links. The program should print confirmation of all established connections. Keep the example simple, focusing only on node creation and topology setup"}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"MeshTopologyExample\", LOG_LEVEL_INFO);\n\n    // Define the number of nodes in the mesh\n    uint32_t numNodes = 4;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(numNodes);\n\n    // Point-to-Point Helper\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create full mesh connections\n    for (uint32_t i = 0; i < numNodes; ++i) {\n        for (uint32_t j = i + 1; j < numNodes; ++j) {\n            NodeContainer link(nodes.Get(i), nodes.Get(j));\n            NetDeviceContainer devices = p2p.Install(link);\n            NS_LOG_INFO(\"Connected Node \" << i << \" to Node \" << j);\n        }\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple Wi-Fi network in NS-3 with two nodes: Node 1 as the AP (Access Point) and Node 2 as the STA (Station). Node 2 sends UDP packets to Node 1 using Wi-Fi communication. Node 2 should move randomly within a specified area while Node 1 remains stationary. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer ap, sta;\n    ap.Create(1);\n    sta.Create(1);\n\n    // Install Wi-Fi devices on the nodes\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\", SsidValue(Ssid(\"wifi-network\")));\n\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, ap);\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(Ssid(\"wifi-network\")));\n    NetDeviceContainer staDevice = wifi.Install(phy, mac, sta);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(ap);\n    internet.Install(sta);\n\n    // Set up mobility model for nodes\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(ap);\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(sta);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper ipv4Address;\n    ipv4Address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apIpIface = ipv4Address.Assign(apDevice);\n    Ipv4InterfaceContainer staIpIface = ipv4Address.Assign(staDevice);\n\n    // Set up UDP client application on Node 2 (STA)\n    uint16_t port = 9;\n    UdpClientHelper udpClient(staIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(ap.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on Node 1 (AP)\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(sta.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 to simulate a simple three-router network with global routing. Set up a point-to-point network between three nodes (A, B, C), with node A having a /32 host route, node B handling transit routing, and node C having its own /32 host route. Assign point-to-point links between A-B and B-C, configure global and static routing for the network, and inject routes at node B. Implement an OnOff UDP application at node A to send traffic to node C, and include packet tracing and PCAP capturing functionality."}, {"role": "assistant", "content": "// Test program for this 3-router scenario, using global routing\n//\n// (a.a.a.a/32)A<--x.x.x.0/30-->B<--y.y.y.0/30-->C(c.c.c.c/32)\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-net-device.h\"\n#include \"ns3/global-router-interface.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/ipv4-global-routing.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ipv4-list-routing.h\"\n#include \"ns3/ipv4-routing-table-entry.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/ipv4-static-routing.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\nusing std::cout;\n\nNS_LOG_COMPONENT_DEFINE(\"GlobalRouterInjectionTest\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Ptr<Node> nA = CreateObject<Node>();\n    Ptr<Node> nB = CreateObject<Node>();\n    Ptr<Node> nC = CreateObject<Node>();\n\n    NodeContainer c = NodeContainer(nA, nB, nC);\n\n    InternetStackHelper internet;\n\n    // Point-to-point links\n    NodeContainer nAnB = NodeContainer(nA, nB);\n    NodeContainer nBnC = NodeContainer(nB, nC);\n\n    internet.Install(nAnB);\n    Ipv4ListRoutingHelper staticonly;\n    Ipv4ListRoutingHelper staticRouting;\n    staticonly.Add(staticRouting, 0);\n    internet.SetRoutingHelper(staticonly); // has effect on the next Install ()\n    internet.Install(NodeContainer(nC));\n\n    // We create the channels first without any IP addressing information\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer dAdB = p2p.Install(nAnB);\n\n    NetDeviceContainer dBdC = p2p.Install(nBnC);\n\n    Ptr<CsmaNetDevice> deviceA = CreateObject<CsmaNetDevice>();\n    deviceA->SetAddress(Mac48Address::Allocate());\n    nA->AddDevice(deviceA);\n    deviceA->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    Ptr<CsmaNetDevice> deviceC = CreateObject<CsmaNetDevice>();\n    deviceC->SetAddress(Mac48Address::Allocate());\n    nC->AddDevice(deviceC);\n    deviceC->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    // Later, we add IP addresses.\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iAiB = ipv4.Assign(dAdB);\n\n    ipv4.SetBase(\"10.1.1.4\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iBiC = ipv4.Assign(dBdC);\n\n    Ptr<Ipv4> ipv4A = nA->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4B = nB->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4C = nC->GetObject<Ipv4>();\n\n    int32_t ifIndexA = ipv4A->AddInterface(deviceA);\n    int32_t ifIndexC = ipv4C->AddInterface(deviceC);\n\n    Ipv4InterfaceAddress ifInAddrA =\n        Ipv4InterfaceAddress(Ipv4Address(\"172.16.1.1\"), Ipv4Mask(\"255.255.255.255\"));\n    ipv4A->AddAddress(ifIndexA, ifInAddrA);\n    ipv4A->SetMetric(ifIndexA, 1);\n    ipv4A->SetUp(ifIndexA);\n\n    Ipv4InterfaceAddress ifInAddrC =\n        Ipv4InterfaceAddress(Ipv4Address(\"192.168.1.1\"), Ipv4Mask(\"255.255.255.255\"));\n    ipv4C->AddAddress(ifIndexC, ifInAddrC);\n    ipv4C->SetMetric(ifIndexC, 1);\n    ipv4C->SetUp(ifIndexC);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n\n    // Populate routing tables for nodes nA and nB\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n    // Inject global routes from Node B, including transit network...\n    Ptr<GlobalRouter> globalRouterB = nB->GetObject<GlobalRouter>();\n    globalRouterB->InjectRoute(\"10.1.1.4\", \"255.255.255.252\");\n    // ...and the host in network \"C\"\n    globalRouterB->InjectRoute(\"192.168.1.1\", \"255.255.255.255\");\n\n    Ipv4GlobalRoutingHelper::RecomputeRoutingTables();\n    // In addition, nB needs a static route to nC so it knows what to do with stuff\n    // going to 192.168.1.1\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> staticRoutingB = ipv4RoutingHelper.GetStaticRouting(ipv4B);\n    staticRoutingB->AddHostRouteTo(Ipv4Address(\"192.168.1.1\"), Ipv4Address(\"10.1.1.6\"), 2);\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(ifInAddrC.GetLocal(), port)));\n    onoff.SetConstantRate(DataRate(6000));\n    ApplicationContainer apps = onoff.Install(nA);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(nC);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"global-routing-injection32.tr\"));\n    p2p.EnablePcapAll(\"global-routing-injection32\");\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Point-to-Point (P2P) wired network with two nodes connected via a 10 Mbps link with 2 ms delay. The first node should run a TCP client using the OnOff application, sending 1024-byte packets at a 5 Mbps data rate to the second node, which runs a TCP server. The simulation should assign IP addresses in the 192.168.1.0/24 subnet, with the server on 192.168.1.2. The server starts at 1 second, and the client starts at 2 seconds. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"PointToPointTcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure a Point-to-Point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a TCP server on node 1\n    uint16_t port = 8080;\n    PacketSinkHelper tcpServer(\"ns3::TcpSocketFactory\",\n                               InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up a TCP client on node 0\n    OnOffHelper tcpClient(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(interfaces.GetAddress(1), port));\n    tcpClient.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    tcpClient.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    tcpClient.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nProvide code for a simple NS-3 simulation that configures an IEEE 802.11n Wi-Fi network with multiple Traffic Operation Set (TOS) values. The simulation should allow the user to specify the number of stations, HT MCS value (0 to 7), channel width (20 or 40 MHz), guard interval (long or short), distance between stations and the access point, and whether RTS/CTS is used. The code should calculate and output the aggregated UDP throughput based on these parameters."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This is a simple example in order to show how to configure an IEEE 802.11n Wi-Fi network\n// with multiple TOS. It outputs the aggregated UDP throughput, which depends on the number of\n// stations, the HT MCS value (0 to 7), the channel width (20 or 40 MHz) and the guard interval\n// (long or short). The user can also specify the distance between the access point and the\n// stations (in meters), and can specify whether RTS/CTS is used or not.\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiMultiTos\");\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t nWifi{4};\n    Time simulationTime{\"10s\"};\n    meter_u distance{1.0};\n    uint16_t mcs{7};\n    uint8_t channelWidth{20}; // MHz\n    bool useShortGuardInterval{false};\n    bool useRts{false};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nWifi\", \"Number of stations\", nWifi);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the stations and the access point\",\n                 distance);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"useRts\", \"Enable/disable RTS/CTS\", useRts);\n    cmd.AddValue(\"mcs\", \"MCS value (0 - 7)\", mcs);\n    cmd.AddValue(\"channelWidth\", \"Channel width in MHz\", channelWidth);\n    cmd.AddValue(\"useShortGuardInterval\",\n                 \"Enable/disable short guard interval\",\n                 useShortGuardInterval);\n    cmd.Parse(argc, argv);\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(nWifi);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n\n    std::ostringstream oss;\n    oss << \"HtMcs\" << mcs;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(oss.str()),\n                                 \"ControlMode\",\n                                 StringValue(oss.str()),\n                                 \"RtsCtsThreshold\",\n                                 UintegerValue(useRts ? 0 : 999999));\n\n    Ssid ssid = Ssid(\"ns3-80211n\");\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set channel width\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/ChannelSettings\",\n                StringValue(\"{0, \" + std::to_string(channelWidth) + \", BAND_2_4GHZ, 0}\"));\n\n    // Set guard interval\n    Config::Set(\n        \"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/ShortGuardIntervalSupported\",\n        BooleanValue(useShortGuardInterval));\n\n    // mobility\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    for (uint32_t i = 0; i < nWifi; i++)\n    {\n        positionAlloc->Add(Vector(distance, 0.0, 0.0));\n    }\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNodes);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n    Ipv4AddressHelper address;\n\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staNodeInterfaces;\n    Ipv4InterfaceContainer apNodeInterface;\n\n    staNodeInterfaces = address.Assign(staDevices);\n    apNodeInterface = address.Assign(apDevice);\n\n    // Setting applications\n    ApplicationContainer sourceApplications;\n    ApplicationContainer sinkApplications;\n    std::vector<uint8_t> tosValues = {0x70, 0x28, 0xb8, 0xc0}; // AC_BE, AC_BK, AC_VI, AC_VO\n    uint32_t portNumber = 9;\n    for (uint32_t index = 0; index < nWifi; ++index)\n    {\n        for (uint8_t tosValue : tosValues)\n        {\n            auto ipv4 = wifiApNode.Get(0)->GetObject<Ipv4>();\n            const auto address = ipv4->GetAddress(1, 0).GetLocal();\n            InetSocketAddress sinkSocket(address, portNumber++);\n            OnOffHelper onOffHelper(\"ns3::UdpSocketFactory\", sinkSocket);\n            onOffHelper.SetAttribute(\"OnTime\",\n                                     StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n            onOffHelper.SetAttribute(\"OffTime\",\n                                     StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n            onOffHelper.SetAttribute(\"DataRate\", DataRateValue(50000000 / nWifi));\n            onOffHelper.SetAttribute(\"PacketSize\", UintegerValue(1472)); // bytes\n            onOffHelper.SetAttribute(\"Tos\", UintegerValue(tosValue));\n            sourceApplications.Add(onOffHelper.Install(wifiStaNodes.Get(index)));\n            PacketSinkHelper packetSinkHelper(\"ns3::UdpSocketFactory\", sinkSocket);\n            sinkApplications.Add(packetSinkHelper.Install(wifiApNode.Get(0)));\n        }\n    }\n\n    sinkApplications.Start(Seconds(0.0));\n    sinkApplications.Stop(simulationTime + Seconds(1.0));\n    sourceApplications.Start(Seconds(1.0));\n    sourceApplications.Stop(simulationTime + Seconds(1.0));\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    Simulator::Stop(simulationTime + Seconds(1.0));\n    Simulator::Run();\n\n    double throughput = 0;\n    for (uint32_t index = 0; index < sinkApplications.GetN(); ++index)\n    {\n        double totalPacketsThrough =\n            DynamicCast<PacketSink>(sinkApplications.Get(index))->GetTotalRx();\n        throughput += ((totalPacketsThrough * 8) / simulationTime.GetMicroSeconds()); // Mbit/s\n    }\n\n    Simulator::Destroy();\n\n    if (throughput > 0)\n    {\n        std::cout << \"Aggregated throughput: \" << throughput << \" Mbit/s\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Obtained throughput is 0!\" << std::endl;\n        exit(1);\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network with three Access Points (APs) and six stations (STA) using the ns-3 simulator. Distribute the stations across the APs and set up UDP traffic flows between the stations and a remote server. Visualize the network in NetAnim and include mobility for the stations to simulate movement between the access points."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimulationExample\");\n\nint main(int argc, char *argv[])\n{\n    double simulationTime = 10.0;\n\n    // Create nodes for Access Points (AP) and Stations (STA)\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(3); // 3 Access Points\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(6); // 6 Stations\n\n    // Create Wi-Fi Helper and configure the PHY and MAC layers\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n\n    YansWifiPhyHelper phyHelper = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channelHelper = YansWifiChannelHelper::Default();\n    phyHelper.SetChannel(channelHelper.Create());\n\n    WifiMacHelper macHelper;\n    Ssid ssid1 = Ssid(\"AP1-SSID\");\n    Ssid ssid2 = Ssid(\"AP2-SSID\");\n    Ssid ssid3 = Ssid(\"AP3-SSID\");\n\n    // Install Wi-Fi devices on the APs\n    NetDeviceContainer apDevices1, apDevices2, apDevices3;\n    macHelper.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid1));\n    apDevices1 = wifiHelper.Install(phyHelper, macHelper, wifiApNodes.Get(0));\n    \n    macHelper.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid2));\n    apDevices2 = wifiHelper.Install(phyHelper, macHelper, wifiApNodes.Get(1));\n    \n    macHelper.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid3));\n    apDevices3 = wifiHelper.Install(phyHelper, macHelper, wifiApNodes.Get(2));\n\n    // Install Wi-Fi devices on the STAs\n    NetDeviceContainer staDevices1, staDevices2, staDevices3;\n    macHelper.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid1));\n    staDevices1 = wifiHelper.Install(phyHelper, macHelper, wifiStaNodes.Get(0));\n    staDevices1.Add(wifiHelper.Install(phyHelper, macHelper, wifiStaNodes.Get(1)));\n\n    macHelper.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid2));\n    staDevices2 = wifiHelper.Install(phyHelper, macHelper, wifiStaNodes.Get(2));\n    staDevices2.Add(wifiHelper.Install(phyHelper, macHelper, wifiStaNodes.Get(3)));\n\n    macHelper.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid3));\n    staDevices3 = wifiHelper.Install(phyHelper, macHelper, wifiStaNodes.Get(4));\n    staDevices3.Add(wifiHelper.Install(phyHelper, macHelper, wifiStaNodes.Get(5)));\n\n    // Install mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNodes);\n    \n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(wifiStaNodes);\n\n    // Install Internet stack on all nodes\n    InternetStackHelper internet;\n    internet.Install(wifiApNodes);\n    internet.Install(wifiStaNodes);\n\n    // Assign IP addresses to all devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apInterfaces1 = ipv4.Assign(apDevices1);\n    Ipv4InterfaceContainer staInterfaces1 = ipv4.Assign(staDevices1);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apInterfaces2 = ipv4.Assign(apDevices2);\n    Ipv4InterfaceContainer staInterfaces2 = ipv4.Assign(staDevices2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apInterfaces3 = ipv4.Assign(apDevices3);\n    Ipv4InterfaceContainer staInterfaces3 = ipv4.Assign(staDevices3);\n\n    // Set up UDP server on one of the stations\n    uint16_t port = 9; // Discard port (just for testing)\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Set up UDP client to send traffic to the server\n    UdpClientHelper client(staInterfaces1.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    client.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = client.Install(wifiStaNodes.Get(5)); // Another station sends traffic\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Enable NetAnim tracing\n    AnimationInterface anim(\"wifi_netanim.xml\");\n    anim.SetConstantPosition(wifiApNodes.Get(0), 0.0, 0.0);\n    anim.SetConstantPosition(wifiApNodes.Get(1), 10.0, 0.0);\n    anim.SetConstantPosition(wifiApNodes.Get(2), 20.0, 0.0);\n    \n    // Run simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a single node broadcasts UDP packets to multiple receiver nodes over a Wi-Fi network. The receivers should log when they receive a packet. Keep the setup simple, with basic Wi-Fi configuration and no mobility."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpBroadcastExample\");\n\n// Function to log received packets\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Receiver received a broadcast packet!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"UdpBroadcastExample\", LOG_LEVEL_INFO);\n\n    int numReceivers = 3;\n    uint16_t port = 4000;\n\n    // Create nodes (1 sender + multiple receivers)\n    NodeContainer wifiNodes;\n    wifiNodes.Create(numReceivers + 1);\n\n    NodeContainer senderNode = wifiNodes.Get(0); // First node is the sender\n\n    // Set up Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"udp-broadcast-network\");\n    mac.SetType(\"ns3::AdhocWifiMac\"); // Ad hoc mode for broadcasting\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, wifiNodes);\n\n    // Mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Setup UDP Broadcast Sender\n    Ptr<Socket> senderSocket = Socket::CreateSocket(senderNode, UdpSocketFactory::GetTypeId());\n    Ipv4Address broadcastAddress(\"192.168.1.255\"); // Broadcast address\n    InetSocketAddress remote = InetSocketAddress(broadcastAddress, port);\n\n    // Schedule broadcast packet transmission\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, senderSocket, Create<Packet>(128), 0, remote);\n\n    // Setup Receivers\n    for (int i = 1; i <= numReceivers; i++) {\n        Ptr<Socket> receiverSocket = Socket::CreateSocket(wifiNodes.Get(i), UdpSocketFactory::GetTypeId());\n        receiverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n        receiverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(2.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a UDP client communicates with a server over a wireless (Wi-Fi) network. The client should send packets to the server at regular intervals, and the server should log the received packets. Configure a Wi-Fi network using the infrastructure mode (where the client connects to an access point, and the server is also connected to the access point). Use custom UDP socket applications instead of NS-3’s built-in UdpEchoClient and UdpEchoServer. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpWifiExample\");\n\n// Server function to receive packets\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a packet over Wi-Fi!\");\n    }\n}\n\n// Client function to send packets\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address dstAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(512); // 512-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(dstAddr, port));\n    Simulator::Schedule(Seconds(1.0), &SendPacket, socket, dstAddr, port); // Schedule next packet\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpWifiExample\", LOG_LEVEL_INFO);\n\n    // Create nodes (1 AP, 1 Client, 1 Server)\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    NodeContainer wifiClientNode, wifiServerNode;\n    wifiClientNode.Create(1);\n    wifiServerNode.Create(1);\n\n    // Configure Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Configure Wi-Fi MAC (Infrastructure Mode)\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211g);\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Configure AP (Access Point)\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Configure Client and Server (Station Mode)\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer clientDevice = wifi.Install(phy, mac, wifiClientNode);\n    NetDeviceContainer serverDevice = wifi.Install(phy, mac, wifiServerNode);\n\n    // Set mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiClientNode);\n    mobility.Install(wifiServerNode);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiClientNode);\n    stack.Install(wifiServerNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n    Ipv4InterfaceContainer clientInterface = address.Assign(clientDevice);\n    Ipv4InterfaceContainer serverInterface = address.Assign(serverDevice);\n\n    uint16_t port = 8080; // UDP port\n\n    // Setup UDP Server\n    Ptr<Socket> serverSocket = Socket::CreateSocket(wifiServerNode.Get(0), UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client\n    Ptr<Socket> clientSocket = Socket::CreateSocket(wifiClientNode.Get(0), UdpSocketFactory::GetTypeId());\n    Simulator::Schedule(Seconds(2.0), &SendPacket, clientSocket, serverInterface.GetAddress(0), port);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a CSMA (Carrier Sense Multiple Access) network in ns-3 with 4 nodes. The nodes will communicate over a shared medium with each node sending TCP traffic to a central server. Include packet loss, delay, and throughput metrics in the simulation, and visualize the communication using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CsmaNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation parameters\n    double simulationTime = 10.0; // seconds\n\n    // Create nodes\n    NodeContainer csmaNodes;\n    csmaNodes.Create(4); // 4 CSMA nodes\n\n    // Create the CSMA channel\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install the CSMA devices\n    NetDeviceContainer csmaDevices;\n    csmaDevices = csma.Install(csmaNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(csmaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer csmaInterfaces = address.Assign(csmaDevices);\n\n    // Install TCP application on each node to communicate with node 0 (central server)\n    uint16_t port = 9; // TCP port\n\n    // Create a packet sink on the first node (server)\n    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(csmaNodes.Get(0));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(simulationTime));\n\n    // Create TCP clients on the other nodes\n    for (uint32_t i = 1; i < csmaNodes.GetN(); ++i)\n    {\n        OnOffHelper onoff(\"ns3::TcpSocketFactory\", InetSocketAddress(csmaInterfaces.GetAddress(0), port));\n        onoff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        onoff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n        onoff.SetAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n        onoff.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n        ApplicationContainer clientApp = onoff.Install(csmaNodes.Get(i));\n        clientApp.Start(Seconds(2.0));\n        clientApp.Stop(Seconds(simulationTime));\n    }\n\n    // Enable NetAnim\n    AnimationInterface anim(\"csma_network.xml\");\n    anim.SetConstantPosition(csmaNodes.Get(0), 10.0, 20.0); // Server\n    anim.SetConstantPosition(csmaNodes.Get(1), 20.0, 40.0); // Client 1\n    anim.SetConstantPosition(csmaNodes.Get(2), 30.0, 40.0); // Client 2\n    anim.SetConstantPosition(csmaNodes.Get(3), 40.0, 40.0); // Client 3\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless network with four nodes using Wi-Fi in ns-3. One node acts as an Access Point (AP), and the other three act as Wi-Fi stations (STA) connected to the AP. The stations will communicate with each other through the AP. The simulation will capture and display packet traces and measure the performance in terms of throughput and packet loss."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set the default Wi-Fi standard to 802.11g\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(\"DsssRate11Mbps\"));\n\n    // Create 4 nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(3);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Configure the Wi-Fi physical layer and MAC\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-ssid\");\n\n    // Configure Wi-Fi stations (STAs)\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure the Access Point (AP)\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set up mobility model for the stations and AP\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(wifiStaNodes);\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses to the Wi-Fi devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces;\n    staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface;\n    apInterface = address.Assign(apDevice);\n\n    // Set up an application to send UDP traffic from STA 1 to STA 2 through the AP\n    uint16_t port = 9;\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApp = echoServer.Install(wifiStaNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(staInterfaces.GetAddress(1), port);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(wifiStaNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable packet tracing\n    phy.EnablePcap(\"wifi-network\", apDevice.Get(0));\n\n    // Monitor the flow\n    FlowMonitorHelper flowmonHelper;\n    Ptr<FlowMonitor> monitor = flowmonHelper.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(11.0));\n    Simulator::Run();\n\n    // Print flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 /\n                                            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n                                            1024 / 1024 << \" Mbps\");\n    }\n\n    // Clean up\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a sensor network communicates using UDP over a Wireless Sensor Network (WSN). The network consists of multiple sensor nodes that periodically send data to a central sink node. The nodes should use the OLSR (Optimized Link State Routing) protocol for efficient data routing. The simulation should include an energy model for sensor nodes and run for 50 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/olsr-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/energy-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpWSNExample\");\n\n// Function to send UDP packets from sensors to the sink\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address sinkAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(256); // 256-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(sinkAddr, port));\n    Simulator::Schedule(Seconds(2.0), &SendPacket, socket, sinkAddr, port); // Schedule next packet\n}\n\n// Function to receive packets at the sink node\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Sink node received a packet from a sensor!\");\n    }\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpWSNExample\", LOG_LEVEL_INFO);\n\n    int numSensors = 20;\n    double simTime = 50.0;\n\n    // Create nodes (sensor nodes + 1 sink)\n    NodeContainer sensors;\n    sensors.Create(numSensors);\n\n    NodeContainer sink;\n    sink.Create(1);\n\n    // Configure Wi-Fi (Ad-Hoc Mode for WSN)\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b); // 802.11b for low-power sensor communication\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer sensorDevices = wifi.Install(phy, mac, sensors);\n    NetDeviceContainer sinkDevice = wifi.Install(phy, mac, sink);\n\n    // Set up mobility (random sensor deployment)\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    \n    for (int i = 0; i < numSensors; i++) {\n        positionAlloc->Add(Vector(rand() % 100, rand() % 100, 0.0)); // Random deployment in 100x100m area\n    }\n    positionAlloc->Add(Vector(50.0, 50.0, 0.0)); // Sink at the center\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(sensors);\n    mobility.Install(sink);\n\n    // Install Energy Model\n    BasicEnergySourceHelper energySourceHelper;\n    energySourceHelper.Set(\"BasicEnergySourceInitialEnergyJ\", DoubleValue(10.0)); // 10 Joules per node\n    EnergySourceContainer energySources = energySourceHelper.Install(sensors);\n\n    WifiRadioEnergyModelHelper radioEnergyHelper;\n    radioEnergyHelper.Install(sensorDevices, energySources);\n\n    // Install Internet stack with OLSR routing\n    OlsrHelper olsr;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(olsr);\n    internet.Install(sensors);\n    internet.Install(sink);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer sensorInterfaces = address.Assign(sensorDevices);\n    Ipv4InterfaceContainer sinkInterface = address.Assign(sinkDevice);\n\n    uint16_t port = 9090; // UDP port\n\n    // Setup UDP Server at Sink Node\n    Ptr<Socket> sinkSocket = Socket::CreateSocket(sink.Get(0), UdpSocketFactory::GetTypeId());\n    sinkSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    sinkSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Clients in Sensor Nodes\n    for (int i = 0; i < numSensors; i++) {\n        Ptr<Socket> sensorSocket = Socket::CreateSocket(sensors.Get(i), UdpSocketFactory::GetTypeId());\n        Simulator::Schedule(Seconds(2.0 + i * 0.5), &SendPacket, sensorSocket, sinkInterface.GetAddress(0), port);\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a Wi-Fi network in NS-3 with three nodes: one Wi-Fi access point and two stations. Node 1 (station) sends UDP packets to Node 2 (AP), and Node 2 forwards them to Node 3. Set up Wi-Fi parameters with a default channel and AARF station management. The simulation should run for 10 seconds, starting the server at 1s and the client at 2s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(3);\n\n    // Set up Wi-Fi channel and devices\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, wifiNodes.Get(0));\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    devices.Add(wifi.Install(phy, mac, wifiNodes.Get(1)));\n    devices.Add(wifi.Install(phy, mac, wifiNodes.Get(2)));\n\n    // Install internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 2\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(wifiNodes.Get(2));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(2), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a simple wired network with HTTP traffic between two nodes. Use PointToPoint links to connect the nodes with a 1Mbps data rate and 10ms delay. Node 0 is the HTTP client, and Node 1 is the HTTP server. The HTTP server listens on port 80. The HTTP client starts generating traffic at 2 seconds and stops at 10 seconds. The server starts at 1 second and stops at 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"HttpSimpleExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"HttpSimpleExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the network\n    NodeContainer nodes;\n    nodes.Create(2); // Two nodes: Client and Server\n\n    // Set up point-to-point link between nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes.Get(0), nodes.Get(1)); // Connection between node 0 and 1\n\n    // Install internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up the HTTP server application on Node 1 (server)\n    uint16_t port = 80; // Standard HTTP port\n    OnOffHelper httpServerHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    httpServerHelper.SetConstantRate(DataRate(\"500kb/s\"));\n    ApplicationContainer serverApp = httpServerHelper.Install(nodes.Get(1)); // Install on Node 1 (Server)\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the HTTP client application on Node 0 (client)\n    HttpRequestHelper httpClientHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    ApplicationContainer clientApp = httpClientHelper.Install(nodes.Get(0)); // Install on Node 0 (Client)\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a WiFi network in NS-3 with two nodes. The first node sends UDP packets to the second node. Use default WiFi attributes and a simple grid mobility model. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up WiFi PHY and MAC attributes\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up WiFi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up WiFi device\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP client application on node 0 (sender)\n    uint16_t port = 9;\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on node 1 (receiver)\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a 5G NR network with one gNB (base station) and two UE nodes using the mmWave module. The UEs should move randomly within a 50x50 area, while the gNB remains stationary. One UE should act as a UDP server on port 5001, while the other should be a UDP client, sending 1024-byte packets every 10ms. The simulation should run for 10 seconds, with PCAP tracing enabled."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-helper.h\"\n#include \"ns3/mmwave-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"NrMmWaveExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"NrMmWaveExample\", LOG_LEVEL_INFO);\n\n    // Create gNB (base station) and UE nodes\n    NodeContainer ueNodes, gnbNode;\n    ueNodes.Create(2);\n    gnbNode.Create(1);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(gnbNode);\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(ueNodes);\n\n    // Install NR mmWave module\n    Ptr<MmWaveHelper> mmWaveHelper = CreateObject<MmWaveHelper>();\n    NetDeviceContainer gnbDevice = mmWaveHelper->InstallGnbDevice(gnbNode);\n    NetDeviceContainer ueDevices = mmWaveHelper->InstallUeDevice(ueNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n\n    // Assign IP addresses\n    Ipv4InterfaceContainer ueInterfaces = mmWaveHelper->AssignUeIpv4Address(NetDeviceContainer(ueDevices));\n\n    // Attach UE nodes to gNB\n    for (uint32_t i = 0; i < ueNodes.GetN(); ++i)\n    {\n        mmWaveHelper->Attach(ueDevices.Get(i), gnbDevice.Get(0));\n    }\n\n    // Set up UDP traffic\n    uint16_t port = 5001;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ueNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    UdpClientHelper udpClient(ueInterfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(ueNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing\n    mmWaveHelper->EnablePcapAll(\"nr-mmwave\");\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple Wi-Fi network in NS-3 with two nodes. Node 0 (UDP client) sends packets to Node 1 (UDP server) starting at 2s and stopping at 10s. Use a data rate of 10Mbps, and a fixed delay of 2ms. The Wi-Fi network should operate on the SSID ns3-wifi, and IP addresses should start with 10.1.1.0/24. Set the mobility model to constant position with grid placement for the nodes."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Wi-Fi configuration\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up Wi-Fi PHY and MAC layers\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    // Install Wi-Fi devices\n    NetDeviceContainer devices;\n    devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Set up mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 1 (Receiver)\n    uint16_t port = 12345;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 0 (Sender)\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 simulator to compare the performance of different MANET routing protocols (DSDV, AODV, OLSR, and DSR) under a typical random waypoint mobility model. The default simulation runs for 200 seconds with 50 nodes moving at 20 m/s in a 300x1500 meter area, using WiFi in ad-hoc mode with a transmission power of 7.5 dBm. The program allows modifying parameters such as protocol choice, node density, mobility, and transmission power. Additionally, it generates 10 UDP source/sink pairs with data transmission starting randomly between 50 and 51 seconds. The simulation outputs data reception statistics in a CSV file, with optional mobility tracing and flow monitoring."}, {"role": "assistant", "content": "/*\n * This example program allows one to run ns-3 DSDV, AODV, or OLSR under\n * a typical random waypoint mobility model.\n *\n * By default, the simulation runs for 200 simulated seconds, of which\n * the first 50 are used for start-up time.  The number of nodes is 50.\n * Nodes move according to RandomWaypointMobilityModel with a speed of\n * 20 m/s and no pause time within a 300x1500 m region.  The WiFi is\n * in ad hoc mode with a 2 Mb/s rate (802.11b) and a Friis loss model.\n * The transmit power is set to 7.5 dBm.\n *\n * It is possible to change the mobility and density of the network by\n * directly modifying the speed and the number of nodes.  It is also\n * possible to change the characteristics of the network by changing\n * the transmit power (as power increases, the impact of mobility\n * decreases and the effective density increases).\n *\n * By default, OLSR is used, but specifying a value of 2 for the protocol\n * will cause AODV to be used, and specifying a value of 3 will cause\n * DSDV to be used.\n *\n * By default, there are 10 source/sink data pairs sending UDP data\n * at an application rate of 2.048 Kb/s each.    This is typically done\n * at a rate of 4 64-byte packets per second.  Application data is\n * started at a random time between 50 and 51 seconds and continues\n * to the end of the simulation.\n *\n * The program outputs a few items:\n * - packet receptions are notified to stdout such as:\n *   <timestamp> <node-id> received one packet from <src-address>\n * - each second, the data reception statistics are tabulated and output\n *   to a comma-separated value (csv) file\n * - some tracing and flow monitor configuration that used to work is\n *   left commented inline in the program\n */\n\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/dsdv-module.h\"\n#include \"ns3/dsr-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/olsr-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <fstream>\n#include <iostream>\n\nusing namespace ns3;\nusing namespace dsr;\n\nNS_LOG_COMPONENT_DEFINE(\"manet-routing-compare\");\n\n/**\n * Routing experiment class.\n *\n * It handles the creation and run of an experiment.\n */\nclass RoutingExperiment\n{\n  public:\n    RoutingExperiment();\n    /**\n     * Run the experiment.\n     */\n    void Run();\n\n    /**\n     * Handles the command-line parameters.\n     * \\param argc The argument count.\n     * \\param argv The argument vector.\n     */\n    void CommandSetup(int argc, char** argv);\n\n  private:\n    /**\n     * Setup the receiving socket in a Sink Node.\n     * \\param addr The address of the node.\n     * \\param node The node pointer.\n     * \\return the socket.\n     */\n    Ptr<Socket> SetupPacketReceive(Ipv4Address addr, Ptr<Node> node);\n    /**\n     * Receive a packet.\n     * \\param socket The receiving socket.\n     */\n    void ReceivePacket(Ptr<Socket> socket);\n    /**\n     * Compute the throughput.\n     */\n    void CheckThroughput();\n\n    uint32_t port{9};            //!< Receiving port number.\n    uint32_t bytesTotal{0};      //!< Total received bytes.\n    uint32_t packetsReceived{0}; //!< Total received packets.\n\n    std::string m_CSVfileName{\"manet-routing.output.csv\"}; //!< CSV filename.\n    int m_nSinks{10};                                      //!< Number of sink nodes.\n    std::string m_protocolName{\"AODV\"};                    //!< Protocol name.\n    double m_txp{7.5};                                     //!< Tx power.\n    bool m_traceMobility{false};                           //!< Enable mobility tracing.\n    bool m_flowMonitor{false};                             //!< Enable FlowMonitor.\n};\n\nRoutingExperiment::RoutingExperiment()\n{\n}\n\nstatic inline std::string\nPrintReceivedPacket(Ptr<Socket> socket, Ptr<Packet> packet, Address senderAddress)\n{\n    std::ostringstream oss;\n\n    oss << Simulator::Now().GetSeconds() << \" \" << socket->GetNode()->GetId();\n\n    if (InetSocketAddress::IsMatchingType(senderAddress))\n    {\n        InetSocketAddress addr = InetSocketAddress::ConvertFrom(senderAddress);\n        oss << \" received one packet from \" << addr.GetIpv4();\n    }\n    else\n    {\n        oss << \" received one packet!\";\n    }\n    return oss.str();\n}\n\nvoid\nRoutingExperiment::ReceivePacket(Ptr<Socket> socket)\n{\n    Ptr<Packet> packet;\n    Address senderAddress;\n    while ((packet = socket->RecvFrom(senderAddress)))\n    {\n        bytesTotal += packet->GetSize();\n        packetsReceived += 1;\n        NS_LOG_UNCOND(PrintReceivedPacket(socket, packet, senderAddress));\n    }\n}\n\nvoid\nRoutingExperiment::CheckThroughput()\n{\n    double kbs = (bytesTotal * 8.0) / 1000;\n    bytesTotal = 0;\n\n    std::ofstream out(m_CSVfileName, std::ios::app);\n\n    out << (Simulator::Now()).GetSeconds() << \",\" << kbs << \",\" << packetsReceived << \",\"\n        << m_nSinks << \",\" << m_protocolName << \",\" << m_txp << \"\" << std::endl;\n\n    out.close();\n    packetsReceived = 0;\n    Simulator::Schedule(Seconds(1.0), &RoutingExperiment::CheckThroughput, this);\n}\n\nPtr<Socket>\nRoutingExperiment::SetupPacketReceive(Ipv4Address addr, Ptr<Node> node)\n{\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> sink = Socket::CreateSocket(node, tid);\n    InetSocketAddress local = InetSocketAddress(addr, port);\n    sink->Bind(local);\n    sink->SetRecvCallback(MakeCallback(&RoutingExperiment::ReceivePacket, this));\n\n    return sink;\n}\n\nvoid\nRoutingExperiment::CommandSetup(int argc, char** argv)\n{\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"CSVfileName\", \"The name of the CSV output file name\", m_CSVfileName);\n    cmd.AddValue(\"traceMobility\", \"Enable mobility tracing\", m_traceMobility);\n    cmd.AddValue(\"protocol\", \"Routing protocol (OLSR, AODV, DSDV, DSR)\", m_protocolName);\n    cmd.AddValue(\"flowMonitor\", \"enable FlowMonitor\", m_flowMonitor);\n    cmd.Parse(argc, argv);\n\n    std::vector<std::string> allowedProtocols{\"OLSR\", \"AODV\", \"DSDV\", \"DSR\"};\n\n    if (std::find(std::begin(allowedProtocols), std::end(allowedProtocols), m_protocolName) ==\n        std::end(allowedProtocols))\n    {\n        NS_FATAL_ERROR(\"No such protocol:\" << m_protocolName);\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    RoutingExperiment experiment;\n    experiment.CommandSetup(argc, argv);\n    experiment.Run();\n\n    return 0;\n}\n\nvoid\nRoutingExperiment::Run()\n{\n    Packet::EnablePrinting();\n\n    // blank out the last output file and write the column headers\n    std::ofstream out(m_CSVfileName);\n    out << \"SimulationSecond,\"\n        << \"ReceiveRate,\"\n        << \"PacketsReceived,\"\n        << \"NumberOfSinks,\"\n        << \"RoutingProtocol,\"\n        << \"TransmissionPower\" << std::endl;\n    out.close();\n\n    int nWifis = 50;\n\n    double TotalTime = 200.0;\n    std::string rate(\"2048bps\");\n    std::string phyMode(\"DsssRate11Mbps\");\n    std::string tr_name(\"manet-routing-compare\");\n    int nodeSpeed = 20; // in m/s\n    int nodePause = 0;  // in s\n\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", StringValue(\"64\"));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(rate));\n\n    // Set Non-unicastMode rate to unicast mode\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(phyMode));\n\n    NodeContainer adhocNodes;\n    adhocNodes.Create(nWifis);\n\n    // setting up wifi phy and channel using helpers\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Add a mac and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n\n    wifiPhy.Set(\"TxPowerStart\", DoubleValue(m_txp));\n    wifiPhy.Set(\"TxPowerEnd\", DoubleValue(m_txp));\n\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer adhocDevices = wifi.Install(wifiPhy, wifiMac, adhocNodes);\n\n    MobilityHelper mobilityAdhoc;\n    int64_t streamIndex = 0; // used to get consistent mobility across scenarios\n\n    ObjectFactory pos;\n    pos.SetTypeId(\"ns3::RandomRectanglePositionAllocator\");\n    pos.Set(\"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=300.0]\"));\n    pos.Set(\"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=1500.0]\"));\n\n    Ptr<PositionAllocator> taPositionAlloc = pos.Create()->GetObject<PositionAllocator>();\n    streamIndex += taPositionAlloc->AssignStreams(streamIndex);\n\n    std::stringstream ssSpeed;\n    ssSpeed << \"ns3::UniformRandomVariable[Min=0.0|Max=\" << nodeSpeed << \"]\";\n    std::stringstream ssPause;\n    ssPause << \"ns3::ConstantRandomVariable[Constant=\" << nodePause << \"]\";\n    mobilityAdhoc.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                                   \"Speed\",\n                                   StringValue(ssSpeed.str()),\n                                   \"Pause\",\n                                   StringValue(ssPause.str()),\n                                   \"PositionAllocator\",\n                                   PointerValue(taPositionAlloc));\n    mobilityAdhoc.SetPositionAllocator(taPositionAlloc);\n    mobilityAdhoc.Install(adhocNodes);\n    streamIndex += mobilityAdhoc.AssignStreams(adhocNodes, streamIndex);\n\n    AodvHelper aodv;\n    OlsrHelper olsr;\n    DsdvHelper dsdv;\n    DsrHelper dsr;\n    DsrMainHelper dsrMain;\n    Ipv4ListRoutingHelper list;\n    InternetStackHelper internet;\n\n    if (m_protocolName == \"OLSR\")\n    {\n        list.Add(olsr, 100);\n        internet.SetRoutingHelper(list);\n        internet.Install(adhocNodes);\n    }\n    else if (m_protocolName == \"AODV\")\n    {\n        list.Add(aodv, 100);\n        internet.SetRoutingHelper(list);\n        internet.Install(adhocNodes);\n    }\n    else if (m_protocolName == \"DSDV\")\n    {\n        list.Add(dsdv, 100);\n        internet.SetRoutingHelper(list);\n        internet.Install(adhocNodes);\n    }\n    else if (m_protocolName == \"DSR\")\n    {\n        internet.Install(adhocNodes);\n        dsrMain.Install(dsr, adhocNodes);\n        if (m_flowMonitor)\n        {\n            NS_FATAL_ERROR(\"Error: FlowMonitor does not work with DSR. Terminating.\");\n        }\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"No such protocol:\" << m_protocolName);\n    }\n\n    NS_LOG_INFO(\"assigning ip address\");\n\n    Ipv4AddressHelper addressAdhoc;\n    addressAdhoc.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer adhocInterfaces;\n    adhocInterfaces = addressAdhoc.Assign(adhocDevices);\n\n    OnOffHelper onoff1(\"ns3::UdpSocketFactory\", Address());\n    onoff1.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"));\n    onoff1.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0.0]\"));\n\n    for (int i = 0; i < m_nSinks; i++)\n    {\n        Ptr<Socket> sink = SetupPacketReceive(adhocInterfaces.GetAddress(i), adhocNodes.Get(i));\n\n        AddressValue remoteAddress(InetSocketAddress(adhocInterfaces.GetAddress(i), port));\n        onoff1.SetAttribute(\"Remote\", remoteAddress);\n\n        Ptr<UniformRandomVariable> var = CreateObject<UniformRandomVariable>();\n        ApplicationContainer temp = onoff1.Install(adhocNodes.Get(i + m_nSinks));\n        temp.Start(Seconds(var->GetValue(100.0, 101.0)));\n        temp.Stop(Seconds(TotalTime));\n    }\n\n    std::stringstream ss;\n    ss << nWifis;\n    std::string nodes = ss.str();\n\n    std::stringstream ss2;\n    ss2 << nodeSpeed;\n    std::string sNodeSpeed = ss2.str();\n\n    std::stringstream ss3;\n    ss3 << nodePause;\n    std::string sNodePause = ss3.str();\n\n    std::stringstream ss4;\n    ss4 << rate;\n    std::string sRate = ss4.str();\n\n    // NS_LOG_INFO(\"Configure Tracing.\");\n    // tr_name = tr_name + \"_\" + m_protocolName +\"_\" + nodes + \"nodes_\" + sNodeSpeed + \"speed_\" +\n    // sNodePause + \"pause_\" + sRate + \"rate\";\n\n    // AsciiTraceHelper ascii;\n    // Ptr<OutputStreamWrapper> osw = ascii.CreateFileStream(tr_name + \".tr\");\n    // wifiPhy.EnableAsciiAll(osw);\n    AsciiTraceHelper ascii;\n    MobilityHelper::EnableAsciiAll(ascii.CreateFileStream(tr_name + \".mob\"));\n\n    FlowMonitorHelper flowmonHelper;\n    Ptr<FlowMonitor> flowmon;\n    if (m_flowMonitor)\n    {\n        flowmon = flowmonHelper.InstallAll();\n    }\n\n    NS_LOG_INFO(\"Run Simulation.\");\n\n    CheckThroughput();\n\n    Simulator::Stop(Seconds(TotalTime));\n    Simulator::Run();\n\n    if (m_flowMonitor)\n    {\n        flowmon->SerializeToXmlFile(tr_name + \".flowmon\", false, false);\n    }\n\n    Simulator::Destroy();\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script for a TCP client-server simulation over a point-to-point link. Create two nodes: one as a TCP server and the other as a TCP client. The client sends 100 TCP packets of size 512 bytes to the server every 0.1 seconds. The link between the nodes has a 5 Mbps data rate and a 2 ms delay. Use port 9 for communication, and run the simulation for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpClientServerExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"TcpClientServerExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes: one for the server and one for the client\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link between the client and the server\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up the TCP server on node 1 (server side)\n    uint16_t port = 9; // Port number\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the TCP client on node 0 (client side)\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));    // Send 100 packets\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1))); // Send packets every 0.1 seconds\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(512));    // 512 bytes packets\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using NS-3 that creates two network nodes and connects them using a point-to-point link. The link should have a data transmission rate of 5 Mbps and a propagation delay of 2 milliseconds. Install the Internet stack on both nodes, which includes the IP protocol, and assign IP addresses to the devices using the address range \"10.1.1.0/24\". The goal is to ensure that the nodes are correctly assigned IP addresses, but there is no need to implement any communication between them. Finally, run and destroy the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"NodeIpAddressAssignment\");\n\nint main(int argc, char *argv[]) {\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link between the two nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack (IP protocol)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a simple WiFi network with one Station (STA) and one Access Point (AP). The STA should run a UDP client on port 9, and the AP should run a UDP server. The STA sends 1,000 UDP packets of 1024 bytes each, with a packet interval of 0.01 seconds. The simulation should run for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWifiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleWifiExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: Station (STA) and Access Point (AP)\n    NodeContainer staNodes, apNodes;\n    staNodes.Create(1);\n    apNodes.Create(1);\n\n    // Set up WiFi helper and configure WiFi standards\n    WifiHelper wifiHelper;\n    wifiHelper.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up WiFi channel and PHY layers\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up MAC layer with IEEE 802.11 standards\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices;\n    staDevices = wifiHelper.Install(phy, mac, staNodes);\n\n    // Set up AP MAC layer\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevices;\n    apDevices = wifiHelper.Install(phy, mac, apNodes);\n\n    // Install the internet stack (IP, TCP, UDP)\n    InternetStackHelper internet;\n    internet.Install(staNodes);\n    internet.Install(apNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staIpIface = ipv4.Assign(staDevices);\n    Ipv4InterfaceContainer apIpIface = ipv4.Assign(apDevices);\n\n    // Set up UDP server on the AP node (Access Point)\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(apNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the STA node (Station)\n    UdpClientHelper udpClient(apIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(staNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wired network with a TCP bulk transfer between two nodes in ns-3. Create a point-to-point link between the nodes with configurable data rate and delay. Implement a TCP bulk send application that sends data from the client to the server. Track and log the number of bytes transmitted and the throughput during the simulation. Enable pcap tracing to capture packets transmitted over the link for detailed analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpBulkTransferExample\");\n\nint main(int argc, char *argv[])\n{\n    double simulationTime = 10.0; // Simulation time in seconds\n    std::string dataRate = \"5Mbps\"; // Link data rate\n    std::string delay = \"2ms\";      // Link delay\n\n    // Enable logging\n    LogComponentEnable(\"TcpBulkTransferExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes (client and server)\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up a point-to-point link with the specified data rate and delay\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(dataRate));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(delay));\n\n    // Install devices and create the point-to-point link\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a TCP bulk send application on the client node\n    uint16_t port = 9; // Port number for the TCP connection\n    BulkSendHelper bulkSend(\"ns3::TcpSocketFactory\",\n                            InetSocketAddress(interfaces.GetAddress(1), port));\n    bulkSend.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data\n    ApplicationContainer clientApp = bulkSend.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Set up a packet sink on the server node to receive the data\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\",\n                                      InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = packetSinkHelper.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Enable pcap tracing\n    pointToPoint.EnablePcap(\"tcp-bulk-transfer\", devices.Get(0), true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n\n    // Log the total number of bytes received by the server\n    Ptr<PacketSink> sink = DynamicCast<PacketSink>(serverApp.Get(0));\n    NS_LOG_INFO(\"Total Bytes Received by Server: \" << sink->GetTotalRx());\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a point-to-point network with two nodes. The link should have a data rate of 5 Mbps and a delay of 2 ms. One node should act as a TCP bulk sender, and the other should act as a TCP sink on port 9. The simulation should run for 10 seconds, with PCAP tracing enabled."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"TcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure a Point-to-Point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a TCP sink on Node 1\n    uint16_t port = 9;\n    Address sinkAddress(InetSocketAddress(interfaces.GetAddress(1), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(0.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Set up a TCP bulk sender on Node 0\n    BulkSendHelper bulkSendHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    bulkSendHelper.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n\n    ApplicationContainer sourceApp = bulkSendHelper.Install(nodes.Get(0));\n    sourceApp.Start(Seconds(1.0));\n    sourceApp.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing for debugging\n    pointToPoint.EnablePcapAll(\"tcp-p2p\");\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a complete NS-3 simulation program for a multi-interface host with static routing. The network should include a source node, a destination node, and two routers, with two routes connecting the source to the destination through the routers. Configure the routes with different metrics to influence traffic routing. Ensure that the program sends UDP packets from the source to the destination, dynamically binding the socket to different interfaces on the source node. Additionally, implement callback functions to handle packet reception at both the source and destination, and log details of each received packet."}, {"role": "assistant", "content": "/* Test program for multi-interface host, static routing\n\n         Destination host (10.20.1.2)\n                 |\n                 | 10.20.1.0/24\n              DSTRTR\n  10.10.1.0/24 /   \\  10.10.2.0/24\n              / \\\n           Rtr1    Rtr2\n 10.1.1.0/24 |      | 10.1.2.0/24\n             |      /\n              \\    /\n             Source\n*/\n\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SocketBoundRoutingExample\");\n\nvoid SendStuff(Ptr<Socket> sock, Ipv4Address dstaddr, uint16_t port);\nvoid BindSock(Ptr<Socket> sock, Ptr<NetDevice> netdev);\nvoid srcSocketRecv(Ptr<Socket> socket);\nvoid dstSocketRecv(Ptr<Socket> socket);\n\nint\nmain(int argc, char* argv[])\n{\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Ptr<Node> nSrc = CreateObject<Node>();\n    Ptr<Node> nDst = CreateObject<Node>();\n    Ptr<Node> nRtr1 = CreateObject<Node>();\n    Ptr<Node> nRtr2 = CreateObject<Node>();\n    Ptr<Node> nDstRtr = CreateObject<Node>();\n\n    NodeContainer c = NodeContainer(nSrc, nDst, nRtr1, nRtr2, nDstRtr);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // Point-to-point links\n    NodeContainer nSrcnRtr1 = NodeContainer(nSrc, nRtr1);\n    NodeContainer nSrcnRtr2 = NodeContainer(nSrc, nRtr2);\n    NodeContainer nRtr1nDstRtr = NodeContainer(nRtr1, nDstRtr);\n    NodeContainer nRtr2nDstRtr = NodeContainer(nRtr2, nDstRtr);\n    NodeContainer nDstRtrnDst = NodeContainer(nDstRtr, nDst);\n\n    // We create the channels first without any IP addressing information\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer dSrcdRtr1 = p2p.Install(nSrcnRtr1);\n    NetDeviceContainer dSrcdRtr2 = p2p.Install(nSrcnRtr2);\n    NetDeviceContainer dRtr1dDstRtr = p2p.Install(nRtr1nDstRtr);\n    NetDeviceContainer dRtr2dDstRtr = p2p.Install(nRtr2nDstRtr);\n    NetDeviceContainer dDstRtrdDst = p2p.Install(nDstRtrnDst);\n\n    Ptr<NetDevice> SrcToRtr1 = dSrcdRtr1.Get(0);\n    Ptr<NetDevice> SrcToRtr2 = dSrcdRtr2.Get(0);\n\n    // Later, we add IP addresses.\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iSrciRtr1 = ipv4.Assign(dSrcdRtr1);\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iSrciRtr2 = ipv4.Assign(dSrcdRtr2);\n    ipv4.SetBase(\"10.10.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iRtr1iDstRtr = ipv4.Assign(dRtr1dDstRtr);\n    ipv4.SetBase(\"10.10.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iRtr2iDstRtr = ipv4.Assign(dRtr2dDstRtr);\n    ipv4.SetBase(\"10.20.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iDstRtrDst = ipv4.Assign(dDstRtrdDst);\n\n    Ptr<Ipv4> ipv4Src = nSrc->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4Rtr1 = nRtr1->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4Rtr2 = nRtr2->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4DstRtr = nDstRtr->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4Dst = nDst->GetObject<Ipv4>();\n\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> staticRoutingSrc = ipv4RoutingHelper.GetStaticRouting(ipv4Src);\n    Ptr<Ipv4StaticRouting> staticRoutingRtr1 = ipv4RoutingHelper.GetStaticRouting(ipv4Rtr1);\n    Ptr<Ipv4StaticRouting> staticRoutingRtr2 = ipv4RoutingHelper.GetStaticRouting(ipv4Rtr2);\n    Ptr<Ipv4StaticRouting> staticRoutingDstRtr = ipv4RoutingHelper.GetStaticRouting(ipv4DstRtr);\n    Ptr<Ipv4StaticRouting> staticRoutingDst = ipv4RoutingHelper.GetStaticRouting(ipv4Dst);\n\n    // Create static routes from Src to Dst\n    staticRoutingRtr1->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.10.1.2\"), 2);\n    staticRoutingRtr2->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.10.2.2\"), 2);\n\n    // Two routes to same destination - setting separate metrics.\n    // You can switch these to see how traffic gets diverted via different routes\n    staticRoutingSrc->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.1.1.2\"), 1, 5);\n    staticRoutingSrc->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.1.2.2\"), 2, 10);\n\n    // Creating static routes from DST to Source pointing to Rtr1 VIA Rtr2(!)\n    staticRoutingDst->AddHostRouteTo(Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.20.1.1\"), 1);\n    staticRoutingDstRtr->AddHostRouteTo(Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.10.2.1\"), 2);\n    staticRoutingRtr2->AddHostRouteTo(Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.1.2.1\"), 1);\n\n    // There are no apps that can utilize the Socket Option so doing the work directly..\n    // Taken from tcp-large-transfer example\n\n    Ptr<Socket> srcSocket =\n        Socket::CreateSocket(nSrc, TypeId::LookupByName(\"ns3::UdpSocketFactory\"));\n    srcSocket->Bind();\n    srcSocket->SetRecvCallback(MakeCallback(&srcSocketRecv));\n\n    Ptr<Socket> dstSocket =\n        Socket::CreateSocket(nDst, TypeId::LookupByName(\"ns3::UdpSocketFactory\"));\n    uint16_t dstport = 12345;\n    Ipv4Address dstaddr(\"10.20.1.2\");\n    InetSocketAddress dst = InetSocketAddress(dstaddr, dstport);\n    dstSocket->Bind(dst);\n    dstSocket->SetRecvCallback(MakeCallback(&dstSocketRecv));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"socket-bound-static-routing.tr\"));\n    p2p.EnablePcapAll(\"socket-bound-static-routing\");\n\n    LogComponentEnableAll(LOG_PREFIX_TIME);\n    LogComponentEnable(\"SocketBoundRoutingExample\", LOG_LEVEL_INFO);\n\n    // First packet as normal (goes via Rtr1)\n    Simulator::Schedule(Seconds(0.1), &SendStuff, srcSocket, dstaddr, dstport);\n    // Second via Rtr1 explicitly\n    Simulator::Schedule(Seconds(1.0), &BindSock, srcSocket, SrcToRtr1);\n    Simulator::Schedule(Seconds(1.1), &SendStuff, srcSocket, dstaddr, dstport);\n    // Third via Rtr2 explicitly\n    Simulator::Schedule(Seconds(2.0), &BindSock, srcSocket, SrcToRtr2);\n    Simulator::Schedule(Seconds(2.1), &SendStuff, srcSocket, dstaddr, dstport);\n    // Fourth again as normal (goes via Rtr1)\n    Simulator::Schedule(Seconds(3.0), &BindSock, srcSocket, Ptr<NetDevice>(nullptr));\n    Simulator::Schedule(Seconds(3.1), &SendStuff, srcSocket, dstaddr, dstport);\n    // If you uncomment what's below, it results in ASSERT failing since you can't\n    // bind to a socket not existing on a node\n    // Simulator::Schedule(Seconds(4.0),&BindSock, srcSocket, dDstRtrdDst.Get(0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}\n\nvoid\nSendStuff(Ptr<Socket> sock, Ipv4Address dstaddr, uint16_t port)\n{\n    Ptr<Packet> p = Create<Packet>();\n    p->AddPaddingAtEnd(100);\n    sock->SendTo(p, 0, InetSocketAddress(dstaddr, port));\n}\n\nvoid\nBindSock(Ptr<Socket> sock, Ptr<NetDevice> netdev)\n{\n    sock->BindToNetDevice(netdev);\n}\n\nvoid\nsrcSocketRecv(Ptr<Socket> socket)\n{\n    Address from;\n    Ptr<Packet> packet = socket->RecvFrom(from);\n    packet->RemoveAllPacketTags();\n    packet->RemoveAllByteTags();\n    NS_LOG_INFO(\"Source Received \" << packet->GetSize() << \" bytes from \"\n                                   << InetSocketAddress::ConvertFrom(from).GetIpv4());\n    if (socket->GetBoundNetDevice())\n    {\n        NS_LOG_INFO(\"Socket was bound\");\n    }\n    else\n    {\n        NS_LOG_INFO(\"Socket was not bound\");\n    }\n}\n\nvoid\ndstSocketRecv(Ptr<Socket> socket)\n{\n    Address from;\n    Ptr<Packet> packet = socket->RecvFrom(from);\n    packet->RemoveAllPacketTags();\n    packet->RemoveAllByteTags();\n    InetSocketAddress address = InetSocketAddress::ConvertFrom(from);\n    NS_LOG_INFO(\"Destination Received \" << packet->GetSize() << \" bytes from \"\n                                        << address.GetIpv4());\n    NS_LOG_INFO(\"Triggering packet back to source node's interface 1\");\n    SendStuff(socket, Ipv4Address(\"10.1.1.1\"), address.GetPort());\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a code example in C++ using the NS-3 simulator that demonstrates the implementation of a WiFi multirate experiment with 100 nodes, multiple simultaneous flows, ad hoc routing, and node mobility. The code should include class declarations and key methods such as running the experiment, setting up applications, monitoring packet reception, calculating throughput, and handling node mobility. Ensure that logging, command-line arguments, and results collection via Gnuplot are also implemented, along with specific instructions for building, running, and debugging the simulation."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/olsr-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/rectangle.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"multirate\");\n\n/**\n * WiFi multirate experiment class.\n *\n * It handles the creation and run of an experiment.\n *\n * Scenarios: 100 nodes, multiple simultaneous flows, multi-hop ad hoc, routing,\n * and mobility\n *\n * QUICK INSTRUCTIONS:\n *\n * To optimize build:\n * ./ns3 configure -d optimized\n * ./ns3\n *\n * To compile:\n * ./ns3 run wifi-multirate\n *\n * To compile with command line(useful for varying parameters):\n * ./ns3 run \"wifi-multirate --totalTime=0.3s --rateManager=ns3::MinstrelWifiManager\"\n *\n * To turn on NS_LOG:\n * export NS_LOG=multirate=level_all\n * (can only view log if built with ./ns3 configure -d debug)\n *\n * To debug:\n * ./ns3 shell\n * gdb ./build/debug/examples/wireless/wifi-multirate\n *\n * To view pcap files:\n * tcpdump -nn -tt -r filename.pcap\n *\n * To monitor the files:\n * tail -f filename.pcap\n *\n */\nclass Experiment\n{\n  public:\n    Experiment();\n    /**\n     * \\brief Construct a new Experiment object\n     *\n     * \\param name The name of the experiment.\n     */\n    Experiment(std::string name);\n    /**\n     * Run an experiment.\n     * \\param wifi The WifiHelper class.\n     * \\param wifiPhy The YansWifiPhyHelper class.\n     * \\param wifiMac The WifiMacHelper class.\n     * \\param wifiChannel The YansWifiChannelHelper class.\n     * \\param mobility The MobilityHelper class.\n     * \\return a 2D dataset of the experiment data.\n     */\n    Gnuplot2dDataset Run(const WifiHelper& wifi,\n                         const YansWifiPhyHelper& wifiPhy,\n                         const WifiMacHelper& wifiMac,\n                         const YansWifiChannelHelper& wifiChannel,\n                         const MobilityHelper& mobility);\n\n    /**\n     * \\brief Setup the experiment from the command line arguments.\n     *\n     * \\param argc The argument count.\n     * \\param argv The argument vector.\n     * \\return true\n     */\n    bool CommandSetup(int argc, char** argv);\n\n    /**\n     * \\brief Check if routing is enabled.\n     *\n     * \\return true if routing is enabled.\n     */\n    bool IsRouting() const\n    {\n        return m_enableRouting;\n    }\n\n    /**\n     * \\brief Check if mobility is enabled.\n     *\n     * \\return true if mobility is enabled.\n     */\n    bool IsMobility() const\n    {\n        return m_enableMobility;\n    }\n\n    /**\n     * \\brief Get the Scenario number.\n     *\n     * \\return the scenario number.\n     */\n    uint32_t GetScenario() const\n    {\n        return m_scenario;\n    }\n\n    /**\n     * \\brief Get the RTS Threshold.\n     *\n     * \\return the RTS Threshold.\n     */\n    std::string GetRtsThreshold() const\n    {\n        return m_rtsThreshold;\n    }\n\n    /**\n     * \\brief Get the Output File Name.\n     *\n     * \\return the Output File Name.\n     */\n    std::string GetOutputFileName() const\n    {\n        return m_outputFileName;\n    }\n\n    /**\n     * \\brief Get the Rate Manager.\n     *\n     * \\return the Rate Manager.\n     */\n    std::string GetRateManager() const\n    {\n        return m_rateManager;\n    }\n\n  private:\n    /**\n     * \\brief Setup the receiving socket.\n     *\n     * \\param node The receiving node.\n     * \\return the Rx socket.\n     */\n    Ptr<Socket> SetupPacketReceive(Ptr<Node> node);\n    /**\n     * Generate 1-hop and 2-hop neighbors of a node in grid topology\n     * \\param c The node container.\n     * \\param senderId The sender ID.\n     * \\return the neighbor nodes.\n     */\n    NodeContainer GenerateNeighbors(NodeContainer c, uint32_t senderId);\n\n    /**\n     * \\brief Setup the application in the nodes.\n     *\n     * \\param client Client node.\n     * \\param server Server node.\n     * \\param start Start time.\n     * \\param stop Stop time.\n     */\n    void ApplicationSetup(Ptr<Node> client, Ptr<Node> server, double start, double stop);\n    /**\n     * Take the grid map, divide it into 4 quadrants\n     * Assign all nodes from each quadrant to a specific container\n     *\n     * \\param c The node container.\n     */\n    void AssignNeighbors(NodeContainer c);\n    /**\n     * Sources and destinations are randomly selected such that a node\n     * may be the source for multiple destinations and a node maybe a destination\n     * for multiple sources.\n     *\n     * \\param c The node container.\n     */\n    void SelectSrcDest(NodeContainer c);\n    /**\n     * \\brief Receive a packet.\n     *\n     * \\param socket The receiving socket.\n     */\n    void ReceivePacket(Ptr<Socket> socket);\n    /**\n     * \\brief Calculate the throughput.\n     */\n    void CheckThroughput();\n    /**\n     * A sender node will  set up a flow to each of the its neighbors\n     * in its quadrant randomly.  All the flows are exponentially distributed.\n     *\n     * \\param sender The sender node.\n     * \\param c The node neighbors.\n     */\n    void SendMultiDestinations(Ptr<Node> sender, NodeContainer c);\n\n    Gnuplot2dDataset m_output; //!< Output dataset.\n\n    double m_totalTime;      //!< Total experiment time.\n    double m_expMean;        //!< Exponential parameter for sending packets.\n    double m_samplingPeriod; //!< Sampling period.\n\n    uint32_t m_bytesTotal;   //!< Total number of received bytes.\n    uint32_t m_packetSize;   //!< Packet size.\n    uint32_t m_gridSize;     //!< Grid size.\n    uint32_t m_nodeDistance; //!< Node distance.\n    uint32_t m_port;         //!< Listening port.\n    uint32_t m_scenario;     //!< Scenario number.\n\n    bool m_enablePcap;     //!< True if PCAP output is enabled.\n    bool m_enableTracing;  //!< True if tracing output is enabled.\n    bool m_enableFlowMon;  //!< True if FlowMon is enabled.\n    bool m_enableRouting;  //!< True if routing is enabled.\n    bool m_enableMobility; //!< True if mobility is enabled.\n\n    /**\n     * Node containers for each quadrant.\n     * @{\n     */\n    NodeContainer m_containerA;\n    NodeContainer m_containerB;\n    NodeContainer m_containerC;\n    NodeContainer m_containerD;\n    /** @} */\n    std::string m_rtsThreshold;   //!< Rts threshold.\n    std::string m_rateManager;    //!< Rate manager.\n    std::string m_outputFileName; //!< Output file name.\n};\n\nExperiment::Experiment()\n{\n}\n\nExperiment::Experiment(std::string name)\n    : m_output(name),\n      m_totalTime(0.3),\n      m_expMean(0.1),\n      // flows being exponentially distributed\n      m_samplingPeriod(0.1),\n      m_bytesTotal(0),\n      m_packetSize(2000),\n      m_gridSize(10),\n      // 10x10 grid  for a total of 100 nodes\n      m_nodeDistance(30),\n      m_port(5000),\n      m_scenario(4),\n      m_enablePcap(false),\n      m_enableTracing(true),\n      m_enableFlowMon(false),\n      m_enableRouting(false),\n      m_enableMobility(false),\n      m_rtsThreshold(\"2200\"),\n      // 0 for enabling rts/cts\n      m_rateManager(\"ns3::MinstrelWifiManager\"),\n      m_outputFileName(\"minstrel\")\n{\n    m_output.SetStyle(Gnuplot2dDataset::LINES);\n}\n\nPtr<Socket>\nExperiment::SetupPacketReceive(Ptr<Node> node)\n{\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> sink = Socket::CreateSocket(node, tid);\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), m_port);\n    sink->Bind(local);\n    sink->SetRecvCallback(MakeCallback(&Experiment::ReceivePacket, this));\n\n    return sink;\n}\n\nvoid\nExperiment::ReceivePacket(Ptr<Socket> socket)\n{\n    Ptr<Packet> packet;\n    while ((packet = socket->Recv()))\n    {\n        m_bytesTotal += packet->GetSize();\n    }\n}\n\nvoid\nExperiment::CheckThroughput()\n{\n    double mbs = ((m_bytesTotal * 8.0) / 1000000 / m_samplingPeriod);\n    m_bytesTotal = 0;\n    m_output.Add((Simulator::Now()).GetSeconds(), mbs);\n\n    // check throughput every samplingPeriod second\n    Simulator::Schedule(Seconds(m_samplingPeriod), &Experiment::CheckThroughput, this);\n}\n\nvoid\nExperiment::AssignNeighbors(NodeContainer c)\n{\n    uint32_t totalNodes = c.GetN();\n    for (uint32_t i = 0; i < totalNodes; i++)\n    {\n        if ((i % m_gridSize) <= (m_gridSize / 2 - 1))\n        {\n            // lower left quadrant\n            if (i < totalNodes / 2)\n            {\n                m_containerA.Add(c.Get(i));\n            }\n\n            // upper left quadrant\n            if (i >= (uint32_t)(4 * totalNodes) / 10)\n            {\n                m_containerC.Add(c.Get(i));\n            }\n        }\n        if ((i % m_gridSize) >= (m_gridSize / 2 - 1))\n        {\n            // lower right quadrant\n            if (i < totalNodes / 2)\n            {\n                m_containerB.Add(c.Get(i));\n            }\n\n            // upper right quadrant\n            if (i >= (uint32_t)(4 * totalNodes) / 10)\n            {\n                m_containerD.Add(c.Get(i));\n            }\n        }\n    }\n}\n\nNodeContainer\nExperiment::GenerateNeighbors(NodeContainer c, uint32_t senderId)\n{\n    NodeContainer nc;\n    uint32_t limit = senderId + 2;\n    for (uint32_t i = senderId - 2; i <= limit; i++)\n    {\n        // must ensure the boundaries for other topologies\n        nc.Add(c.Get(i));\n        nc.Add(c.Get(i + 10));\n        nc.Add(c.Get(i + 20));\n        nc.Add(c.Get(i - 10));\n        nc.Add(c.Get(i - 20));\n    }\n    return nc;\n}\n\nvoid\nExperiment::SelectSrcDest(NodeContainer c)\n{\n    uint32_t totalNodes = c.GetN();\n    Ptr<UniformRandomVariable> uvSrc = CreateObject<UniformRandomVariable>();\n    uvSrc->SetAttribute(\"Min\", DoubleValue(0));\n    uvSrc->SetAttribute(\"Max\", DoubleValue(totalNodes / 2 - 1));\n    Ptr<UniformRandomVariable> uvDest = CreateObject<UniformRandomVariable>();\n    uvDest->SetAttribute(\"Min\", DoubleValue(totalNodes / 2));\n    uvDest->SetAttribute(\"Max\", DoubleValue(totalNodes));\n\n    for (uint32_t i = 0; i < totalNodes / 3; i++)\n    {\n        ApplicationSetup(c.Get(uvSrc->GetInteger()), c.Get(uvDest->GetInteger()), 0, m_totalTime);\n    }\n}\n\nvoid\nExperiment::SendMultiDestinations(Ptr<Node> sender, NodeContainer c)\n{\n    // UniformRandomVariable params: (Xrange, Yrange)\n    Ptr<UniformRandomVariable> uv = CreateObject<UniformRandomVariable>();\n    uv->SetAttribute(\"Min\", DoubleValue(0));\n    uv->SetAttribute(\"Max\", DoubleValue(c.GetN()));\n\n    // ExponentialRandomVariable params: (mean, upperbound)\n    Ptr<ExponentialRandomVariable> ev = CreateObject<ExponentialRandomVariable>();\n    ev->SetAttribute(\"Mean\", DoubleValue(m_expMean));\n    ev->SetAttribute(\"Bound\", DoubleValue(m_totalTime));\n\n    double start = 0.0;\n    double stop;\n    uint32_t destIndex;\n\n    for (uint32_t i = 0; i < c.GetN(); i++)\n    {\n        stop = start + ev->GetValue();\n        NS_LOG_DEBUG(\"Start=\" << start << \" Stop=\" << stop);\n\n        do\n        {\n            destIndex = (uint32_t)uv->GetValue();\n        } while ((c.Get(destIndex))->GetId() == sender->GetId());\n\n        ApplicationSetup(sender, c.Get(destIndex), start, stop);\n\n        start = stop;\n\n        if (start > m_totalTime)\n        {\n            break;\n        }\n    }\n}\n\n/**\n * Print the position of two nodes.\n *\n * \\param client Client node.\n * \\param server Server node.\n * \\return a string with the nodes data and positions\n */\nstatic inline std::string\nPrintPosition(Ptr<Node> client, Ptr<Node> server)\n{\n    Vector serverPos = server->GetObject<MobilityModel>()->GetPosition();\n    Vector clientPos = client->GetObject<MobilityModel>()->GetPosition();\n\n    Ptr<Ipv4> ipv4Server = server->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4Client = client->GetObject<Ipv4>();\n\n    Ipv4InterfaceAddress iaddrServer = ipv4Server->GetAddress(1, 0);\n    Ipv4InterfaceAddress iaddrClient = ipv4Client->GetAddress(1, 0);\n\n    Ipv4Address ipv4AddrServer = iaddrServer.GetLocal();\n    Ipv4Address ipv4AddrClient = iaddrClient.GetLocal();\n\n    std::ostringstream oss;\n    oss << \"Set up Server Device \" << (server->GetDevice(0))->GetAddress() << \" with ip \"\n        << ipv4AddrServer << \" position (\" << serverPos.x << \",\" << serverPos.y << \",\"\n        << serverPos.z << \")\";\n\n    oss << \"Set up Client Device \" << (client->GetDevice(0))->GetAddress() << \" with ip \"\n        << ipv4AddrClient << \" position (\" << clientPos.x << \",\" << clientPos.y << \",\"\n        << clientPos.z << \")\"\n        << \"\\n\";\n    return oss.str();\n}\n\nvoid\nExperiment::ApplicationSetup(Ptr<Node> client, Ptr<Node> server, double start, double stop)\n{\n    Ptr<Ipv4> ipv4Server = server->GetObject<Ipv4>();\n\n    Ipv4InterfaceAddress iaddrServer = ipv4Server->GetAddress(1, 0);\n    Ipv4Address ipv4AddrServer = iaddrServer.GetLocal();\n\n    NS_LOG_DEBUG(PrintPosition(client, server));\n\n    // Equipping the source  node with OnOff Application used for sending\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(Ipv4Address(\"10.0.0.1\"), m_port)));\n    onoff.SetConstantRate(DataRate(54000000));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(m_packetSize));\n    onoff.SetAttribute(\"Remote\", AddressValue(InetSocketAddress(ipv4AddrServer, m_port)));\n\n    ApplicationContainer apps = onoff.Install(client);\n    apps.Start(Seconds(start));\n    apps.Stop(Seconds(stop));\n\n    Ptr<Socket> sink = SetupPacketReceive(server);\n}\n\nGnuplot2dDataset\nExperiment::Run(const WifiHelper& wifi,\n                const YansWifiPhyHelper& wifiPhy,\n                const WifiMacHelper& wifiMac,\n                const YansWifiChannelHelper& wifiChannel,\n                const MobilityHelper& mobility)\n{\n    uint32_t nodeSize = m_gridSize * m_gridSize;\n    NodeContainer c;\n    c.Create(nodeSize);\n\n    YansWifiPhyHelper phy = wifiPhy;\n    phy.SetChannel(wifiChannel.Create());\n\n    NetDeviceContainer devices = wifi.Install(phy, wifiMac, c);\n\n    OlsrHelper olsr;\n    Ipv4StaticRoutingHelper staticRouting;\n\n    Ipv4ListRoutingHelper list;\n\n    if (m_enableRouting)\n    {\n        list.Add(staticRouting, 0);\n        list.Add(olsr, 10);\n    }\n\n    InternetStackHelper internet;\n\n    if (m_enableRouting)\n    {\n        internet.SetRoutingHelper(list); // has effect on the next Install ()\n    }\n    internet.Install(c);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer ipInterfaces;\n    ipInterfaces = address.Assign(devices);\n\n    MobilityHelper mobil = mobility;\n    mobil.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                               \"MinX\",\n                               DoubleValue(0.0),\n                               \"MinY\",\n                               DoubleValue(0.0),\n                               \"DeltaX\",\n                               DoubleValue(m_nodeDistance),\n                               \"DeltaY\",\n                               DoubleValue(m_nodeDistance),\n                               \"GridWidth\",\n                               UintegerValue(m_gridSize),\n                               \"LayoutType\",\n                               StringValue(\"RowFirst\"));\n\n    mobil.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    if (m_enableMobility && m_enableRouting)\n    {\n        // Rectangle (xMin, xMax, yMin, yMax)\n        mobil.SetMobilityModel(\"ns3::RandomDirection2dMobilityModel\",\n                               \"Bounds\",\n                               RectangleValue(Rectangle(0, 500, 0, 500)),\n                               \"Speed\",\n                               StringValue(\"ns3::ConstantRandomVariable[Constant=10]\"),\n                               \"Pause\",\n                               StringValue(\"ns3::ConstantRandomVariable[Constant=0.2]\"));\n    }\n    mobil.Install(c);\n\n    if (m_scenario == 1 && m_enableRouting)\n    {\n        SelectSrcDest(c);\n    }\n    else if (m_scenario == 2)\n    {\n        // All flows begin at the same time\n        for (uint32_t i = 0; i < nodeSize - 1; i = i + 2)\n        {\n            ApplicationSetup(c.Get(i), c.Get(i + 1), 0, m_totalTime);\n        }\n    }\n    else if (m_scenario == 3)\n    {\n        AssignNeighbors(c);\n        // Note: these senders are hand-picked in order to ensure good coverage\n        // for 10x10 grid, basically one sender for each quadrant\n        // you might have to change these values for other grids\n        NS_LOG_DEBUG(\">>>>>>>>>region A<<<<<<<<<\");\n        SendMultiDestinations(c.Get(22), m_containerA);\n\n        NS_LOG_DEBUG(\">>>>>>>>>region B<<<<<<<<<\");\n        SendMultiDestinations(c.Get(26), m_containerB);\n\n        NS_LOG_DEBUG(\">>>>>>>>>region C<<<<<<<<<\");\n        SendMultiDestinations(c.Get(72), m_containerC);\n\n        NS_LOG_DEBUG(\">>>>>>>>>region D<<<<<<<<<\");\n        SendMultiDestinations(c.Get(76), m_containerD);\n    }\n    else if (m_scenario == 4)\n    {\n        // GenerateNeighbors(NodeContainer, uint32_t sender)\n        // Note: these senders are hand-picked in order to ensure good coverage\n        // you might have to change these values for other grids\n        NodeContainer c1;\n        NodeContainer c2;\n        NodeContainer c3;\n        NodeContainer c4;\n        NodeContainer c5;\n        NodeContainer c6;\n        NodeContainer c7;\n        NodeContainer c8;\n        NodeContainer c9;\n\n        c1 = GenerateNeighbors(c, 22);\n        c2 = GenerateNeighbors(c, 24);\n        c3 = GenerateNeighbors(c, 26);\n        c4 = GenerateNeighbors(c, 42);\n        c5 = GenerateNeighbors(c, 44);\n        c6 = GenerateNeighbors(c, 46);\n        c7 = GenerateNeighbors(c, 62);\n        c8 = GenerateNeighbors(c, 64);\n        c9 = GenerateNeighbors(c, 66);\n\n        SendMultiDestinations(c.Get(22), c1);\n        SendMultiDestinations(c.Get(24), c2);\n        SendMultiDestinations(c.Get(26), c3);\n        SendMultiDestinations(c.Get(42), c4);\n        SendMultiDestinations(c.Get(44), c5);\n        SendMultiDestinations(c.Get(46), c6);\n        SendMultiDestinations(c.Get(62), c7);\n        SendMultiDestinations(c.Get(64), c8);\n        SendMultiDestinations(c.Get(66), c9);\n    }\n\n    CheckThroughput();\n\n    if (m_enablePcap)\n    {\n        phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n        phy.EnablePcapAll(GetOutputFileName());\n    }\n\n    if (m_enableTracing)\n    {\n        AsciiTraceHelper ascii;\n        phy.EnableAsciiAll(ascii.CreateFileStream(GetOutputFileName() + \".tr\"));\n    }\n\n    FlowMonitorHelper flowmonHelper;\n\n    if (m_enableFlowMon)\n    {\n        flowmonHelper.InstallAll();\n    }\n\n    Simulator::Stop(Seconds(m_totalTime));\n    Simulator::Run();\n\n    if (m_enableFlowMon)\n    {\n        flowmonHelper.SerializeToXmlFile((GetOutputFileName() + \".flomon\"), false, false);\n    }\n\n    Simulator::Destroy();\n\n    return m_output;\n}\n\nbool\nExperiment::CommandSetup(int argc, char** argv)\n{\n    // for commandline input\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"packetSize\", \"packet size\", m_packetSize);\n    cmd.AddValue(\"totalTime\", \"simulation time\", m_totalTime);\n    // according to totalTime, select an appropriate samplingPeriod automatically.\n    if (m_totalTime < 1.0)\n    {\n        m_samplingPeriod = 0.1;\n    }\n    else\n    {\n        m_samplingPeriod = 1.0;\n    }\n    // or user selects a samplingPeriod.\n    cmd.AddValue(\"samplingPeriod\", \"sampling period\", m_samplingPeriod);\n    cmd.AddValue(\"rtsThreshold\", \"rts threshold\", m_rtsThreshold);\n    cmd.AddValue(\"rateManager\", \"type of rate\", m_rateManager);\n    cmd.AddValue(\"outputFileName\", \"output filename\", m_outputFileName);\n    cmd.AddValue(\"enableRouting\", \"enable Routing\", m_enableRouting);\n    cmd.AddValue(\"enableMobility\", \"enable Mobility\", m_enableMobility);\n    cmd.AddValue(\"scenario\", \"scenario \", m_scenario);\n\n    cmd.Parse(argc, argv);\n    return true;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    Experiment experiment;\n    experiment = Experiment(\"multirate\");\n\n    // for commandline input\n    experiment.CommandSetup(argc, argv);\n\n    std::ofstream outfile(experiment.GetOutputFileName() + \".plt\");\n\n    MobilityHelper mobility;\n    Gnuplot gnuplot;\n    Gnuplot2dDataset dataset;\n\n    WifiHelper wifi;\n    WifiMacHelper wifiMac;\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n\n    wifiMac.SetType(\"ns3::AdhocWifiMac\", \"Ssid\", StringValue(\"Testbed\"));\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n    wifi.SetRemoteStationManager(experiment.GetRateManager());\n\n    NS_LOG_INFO(\"Scenario: \" << experiment.GetScenario());\n    NS_LOG_INFO(\"Rts Threshold: \" << experiment.GetRtsThreshold());\n    NS_LOG_INFO(\"Name:  \" << experiment.GetOutputFileName());\n    NS_LOG_INFO(\"Rate:  \" << experiment.GetRateManager());\n    NS_LOG_INFO(\"Routing: \" << experiment.IsRouting());\n    NS_LOG_INFO(\"Mobility: \" << experiment.IsMobility());\n\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel, mobility);\n\n    gnuplot.AddDataset(dataset);\n    gnuplot.GenerateOutput(outfile);\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate simple simulation of an IEEE 802.11n Wi-Fi network using the NS-3 simulator. The program should configure the network to evaluate the goodput for different Modulation and Coding Scheme (MCS) values (from 0 to 7), varying channel widths (20 or 40 MHz), and guard intervals (short or long). It should allow the user to configure parameters like the simulation time, UDP or TCP mode, RTS/CTS, distance between the station and access point, and expected throughput."}, {"role": "assistant", "content": "#include \"ns3/attribute-container.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/ht-phy.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/tuple.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This is a simple example in order to show how to configure an IEEE 802.11n Wi-Fi network.\n//\n// It outputs the UDP or TCP goodput for every HT MCS value, which depends on the MCS value (0 to\n// 7), the channel width (20 or 40 MHz) and the guard interval (long or short). The PHY bitrate is\n// constant over all the simulation run. The user can also specify the distance between the access\n// point and the station: the larger the distance the smaller the goodput.\n//\n// The simulation assumes a single station in an infrastructure network:\n//\n//  STA     AP\n//    *     *\n//    |     |\n//   n1     n2\n//\n// Packets in this simulation belong to BestEffort Access Class (AC_BE).\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ht-wifi-network\");\n\nint\nmain(int argc, char* argv[])\n{\n    bool udp{true};\n    bool useRts{false};\n    Time simulationTime{\"10s\"};\n    meter_u distance{1.0};\n    double frequency{5}; // whether 2.4 or 5 GHz\n    int mcs{-1};         // -1 indicates an unset value\n    double minExpectedThroughput{0.0};\n    double maxExpectedThroughput{0.0};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"frequency\",\n                 \"Whether working in the 2.4 or 5.0 GHz band (other values gets rejected)\",\n                 frequency);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the station and the access point\",\n                 distance);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"udp\", \"UDP if set to 1, TCP otherwise\", udp);\n    cmd.AddValue(\"useRts\", \"Enable/disable RTS/CTS\", useRts);\n    cmd.AddValue(\"mcs\", \"if set, limit testing to a specific MCS (0-7)\", mcs);\n    cmd.AddValue(\"minExpectedThroughput\",\n                 \"if set, simulation fails if the lowest throughput is below this value\",\n                 minExpectedThroughput);\n    cmd.AddValue(\"maxExpectedThroughput\",\n                 \"if set, simulation fails if the highest throughput is above this value\",\n                 maxExpectedThroughput);\n    cmd.Parse(argc, argv);\n\n    if (useRts)\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"0\"));\n    }\n\n    double prevThroughput[8] = {0};\n\n    std::cout << \"MCS value\"\n              << \"\\t\\t\"\n              << \"Channel width\"\n              << \"\\t\\t\"\n              << \"short GI\"\n              << \"\\t\\t\"\n              << \"Throughput\" << '\\n';\n    int minMcs = 0;\n    int maxMcs = 7;\n    if (mcs >= 0 && mcs <= 7)\n    {\n        minMcs = mcs;\n        maxMcs = mcs;\n    }\n    for (int mcs = minMcs; mcs <= maxMcs; mcs++)\n    {\n        uint8_t index = 0;\n        double previous = 0;\n        for (int channelWidth = 20; channelWidth <= 40;)\n        {\n            for (auto sgi : {false, true})\n            {\n                uint32_t payloadSize; // 1500 byte IP packet\n                if (udp)\n                {\n                    payloadSize = 1472; // bytes\n                }\n                else\n                {\n                    payloadSize = 1448; // bytes\n                    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n                }\n\n                NodeContainer wifiStaNode;\n                wifiStaNode.Create(1);\n                NodeContainer wifiApNode;\n                wifiApNode.Create(1);\n\n                YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n                YansWifiPhyHelper phy;\n                phy.SetChannel(channel.Create());\n\n                WifiMacHelper mac;\n                WifiHelper wifi;\n                std::ostringstream ossControlMode;\n\n                if (frequency == 5.0)\n                {\n                    ossControlMode << \"OfdmRate\";\n                    wifi.SetStandard(WIFI_STANDARD_80211n);\n                }\n                else if (frequency == 2.4)\n                {\n                    wifi.SetStandard(WIFI_STANDARD_80211n);\n                    ossControlMode << \"ErpOfdmRate\";\n                    Config::SetDefault(\"ns3::LogDistancePropagationLossModel::ReferenceLoss\",\n                                       DoubleValue(40.046));\n                }\n                else\n                {\n                    NS_FATAL_ERROR(\"Wrong frequency value!\");\n                }\n\n                auto nonHtRefRateMbps = HtPhy::GetNonHtReferenceRate(mcs) / 1e6;\n                ossControlMode << nonHtRefRateMbps << \"Mbps\";\n\n                std::ostringstream ossDataMode;\n                ossDataMode << \"HtMcs\" << mcs;\n                wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                             \"DataMode\",\n                                             StringValue(ossDataMode.str()),\n                                             \"ControlMode\",\n                                             StringValue(ossControlMode.str()));\n                // Set guard interval\n                wifi.ConfigHtOptions(\"ShortGuardIntervalSupported\", BooleanValue(sgi));\n\n                Ssid ssid = Ssid(\"ns3-80211n\");\n                AttributeContainerValue<\n                    TupleValue<UintegerValue, UintegerValue, EnumValue<WifiPhyBand>, UintegerValue>,\n                    ';'>\n                    channelValue;\n                WifiPhyBand band = (frequency == 5.0 ? WIFI_PHY_BAND_5GHZ : WIFI_PHY_BAND_2_4GHZ);\n                channelValue.Set(WifiPhy::ChannelSegments{{0, channelWidth, band, 0}});\n\n                mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n                phy.Set(\"ChannelSettings\", channelValue);\n\n                NetDeviceContainer staDevice;\n                staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n                mac.SetType(\"ns3::ApWifiMac\",\n                            \"EnableBeaconJitter\",\n                            BooleanValue(false),\n                            \"Ssid\",\n                            SsidValue(ssid));\n\n                NetDeviceContainer apDevice;\n                apDevice = wifi.Install(phy, mac, wifiApNode);\n\n                int64_t streamNumber = 150;\n                streamNumber += WifiHelper::AssignStreams(apDevice, streamNumber);\n                streamNumber += WifiHelper::AssignStreams(staDevice, streamNumber);\n\n                // mobility.\n                MobilityHelper mobility;\n                Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n                positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n                positionAlloc->Add(Vector(distance, 0.0, 0.0));\n                mobility.SetPositionAllocator(positionAlloc);\n\n                mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n                mobility.Install(wifiApNode);\n                mobility.Install(wifiStaNode);\n\n                /* Internet stack*/\n                InternetStackHelper stack;\n                stack.Install(wifiApNode);\n                stack.Install(wifiStaNode);\n                streamNumber += stack.AssignStreams(wifiApNode, streamNumber);\n                streamNumber += stack.AssignStreams(wifiStaNode, streamNumber);\n\n                Ipv4AddressHelper address;\n                address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n                Ipv4InterfaceContainer staNodeInterface;\n                Ipv4InterfaceContainer apNodeInterface;\n\n                staNodeInterface = address.Assign(staDevice);\n                apNodeInterface = address.Assign(apDevice);\n\n                /* Setting applications */\n                const auto maxLoad =\n                    HtPhy::GetDataRate(mcs, channelWidth, NanoSeconds(sgi ? 400 : 800), 1);\n                ApplicationContainer serverApp;\n                if (udp)\n                {\n                    // UDP flow\n                    uint16_t port = 9;\n                    UdpServerHelper server(port);\n                    serverApp = server.Install(wifiStaNode.Get(0));\n                    streamNumber += server.AssignStreams(wifiStaNode.Get(0), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n                    const auto packetInterval = payloadSize * 8.0 / maxLoad;\n\n                    UdpClientHelper client(staNodeInterface.GetAddress(0), port);\n                    client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n                    client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n                    client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                    ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n                    streamNumber += client.AssignStreams(wifiApNode.Get(0), streamNumber);\n\n                    clientApp.Start(Seconds(1.0));\n                    clientApp.Stop(simulationTime + Seconds(1.0));\n                }\n                else\n                {\n                    // TCP flow\n                    uint16_t port = 50000;\n                    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n                    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n                    serverApp = packetSinkHelper.Install(wifiStaNode.Get(0));\n                    streamNumber +=\n                        packetSinkHelper.AssignStreams(wifiStaNode.Get(0), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n\n                    OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n                    onoff.SetAttribute(\"OnTime\",\n                                       StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n                    onoff.SetAttribute(\"OffTime\",\n                                       StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n                    onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                    onoff.SetAttribute(\"DataRate\", DataRateValue(maxLoad));\n                    AddressValue remoteAddress(\n                        InetSocketAddress(staNodeInterface.GetAddress(0), port));\n                    onoff.SetAttribute(\"Remote\", remoteAddress);\n                    ApplicationContainer clientApp = onoff.Install(wifiApNode.Get(0));\n                    streamNumber += onoff.AssignStreams(wifiApNode.Get(0), streamNumber);\n\n                    clientApp.Start(Seconds(1.0));\n                    clientApp.Stop(simulationTime + Seconds(1.0));\n                }\n\n                Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n                Simulator::Stop(simulationTime + Seconds(1.0));\n                Simulator::Run();\n\n                auto rxBytes = 0.0;\n                if (udp)\n                {\n                    rxBytes = payloadSize * DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n                }\n                else\n                {\n                    rxBytes = DynamicCast<PacketSink>(serverApp.Get(0))->GetTotalRx();\n                }\n                auto throughput = (rxBytes * 8) / simulationTime.GetMicroSeconds(); // Mbit/s\n\n                Simulator::Destroy();\n\n                std::cout << mcs << \"\\t\\t\\t\" << channelWidth << \" MHz\\t\\t\\t\" << std::boolalpha\n                          << sgi << \"\\t\\t\\t\" << throughput << \" Mbit/s\" << std::endl;\n\n                // test first element\n                if (mcs == minMcs && channelWidth == 20 && !sgi)\n                {\n                    if (throughput < minExpectedThroughput)\n                    {\n                        NS_FATAL_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                    }\n                }\n                // test last element\n                if (mcs == maxMcs && channelWidth == 40 && sgi)\n                {\n                    if (maxExpectedThroughput > 0 && throughput > maxExpectedThroughput)\n                    {\n                        NS_FATAL_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                    }\n                }\n                // test previous throughput is smaller (for the same mcs)\n                if (throughput > previous)\n                {\n                    previous = throughput;\n                }\n                else\n                {\n                    NS_FATAL_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                }\n                // test previous throughput is smaller (for the same channel width and GI)\n                if (throughput > prevThroughput[index])\n                {\n                    prevThroughput[index] = throughput;\n                }\n                else\n                {\n                    NS_FATAL_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                }\n                index++;\n            }\n            channelWidth *= 2;\n        }\n    }\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a wireless sensor network (WSN) with 10 nodes using the ZigBee protocol. One node should act as the coordinator, and the others should act as end devices. Each end device should send 128-byte UDP packets to the coordinator every 500ms. The simulation should run for 10 seconds. Use ZigBee PRO mode, and set the node mobility to random walk within a 100m x 100m area. Enable PCAP tracing for the ZigBee communication."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/zigbee-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ZigBeeExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"ZigBeeExample\", LOG_LEVEL_INFO);\n\n    // Create sensor nodes\n    NodeContainer nodes;\n    nodes.Create(10);\n\n    // Configure ZigBee communication\n    ZigBeeHelper zigbeeHelper;\n    zigbeeHelper.SetInterfaceType(ZigBeeHelper::ZIGBEE_PRO);\n\n    // Install ZigBee devices\n    NetDeviceContainer devices = zigbeeHelper.Install(nodes);\n\n    // Configure mobility\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0.0, 100.0, 0.0, 100.0)));\n    mobility.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Create applications (UDP server on the coordinator, client on other nodes)\n    uint16_t port = 5000;\n\n    // Set up UDP server (Coordinator)\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(0)); // Coordinator\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP clients (End Devices)\n    for (uint32_t i = 1; i < 10; ++i)\n    {\n        UdpClientHelper udpClient(interfaces.GetAddress(0), port);\n        udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n        udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(500)));\n        udpClient.SetAttribute(\"PacketSize\", UintegerValue(128));\n\n        ApplicationContainer clientApp = udpClient.Install(nodes.Get(i));\n        clientApp.Start(Seconds(2.0));\n        clientApp.Stop(Seconds(10.0));\n    }\n\n    // Enable tracing\n    zigbeeHelper.EnablePcap(\"zigbee_network\", devices);\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the NS-3 simulation framework to simulate a network topology with two nodes (n0, n1) connected via a CSMA LAN. The program should simulate a UDP flow from node n0 to node n1, where the client on n0 sends 1024-byte packets at 50 ms intervals, for a maximum of 320 packets or until the simulation ends. The user should be able to select either IPv4 or IPv6 addressing via command-line arguments, and there should be an option to enable or disable logging statements. If logging is enabled, log detailed information for the UDP client and server. The CSMA channel should be configured with a data rate of 5 Mbps, a delay of 2 ms, and an MTU of 1400 bytes. The server should run on port 4000, and the client should start sending packets at 2 seconds, with the simulation running for a total of 10 seconds. Ensure the program uses the necessary NS-3 modules (applications, core, csma, and internet) and outputs appropriate log messages during the simulation."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1\n//       |     |\n//       =======\n//         LAN (CSMA)\n//\n// - UDP flow from n0 to n1 of 1024 byte packets at intervals of 50 ms\n//   - maximum of 320 packets sent (or limited by simulation duration)\n//   - option to use IPv4 or IPv6 addressing\n//   - option to disable logging statements\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpClientServerExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Declare variables used in command-line arguments\n    bool useV6 = false;\n    bool logging = true;\n    Address serverAddress;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"useIpv6\", \"Use Ipv6\", useV6);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.Parse(argc, argv);\n\n    if (logging)\n    {\n        LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n    }\n\n    NS_LOG_INFO(\"Create nodes in above topology.\");\n    NodeContainer n;\n    n.Create(2);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    NS_LOG_INFO(\"Create channel between the two nodes.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    if (!useV6)\n    {\n        Ipv4AddressHelper ipv4;\n        ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer i = ipv4.Assign(d);\n        serverAddress = Address(i.GetAddress(1));\n    }\n    else\n    {\n        Ipv6AddressHelper ipv6;\n        ipv6.SetBase(\"2001:0000:f00d:cafe::\", Ipv6Prefix(64));\n        Ipv6InterfaceContainer i6 = ipv6.Assign(d);\n        serverAddress = Address(i6.GetAddress(1, 1));\n    }\n\n    NS_LOG_INFO(\"Create UdpServer application on node 1.\");\n    uint16_t port = 4000;\n    UdpServerHelper server(port);\n    ApplicationContainer apps = server.Install(n.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Create UdpClient application on node 0 to send to node 1.\");\n    uint32_t MaxPacketSize = 1024;\n    Time interPacketInterval = Seconds(0.05);\n    uint32_t maxPacketCount = 320;\n    UdpClientHelper client(serverAddress, port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    client.SetAttribute(\"PacketSize\", UintegerValue(MaxPacketSize));\n    apps = client.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate C++ code using ns-3 that demonstrates the setup of a Wi-Fi network with QoS for different access categories (AC). The code should define 4 independent Wi-Fi networks, each consisting of one access point (AP) and one station (STA), operating on different logical channels of the same physical medium. Each STA sends data packets to its respective AP using different QoS settings for AC_BE and AC_VI. The user should be able to configure parameters such as payload size, distance between nodes, RTS/CTS settings, and simulation time. The code should trace the TXOP duration for each QoS configuration and output the measured throughput. Include application setup using UdpServer and OnOffHelper for traffic generation, mobility models for positioning nodes, and the InternetStackHelper for IP addressing. Add command-line support to customize parameters and allow enabling or disabling of pcap file generation. The simulation should stop after the configured time, and the throughput and TXOP duration results should be printed."}, {"role": "assistant", "content": "#include \"ns3/command-line.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/pointer.h\"\n#include \"ns3/qos-txop.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/wifi-mac.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This is an example that illustrates 802.11 QoS for different Access Categories.\n// It defines 4 independent Wi-Fi networks (working on different logical channels\n// on the same \"ns3::YansWifiPhy\" channel object).\n// Each network contains one access point and one station. Each station continuously\n// transmits data packets to its respective AP.\n//\n// Network topology (numbers in parentheses are channel numbers):\n//\n//  BSS A (36)        BSS B (40)       BSS C (44)        BSS D (48)\n//   *      *          *      *         *      *          *      *\n//   |      |          |      |         |      |          |      |\n//  AP A   STA A      AP B   STA B     AP C   STA C      AP D   STA D\n//\n// The configuration is the following on the 4 networks:\n// - STA A sends AC_BE traffic to AP A with default AC_BE TXOP value of 0 (1 MSDU);\n// - STA B sends AC_BE traffic to AP B with non-default AC_BE TXOP of 4096 us;\n// - STA C sends AC_VI traffic to AP C with default AC_VI TXOP of 4096 us;\n// - STA D sends AC_VI traffic to AP D with non-default AC_VI TXOP value of 0 (1 MSDU);\n//\n// The user can select the distance between the stations and the APs, can enable/disable the RTS/CTS\n// mechanism and can choose the payload size and the simulation duration. Example: ./ns3 run\n// \"wifi-80211e-txop --distance=10 --simulationTime=20s --payloadSize=1000\"\n//\n// The output prints the throughput measured for the 4 cases/networks described above. When TXOP is\n// enabled, results show increased throughput since the channel is granted for a longer duration.\n// TXOP is enabled by default for AC_VI and AC_VO, so that they can use the channel for a longer\n// duration than AC_BE and AC_BK.\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"80211eTxop\");\n\n/**\n * Keeps the maximum duration among all TXOPs\n */\nstruct TxopDurationTracer\n{\n    /**\n     * Callback connected to TXOP duration trace source.\n     *\n     * \\param startTime TXOP start time\n     * \\param duration TXOP duration\n     * \\param linkId the ID of the link\n     */\n    void Trace(Time startTime, Time duration, uint8_t linkId);\n    Time m_max{Seconds(0)}; //!< maximum TXOP duration\n};\n\nvoid\nTxopDurationTracer::Trace(Time startTime, Time duration, uint8_t linkId)\n{\n    if (duration > m_max)\n    {\n        m_max = duration;\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t payloadSize{1472}; // bytes\n    Time simulationTime{\"10s\"};\n    meter_u distance{5};\n    bool enablePcap{false};\n    bool verifyResults{false}; // used for regression\n    Time txopLimit{\"4096us\"};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"payloadSize\", \"Payload size in bytes\", payloadSize);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the station and the access point\",\n                 distance);\n    cmd.AddValue(\"enablePcap\", \"Enable/disable pcap file generation\", enablePcap);\n    cmd.AddValue(\"verifyResults\",\n                 \"Enable/disable results verification at the end of the simulation\",\n                 verifyResults);\n    cmd.Parse(argc, argv);\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(4);\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(4);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n    wifi.SetRemoteStationManager(\"ns3::IdealWifiManager\");\n    WifiMacHelper mac;\n\n    NetDeviceContainer staDeviceA;\n    NetDeviceContainer staDeviceB;\n    NetDeviceContainer staDeviceC;\n    NetDeviceContainer staDeviceD;\n    NetDeviceContainer apDeviceA;\n    NetDeviceContainer apDeviceB;\n    NetDeviceContainer apDeviceC;\n    NetDeviceContainer apDeviceD;\n    Ssid ssid;\n\n    // Network A\n    ssid = Ssid(\"network-A\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{36, 20, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"QosSupported\", BooleanValue(true), \"Ssid\", SsidValue(ssid));\n    staDeviceA = wifi.Install(phy, mac, wifiStaNodes.Get(0));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"QosSupported\",\n                BooleanValue(true),\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceA = wifi.Install(phy, mac, wifiApNodes.Get(0));\n\n    // Network B\n    ssid = Ssid(\"network-B\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{40, 20, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"QosSupported\", BooleanValue(true), \"Ssid\", SsidValue(ssid));\n\n    staDeviceB = wifi.Install(phy, mac, wifiStaNodes.Get(1));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"QosSupported\",\n                BooleanValue(true),\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceB = wifi.Install(phy, mac, wifiApNodes.Get(1));\n\n    // Modify EDCA configuration (TXOP limit) for AC_BE\n    Ptr<NetDevice> dev = wifiApNodes.Get(1)->GetDevice(0);\n    Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    Ptr<WifiMac> wifi_mac = wifi_dev->GetMac();\n    PointerValue ptr;\n    Ptr<QosTxop> edca;\n    wifi_mac->GetAttribute(\"BE_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n    edca->SetTxopLimit(txopLimit);\n\n    // Trace TXOP duration for BE on STA1\n    dev = wifiStaNodes.Get(1)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_mac = wifi_dev->GetMac();\n    wifi_mac->GetAttribute(\"BE_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n    TxopDurationTracer beTxopTracer;\n    edca->TraceConnectWithoutContext(\"TxopTrace\",\n                                     MakeCallback(&TxopDurationTracer::Trace, &beTxopTracer));\n\n    // Network C\n    ssid = Ssid(\"network-C\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{44, 20, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"QosSupported\", BooleanValue(true), \"Ssid\", SsidValue(ssid));\n\n    staDeviceC = wifi.Install(phy, mac, wifiStaNodes.Get(2));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"QosSupported\",\n                BooleanValue(true),\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceC = wifi.Install(phy, mac, wifiApNodes.Get(2));\n\n    // Trace TXOP duration for VI on STA2\n    dev = wifiStaNodes.Get(2)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_mac = wifi_dev->GetMac();\n    wifi_mac->GetAttribute(\"VI_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n    TxopDurationTracer viTxopTracer;\n    edca->TraceConnectWithoutContext(\"TxopTrace\",\n                                     MakeCallback(&TxopDurationTracer::Trace, &viTxopTracer));\n\n    // Network D\n    ssid = Ssid(\"network-D\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{48, 20, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"QosSupported\", BooleanValue(true), \"Ssid\", SsidValue(ssid));\n\n    staDeviceD = wifi.Install(phy, mac, wifiStaNodes.Get(3));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"QosSupported\",\n                BooleanValue(true),\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceD = wifi.Install(phy, mac, wifiApNodes.Get(3));\n\n    // Modify EDCA configuration (TXOP limit) for AC_VO\n    dev = wifiApNodes.Get(3)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_mac = wifi_dev->GetMac();\n    wifi_mac->GetAttribute(\"VI_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n    edca->SetTxopLimit(MicroSeconds(0));\n\n    /* Setting mobility model */\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    // Set position for APs\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(10.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(20.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(30.0, 0.0, 0.0));\n    // Set position for STAs\n    positionAlloc->Add(Vector(distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(10 + distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(20 + distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(30 + distance, 0.0, 0.0));\n    // Remark: while we set these positions 10 meters apart, the networks do not interact\n    // and the only variable that affects transmission performance is the distance.\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(wifiApNodes);\n    mobility.Install(wifiStaNodes);\n\n    /* Internet stack */\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceA;\n    StaInterfaceA = address.Assign(staDeviceA);\n    Ipv4InterfaceContainer ApInterfaceA;\n    ApInterfaceA = address.Assign(apDeviceA);\n\n    address.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceB;\n    StaInterfaceB = address.Assign(staDeviceB);\n    Ipv4InterfaceContainer ApInterfaceB;\n    ApInterfaceB = address.Assign(apDeviceB);\n\n    address.SetBase(\"192.168.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceC;\n    StaInterfaceC = address.Assign(staDeviceC);\n    Ipv4InterfaceContainer ApInterfaceC;\n    ApInterfaceC = address.Assign(apDeviceC);\n\n    address.SetBase(\"192.168.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceD;\n    StaInterfaceD = address.Assign(staDeviceD);\n    Ipv4InterfaceContainer ApInterfaceD;\n    ApInterfaceD = address.Assign(apDeviceD);\n\n    /* Setting applications */\n    uint16_t port = 5001;\n    UdpServerHelper serverA(port);\n    ApplicationContainer serverAppA = serverA.Install(wifiApNodes.Get(0));\n    serverAppA.Start(Seconds(0.0));\n    serverAppA.Stop(simulationTime + Seconds(1.0));\n\n    InetSocketAddress destA(ApInterfaceA.GetAddress(0), port);\n\n    OnOffHelper clientA(\"ns3::UdpSocketFactory\", destA);\n    clientA.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientA.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientA.SetAttribute(\"DataRate\", StringValue(\"100000kb/s\"));\n    clientA.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n    clientA.SetAttribute(\"Tos\", UintegerValue(0x70)); // AC_BE\n\n    ApplicationContainer clientAppA = clientA.Install(wifiStaNodes.Get(0));\n    clientAppA.Start(Seconds(1.0));\n    clientAppA.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverB(port);\n    ApplicationContainer serverAppB = serverB.Install(wifiApNodes.Get(1));\n    serverAppB.Start(Seconds(0.0));\n    serverAppB.Stop(simulationTime + Seconds(1.0));\n\n    InetSocketAddress destB(ApInterfaceB.GetAddress(0), port);\n\n    OnOffHelper clientB(\"ns3::UdpSocketFactory\", destB);\n    clientB.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientB.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientB.SetAttribute(\"DataRate\", StringValue(\"100000kb/s\"));\n    clientB.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n    clientB.SetAttribute(\"Tos\", UintegerValue(0x70)); // AC_BE\n\n    ApplicationContainer clientAppB = clientB.Install(wifiStaNodes.Get(1));\n    clientAppB.Start(Seconds(1.0));\n    clientAppB.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverC(port);\n    ApplicationContainer serverAppC = serverC.Install(wifiApNodes.Get(2));\n    serverAppC.Start(Seconds(0.0));\n    serverAppC.Stop(simulationTime + Seconds(1.0));\n\n    InetSocketAddress destC(ApInterfaceC.GetAddress(0), port);\n\n    OnOffHelper clientC(\"ns3::UdpSocketFactory\", destC);\n    clientC.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientC.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientC.SetAttribute(\"DataRate\", StringValue(\"100000kb/s\"));\n    clientC.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n    clientC.SetAttribute(\"Tos\", UintegerValue(0xb8)); // AC_VI\n\n    ApplicationContainer clientAppC = clientC.Install(wifiStaNodes.Get(2));\n    clientAppC.Start(Seconds(1.0));\n    clientAppC.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverD(port);\n    ApplicationContainer serverAppD = serverD.Install(wifiApNodes.Get(3));\n    serverAppD.Start(Seconds(0.0));\n    serverAppD.Stop(simulationTime + Seconds(1.0));\n\n    InetSocketAddress destD(ApInterfaceD.GetAddress(0), port);\n\n    OnOffHelper clientD(\"ns3::UdpSocketFactory\", destD);\n    clientD.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientD.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientD.SetAttribute(\"DataRate\", StringValue(\"100000kb/s\"));\n    clientD.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n    clientD.SetAttribute(\"Tos\", UintegerValue(0xb8)); // AC_VI\n\n    ApplicationContainer clientAppD = clientD.Install(wifiStaNodes.Get(3));\n    clientAppD.Start(Seconds(1.0));\n    clientAppD.Stop(simulationTime + Seconds(1.0));\n\n    if (enablePcap)\n    {\n        phy.EnablePcap(\"AP_A\", apDeviceA.Get(0));\n        phy.EnablePcap(\"STA_A\", staDeviceA.Get(0));\n        phy.EnablePcap(\"AP_B\", apDeviceB.Get(0));\n        phy.EnablePcap(\"STA_B\", staDeviceB.Get(0));\n        phy.EnablePcap(\"AP_C\", apDeviceC.Get(0));\n        phy.EnablePcap(\"STA_C\", staDeviceC.Get(0));\n        phy.EnablePcap(\"AP_D\", apDeviceD.Get(0));\n        phy.EnablePcap(\"STA_D\", staDeviceD.Get(0));\n    }\n\n    Simulator::Stop(simulationTime + Seconds(1.0));\n    Simulator::Run();\n\n    /* Show results */\n    double totalPacketsThroughA = DynamicCast<UdpServer>(serverAppA.Get(0))->GetReceived();\n    double totalPacketsThroughB = DynamicCast<UdpServer>(serverAppB.Get(0))->GetReceived();\n    double totalPacketsThroughC = DynamicCast<UdpServer>(serverAppC.Get(0))->GetReceived();\n    double totalPacketsThroughD = DynamicCast<UdpServer>(serverAppD.Get(0))->GetReceived();\n\n    Simulator::Destroy();\n\n    auto throughput = totalPacketsThroughA * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"AC_BE with default TXOP limit (0ms): \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 28 || throughput > 29))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    throughput = totalPacketsThroughB * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"AC_BE with non-default TXOP limit (4.096ms): \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 36.5 || throughput > 37))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"  Maximum TXOP duration = \" << beTxopTracer.m_max.GetMicroSeconds() << \" us\"\n              << '\\n';\n    if (verifyResults &&\n        (beTxopTracer.m_max < MicroSeconds(3008) || beTxopTracer.m_max > txopLimit))\n    {\n        NS_LOG_ERROR(\"Maximum TXOP duration \" << beTxopTracer.m_max\n                                              << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    throughput = totalPacketsThroughC * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"AC_VI with default TXOP limit (4.096ms): \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 36.5 || throughput > 37.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"  Maximum TXOP duration = \" << viTxopTracer.m_max.GetMicroSeconds() << \" us\"\n              << '\\n';\n    if (verifyResults &&\n        (viTxopTracer.m_max < MicroSeconds(3008) || viTxopTracer.m_max > txopLimit))\n    {\n        NS_LOG_ERROR(\"Maximum TXOP duration \" << viTxopTracer.m_max\n                                              << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    throughput = totalPacketsThroughD * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"AC_VI with non-default TXOP limit (0ms): \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 31.5 || throughput > 32.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a Wi-Fi network in NS-3 with two nodes: a station (Node 1) and an access point (Node 0). The station should send UDP packets to the access point starting at 2s and stopping at 10s. Use Wi-Fi with an SSID of ns-3-ssid, and set the simulation duration to 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Wi-Fi helper\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up Wi-Fi channel\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::LogDistancePropagationLossModel\");\n\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Set up MAC\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::StaWifiMac\",\n                    \"Ssid\", SsidValue(Ssid(\"ns-3-ssid\")),\n                    \"Active\", BooleanValue(true));\n\n    // Install Wi-Fi devices\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Set up Mobility Model for nodes\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the Internet stack on nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 0 (Access Point)\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 1 (Station)\n    UdpClientHelper udpClient(interfaces.GetAddress(0), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a WiFi network with two nodes communicating over TCP. The nodes should use WiFi 802.11b with a grid-based mobility model where nodes have static positions at (0,0) and (5,10) meters. Set the client node (node 0) to send 100 TCP packets of 512 bytes every 0.1 seconds to the server node (node 1) on port 9. The simulation should run for 20 seconds. Use a WiFi Aarf (adaptive rate) manager for connection management."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiTcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the WiFi channel (802.11b standard)\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up the WiFi mac layer\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(Ssid(\"wifi-network\")));\n\n    // Install the WiFi devices (NICs)\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set up mobility for the nodes (Static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the Internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the WiFi devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Install a TCP server on node 1 (server side)\n    uint16_t port = 9; // Port 9\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Install a TCP client on node 0 (client side)\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(512)); // 512 bytes packets\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(20.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a point-to-point network between two nodes with a TCP bulk sender on Node 0 and a TCP sink on Node 1. The link should have a 5 Mbps data rate and a 2 ms delay. The IP range should be 10.1.1.0/24. The TCP sink should start at 1 second and run until 10 seconds, while the TCP sender starts at 2 seconds. The sender should transfer unlimited data (MaxBytes = 0)."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"P2PTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create 2 nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install P2P devices on nodes\n    NetDeviceContainer devices = p2p.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP Sink on Node 1\n    uint16_t port = 8080;\n    Address sinkAddress(InetSocketAddress(interfaces.GetAddress(1), port));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    ApplicationContainer sinkApp = sinkHelper.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Set up TCP Bulk Sender on Node 0\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", sinkAddress);\n    source.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Send unlimited data\n    ApplicationContainer sourceApp = source.Install(nodes.Get(0));\n    sourceApp.Start(Seconds(2.0));\n    sourceApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network in ns-3 where two stations (STA) are connected to an access point (AP). One station sends UDP packets to the other via the AP, and the performance metrics such as throughput and packet loss are measured. Use NetAnim to visualize the communication."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation parameters\n    double simulationTime = 10.0; // seconds\n\n    // Create nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2); // Two stations\n\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1); // One access point\n\n    // Setup Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Install UDP application\n    uint16_t port = 9; // UDP port\n\n    // Create UDP server on one of the stations\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiStaNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Create UDP client on the other station\n    UdpClientHelper udpClient(staInterfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05))); // 20 packets per second\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024)); // 1024 bytes per packet\n\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Enable NetAnim\n    AnimationInterface anim(\"wifi_network.xml\");\n    anim.SetConstantPosition(wifiApNode.Get(0), 50.0, 50.0); // AP position\n    anim.SetConstantPosition(wifiStaNodes.Get(0), 30.0, 30.0); // STA 1 position\n    anim.SetConstantPosition(wifiStaNodes.Get(1), 70.0, 30.0); // STA 2 position\n\n    // Run simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that demonstrates packet loss in a simple wired network with two nodes connected via a point-to-point link. The simulation should send packets using a UDP application, where packet loss occurs due to a rate-limiting queue. The example should also include NetAnim for visualizing packet transmissions and losses in the network."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/traffic-control-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PacketLossExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set up logging\n    LogComponentEnable(\"PacketLossExample\", LOG_LEVEL_INFO);\n\n    // Simulation time\n    double simulationTime = 5.0; // seconds\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Create a point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"2Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    // Install net devices on both nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the internet stack on both nodes\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a traffic control helper with a queue to simulate packet loss\n    TrafficControlHelper tch;\n    tch.SetRootQueueDisc(\"ns3::RedQueueDisc\"); // Use Random Early Detection (RED) queue for packet loss\n    tch.Install(devices);\n\n    // Create a UDP server application on Node 1\n    uint16_t port = 9; // Port number\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Create a UDP client application on Node 0\n    UdpClientHelper client(interfaces.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    client.SetAttribute(\"Interval\", TimeValue(Seconds(0.05))); // 50 ms interval between packets\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));    // 1024 bytes per packet\n\n    ApplicationContainer clientApp = client.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Set up NetAnim for visualization\n    AnimationInterface anim(\"packet_loss_netanim.xml\");\n\n    // Set constant positions for NetAnim visualization\n    anim.SetConstantPosition(nodes.Get(0), 0, 0); // Node 0 (Sender)\n    anim.SetConstantPosition(nodes.Get(1), 5, 0); // Node 1 (Receiver)\n\n    // Enable packet metadata in NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a simple LTE network with one eNodeB (base station) and three UEs (User Equipments). The eNodeB runs a UDP server on port 9, and the UEs act as UDP clients. The UDP clients send 1,000 UDP packets of 1024 bytes each with an interval of 0.01 seconds. The simulation runs for 10 seconds, with the server starting at 1 second and the clients starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleLteExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleLteExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: one eNodeB (base station) and multiple UEs\n    NodeContainer enbNode, ueNodes;\n    enbNode.Create(1);\n    ueNodes.Create(3);\n\n    // Set up LTE helper and install LTE stack\n    LteHelper lteHelper;\n    lteHelper.SetSchedulerType(\"ns3::PfSocketScheduler\");\n    NetDeviceContainer enbDevice, ueDevices;\n    enbDevice = lteHelper.InstallEnbDevice(enbNode);\n    ueDevices = lteHelper.InstallUeDevice(ueNodes);\n\n    // Install internet stack (IP, UDP, etc.)\n    InternetStackHelper stack;\n    stack.Install(enbNode);\n    stack.Install(ueNodes);\n\n    // Assign IP addresses to UEs and eNodeB\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface = ipv4.Assign(ueDevices);\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer enbIpIface = ipv4.Assign(enbDevice);\n\n    // Set up UDP server on the eNodeB\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(enbNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on each UE\n    UdpClientHelper udpClient(enbIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(ueNodes);\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Attach UEs to the eNodeB\n    lteHelper.Attach(ueDevices.Get(0), enbDevice.Get(0));\n    lteHelper.Attach(ueDevices.Get(1), enbDevice.Get(0));\n    lteHelper.Attach(ueDevices.Get(2), enbDevice.Get(0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a WiFi network with three nodes. The nodes are statically placed with a grid-based mobility model, and the WiFi devices should use 802.11b. Node 2 should act as a TCP server listening on port 9, while node 0 and node 1 act as TCP clients. Each client sends 10 TCP packets of 512 bytes to the server at intervals of 0.1 seconds. The simulation should run for 20 seconds. The nodes should be arranged in a 3x3 grid layout."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiTcpMultipleClients\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiTcpMultipleClients\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Setup the WiFi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Setup the WiFi MAC layer\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(Ssid(\"wifi-network\")));\n\n    // Install WiFi devices on the nodes\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set up mobility for the nodes (Static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the Internet stack (IP/TCP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Install a TCP server on node 2 (server side)\n    uint16_t port = 9;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(2));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Install TCP clients on nodes 0 and 1 (client side)\n    TcpClientHelper tcpClient1(interfaces.GetAddress(2), port);\n    tcpClient1.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    tcpClient1.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient1.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp1 = tcpClient1.Install(nodes.Get(0));\n    clientApp1.Start(Seconds(2.0));\n    clientApp1.Stop(Seconds(20.0));\n\n    TcpClientHelper tcpClient2(interfaces.GetAddress(2), port);\n    tcpClient2.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    tcpClient2.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient2.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp2 = tcpClient2.Install(nodes.Get(1));\n    clientApp2.Start(Seconds(3.0));\n    clientApp2.Stop(Seconds(20.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple wireless network using ns-3, comprising three nodes arranged in a line topology. Configure the middle node as a router that forwards packets between the two end nodes. Implement a Constant Bit Rate (CBR) traffic source on one end node and a packet sink on the other to measure end-to-end throughput. Enable tracing to capture packet transmissions and receptions, and output the results to a file for analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWirelessNetwork\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"SimpleWirelessNetwork\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Configure Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    // Configure PHY and MAC\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n    NqosWifiMacHelper mac = NqosWifiMacHelper::Default();\n\n    // Install Wi-Fi devices\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Configure routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create applications\n    uint16_t port = 9; // Well-known echo port number\n\n    // CBR traffic source on node 0\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(interfaces.GetAddress(2), port));\n    onoff.SetAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer sourceApps = onoff.Install(nodes.Get(0));\n    sourceApps.Start(Seconds(1.0));\n    sourceApps.Stop(Seconds(10.0));\n\n    // Packet sink on node 2\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApps = sink.Install(nodes.Get(2));\n    sinkApps.Start(Seconds(1.0));\n    sinkApps.Stop(Seconds(10.0));\n\n    // Enable tracing\n    AsciiTraceHelper ascii;\n    phy.EnableAsciiAll(ascii.CreateFileStream(\"simple-wireless-network.tr\"));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a TCP client and TCP server communicate over a Point-to-Point (P2P) network with an intermediate router node. The client sends TCP packets to the server, and the server acknowledges the packets."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpRoutedExample\");\n\nint main() {\n    LogComponentEnable(\"TcpRoutedExample\", LOG_LEVEL_INFO);\n\n    // Create nodes (Client, Router, Server)\n    NodeContainer clientRouter, routerServer;\n    clientRouter.Create(2); // Client and Router\n    routerServer.Add(clientRouter.Get(1)); // Reuse Router node\n    routerServer.Create(1); // Server\n\n    // Setup Point-to-Point links\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer clientRouterDevices = p2p.Install(clientRouter);\n    NetDeviceContainer routerServerDevices = p2p.Install(routerServer);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(clientRouter);\n    internet.Install(routerServer.Get(1)); // Server\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer clientRouterInterfaces = address.Assign(clientRouterDevices);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer routerServerInterfaces = address.Assign(routerServerDevices);\n\n    // Set up routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Setup TCP Server (Server Node)\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(routerServerInterfaces.GetAddress(1), port));\n\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = sinkHelper.Install(routerServer.Get(1));\n    serverApp.Start(Seconds(0.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup TCP Client (Client Node)\n    BulkSendHelper clientHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    clientHelper.SetAttribute(\"MaxBytes\", UintegerValue(1024)); // Send 1024 bytes\n\n    ApplicationContainer clientApp = clientHelper.Install(clientRouter.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a VANET using Wi-Fi 802.11p (WAVE). Create three vehicles, each assigned a unique IP address in the 192.168.1.0/24 subnet. Use a constant velocity mobility model with vehicles moving at different speeds along the X-axis. The last vehicle should act as a UDP echo server on port 9, while the first vehicle should act as a client, sending three packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wave-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    NodeContainer vehicles;\n    vehicles.Create(3); // Create 3 vehicles (nodes)\n\n    YansWifiChannelHelper waveChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wavePhy = YansWifiPhyHelper::Default();\n    wavePhy.SetChannel(waveChannel.Create());\n\n    NqosWaveMacHelper waveMac = NqosWaveMacHelper::Default();\n    Wifi80211pHelper waveHelper = Wifi80211pHelper::Default();\n\n    NetDeviceContainer waveDevices = waveHelper.Install(wavePhy, waveMac, vehicles);\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(vehicles);\n\n    vehicles.Get(0)->GetObject<MobilityModel>()->SetPosition(Vector(0, 0, 0));\n    vehicles.Get(1)->GetObject<MobilityModel>()->SetPosition(Vector(50, 0, 0));\n    vehicles.Get(2)->GetObject<MobilityModel>()->SetPosition(Vector(100, 0, 0));\n\n    vehicles.Get(0)->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(10, 0, 0));\n    vehicles.Get(1)->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(15, 0, 0));\n    vehicles.Get(2)->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(20, 0, 0));\n\n    InternetStackHelper internet;\n    internet.Install(vehicles);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(waveDevices);\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(vehicles.Get(2)); // Last vehicle is the server\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(2), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(3));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(vehicles.Get(0)); // First vehicle is the client\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a vehicle (moving node) communicates with a Roadside Unit (RSU) using a Vehicular Ad-hoc Network (VANET) over a Wi-Fi 802.11p (WAVE) connection. The vehicle should periodically send UDP packets to the RSU."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wave-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"VANET_80211p_Example\");\n\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"RSU received a UDP packet from the vehicle!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"VANET_80211p_Example\", LOG_LEVEL_INFO);\n\n    uint16_t port = 4000;\n\n    // Create nodes (1 Vehicle, 1 RSU)\n    NodeContainer nodes;\n    nodes.Create(2);\n    Ptr<Node> vehicle = nodes.Get(0);\n    Ptr<Node> rsu = nodes.Get(1);\n\n    // Setup 802.11p (WAVE) for VANET communication\n    YansWifiChannelHelper waveChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wavePhy = YansWifiPhyHelper::Default();\n    wavePhy.SetChannel(waveChannel.Create());\n\n    QosWaveMacHelper waveMac = QosWaveMacHelper::Default();\n    WaveHelper wave;\n    NetDeviceContainer devices = wave.Install(wavePhy, waveMac, nodes);\n\n    // Mobility model (Vehicle moves, RSU is static)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(rsu);\n\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(vehicle);\n    vehicle->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(10.0, 0.0, 0.0)); // Vehicle moves at 10 m/s\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Setup UDP Receiver (RSU)\n    Ptr<Socket> rsuSocket = Socket::CreateSocket(rsu, UdpSocketFactory::GetTypeId());\n    rsuSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    rsuSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Sender (Vehicle)\n    Ptr<Socket> vehicleSocket = Socket::CreateSocket(vehicle, UdpSocketFactory::GetTypeId());\n    InetSocketAddress rsuAddress(interfaces.GetAddress(1), port);\n\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, vehicleSocket, Create<Packet>(128), 0, rsuAddress);\n    Simulator::Schedule(Seconds(2.0), &Socket::SendTo, vehicleSocket, Create<Packet>(128), 0, rsuAddress);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(5.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nProvide code that validates NIST, YANS, and Table-based error rate models for HT (High Throughput) rates in NS-3. The program should generate Gnuplot plots of Frame Success Rate versus Signal-to-Noise Ratio (SNR) for each error rate model and for every HT MCS value. It should iterate over SNR values, calculate the frame success rate for each mode and model, and output the results as Gnuplot datasets while allowing configuration of frame size."}, {"role": "assistant", "content": "// This example is used to validate Nist, Yans and Table-based error rate models for HT rates.\n//\n// It outputs plots of the Frame Success Rate versus the Signal-to-noise ratio for\n// Nist, Yans and Table-based error rate models and for every HT MCS value.\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t frameSizeBytes = 1500;\n    std::ofstream yansfile(\"yans-frame-success-rate-n.plt\");\n    std::ofstream nistfile(\"nist-frame-success-rate-n.plt\");\n    std::ofstream tablefile(\"table-frame-success-rate-n.plt\");\n\n    const std::vector<std::string> modes{\n        \"HtMcs0\",\n        \"HtMcs1\",\n        \"HtMcs2\",\n        \"HtMcs3\",\n        \"HtMcs4\",\n        \"HtMcs5\",\n        \"HtMcs6\",\n        \"HtMcs7\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"FrameSize\", \"The frame size in bytes\", frameSizeBytes);\n    cmd.Parse(argc, argv);\n\n    Gnuplot yansplot = Gnuplot(\"yans-frame-success-rate-n.eps\");\n    Gnuplot nistplot = Gnuplot(\"nist-frame-success-rate-n.eps\");\n    Gnuplot tableplot = Gnuplot(\"table-frame-success-rate-n.eps\");\n    WifiTxVector txVector;\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n\n    uint32_t frameSizeBits = frameSizeBytes * 8;\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset yansdataset(mode);\n        Gnuplot2dDataset nistdataset(mode);\n        Gnuplot2dDataset tabledataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -5.0; snrDb <= 30.0; snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double ps = yans->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            yansdataset.Add(snrDb, ps);\n\n            ps = nist->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            nistdataset.Add(snrDb, ps);\n\n            ps = table->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            tabledataset.Add(snrDb, ps);\n        }\n\n        yansplot.AddDataset(yansdataset);\n        nistplot.AddDataset(nistdataset);\n        tableplot.AddDataset(tabledataset);\n    }\n\n    yansplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    yansplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    yansplot.SetExtra(\"set xrange [-5:30]\\n\\\nset yrange [0:1.2]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style increment user\");\n    yansplot.GenerateOutput(yansfile);\n    yansfile.close();\n\n    nistplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    nistplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    nistplot.SetExtra(\"set xrange [-5:30]\\n\\\nset yrange [0:1.2]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style increment user\");\n\n    nistplot.GenerateOutput(nistfile);\n    nistfile.close();\n\n    tableplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    tableplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    tableplot.SetExtra(\"set xrange [-5:30]\\n\\\nset yrange [0:1.2]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style increment user\");\n\n    tableplot.GenerateOutput(tablefile);\n    tablefile.close();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a Mobile Ad Hoc Network (MANET) with 10 nodes using AODV routing protocol. The nodes should move randomly within a 500m x 500m area at 5 m/s, with a 2-second pause time. The network should use WiFi (802.11b, Ad Hoc mode). One node should act as a UDP server on port 4000, while another node should act as a UDP client sending 1024-byte packets every second. The simulation should run for 20 seconds, with PCAP tracing enabled."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ManetAodvExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"ManetAodvExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(10);\n\n    // Configure WiFi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Install devices\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Configure mobility\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", StringValue(\"ns3::ConstantRandomVariable[Constant=5.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=2.0]\"),\n                              \"PositionAllocator\", StringValue(\"ns3::RandomRectanglePositionAllocator[MinX=0.0|MinY=0.0|MaxX=500.0|MaxY=500.0]\"));\n    mobility.Install(nodes);\n\n    // Install Internet stack with AODV\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on last node\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(9));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Set up UDP client on first node\n    UdpClientHelper udpClient(interfaces.GetAddress(9), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(50));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(20.0));\n\n    // Enable tracing\n    phy.EnablePcap(\"manet-aodv\", devices);\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an NS-3 simulation that conducts an experiment to analyze the performance of WiFi clear channel conditions under different data rates using the 802.11b standard. Implement an `Experiment` class to handle the setup and execution of the experiment, including methods for traffic generation, packet reception, and node positioning. In the `main` function, set up a loop to test various transmission modes, configure the WiFi helper and PHY layer parameters, and simulate the effects of different received signal strengths on packet reception. Finally, collect the results in a Gnuplot dataset and generate a visual output in EPS format, showing the relationship between RSS and the number of packets received."}, {"role": "assistant", "content": "#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/string.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ClearChannelCmu\");\n\n/**\n * WiFi clear channel cmu experiment class.\n *\n * It handles the creation and run of an experiment.\n */\nclass Experiment\n{\n  public:\n    Experiment();\n    /**\n     * Constructor.\n     * \\param name The name of the experiment.\n     */\n    Experiment(std::string name);\n    /**\n     * Run an experiment.\n     * \\param wifi      //!< The WifiHelper class.\n     * \\param wifiPhy   //!< The YansWifiPhyHelper class.\n     * \\param wifiMac   //!< The WifiMacHelper class.\n     * \\param wifiChannel //!< The YansWifiChannelHelper class.\n     * \\return the number of received packets.\n     */\n    uint32_t Run(const WifiHelper& wifi,\n                 const YansWifiPhyHelper& wifiPhy,\n                 const WifiMacHelper& wifiMac,\n                 const YansWifiChannelHelper& wifiChannel);\n\n  private:\n    /**\n     * Receive a packet.\n     * \\param socket The receiving socket.\n     */\n    void ReceivePacket(Ptr<Socket> socket);\n    /**\n     * Set the position of a node.\n     * \\param node The node.\n     * \\param position The position of the node.\n     */\n    void SetPosition(Ptr<Node> node, Vector position);\n    /**\n     * Get the position of a node.\n     * \\param node The node.\n     * \\return the position of the node.\n     */\n    Vector GetPosition(Ptr<Node> node);\n    /**\n     * Setup the receiving socket.\n     * \\param node The receiving node.\n     * \\return the socket.\n     */\n    Ptr<Socket> SetupPacketReceive(Ptr<Node> node);\n    /**\n     * Generate the traffic.\n     * \\param socket The sending socket.\n     * \\param pktSize The packet size.\n     * \\param pktCount The number of packets to send.\n     * \\param pktInterval The time between packets.\n     */\n    void GenerateTraffic(Ptr<Socket> socket, uint32_t pktSize, uint32_t pktCount, Time pktInterval);\n\n    uint32_t m_pktsTotal;      //!< Total number of received packets\n    Gnuplot2dDataset m_output; //!< Output dataset.\n};\n\nExperiment::Experiment()\n{\n}\n\nExperiment::Experiment(std::string name)\n    : m_output(name)\n{\n    m_output.SetStyle(Gnuplot2dDataset::LINES);\n}\n\nvoid\nExperiment::SetPosition(Ptr<Node> node, Vector position)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    mobility->SetPosition(position);\n}\n\nVector\nExperiment::GetPosition(Ptr<Node> node)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    return mobility->GetPosition();\n}\n\nvoid\nExperiment::ReceivePacket(Ptr<Socket> socket)\n{\n    Ptr<Packet> packet;\n    while ((packet = socket->Recv()))\n    {\n        m_pktsTotal++;\n    }\n}\n\nPtr<Socket>\nExperiment::SetupPacketReceive(Ptr<Node> node)\n{\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> sink = Socket::CreateSocket(node, tid);\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 80);\n    sink->Bind(local);\n    sink->SetRecvCallback(MakeCallback(&Experiment::ReceivePacket, this));\n    return sink;\n}\n\nvoid\nExperiment::GenerateTraffic(Ptr<Socket> socket,\n                            uint32_t pktSize,\n                            uint32_t pktCount,\n                            Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval,\n                            &Experiment::GenerateTraffic,\n                            this,\n                            socket,\n                            pktSize,\n                            pktCount - 1,\n                            pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\nuint32_t\nExperiment::Run(const WifiHelper& wifi,\n                const YansWifiPhyHelper& wifiPhy,\n                const WifiMacHelper& wifiMac,\n                const YansWifiChannelHelper& wifiChannel)\n{\n    m_pktsTotal = 0;\n\n    NodeContainer c;\n    c.Create(2);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    YansWifiPhyHelper phy = wifiPhy;\n    phy.SetChannel(wifiChannel.Create());\n\n    NetDeviceContainer devices = wifi.Install(phy, wifiMac, c);\n\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    Ipv4AddressHelper ipv4;\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    Ptr<Socket> recvSink = SetupPacketReceive(c.Get(0));\n\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> source = Socket::CreateSocket(c.Get(1), tid);\n    InetSocketAddress remote = InetSocketAddress(Ipv4Address(\"255.255.255.255\"), 80);\n    source->SetAllowBroadcast(true);\n    source->Connect(remote);\n    uint32_t packetSize = 1014;\n    uint32_t maxPacketCount = 200;\n    Time interPacketInterval = Seconds(1.);\n    Simulator::Schedule(Seconds(1.0),\n                        &Experiment::GenerateTraffic,\n                        this,\n                        source,\n                        packetSize,\n                        maxPacketCount,\n                        interPacketInterval);\n    Simulator::Run();\n\n    Simulator::Destroy();\n\n    return m_pktsTotal;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::ofstream outfile(\"clear-channel.plt\");\n\n    const std::vector<std::string> modes{\n        \"DsssRate1Mbps\",\n        \"DsssRate2Mbps\",\n        \"DsssRate5_5Mbps\",\n        \"DsssRate11Mbps\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Gnuplot gnuplot = Gnuplot(\"clear-channel.eps\");\n\n    for (uint32_t i = 0; i < modes.size(); i++)\n    {\n        std::cout << modes[i] << std::endl;\n        Gnuplot2dDataset dataset(modes[i]);\n\n        for (double rss = -102.0; rss <= -80.0; rss += 0.5)\n        {\n            Experiment experiment;\n            dataset.SetStyle(Gnuplot2dDataset::LINES);\n\n            WifiHelper wifi;\n            wifi.SetStandard(WIFI_STANDARD_80211b);\n            WifiMacHelper wifiMac;\n            Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\",\n                               StringValue(modes[i]));\n            wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                         \"DataMode\",\n                                         StringValue(modes[i]),\n                                         \"ControlMode\",\n                                         StringValue(modes[i]));\n            wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n            YansWifiPhyHelper wifiPhy;\n            YansWifiChannelHelper wifiChannel;\n            wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n            wifiChannel.AddPropagationLoss(\"ns3::FixedRssLossModel\", \"Rss\", DoubleValue(rss));\n\n            NS_LOG_DEBUG(modes[i]);\n            experiment = Experiment(modes[i]);\n            wifiPhy.Set(\"TxPowerStart\", DoubleValue(15.0));\n            wifiPhy.Set(\"TxPowerEnd\", DoubleValue(15.0));\n            wifiPhy.Set(\"RxGain\", DoubleValue(0));\n            wifiPhy.Set(\"RxNoiseFigure\", DoubleValue(7));\n            uint32_t pktsRecvd = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n            dataset.Add(rss, pktsRecvd);\n        }\n\n        gnuplot.AddDataset(dataset);\n    }\n    gnuplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    gnuplot.SetLegend(\"RSS(dBm)\", \"Number of packets received\");\n    gnuplot.SetExtra(\"set xrange [-102:-83]\");\n    gnuplot.GenerateOutput(outfile);\n    outfile.close();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Wi-Fi mesh network using Ad-Hoc mode with 5 nodes. Each node should communicate with the others using UDP packets. Set up a UDP server on the last node and a UDP client on the first node. The Wi-Fi nodes should use the AarfWifiManager for station management and have random mobility. The UDP client sends packets to the UDP server with a packet size of 1024 bytes, a maximum of 100 packets, and an interval of 100ms. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiMeshUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set default values for command line arguments\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"WifiMeshUdpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the Wi-Fi mesh network\n    NodeContainer wifiNodes;\n    wifiNodes.Create(5); // Create 5 Wi-Fi nodes\n\n    // Set up Wi-Fi Mesh Helper\n    WifiMeshHelper wifiMesh;\n    wifiMesh.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up Wi-Fi MAC and PHY attributes\n    MeshHelper meshHelper;\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns3-mesh-ssid\");\n    wifiMac.SetType(\"ns3::AdhocWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer meshDevices = wifiMesh.Install(wifiPhy, wifiMac, wifiNodes);\n\n    // Set up mobility model for the nodes\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack on the nodes\n    InternetStackHelper internet;\n    internet.Install(wifiNodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(meshDevices);\n\n    // Set up the UDP server on the last node (destination)\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiNodes.Get(4)); // Last node\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the first node (source)\n    UdpClientHelper udpClient(interfaces.GetAddress(4), port); // Sending to last node\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(wifiNodes.Get(0)); // First node\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 library to simulate a network topology featuring two routers (R1, R2) and two station nodes (STA1, STA2). Implement the following configuration: STA1 uses R1 as its default route, R1 has a static route to STA2 via R2, and STA2 uses R2 as its default route. Have STA1 send an Echo Request to STA2 through R1, which forwards it to R2. Afterward, R1 sends an ICMPv6 Redirection message to STA1, indicating that future Echo Requests to STA2 should go directly to R2. Include tracing of packet flows to a file named 'icmpv6-redirect.tr'."}, {"role": "assistant", "content": "\u0002\n// Network topology\n//\n//             STA2\n//              |\n//              |\n//   R1         R2\n//   |          |\n//   |          |\n//   ------------\n//           |\n//           |\n//          STA 1\n//\n// - Initial configuration :\n//         - STA1 default route : R1\n//         - R1 static route to STA2 : R2\n//         - STA2 default route : R2\n// - STA1 send Echo Request to STA2 using its default route to R1\n// - R1 receive Echo Request from STA1, and forward it to R2\n// - R1 send an ICMPv6 Redirection to STA1 with Target STA2 and Destination R2\n// - Next Echo Request from STA1 to STA2 are directly sent to R2\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Icmpv6RedirectExample\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Icmpv6RedirectExample\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"NdiscCache\", LOG_LEVEL_ALL);\n    }\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> sta1 = CreateObject<Node>();\n    Ptr<Node> r1 = CreateObject<Node>();\n    Ptr<Node> r2 = CreateObject<Node>();\n    Ptr<Node> sta2 = CreateObject<Node>();\n    NodeContainer net1(sta1, r1, r2);\n    NodeContainer net2(r2, sta2);\n    NodeContainer all(sta1, r1, r2, sta2);\n\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer ndc1 = csma.Install(net1);\n    NetDeviceContainer ndc2 = csma.Install(net2);\n\n    NS_LOG_INFO(\"Assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic1 = ipv6.Assign(ndc1);\n    iic1.SetForwarding(2, true);\n    iic1.SetForwarding(1, true);\n    iic1.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic2 = ipv6.Assign(ndc2);\n    iic2.SetForwarding(0, true);\n    iic2.SetDefaultRouteInAllNodes(0);\n\n    Ipv6StaticRoutingHelper routingHelper;\n\n    // manually inject a static route to the second router.\n    Ptr<Ipv6StaticRouting> routing = routingHelper.GetStaticRouting(r1->GetObject<Ipv6>());\n    routing->AddHostRouteTo(iic2.GetAddress(1, 1),\n                            iic1.GetAddress(2, 0),\n                            iic1.GetInterfaceIndex(1));\n\n    Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);\n    Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(0.0), r1, routingStream);\n    Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(3.0), sta1, routingStream);\n\n    NS_LOG_INFO(\"Create Applications.\");\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 5;\n    PingHelper ping(iic2.GetAddress(1, 1));\n\n    ping.SetAttribute(\"Count\", UintegerValue(maxPacketCount));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    ApplicationContainer apps = ping.Install(sta1);\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"icmpv6-redirect.tr\"));\n    csma.EnablePcapAll(\"icmpv6-redirect\", true);\n\n    /* Now, do the actual simulation. */\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Wi-Fi mesh network using the 802.11s mesh protocol. The network should consist of five nodes with unique IPv4 addresses in the 192.168.1.0/24 subnet. Nodes should use the RandomWalk2dMobilityModel within a bounded area (-50, 50, -50, 50). The last node should act as a UDP echo server on port 9, while the first node should be a client sending three packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    NodeContainer nodes;\n    nodes.Create(5); // Create 5 mesh nodes\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::StaWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(nodes);\n\n    MeshHelper mesh;\n    mesh.SetStackInstall(true);\n    mesh.Install(nodes);\n\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(4)); // Last node as server\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(4), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(3));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0)); // First node as client\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ simulation using ns-3 to simulate a ring topology with 3 nodes. The nodes are interconnected in a ring, and point-to-point links are used between adjacent nodes. Set the link data rate to 10Mbps and delay to 2ms. Install basic Internet stack, assign IP addresses, and simulate packet transmission between the nodes in the ring. Use logging to track packet transmissions."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RingTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"RingTopologyExample\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Set up point-to-point links between the nodes to form a ring\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install the devices on the nodes (Node 0 <-> Node 1, Node 1 <-> Node 2, Node 2 <-> Node 0)\n    NetDeviceContainer devices01, devices12, devices20;\n    devices01 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));\n    devices12 = pointToPoint.Install(nodes.Get(1), nodes.Get(2));\n    devices20 = pointToPoint.Install(nodes.Get(2), nodes.Get(0));\n\n    // Install the Internet stack (TCP/IP) on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to each pair of point-to-point links\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfaces01, interfaces12, interfaces20;\n\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    interfaces01 = address.Assign(devices01);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    interfaces12 = address.Assign(devices12);\n\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    interfaces20 = address.Assign(devices20);\n\n    // Create an application (OnOff Application) to send packets from node 0 to node 1\n    uint16_t port = 9; // Port for communication\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(interfaces01.GetAddress(1), port));\n    onoff.SetConstantRate(DataRate(\"1Mbps\"), 1024); // 1Mbps data rate, 1024-byte packets\n    ApplicationContainer app = onoff.Install(nodes.Get(0)); // Install on node 0\n    app.Start(Seconds(1.0)); // Start at 1 second\n    app.Stop(Seconds(10.0)); // Stop at 10 seconds\n\n    // Set up a PacketSink on node 1 to receive packets from node 0\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sink.Install(nodes.Get(1)); // Install sink on node 1\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Enable routing between the nodes in the ring\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 to simulate a network where routers exchange Link State Advertisements (LSAs) as part of Link State Routing. Create a topology with four routers connected via point-to-point links, where OSPF is used for route discovery and link state updates. Simulate the transmission of LSAs between the routers as network changes occur, and visualize the LSA process using pcap tracing. Also, generate traffic from one node to another to observe how link state routing adapts."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ospf-helper.h\"\n#include \"ns3/traffic-control-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LinkStateAdvertisementExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for OSPF\n    LogComponentEnable(\"OspfHelper\", LOG_LEVEL_INFO);\n\n    // Parse command line arguments\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Step 1: Create 4 routers\n    NodeContainer routers;\n    routers.Create(4);\n\n    // Step 2: Create point-to-point links between routers\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create the links between the routers\n    NetDeviceContainer link1 = p2p.Install(routers.Get(0), routers.Get(1)); // R0 <-> R1\n    NetDeviceContainer link2 = p2p.Install(routers.Get(1), routers.Get(2)); // R1 <-> R2\n    NetDeviceContainer link3 = p2p.Install(routers.Get(2), routers.Get(3)); // R2 <-> R3\n    NetDeviceContainer link4 = p2p.Install(routers.Get(0), routers.Get(3)); // R0 <-> R3\n\n    // Step 3: Install Internet Stack with OSPF on routers\n    OspfHelper ospfRouting;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(ospfRouting);  // Use OSPF for routing\n    internet.Install(routers);\n\n    // Step 4: Assign IP addresses to the links\n    Ipv4AddressHelper ipv4;\n\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1 = ipv4.Assign(link1);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i2 = ipv4.Assign(link2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i3 = ipv4.Assign(link3);\n\n    ipv4.SetBase(\"10.1.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i4 = ipv4.Assign(link4);\n\n    // Step 5: Populate routing tables with OSPF\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Step 6: Create traffic flow (UDP echo)\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(routers.Get(3));  // Server on router R3\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(i4.GetAddress(1), 9);  // Send to R3 (link4's IP)\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(routers.Get(0));  // Client on router R0\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Step 7: Enable pcap tracing\n    p2p.EnablePcapAll(\"lsa-ospf\");\n\n    // Step 8: Run the simulation\n    Simulator::Stop(Seconds(12.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network in ns-3 with two access points (APs) and multiple stations (STA). Each AP supports a group of stations, and the stations are configured to communicate with their respective APs. Use UDP as the transport protocol, and set up a UDP client-server application where the stations send continuous data to a server. Enable pcap and ASCII tracing for traffic analysis, and print the total data sent by each station."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ssid.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    uint32_t nStas = 4; // Number of stations per AP\n    double simulationTime = 10.0; // Simulation time in seconds\n\n    // Create two access points and multiple stations\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(2);\n    NodeContainer wifiStaNodes1;\n    wifiStaNodes1.Create(nStas);\n    NodeContainer wifiStaNodes2;\n    wifiStaNodes2.Create(nStas);\n\n    // Set up the Wi-Fi channel and PHY\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up Wi-Fi MAC layer (non-QoS)\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper mac;\n    Ssid ssid1 = Ssid(\"network-1\");\n    Ssid ssid2 = Ssid(\"network-2\");\n\n    // Configure the APs\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid1));\n    NetDeviceContainer apDevices1 = wifi.Install(phy, mac, wifiApNodes.Get(0));\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid2));\n    NetDeviceContainer apDevices2 = wifi.Install(phy, mac, wifiApNodes.Get(1));\n\n    // Configure the stations for AP 1\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid1));\n    NetDeviceContainer staDevices1 = wifi.Install(phy, mac, wifiStaNodes1);\n\n    // Configure the stations for AP 2\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid2));\n    NetDeviceContainer staDevices2 = wifi.Install(phy, mac, wifiStaNodes2);\n\n    // Set up mobility models\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNodes);\n    mobility.Install(wifiStaNodes1);\n    mobility.Install(wifiStaNodes2);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes1);\n    stack.Install(wifiStaNodes2);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer ap1Interface, ap2Interface, sta1Interface, sta2Interface;\n\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ap1Interface = address.Assign(apDevices1);\n    sta1Interface = address.Assign(staDevices1);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    ap2Interface = address.Assign(apDevices2);\n    sta2Interface = address.Assign(staDevices2);\n\n    // Set up UDP server on the access points\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp1 = udpServer.Install(wifiApNodes.Get(0));\n    ApplicationContainer serverApp2 = udpServer.Install(wifiApNodes.Get(1));\n    serverApp1.Start(Seconds(1.0));\n    serverApp2.Start(Seconds(1.0));\n    serverApp1.Stop(Seconds(simulationTime));\n    serverApp2.Stop(Seconds(simulationTime));\n\n    // Set up UDP clients on the stations\n    UdpClientHelper udpClient1(ap1Interface.GetAddress(0), 9);\n    udpClient1.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient1.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    udpClient1.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    UdpClientHelper udpClient2(ap2Interface.GetAddress(0), 9);\n    udpClient2.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient2.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    udpClient2.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps1, clientApps2;\n    clientApps1.Add(udpClient1.Install(wifiStaNodes1));\n    clientApps2.Add(udpClient2.Install(wifiStaNodes2));\n\n    clientApps1.Start(Seconds(2.0));\n    clientApps2.Start(Seconds(2.0));\n    clientApps1.Stop(Seconds(simulationTime));\n    clientApps2.Stop(Seconds(simulationTime));\n\n    // Enable packet tracing (ASCII and pcap files)\n    phy.EnablePcap(\"wifi-network-ap1\", apDevices1.Get(0));\n    phy.EnablePcap(\"wifi-network-ap2\", apDevices2.Get(0));\n    phy.EnableAsciiAll(CreateObject<OutputStreamWrapper>(\"wifi-network.tr\", std::ios::out));\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n\n    // Log the total packets received by each AP\n    Ptr<UdpServer> server1 = DynamicCast<UdpServer>(serverApp1.Get(0));\n    Ptr<UdpServer> server2 = DynamicCast<UdpServer>(serverApp2.Get(0));\n    NS_LOG_INFO(\"Total Packets Received by AP 1: \" << server1->GetReceived());\n    NS_LOG_INFO(\"Total Packets Received by AP 2: \" << server2->GetReceived());\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a basic wireless network in ns-3 where two nodes communicate using TCP over Wi-Fi. One node acts as a TCP server, and the other node as a TCP client. Measure and output the throughput of the communication. Use the AODV routing protocol and visualize the network using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/aodv-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"TcpWifiExample\");\n\nint main (int argc, char *argv[])\n{\n  // Set the simulation time\n  double simTime = 10.0;\n\n  // Create two nodes\n  NodeContainer wifiNodes;\n  wifiNodes.Create (2);\n\n  // Setup Wi-Fi physical and MAC layers\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();\n  YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();\n  phy.SetChannel (channel.Create ());\n\n  WifiHelper wifi;\n  wifi.SetRemoteStationManager (\"ns3::AarfWifiManager\");\n\n  WifiMacHelper mac;\n  mac.SetType (\"ns3::AdhocWifiMac\");\n\n  NetDeviceContainer devices = wifi.Install (phy, mac, wifiNodes);\n\n  // Set mobility models for the nodes\n  MobilityHelper mobility;\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0),\n                                 \"MinY\", DoubleValue (0.0),\n                                 \"DeltaX\", DoubleValue (5.0),\n                                 \"DeltaY\", DoubleValue (10.0),\n                                 \"GridWidth\", UintegerValue (2),\n                                 \"LayoutType\", StringValue (\"RowFirst\"));\n  mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install (wifiNodes);\n\n  // Install Internet stack with AODV routing protocol\n  AodvHelper aodv;\n  InternetStackHelper internet;\n  internet.SetRoutingHelper (aodv);\n  internet.Install (wifiNodes);\n\n  // Assign IP addresses\n  Ipv4AddressHelper ipv4;\n  ipv4.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);\n\n  // Setup TCP server on Node 1\n  uint16_t port = 9;\n  Address serverAddress (InetSocketAddress (interfaces.GetAddress (1), port));\n  PacketSinkHelper sink (\"ns3::TcpSocketFactory\", serverAddress);\n  ApplicationContainer serverApp = sink.Install (wifiNodes.Get (1));\n  serverApp.Start (Seconds (1.0));\n  serverApp.Stop (Seconds (simTime));\n\n  // Setup TCP client on Node 0\n  OnOffHelper client (\"ns3::TcpSocketFactory\", serverAddress);\n  client.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=1]\"));\n  client.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0]\"));\n  client.SetAttribute (\"DataRate\", DataRateValue (DataRate (\"1Mbps\")));\n  client.SetAttribute (\"PacketSize\", UintegerValue (1024));\n\n  ApplicationContainer clientApp = client.Install (wifiNodes.Get (0));\n  clientApp.Start (Seconds (2.0));\n  clientApp.Stop (Seconds (simTime));\n\n  // Enable NetAnim\n  AnimationInterface anim (\"tcp_wifi_example.xml\");\n\n  // Set up FlowMonitor to calculate throughput\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n  // Run the simulation\n  Simulator::Stop (Seconds (simTime));\n  Simulator::Run ();\n\n  // Calculate throughput\n  monitor->CheckForLostPackets ();\n  Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());\n  std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats ();\n  \n  for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n    {\n      Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);\n      if (t.destinationPort == port)\n        {\n          std::cout << \"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\\n\";\n          std::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n          std::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n          std::cout << \"  Throughput: \" << i->second.rxBytes * 8.0 / simTime / 1000000 << \" Mbps\\n\";\n        }\n    }\n\n  // Destroy the simulation\n  Simulator::Destroy ();\n  return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 that sets up a simple network with four nodes connected in a square topology. Use point-to-point links between the nodes and configure OSPF (Open Shortest Path First) as the routing protocol. Assign IP addresses to the nodes and set up UDP communication between two of the nodes. Enable packet tracing and create a pcap trace file for each point-to-point link. The network should use OSPF to dynamically find the best route for packets. Additionally, display the routing tables at the end of the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ospf-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OSPFExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for debugging\n    LogComponentEnable(\"OSPFExample\", LOG_LEVEL_INFO);\n\n    // Step 1: Create four nodes in a square topology\n    NS_LOG_INFO(\"Creating nodes.\");\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Step 2: Set up point-to-point links between the nodes\n    NS_LOG_INFO(\"Creating point-to-point links.\");\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devicesAB, devicesBC, devicesCD, devicesDA;\n    devicesAB = pointToPoint.Install(nodes.Get(0), nodes.Get(1)); // Link between node 0 and node 1\n    devicesBC = pointToPoint.Install(nodes.Get(1), nodes.Get(2)); // Link between node 1 and node 2\n    devicesCD = pointToPoint.Install(nodes.Get(2), nodes.Get(3)); // Link between node 2 and node 3\n    devicesDA = pointToPoint.Install(nodes.Get(3), nodes.Get(0)); // Link between node 3 and node 0\n\n    // Step 3: Install the internet stack with OSPF routing\n    NS_LOG_INFO(\"Installing internet stack.\");\n    OspfHelper ospf; // Helper to set up OSPF\n    Ipv4ListRoutingHelper listRouting;\n    listRouting.Add(ospf, 10); // Add OSPF with priority 10\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(listRouting); // Set the routing protocol to OSPF\n    internet.Install(nodes);\n\n    // Step 4: Assign IP addresses to the nodes\n    NS_LOG_INFO(\"Assigning IP addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfacesAB = ipv4.Assign(devicesAB);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfacesBC = ipv4.Assign(devicesBC);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfacesCD = ipv4.Assign(devicesCD);\n\n    ipv4.SetBase(\"10.1.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfacesDA = ipv4.Assign(devicesDA);\n\n    // Step 5: Set up UDP communication\n    NS_LOG_INFO(\"Setting up UDP communication.\");\n    uint16_t port = 9; // Port number for the UDP application\n\n    // UDP Server on node 3\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(3));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // UDP Client on node 0\n    UdpClientHelper udpClient(interfacesCD.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Step 6: Enable packet tracing\n    NS_LOG_INFO(\"Enabling packet tracing.\");\n    pointToPoint.EnablePcapAll(\"ospf-routing-example\");\n\n    // Step 7: Display the routing tables\n    NS_LOG_INFO(\"Printing routing tables.\");\n    for (uint32_t i = 0; i < nodes.GetN(); i++)\n    {\n        Ptr<Ipv4> ipv4 = nodes.Get(i)->GetObject<Ipv4>();\n        ipv4->GetRoutingProtocol()->PrintRoutingTable(Create<OutputStreamWrapper>(&std::cout));\n    }\n\n    // Step 8: Run the simulation\n    NS_LOG_INFO(\"Running the simulation.\");\n    Simulator::Run();\n\n    // Step 9: Clean up and destroy the simulation\n    NS_LOG_INFO(\"Destroying the simulation.\");\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a TCP connection between two nodes in NS-3. Node 0 (client) sends TCP packets to Node 1 (server). The server listens on port 8080 and the client connects to the server on the same port. Use a grid mobility model with nodes positioned at 0,0 and 5,5. Ensure that the simulation runs from 1s to 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpExample\");\n\nvoid ReceivePacket(Ptr<Socket> socket)\n{\n    while (socket->Recv())\n    {\n        NS_LOG_UNCOND(\"Received one packet!\");\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Set up mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Set up TCP socket\n    TypeId tid = TypeId::LookupByName(\"ns3::TcpSocketFactory\");\n    Ptr<Socket> tcpServerSocket = Socket::CreateSocket(nodes.Get(1), tid);\n\n    // Bind the server socket to a port\n    InetSocketAddress serverAddress = InetSocketAddress(Ipv4Address::GetAny(), 8080);\n    tcpServerSocket->Bind(serverAddress);\n    tcpServerSocket->Listen();\n    tcpServerSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(nodes);\n\n    // Set up TCP client on Node 0\n    Ptr<Socket> tcpClientSocket = Socket::CreateSocket(nodes.Get(0), tid);\n    InetSocketAddress clientAddress = InetSocketAddress(interfaces.GetAddress(1), 8080);\n    tcpClientSocket->Connect(clientAddress);\n\n    // Create a TCP application (client)\n    Ptr<Socket> appSocket = Socket::CreateSocket(nodes.Get(0), tid);\n    Ptr<TcpClient> clientApp = CreateObject<TcpClient>();\n    clientApp->Setup(appSocket, InetSocketAddress(interfaces.GetAddress(1), 8080), 1000);\n    nodes.Get(0)->AddApplication(clientApp);\n    clientApp->SetStartTime(Seconds(1.0));\n    clientApp->SetStopTime(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate code that creates a network topology with four nodes (n0, n1, n2, and n3) connected in a series, where n0 to n1 has a 10 Mbps link with 1 ms delay, n1 to n2 has a 1 Mbps link with 10 ms delay, and n2 to n3 has a 10 Mbps link with 1 ms delay. Implement a TCP flow from n0 to n3 using the BulkSendApplication. Store simulation output in the \"results/\" directory, including cwnd traces in \"cwndTraces\", queue length statistics in \"queue-size.dat\", PCAP files in \"pcap\", queue drop statistics in \"queueTraces\", and queue stats in \"queueStats.txt\". Include configuration details in \"config.txt\"."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0 ---------- n1 ---------- n2 ---------- n3\n//            10 Mbps       1 Mbps        10 Mbps\n//             1 ms         10 ms          1 ms\n//\n// - TCP flow from n0 to n3 using BulkSendApplication.\n// - The following simulation output is stored in results/ in ns-3 top-level directory:\n//   - cwnd traces are stored in cwndTraces folder\n//   - queue length statistics are stored in queue-size.dat file\n//   - pcaps are stored in pcap folder\n//   - queueTraces folder contain the drop statistics at queue\n//   - queueStats.txt file contains the queue stats and config.txt file contains\n//     the simulation configuration.\n// - The cwnd and queue length traces obtained from this example were tested against\n//   the respective traces obtained from Linux Reno by using ns-3 Direct Code Execution.\n//   See internet/doc/tcp.rst for more details.\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <sys/stat.h>\n\nusing namespace ns3;\nstd::string dir = \"results/\";\nTime stopTime = Seconds(60);\nuint32_t segmentSize = 524;\n\nstd::ofstream fPlotQueue;\nstd::ofstream fPlotCwnd;\n\n// Function to check queue length of Router 1\nvoid\nCheckQueueSize(Ptr<QueueDisc> queue)\n{\n    uint32_t qSize = queue->GetCurrentSize().GetValue();\n\n    // Check queue size every 1/100 of a second\n    Simulator::Schedule(Seconds(0.001), &CheckQueueSize, queue);\n    fPlotQueue << Simulator::Now().GetSeconds() << \" \" << qSize << std::endl;\n}\n\n// Function to trace change in cwnd at n0\nstatic void\nCwndChange(uint32_t oldCwnd, uint32_t newCwnd)\n{\n    fPlotCwnd << Simulator::Now().GetSeconds() << \" \" << newCwnd / segmentSize << std::endl;\n}\n\n// Function to calculate drops in a particular Queue\nstatic void\nDropAtQueue(Ptr<OutputStreamWrapper> stream, Ptr<const QueueDiscItem> item)\n{\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" 1\" << std::endl;\n}\n\n// Trace Function for cwnd\nvoid\nTraceCwnd(uint32_t node, uint32_t cwndWindow, Callback<void, uint32_t, uint32_t> CwndTrace)\n{\n    Config::ConnectWithoutContext(\"/NodeList/\" + std::to_string(node) +\n                                      \"/$ns3::TcpL4Protocol/SocketList/\" +\n                                      std::to_string(cwndWindow) + \"/CongestionWindow\",\n                                  CwndTrace);\n}\n\n// Function to install BulkSend application\nvoid\nInstallBulkSend(Ptr<Node> node,\n                Ipv4Address address,\n                uint16_t port,\n                std::string socketFactory,\n                uint32_t nodeId,\n                uint32_t cwndWindow,\n                Callback<void, uint32_t, uint32_t> CwndTrace)\n{\n    BulkSendHelper source(socketFactory, InetSocketAddress(address, port));\n    source.SetAttribute(\"MaxBytes\", UintegerValue(0));\n    ApplicationContainer sourceApps = source.Install(node);\n    sourceApps.Start(Seconds(10.0));\n    Simulator::Schedule(Seconds(10.0) + Seconds(0.001), &TraceCwnd, nodeId, cwndWindow, CwndTrace);\n    sourceApps.Stop(stopTime);\n}\n\n// Function to install sink application\nvoid\nInstallPacketSink(Ptr<Node> node, uint16_t port, std::string socketFactory)\n{\n    PacketSinkHelper sink(socketFactory, InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApps = sink.Install(node);\n    sinkApps.Start(Seconds(10.0));\n    sinkApps.Stop(stopTime);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t stream = 1;\n    std::string socketFactory = \"ns3::TcpSocketFactory\";\n    std::string tcpTypeId = \"ns3::TcpLinuxReno\";\n    std::string qdiscTypeId = \"ns3::FifoQueueDisc\";\n    bool isSack = true;\n    uint32_t delAckCount = 1;\n    std::string recovery = \"ns3::TcpClassicRecovery\";\n\n    CommandLine cmd;\n    cmd.AddValue(\"tcpTypeId\",\n                 \"TCP variant to use (e.g., ns3::TcpNewReno, ns3::TcpLinuxReno, etc.)\",\n                 tcpTypeId);\n    cmd.AddValue(\"qdiscTypeId\", \"Queue disc for gateway (e.g., ns3::CoDelQueueDisc)\", qdiscTypeId);\n    cmd.AddValue(\"segmentSize\", \"TCP segment size (bytes)\", segmentSize);\n    cmd.AddValue(\"delAckCount\", \"Delayed ack count\", delAckCount);\n    cmd.AddValue(\"enableSack\", \"Flag to enable/disable sack in TCP\", isSack);\n    cmd.AddValue(\"stopTime\",\n                 \"Stop time for applications / simulation time will be stopTime\",\n                 stopTime);\n    cmd.AddValue(\"recovery\", \"Recovery algorithm type to use (e.g., ns3::TcpPrrRecovery\", recovery);\n    cmd.Parse(argc, argv);\n\n    TypeId qdTid;\n    NS_ABORT_MSG_UNLESS(TypeId::LookupByNameFailSafe(qdiscTypeId, &qdTid),\n                        \"TypeId \" << qdiscTypeId << \" not found\");\n\n    // Set recovery algorithm and TCP variant\n    Config::SetDefault(\"ns3::TcpL4Protocol::RecoveryType\",\n                       TypeIdValue(TypeId::LookupByName(recovery)));\n    TypeId tcpTid;\n    NS_ABORT_MSG_UNLESS(TypeId::LookupByNameFailSafe(tcpTypeId, &tcpTid),\n                        \"TypeId \" << tcpTypeId << \" not found\");\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\",\n                       TypeIdValue(TypeId::LookupByName(tcpTypeId)));\n\n    // Create nodes\n    NodeContainer leftNodes;\n    NodeContainer rightNodes;\n    NodeContainer routers;\n    routers.Create(2);\n    leftNodes.Create(1);\n    rightNodes.Create(1);\n\n    std::vector<NetDeviceContainer> leftToRouter;\n    std::vector<NetDeviceContainer> routerToRight;\n\n    // Create the point-to-point link helpers and connect two router nodes\n    PointToPointHelper pointToPointRouter;\n    pointToPointRouter.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    pointToPointRouter.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    NetDeviceContainer r1r2ND = pointToPointRouter.Install(routers.Get(0), routers.Get(1));\n\n    // Create the point-to-point link helpers and connect leaf nodes to router\n    PointToPointHelper pointToPointLeaf;\n    pointToPointLeaf.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPointLeaf.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n    leftToRouter.push_back(pointToPointLeaf.Install(leftNodes.Get(0), routers.Get(0)));\n    routerToRight.push_back(pointToPointLeaf.Install(routers.Get(1), rightNodes.Get(0)));\n\n    InternetStackHelper internetStack;\n\n    internetStack.Install(leftNodes);\n    internetStack.Install(rightNodes);\n    internetStack.Install(routers);\n\n    // Assign IP addresses to all the network devices\n    Ipv4AddressHelper ipAddresses(\"10.0.0.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer r1r2IPAddress = ipAddresses.Assign(r1r2ND);\n    ipAddresses.NewNetwork();\n\n    std::vector<Ipv4InterfaceContainer> leftToRouterIPAddress;\n    leftToRouterIPAddress.push_back(ipAddresses.Assign(leftToRouter[0]));\n    ipAddresses.NewNetwork();\n\n    std::vector<Ipv4InterfaceContainer> routerToRightIPAddress;\n    routerToRightIPAddress.push_back(ipAddresses.Assign(routerToRight[0]));\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Set default sender and receiver buffer size as 1MB\n    Config::SetDefault(\"ns3::TcpSocket::SndBufSize\", UintegerValue(1 << 20));\n    Config::SetDefault(\"ns3::TcpSocket::RcvBufSize\", UintegerValue(1 << 20));\n\n    // Set default initial congestion window as 10 segments\n    Config::SetDefault(\"ns3::TcpSocket::InitialCwnd\", UintegerValue(10));\n\n    // Set default delayed ack count to a specified value\n    Config::SetDefault(\"ns3::TcpSocket::DelAckCount\", UintegerValue(delAckCount));\n\n    // Set default segment size of TCP packet to a specified value\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(segmentSize));\n\n    // Enable/Disable SACK in TCP\n    Config::SetDefault(\"ns3::TcpSocketBase::Sack\", BooleanValue(isSack));\n\n    // Create directories to store dat files\n    struct stat buffer;\n    int retVal [[maybe_unused]];\n    if ((stat(dir.c_str(), &buffer)) == 0)\n    {\n        std::string dirToRemove = \"rm -rf \" + dir;\n        retVal = system(dirToRemove.c_str());\n        NS_ASSERT_MSG(retVal == 0, \"Error in return value\");\n    }\n\n    SystemPath::MakeDirectories(dir);\n    SystemPath::MakeDirectories(dir + \"/pcap/\");\n    SystemPath::MakeDirectories(dir + \"/queueTraces/\");\n    SystemPath::MakeDirectories(dir + \"/cwndTraces/\");\n\n    // Set default parameters for queue discipline\n    Config::SetDefault(qdiscTypeId + \"::MaxSize\", QueueSizeValue(QueueSize(\"100p\")));\n\n    // Install queue discipline on router\n    TrafficControlHelper tch;\n    tch.SetRootQueueDisc(qdiscTypeId);\n    QueueDiscContainer qd;\n    tch.Uninstall(routers.Get(0)->GetDevice(0));\n    qd.Add(tch.Install(routers.Get(0)->GetDevice(0)).Get(0));\n\n    // Enable BQL\n    tch.SetQueueLimits(\"ns3::DynamicQueueLimits\");\n\n    // Open files for writing queue size and cwnd traces\n    fPlotQueue.open(dir + \"queue-size.dat\", std::ios::out);\n    fPlotCwnd.open(dir + \"cwndTraces/n0.dat\", std::ios::out);\n\n    // Calls function to check queue size\n    Simulator::ScheduleNow(&CheckQueueSize, qd.Get(0));\n\n    AsciiTraceHelper asciiTraceHelper;\n    Ptr<OutputStreamWrapper> streamWrapper;\n\n    // Create dat to store packets dropped and marked at the router\n    streamWrapper = asciiTraceHelper.CreateFileStream(dir + \"/queueTraces/drop-0.dat\");\n    qd.Get(0)->TraceConnectWithoutContext(\"Drop\", MakeBoundCallback(&DropAtQueue, streamWrapper));\n\n    // Install packet sink at receiver side\n    uint16_t port = 50000;\n    InstallPacketSink(rightNodes.Get(0), port, \"ns3::TcpSocketFactory\");\n\n    // Install BulkSend application\n    InstallBulkSend(leftNodes.Get(0),\n                    routerToRightIPAddress[0].GetAddress(1),\n                    port,\n                    socketFactory,\n                    2,\n                    0,\n                    MakeCallback(&CwndChange));\n\n    // Enable PCAP on all the point to point interfaces\n    pointToPointLeaf.EnablePcapAll(dir + \"pcap/ns-3\", true);\n\n    Simulator::Stop(stopTime);\n    Simulator::Run();\n\n    // Store queue stats in a file\n    std::ofstream myfile;\n    myfile.open(dir + \"queueStats.txt\", std::fstream::in | std::fstream::out | std::fstream::app);\n    myfile << std::endl;\n    myfile << \"Stat for Queue 1\";\n    myfile << qd.Get(0)->GetStats();\n    myfile.close();\n\n    // Store configuration of the simulation in a file\n    myfile.open(dir + \"config.txt\", std::fstream::in | std::fstream::out | std::fstream::app);\n    myfile << \"qdiscTypeId \" << qdiscTypeId << \"\\n\";\n    myfile << \"stream  \" << stream << \"\\n\";\n    myfile << \"segmentSize \" << segmentSize << \"\\n\";\n    myfile << \"delAckCount \" << delAckCount << \"\\n\";\n    myfile << \"stopTime \" << stopTime.As(Time::S) << \"\\n\";\n    myfile.close();\n\n    Simulator::Destroy();\n\n    fPlotQueue.close();\n    fPlotCwnd.close();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Wi-Fi network with a UDP connection between a station (STA) and an access point (AP). The STA should act as a UDP client, and the AP should act as a UDP server. The Wi-Fi standard should be 802.11n. The client should send 50 packets of 1024 bytes each at an interval of 200ms. The server should receive the packets. Assign IP addresses from the range 192.168.1.0/24. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create nodes (1 AP and 1 STA)\n    NodeContainer wifiStaNode;\n    wifiStaNode.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Create Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up Wi-Fi helper\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    WifiMacHelper mac;\n\n    // Set up STA\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNode);\n\n    // Set up AP\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevices = wifi.Install(phy, mac, wifiApNode);\n\n    // Mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNode);\n    mobility.Install(wifiApNode);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNode);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterface = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevices);\n\n    // Set up UDP server on AP\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on STA\n    UdpClientHelper udpClient(apInterface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(50));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(200)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library that simulates a basic LAN topology with two nodes (n0 and n1) connected via a CSMA link. The program should establish a UDP communication between the two nodes, with node n0 sending packets to node n1. The sender should have options to set IP_TOS and IP_TTL values for the packets, while the receiver should log received packets along with their TOS and TTL values. Include command-line parameters to configure packet size, number of packets, packet interval, and socket options such as TOS, TTL, RECVTOS, and RECVTTL."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0              n1\n//       |               |\n//       =================\n//              LAN\n//\n// - UDP flows from n0 to n1\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SocketOptionsIpv4\");\n\nvoid\nReceivePacket(Ptr<Socket> socket)\n{\n    NS_LOG_INFO(\"Received one packet!\");\n    Ptr<Packet> packet = socket->Recv();\n    SocketIpTosTag tosTag;\n    if (packet->RemovePacketTag(tosTag))\n    {\n        NS_LOG_INFO(\" TOS = \" << (uint32_t)tosTag.GetTos());\n    }\n    SocketIpTtlTag ttlTag;\n    if (packet->RemovePacketTag(ttlTag))\n    {\n        NS_LOG_INFO(\" TTL = \" << (uint32_t)ttlTag.GetTtl());\n    }\n}\n\nstatic void\nSendPacket(Ptr<Socket> socket, uint32_t pktSize, uint32_t pktCount, Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval, &SendPacket, socket, pktSize, pktCount - 1, pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    //\n    // Allow the user to override any of the defaults and the above Bind() at\n    // run-time, via command-line arguments\n    //\n    uint32_t packetSize = 1024;\n    uint32_t packetCount = 10;\n    double packetInterval = 1.0;\n\n    // Socket options for IPv4, currently TOS, TTL, RECVTOS, and RECVTTL\n    uint32_t ipTos = 0;\n    bool ipRecvTos = true;\n    uint32_t ipTtl = 0;\n    bool ipRecvTtl = true;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"PacketSize\", \"Packet size in bytes\", packetSize);\n    cmd.AddValue(\"PacketCount\", \"Number of packets to send\", packetCount);\n    cmd.AddValue(\"Interval\", \"Interval between packets\", packetInterval);\n    cmd.AddValue(\"IP_TOS\", \"IP_TOS\", ipTos);\n    cmd.AddValue(\"IP_RECVTOS\", \"IP_RECVTOS\", ipRecvTos);\n    cmd.AddValue(\"IP_TTL\", \"IP_TTL\", ipTtl);\n    cmd.AddValue(\"IP_RECVTTL\", \"IP_RECVTTL\", ipRecvTtl);\n    cmd.Parse(argc, argv);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer n;\n    n.Create(2);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    Address serverAddress;\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(d);\n    serverAddress = Address(i.GetAddress(1));\n\n    NS_LOG_INFO(\"Create sockets.\");\n    // Receiver socket on n1\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(n.Get(1), tid);\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 4477);\n    recvSink->SetIpRecvTos(ipRecvTos);\n    recvSink->SetIpRecvTtl(ipRecvTtl);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Sender socket on n0\n    Ptr<Socket> source = Socket::CreateSocket(n.Get(0), tid);\n    InetSocketAddress remote = InetSocketAddress(i.GetAddress(1), 4477);\n\n    // Set socket options, it is also possible to set the options after the socket has been\n    // created/connected.\n    if (ipTos > 0)\n    {\n        source->SetIpTos(ipTos);\n    }\n\n    if (ipTtl > 0)\n    {\n        source->SetIpTtl(ipTtl);\n    }\n    source->Connect(remote);\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"socket-options-ipv4.tr\"));\n    csma.EnablePcapAll(\"socket-options-ipv4\", false);\n\n    // Schedule SendPacket\n    Time interPacketInterval = Seconds(packetInterval);\n    Simulator::ScheduleWithContext(source->GetNode()->GetId(),\n                                   Seconds(1.0),\n                                   &SendPacket,\n                                   source,\n                                   packetSize,\n                                   packetCount,\n                                   interPacketInterval);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple 5G NR network with one gNodeB (5G base station) and two UEs. The UEs should be using a random walk mobility model within a 50x50 area. Set up the network devices, assign IP addresses, and configure TCP communication. The first UE will act as a TCP client, sending packets to a server running on the second UE. The simulation should run for 10 seconds, and the server should be listening on port 8080."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ue-phy-simulator.h\"\n#include \"ns3/gnb-phy-simulator.h\"\n#include \"ns3/nr-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time resolution\n    Time::SetResolution(Time::NS);\n\n    // Create nodes: one gNodeB and two UEs\n    NodeContainer gnbNode, ueNodes;\n    gnbNode.Create(1);\n    ueNodes.Create(2);\n\n    // Set up the 5G NR Helper\n    NrHelper nrHelper;\n    Ptr<NrNetDevice> gnbDevice = nrHelper.InstallGnbDevice(gnbNode.Get(0));\n    Ptr<NrNetDevice> ueDevice1 = nrHelper.InstallUeDevice(ueNodes.Get(0));\n    Ptr<NrNetDevice> ueDevice2 = nrHelper.InstallUeDevice(ueNodes.Get(1));\n\n    // Install IP stack for routing\n    InternetStackHelper internet;\n    internet.Install(gnbNode);\n    internet.Install(ueNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer gnbIpIface, ueIpIface;\n    gnbIpIface = ipv4.Assign(gnbDevice);\n    ueIpIface = ipv4.Assign(ueDevice1);\n    ipv4.SetBase(\"10.0.1.0\", \"255.255.255.0\");\n    ipv4.Assign(ueDevice2);\n\n    // Set up the TCP server on UE1 (client side)\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(ueNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the TCP client on UE2 (server side)\n    TcpClientHelper tcpClient(gnbIpIface.GetAddress(0), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = tcpClient.Install(ueNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set mobility model for gNodeB and UEs\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(gnbNode);\n\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 50, 0, 50)));\n    mobility.Install(ueNodes);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a Wi-Fi network with one access point (AP) and two stations (STA). The AP and STAs should use 802.11g Wi-Fi standard. The network should assign 192.168.1.x IP addresses. Station 1 should act as a UDP server listening on port 8080, while Station 0 should act as a UDP client, sending 1024-byte packets every 10 milliseconds starting at 2 seconds. The client should send a maximum of 1000 packets. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWifiExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create Nodes (1 Access Point + 2 Stations)\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Setup Wi-Fi Channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    // Setup Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211g);\n    WifiMacHelper mac;\n\n    // Configure Station Devices\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure Access Point Device\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Setup Mobility Model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Install Internet Stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP Addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // UDP Server on Station 1\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiStaNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // UDP Client on Station 0\n    UdpClientHelper udpClient(staInterfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run Simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 to simulate a UDP Echo Client and Server between three nodes. Set up two point-to-point connections: one between the first and second nodes, and another between the second and third nodes. Both links should have a data rate of 5Mbps and a delay of 2ms. The client on the first node should send UDP packets to the server on the third node, with the second node acting as a router. The simulation should log packet transmission and reception, and the IP address configuration should reflect proper routing between the nodes."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpEchoThreeNodesExample\");\n\nint \nmain(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"UdpEchoThreeNodesExample\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create three nodes\n    NodeContainer nodes;\n    nodes.Create(3); // Three nodes: n0 -> n1 -> n2\n\n    // Configure point-to-point link between nodes n0 and n1\n    PointToPointHelper pointToPoint1;\n    pointToPoint1.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint1.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Configure point-to-point link between nodes n1 and n2\n    PointToPointHelper pointToPoint2;\n    pointToPoint2.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint2.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on the nodes and the links between them\n    NetDeviceContainer devices1, devices2;\n    devices1 = pointToPoint1.Install(nodes.Get(0), nodes.Get(1)); // Link n0 -> n1\n    devices2 = pointToPoint2.Install(nodes.Get(1), nodes.Get(2)); // Link n1 -> n2\n\n    // Install Internet stack (TCP/IP stack) on the nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes' links\n    Ipv4AddressHelper address;\n    \n    // IP address for the link between n0 and n1\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces1 = address.Assign(devices1);\n\n    // IP address for the link between n1 and n2\n    address.SetBase(\"10.2.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces2 = address.Assign(devices2);\n\n    // Enable routing on node n1 (the router)\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create and set up UDP Echo Server on node n2 (server)\n    uint16_t port = 9; // Echo server port number\n    UdpEchoServerHelper echoServer(port);\n\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(2)); // Server is node n2\n    serverApp.Start(Seconds(1.0)); // Start server at time = 1 second\n    serverApp.Stop(Seconds(10.0)); // Stop server at time = 10 seconds\n\n    // Create and set up UDP Echo Client on node n0 (client)\n    uint32_t packetSize = 1024;   // Packet size\n    uint32_t nPackets = 10;       // Number of packets to send\n    double interval = 1.0;        // Interval between packets (1 second)\n    \n    UdpEchoClientHelper echoClient(interfaces2.GetAddress(1), port); // Server's IP (n2)\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(nPackets));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(interval)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0)); // Client is node n0\n    clientApp.Start(Seconds(2.0)); // Start client at time = 2 seconds\n    clientApp.Stop(Seconds(10.0)); // Stop client at time = 10 seconds\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple point-to-point (P2P) network in ns-3 where a TCP client communicates with a TCP server. The link should have a data rate of 5 Mbps and a delay of 2 milliseconds. The TCP client should send data to the server using a bulk send application, and the server should use a packet sink to receive data. Enable pcap tracing to log packet transmissions and receptions. Run the simulation for 10 seconds and observe the throughput at the server."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for bulk send and packet sink\n    LogComponentEnable(\"BulkSendApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"PacketSink\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);  // Two nodes\n\n    // Set up point-to-point channel properties\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install the point-to-point devices and channels on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the TCP/IP stack on both nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP server (packet sink) on one node\n    uint16_t port = 9;  // Well-known port for TCP\n    Address sinkAddress(InetSocketAddress(interfaces.GetAddress(1), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Create a TCP client (bulk sender) on the other node\n    BulkSendHelper bulkSend(\"ns3::TcpSocketFactory\", sinkAddress);\n    bulkSend.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data\n    ApplicationContainer clientApp = bulkSend.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable packet tracing\n    pointToPoint.EnablePcapAll(\"p2p-tcp\");\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simulation of a Wi-Fi environment using NS-3 to evaluate throughput for different Modulation and Coding Scheme (MCS) values, channel widths, and guard intervals (GI) under the IEEE 802.11be (Wi-Fi 7) standard. The program should accept input parameters such as MCS, operating frequencies (2.4 GHz, 5 GHz, or 6 GHz), uplink OFDMA and BSRP flags, number of stations, traffic type (TCP or UDP), payload size, MPDU buffer size, and auxiliary PHY settings. For each combination of MCS, channel width, and GI, the simulation must create Wi-Fi stations and access points, configure them with the specified frequencies, and evaluate data throughput based on available bandwidth per station. The simulation should test both TCP and UDP traffic, run for a specified time, and print the results. Multiple frequencies (2.4, 5, and 6 GHz) should be configured correctly, ensuring they are unique to prevent collisions. Throughput tests should gather cumulative RX bytes per station and validate results against minimum and maximum expected throughput values, with a tolerance to account for real-world variances. If any throughput result is unexpectedly low or high for any MCS, channel width, or GI combination, an error should be logged, and the simulation should terminate. The output must display a table showing the MCS value, channel width, guard interval, and calculated throughput in Mbps."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/eht-phy.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/wifi-acknowledgment.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <array>\n#include <functional>\n#include <numeric>\n\n// This is a simple example in order to show how to configure an IEEE 802.11be Wi-Fi network.\n//\n// It outputs the UDP or TCP goodput for every EHT MCS value, which depends on the MCS value (0 to\n// 13), the channel width (20, 40, 80 or 160 MHz) and the guard interval (800ns, 1600ns or 3200ns).\n// The PHY bitrate is constant over all the simulation run. The user can also specify the distance\n// between the access point and the station: the larger the distance the smaller the goodput.\n//\n// The simulation assumes a configurable number of stations in an infrastructure network:\n//\n//  STA     AP\n//    *     *\n//    |     |\n//   n1     n2\n//\n// Packets in this simulation belong to BestEffort Access Class (AC_BE).\n// By selecting an acknowledgment sequence for DL MU PPDUs, it is possible to aggregate a\n// Round Robin scheduler to the AP, so that DL MU PPDUs are sent by the AP via DL OFDMA.\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"eht-wifi-network\");\n\n/**\n * \\param udp true if UDP is used, false if TCP is used\n * \\param serverApp a container of server applications\n * \\param payloadSize the size in bytes of the packets\n * \\return the bytes received by each server application\n */\nstd::vector<uint64_t>\nGetRxBytes(bool udp, const ApplicationContainer& serverApp, uint32_t payloadSize)\n{\n    std::vector<uint64_t> rxBytes(serverApp.GetN(), 0);\n    if (udp)\n    {\n        for (uint32_t i = 0; i < serverApp.GetN(); i++)\n        {\n            rxBytes[i] = payloadSize * DynamicCast<UdpServer>(serverApp.Get(i))->GetReceived();\n        }\n    }\n    else\n    {\n        for (uint32_t i = 0; i < serverApp.GetN(); i++)\n        {\n            rxBytes[i] = DynamicCast<PacketSink>(serverApp.Get(i))->GetTotalRx();\n        }\n    }\n    return rxBytes;\n}\n\n/**\n * Print average throughput over an intermediate time interval.\n * \\param rxBytes a vector of the amount of bytes received by each server application\n * \\param udp true if UDP is used, false if TCP is used\n * \\param serverApp a container of server applications\n * \\param payloadSize the size in bytes of the packets\n * \\param tputInterval the duration of an intermediate time interval\n * \\param simulationTime the simulation time in seconds\n */\nvoid\nPrintIntermediateTput(std::vector<uint64_t>& rxBytes,\n                      bool udp,\n                      const ApplicationContainer& serverApp,\n                      uint32_t payloadSize,\n                      Time tputInterval,\n                      Time simulationTime)\n{\n    auto newRxBytes = GetRxBytes(udp, serverApp, payloadSize);\n    Time now = Simulator::Now();\n\n    std::cout << \"[\" << (now - tputInterval).As(Time::S) << \" - \" << now.As(Time::S)\n              << \"] Per-STA Throughput (Mbit/s):\";\n\n    for (std::size_t i = 0; i < newRxBytes.size(); i++)\n    {\n        std::cout << \"\\t\\t(\" << i << \") \"\n                  << (newRxBytes[i] - rxBytes[i]) * 8. / tputInterval.GetMicroSeconds(); // Mbit/s\n    }\n    std::cout << std::endl;\n\n    rxBytes.swap(newRxBytes);\n\n    if (now < (simulationTime - NanoSeconds(1)))\n    {\n        Simulator::Schedule(Min(tputInterval, simulationTime - now - NanoSeconds(1)),\n                            &PrintIntermediateTput,\n                            rxBytes,\n                            udp,\n                            serverApp,\n                            payloadSize,\n                            tputInterval,\n                            simulationTime);\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    bool udp{true};\n    bool downlink{true};\n    bool useRts{false};\n    bool use80Plus80{false};\n    uint16_t mpduBufferSize{512};\n    std::string emlsrLinks;\n    uint16_t paddingDelayUsec{32};\n    uint16_t transitionDelayUsec{128};\n    uint16_t channelSwitchDelayUsec{100};\n    bool switchAuxPhy{true};\n    uint16_t auxPhyChWidth{20};\n    bool auxPhyTxCapable{true};\n    Time simulationTime{\"10s\"};\n    meter_u distance{1.0};\n    double frequency{5};  // whether the first link operates in the 2.4, 5 or 6 GHz\n    double frequency2{0}; // whether the second link operates in the 2.4, 5 or 6 GHz (0 means no\n                          // second link exists)\n    double frequency3{\n        0}; // whether the third link operates in the 2.4, 5 or 6 GHz (0 means no third link exists)\n    std::size_t nStations{1};\n    std::string dlAckSeqType{\"NO-OFDMA\"};\n    bool enableUlOfdma{false};\n    bool enableBsrp{false};\n    int mcs{-1}; // -1 indicates an unset value\n    uint32_t payloadSize =\n        700; // must fit in the max TX duration when transmitting at MCS 0 over an RU of 26 tones\n    Time tputInterval{0}; // interval for detailed throughput measurement\n    double minExpectedThroughput{0};\n    double maxExpectedThroughput{0};\n    Time accessReqInterval{0};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\n        \"frequency\",\n        \"Whether the first link operates in the 2.4, 5 or 6 GHz band (other values gets rejected)\",\n        frequency);\n    cmd.AddValue(\n        \"frequency2\",\n        \"Whether the second link operates in the 2.4, 5 or 6 GHz band (0 means the device has one \"\n        \"link, otherwise the band must be different than first link and third link)\",\n        frequency2);\n    cmd.AddValue(\n        \"frequency3\",\n        \"Whether the third link operates in the 2.4, 5 or 6 GHz band (0 means the device has up to \"\n        \"two links, otherwise the band must be different than first link and second link)\",\n        frequency3);\n    cmd.AddValue(\"emlsrLinks\",\n                 \"The comma separated list of IDs of EMLSR links (for MLDs only)\",\n                 emlsrLinks);\n    cmd.AddValue(\"emlsrPaddingDelay\",\n                 \"The EMLSR padding delay in microseconds (0, 32, 64, 128 or 256)\",\n                 paddingDelayUsec);\n    cmd.AddValue(\"emlsrTransitionDelay\",\n                 \"The EMLSR transition delay in microseconds (0, 16, 32, 64, 128 or 256)\",\n                 transitionDelayUsec);\n    cmd.AddValue(\"emlsrAuxSwitch\",\n                 \"Whether Aux PHY should switch channel to operate on the link on which \"\n                 \"the Main PHY was operating before moving to the link of the Aux PHY. \",\n                 switchAuxPhy);\n    cmd.AddValue(\"emlsrAuxChWidth\",\n                 \"The maximum channel width (MHz) supported by Aux PHYs.\",\n                 auxPhyChWidth);\n    cmd.AddValue(\"emlsrAuxTxCapable\",\n                 \"Whether Aux PHYs are capable of transmitting.\",\n                 auxPhyTxCapable);\n    cmd.AddValue(\"channelSwitchDelay\",\n                 \"The PHY channel switch delay in microseconds\",\n                 channelSwitchDelayUsec);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the station and the access point\",\n                 distance);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"udp\", \"UDP if set to 1, TCP otherwise\", udp);\n    cmd.AddValue(\"downlink\",\n                 \"Generate downlink flows if set to 1, uplink flows otherwise\",\n                 downlink);\n    cmd.AddValue(\"useRts\", \"Enable/disable RTS/CTS\", useRts);\n    cmd.AddValue(\"use80Plus80\", \"Enable/disable use of 80+80 MHz\", use80Plus80);\n    cmd.AddValue(\"mpduBufferSize\",\n                 \"Size (in number of MPDUs) of the BlockAck buffer\",\n                 mpduBufferSize);\n    cmd.AddValue(\"nStations\", \"Number of non-AP EHT stations\", nStations);\n    cmd.AddValue(\"dlAckType\",\n                 \"Ack sequence type for DL OFDMA (NO-OFDMA, ACK-SU-FORMAT, MU-BAR, AGGR-MU-BAR)\",\n                 dlAckSeqType);\n    cmd.AddValue(\"enableUlOfdma\",\n                 \"Enable UL OFDMA (useful if DL OFDMA is enabled and TCP is used)\",\n                 enableUlOfdma);\n    cmd.AddValue(\"enableBsrp\",\n                 \"Enable BSRP (useful if DL and UL OFDMA are enabled and TCP is used)\",\n                 enableBsrp);\n    cmd.AddValue(\n        \"muSchedAccessReqInterval\",\n        \"Duration of the interval between two requests for channel access made by the MU scheduler\",\n        accessReqInterval);\n    cmd.AddValue(\"mcs\", \"if set, limit testing to a specific MCS (0-11)\", mcs);\n    cmd.AddValue(\"payloadSize\", \"The application payload size in bytes\", payloadSize);\n    cmd.AddValue(\"tputInterval\", \"duration of intervals for throughput measurement\", tputInterval);\n    cmd.AddValue(\"minExpectedThroughput\",\n                 \"if set, simulation fails if the lowest throughput is below this value\",\n                 minExpectedThroughput);\n    cmd.AddValue(\"maxExpectedThroughput\",\n                 \"if set, simulation fails if the highest throughput is above this value\",\n                 maxExpectedThroughput);\n    cmd.Parse(argc, argv);\n\n    if (useRts)\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"0\"));\n        Config::SetDefault(\"ns3::WifiDefaultProtectionManager::EnableMuRts\", BooleanValue(true));\n    }\n\n    if (dlAckSeqType == \"ACK-SU-FORMAT\")\n    {\n        Config::SetDefault(\"ns3::WifiDefaultAckManager::DlMuAckSequenceType\",\n                           EnumValue(WifiAcknowledgment::DL_MU_BAR_BA_SEQUENCE));\n    }\n    else if (dlAckSeqType == \"MU-BAR\")\n    {\n        Config::SetDefault(\"ns3::WifiDefaultAckManager::DlMuAckSequenceType\",\n                           EnumValue(WifiAcknowledgment::DL_MU_TF_MU_BAR));\n    }\n    else if (dlAckSeqType == \"AGGR-MU-BAR\")\n    {\n        Config::SetDefault(\"ns3::WifiDefaultAckManager::DlMuAckSequenceType\",\n                           EnumValue(WifiAcknowledgment::DL_MU_AGGREGATE_TF));\n    }\n    else if (dlAckSeqType != \"NO-OFDMA\")\n    {\n        NS_ABORT_MSG(\"Invalid DL ack sequence type (must be NO-OFDMA, ACK-SU-FORMAT, MU-BAR or \"\n                     \"AGGR-MU-BAR)\");\n    }\n\n    double prevThroughput[12] = {0};\n\n    std::cout << \"MCS value\"\n              << \"\\t\\t\"\n              << \"Channel width\"\n              << \"\\t\\t\"\n              << \"GI\"\n              << \"\\t\\t\\t\"\n              << \"Throughput\" << '\\n';\n    int minMcs = 0;\n    int maxMcs = 13;\n    if (mcs >= 0 && mcs <= 13)\n    {\n        minMcs = mcs;\n        maxMcs = mcs;\n    }\n    for (int mcs = minMcs; mcs <= maxMcs; mcs++)\n    {\n        uint8_t index = 0;\n        double previous = 0;\n        uint16_t maxChannelWidth =\n            (frequency != 2.4 && frequency2 != 2.4 && frequency3 != 2.4) ? 160 : 40;\n        int minGi = enableUlOfdma ? 1600 : 800;\n        for (int channelWidth = 20; channelWidth <= maxChannelWidth;) // MHz\n        {\n            const auto is80Plus80 = (use80Plus80 && (channelWidth == 160));\n            const std::string widthStr = is80Plus80 ? \"80+80\" : std::to_string(channelWidth);\n            const auto segmentWidthStr = is80Plus80 ? \"80\" : widthStr;\n            for (int gi = 3200; gi >= minGi;) // Nanoseconds\n            {\n                if (!udp)\n                {\n                    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n                }\n\n                NodeContainer wifiStaNodes;\n                wifiStaNodes.Create(nStations);\n                NodeContainer wifiApNode;\n                wifiApNode.Create(1);\n\n                NetDeviceContainer apDevice;\n                NetDeviceContainer staDevices;\n                WifiMacHelper mac;\n                WifiHelper wifi;\n\n                wifi.SetStandard(WIFI_STANDARD_80211be);\n                std::array<std::string, 3> channelStr;\n                std::array<FrequencyRange, 3> freqRanges;\n                uint8_t nLinks = 0;\n                std::string dataModeStr = \"EhtMcs\" + std::to_string(mcs);\n                std::string ctrlRateStr;\n                uint64_t nonHtRefRateMbps = EhtPhy::GetNonHtReferenceRate(mcs) / 1e6;\n\n                if (frequency2 == frequency || frequency3 == frequency ||\n                    (frequency3 != 0 && frequency3 == frequency2))\n                {\n                    NS_FATAL_ERROR(\"Frequency values must be unique!\");\n                }\n\n                for (auto freq : {frequency, frequency2, frequency3})\n                {\n                    if (nLinks > 0 && freq == 0)\n                    {\n                        break;\n                    }\n                    channelStr[nLinks] = \"{0, \" + segmentWidthStr + \", \";\n                    if (freq == 6)\n                    {\n                        channelStr[nLinks] += \"BAND_6GHZ, 0}\";\n                        freqRanges[nLinks] = WIFI_SPECTRUM_6_GHZ;\n                        Config::SetDefault(\"ns3::LogDistancePropagationLossModel::ReferenceLoss\",\n                                           DoubleValue(48));\n                        wifi.SetRemoteStationManager(nLinks,\n                                                     \"ns3::ConstantRateWifiManager\",\n                                                     \"DataMode\",\n                                                     StringValue(dataModeStr),\n                                                     \"ControlMode\",\n                                                     StringValue(dataModeStr));\n                    }\n                    else if (freq == 5)\n                    {\n                        channelStr[nLinks] += \"BAND_5GHZ, 0}\";\n                        freqRanges[nLinks] = WIFI_SPECTRUM_5_GHZ;\n                        ctrlRateStr = \"OfdmRate\" + std::to_string(nonHtRefRateMbps) + \"Mbps\";\n                        wifi.SetRemoteStationManager(nLinks,\n                                                     \"ns3::ConstantRateWifiManager\",\n                                                     \"DataMode\",\n                                                     StringValue(dataModeStr),\n                                                     \"ControlMode\",\n                                                     StringValue(ctrlRateStr));\n                    }\n                    else if (freq == 2.4)\n                    {\n                        channelStr[nLinks] += \"BAND_2_4GHZ, 0}\";\n                        freqRanges[nLinks] = WIFI_SPECTRUM_2_4_GHZ;\n                        Config::SetDefault(\"ns3::LogDistancePropagationLossModel::ReferenceLoss\",\n                                           DoubleValue(40));\n                        ctrlRateStr = \"ErpOfdmRate\" + std::to_string(nonHtRefRateMbps) + \"Mbps\";\n                        wifi.SetRemoteStationManager(nLinks,\n                                                     \"ns3::ConstantRateWifiManager\",\n                                                     \"DataMode\",\n                                                     StringValue(dataModeStr),\n                                                     \"ControlMode\",\n                                                     StringValue(ctrlRateStr));\n                    }\n                    else\n                    {\n                        NS_FATAL_ERROR(\"Wrong frequency value!\");\n                    }\n\n                    if (is80Plus80)\n                    {\n                        channelStr[nLinks] += std::string(\";\") + channelStr[nLinks];\n                    }\n\n                    nLinks++;\n                }\n\n                if (nLinks > 1 && !emlsrLinks.empty())\n                {\n                    wifi.ConfigEhtOptions(\"EmlsrActivated\", BooleanValue(true));\n                }\n\n                Ssid ssid = Ssid(\"ns3-80211be\");\n\n                SpectrumWifiPhyHelper phy(nLinks);\n                phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n                phy.Set(\"ChannelSwitchDelay\", TimeValue(MicroSeconds(channelSwitchDelayUsec)));\n\n                mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n                mac.SetEmlsrManager(\"ns3::DefaultEmlsrManager\",\n                                    \"EmlsrLinkSet\",\n                                    StringValue(emlsrLinks),\n                                    \"EmlsrPaddingDelay\",\n                                    TimeValue(MicroSeconds(paddingDelayUsec)),\n                                    \"EmlsrTransitionDelay\",\n                                    TimeValue(MicroSeconds(transitionDelayUsec)),\n                                    \"SwitchAuxPhy\",\n                                    BooleanValue(switchAuxPhy),\n                                    \"AuxPhyTxCapable\",\n                                    BooleanValue(auxPhyTxCapable),\n                                    \"AuxPhyChannelWidth\",\n                                    UintegerValue(auxPhyChWidth));\n                for (uint8_t linkId = 0; linkId < nLinks; linkId++)\n                {\n                    phy.Set(linkId, \"ChannelSettings\", StringValue(channelStr[linkId]));\n\n                    auto spectrumChannel = CreateObject<MultiModelSpectrumChannel>();\n                    auto lossModel = CreateObject<LogDistancePropagationLossModel>();\n                    spectrumChannel->AddPropagationLossModel(lossModel);\n                    phy.AddChannel(spectrumChannel, freqRanges[linkId]);\n                }\n                staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n                if (dlAckSeqType != \"NO-OFDMA\")\n                {\n                    mac.SetMultiUserScheduler(\"ns3::RrMultiUserScheduler\",\n                                              \"EnableUlOfdma\",\n                                              BooleanValue(enableUlOfdma),\n                                              \"EnableBsrp\",\n                                              BooleanValue(enableBsrp),\n                                              \"AccessReqInterval\",\n                                              TimeValue(accessReqInterval));\n                }\n                mac.SetType(\"ns3::ApWifiMac\",\n                            \"EnableBeaconJitter\",\n                            BooleanValue(false),\n                            \"Ssid\",\n                            SsidValue(ssid));\n                apDevice = wifi.Install(phy, mac, wifiApNode);\n\n                int64_t streamNumber = 100;\n                streamNumber += WifiHelper::AssignStreams(apDevice, streamNumber);\n                streamNumber += WifiHelper::AssignStreams(staDevices, streamNumber);\n\n                // Set guard interval and MPDU buffer size\n                Config::Set(\n                    \"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HeConfiguration/GuardInterval\",\n                    TimeValue(NanoSeconds(gi)));\n                Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/MpduBufferSize\",\n                            UintegerValue(mpduBufferSize));\n\n                // mobility.\n                MobilityHelper mobility;\n                Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n                positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n                positionAlloc->Add(Vector(distance, 0.0, 0.0));\n                mobility.SetPositionAllocator(positionAlloc);\n\n                mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n                mobility.Install(wifiApNode);\n                mobility.Install(wifiStaNodes);\n\n                /* Internet stack*/\n                InternetStackHelper stack;\n                stack.Install(wifiApNode);\n                stack.Install(wifiStaNodes);\n                streamNumber += stack.AssignStreams(wifiApNode, streamNumber);\n                streamNumber += stack.AssignStreams(wifiStaNodes, streamNumber);\n\n                Ipv4AddressHelper address;\n                address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n                Ipv4InterfaceContainer staNodeInterfaces;\n                Ipv4InterfaceContainer apNodeInterface;\n\n                staNodeInterfaces = address.Assign(staDevices);\n                apNodeInterface = address.Assign(apDevice);\n\n                /* Setting applications */\n                ApplicationContainer serverApp;\n                auto serverNodes = downlink ? std::ref(wifiStaNodes) : std::ref(wifiApNode);\n                Ipv4InterfaceContainer serverInterfaces;\n                NodeContainer clientNodes;\n                for (std::size_t i = 0; i < nStations; i++)\n                {\n                    serverInterfaces.Add(downlink ? staNodeInterfaces.Get(i)\n                                                  : apNodeInterface.Get(0));\n                    clientNodes.Add(downlink ? wifiApNode.Get(0) : wifiStaNodes.Get(i));\n                }\n\n                const auto maxLoad =\n                    nLinks * EhtPhy::GetDataRate(mcs, channelWidth, NanoSeconds(gi), 1) / nStations;\n                if (udp)\n                {\n                    // UDP flow\n                    uint16_t port = 9;\n                    UdpServerHelper server(port);\n                    serverApp = server.Install(serverNodes.get());\n                    streamNumber += server.AssignStreams(serverNodes.get(), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n                    const auto packetInterval = payloadSize * 8.0 / maxLoad;\n\n                    for (std::size_t i = 0; i < nStations; i++)\n                    {\n                        UdpClientHelper client(serverInterfaces.GetAddress(i), port);\n                        client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n                        client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n                        client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                        ApplicationContainer clientApp = client.Install(clientNodes.Get(i));\n                        streamNumber += client.AssignStreams(clientNodes.Get(i), streamNumber);\n\n                        clientApp.Start(Seconds(1.0));\n                        clientApp.Stop(simulationTime + Seconds(1.0));\n                    }\n                }\n                else\n                {\n                    // TCP flow\n                    uint16_t port = 50000;\n                    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n                    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n                    serverApp = packetSinkHelper.Install(serverNodes.get());\n                    streamNumber += packetSinkHelper.AssignStreams(serverNodes.get(), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n\n                    for (std::size_t i = 0; i < nStations; i++)\n                    {\n                        OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n                        onoff.SetAttribute(\"OnTime\",\n                                           StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n                        onoff.SetAttribute(\"OffTime\",\n                                           StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n                        onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                        onoff.SetAttribute(\"DataRate\", DataRateValue(maxLoad));\n                        AddressValue remoteAddress(\n                            InetSocketAddress(serverInterfaces.GetAddress(i), port));\n                        onoff.SetAttribute(\"Remote\", remoteAddress);\n                        ApplicationContainer clientApp = onoff.Install(clientNodes.Get(i));\n                        streamNumber += onoff.AssignStreams(clientNodes.Get(i), streamNumber);\n\n                        clientApp.Start(Seconds(1.0));\n                        clientApp.Stop(simulationTime + Seconds(1.0));\n                    }\n                }\n\n                // cumulative number of bytes received by each server application\n                std::vector<uint64_t> cumulRxBytes(nStations, 0);\n\n                if (tputInterval.IsStrictlyPositive())\n                {\n                    Simulator::Schedule(Seconds(1) + tputInterval,\n                                        &PrintIntermediateTput,\n                                        cumulRxBytes,\n                                        udp,\n                                        serverApp,\n                                        payloadSize,\n                                        tputInterval,\n                                        simulationTime + Seconds(1.0));\n                }\n\n                Simulator::Stop(simulationTime + Seconds(1.0));\n                Simulator::Run();\n\n                // When multiple stations are used, there are chances that association requests\n                // collide and hence the throughput may be lower than expected. Therefore, we relax\n                // the check that the throughput cannot decrease by introducing a scaling factor (or\n                // tolerance)\n                auto tolerance = 0.10;\n                cumulRxBytes = GetRxBytes(udp, serverApp, payloadSize);\n                auto rxBytes = std::accumulate(cumulRxBytes.cbegin(), cumulRxBytes.cend(), 0.0);\n                auto throughput = (rxBytes * 8) / simulationTime.GetMicroSeconds(); // Mbit/s\n\n                Simulator::Destroy();\n\n                std::cout << +mcs << \"\\t\\t\\t\" << widthStr << \" MHz\\t\\t\"\n                          << (widthStr.size() > 3 ? \"\" : \"\\t\") << gi << \" ns\\t\\t\\t\" << throughput\n                          << \" Mbit/s\" << std::endl;\n\n                // test first element\n                if (mcs == minMcs && channelWidth == 20 && gi == 3200)\n                {\n                    if (throughput * (1 + tolerance) < minExpectedThroughput)\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                }\n                // test last element\n                if (mcs == maxMcs && channelWidth == maxChannelWidth && gi == 800)\n                {\n                    if (maxExpectedThroughput > 0 &&\n                        throughput > maxExpectedThroughput * (1 + tolerance))\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                }\n                // test previous throughput is smaller (for the same mcs)\n                if (throughput * (1 + tolerance) > previous)\n                {\n                    previous = throughput;\n                }\n                else if (throughput > 0)\n                {\n                    NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                    exit(1);\n                }\n                // test previous throughput is smaller (for the same channel width and GI)\n                if (throughput * (1 + tolerance) > prevThroughput[index])\n                {\n                    prevThroughput[index] = throughput;\n                }\n                else if (throughput > 0)\n                {\n                    NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                    exit(1);\n                }\n                index++;\n                gi /= 2;\n            }\n            channelWidth *= 2;\n        }\n    }\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ script using the ns-3 library to simulate a basic network topology with three nodes (n0, r, n1) where n0 and n1 are connected through a router (r) using IPv6. Set up the nodes with an IPv6 internet stack, and connect them using CSMA channels with a specified data rate and delay. Assign IPv6 addresses to the network interfaces and configure forwarding and default routes on the router. Include a ping application on n0 to send ICMPv6 echo requests to n1, and enable ASCII and pcap tracing to log the simulation to a file. Print the IPv6 routing table of node n0."}, {"role": "assistant", "content": "// Network topology\n// //\n// //             n0   r    n1\n// //             |    _    |\n// //             ====|_|====\n// //                router\n// //\n// // - Tracing of queues and packet receptions to file \"simple-routing-ping6.tr\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleRoutingPing6Example\");\n\n/**\n * \\class StackHelper\n * \\brief Helper to set or get some IPv6 information about nodes.\n */\nclass StackHelper\n{\n  public:\n    /**\n     * \\brief Add an address to a IPv6 node.\n     * \\param n node\n     * \\param interface interface index\n     * \\param address IPv6 address to add\n     */\n    inline void AddAddress(Ptr<Node>& n, uint32_t interface, Ipv6Address address)\n    {\n        Ptr<Ipv6> ipv6 = n->GetObject<Ipv6>();\n        ipv6->AddAddress(interface, address);\n    }\n\n    /**\n     * \\brief Print the routing table.\n     * \\param n the node\n     */\n    inline void PrintRoutingTable(Ptr<Node>& n)\n    {\n        Ptr<Ipv6StaticRouting> routing = nullptr;\n        Ipv6StaticRoutingHelper routingHelper;\n        Ptr<Ipv6> ipv6 = n->GetObject<Ipv6>();\n        uint32_t nbRoutes = 0;\n        Ipv6RoutingTableEntry route;\n\n        routing = routingHelper.GetStaticRouting(ipv6);\n\n        std::cout << \"Routing table of \" << n << \" : \" << std::endl;\n        std::cout << \"Destination\\t\\t\\t\\t\"\n                  << \"Gateway\\t\\t\\t\\t\\t\"\n                  << \"Interface\\t\"\n                  << \"Prefix to use\" << std::endl;\n\n        nbRoutes = routing->GetNRoutes();\n        for (uint32_t i = 0; i < nbRoutes; i++)\n        {\n            route = routing->GetRoute(i);\n            std::cout << route.GetDest() << \"\\t\" << route.GetGateway() << \"\\t\"\n                      << route.GetInterface() << \"\\t\" << route.GetPrefixToUse() << \"\\t\"\n                      << std::endl;\n        }\n    }\n};\n\nint\nmain(int argc, char** argv)\n{\n#if 0\n  LogComponentEnable (\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"Ipv6Interface\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"Ping\", LOG_LEVEL_ALL);\n#endif\n\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    StackHelper stackHelper;\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> n0 = CreateObject<Node>();\n    Ptr<Node> r = CreateObject<Node>();\n    Ptr<Node> n1 = CreateObject<Node>();\n\n    NodeContainer net1(n0, r);\n    NodeContainer net2(r, n1);\n    NodeContainer all(n0, r, n1);\n\n    NS_LOG_INFO(\"Create IPv6 Internet Stack\");\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d1 = csma.Install(net1);\n    NetDeviceContainer d2 = csma.Install(net2);\n\n    NS_LOG_INFO(\"Create networks and assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i1 = ipv6.Assign(d1);\n    i1.SetForwarding(1, true);\n    i1.SetDefaultRouteInAllNodes(1);\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i2 = ipv6.Assign(d2);\n    i2.SetForwarding(0, true);\n    i2.SetDefaultRouteInAllNodes(0);\n\n    stackHelper.PrintRoutingTable(n0);\n\n    /* Create a Ping application to send ICMPv6 echo request from n0 to n1 via r */\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 5;\n    PingHelper ping(i2.GetAddress(1, 1));\n\n    ping.SetAttribute(\"Count\", UintegerValue(maxPacketCount));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    ApplicationContainer apps = ping.Install(net1.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(20.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"simple-routing-ping6.tr\"));\n    csma.EnablePcapAll(\"simple-routing-ping6\", true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a network with two point-to-point links connecting three routers (R1, R2, R3) and a LAN connected to one of the routers (R2). The simulation uses the TCP protocol to send traffic from a node in the LAN to a node connected to Router R3, passing through Router R2. The simulation collects data on packet transmission, reception, and throughput, and saves this information into an output file."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointAndLanExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n\n    // Create 3 routers and 2 nodes in a LAN\n    NodeContainer routers;\n    routers.Create(3);\n\n    NodeContainer lanNodes;\n    lanNodes.Add(routers.Get(1)); // Connect R2 to the LAN\n    lanNodes.Create(2);           // Add 2 LAN nodes\n\n    // Create point-to-point links between routers\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devicesR1R2, devicesR2R3;\n    devicesR1R2 = pointToPoint.Install(routers.Get(0), routers.Get(1)); // R1-R2 link\n    devicesR2R3 = pointToPoint.Install(routers.Get(1), routers.Get(2)); // R2-R3 link\n\n    // Create CSMA (LAN) link\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    NetDeviceContainer lanDevices;\n    lanDevices = csma.Install(lanNodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(routers);\n    stack.Install(lanNodes.Get(1)); // Install on LAN nodes\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfacesR1R2 = address.Assign(devicesR1R2);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfacesR2R3 = address.Assign(devicesR2R3);\n\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer lanInterfaces = address.Assign(lanDevices);\n\n    // Enable routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Install UDP server on R3 (node 2)\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(routers.Get(2)); // R3\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Install UDP client on one of the LAN nodes\n    UdpClientHelper udpClient(interfacesR2R3.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(lanNodes.Get(1)); // LAN Node\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up FlowMonitor to track traffic\n    FlowMonitorHelper flowmonHelper;\n    Ptr<FlowMonitor> monitor = flowmonHelper.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Print FlowMonitor statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow ID: \" << i->first << \" Src Addr \" << t.sourceAddress << \" Dst Addr \" << t.destinationAddress);\n        NS_LOG_UNCOND(\"Tx Packets = \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"Rx Packets = \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"Throughput: \" << i->second.rxBytes * 8.0 / (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) / 1024 / 1024 << \" Mbps\");\n    }\n\n    // Clean up and exit\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an Ethernet network in NS-3 with two nodes. The first node (client) sends TCP packets to the second node (server). Set the link data rate to 100Mbps and delay to 5ms. Use 192.168.1.0/24 IP addresses. The client sends packets at 0.1s intervals starting at 2s, and the server runs from 1s to 10s. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ethernet-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"EthernetTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Ethernet point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP server on node 1\n    uint16_t port = 9;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on node 0\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a wired network with TCP communication between two computers. The first computer (Computer 1) sends 10 TCP packets (each 1024 bytes) to the second computer (Computer 2) over a Point-to-Point connection with a data rate of 5 Mbps and a 10 ms delay. The communication takes place on port 9, and the client sends packets at a 1-second interval. Use the IP address range 192.168.1.0/24."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WiredTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WiredTcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes representing the computers\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point connection between the two computers\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP server on the second node (Computer 2)\n    TcpServerHelper tcpServer(9); // Listening on port 9\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on the first node (Computer 1)\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), 9);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // Send 10 packets\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // 1-second interval\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // 1024 byte packets\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nProvide code that validates the NIST, YANS, and Table-based error rate models for HE (High Efficiency) rates in NS-3. The program should output Gnuplot plots of Frame Success Rate versus Signal-to-Noise Ratio (SNR) for each error rate model and for every HE MCS value. The code should allow configuration of frame size and iterate through a range of SNR values while generating the corresponding datasets for plotting."}, {"role": "assistant", "content": "// This example is used to validate Nist, Yans and Table-based error rate models for HE rates.\n//\n// It outputs plots of the Frame Success Rate versus the Signal-to-noise ratio for\n// Nist, Yans and Table-based error rate models and for every HE MCS value.\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t frameSizeBytes = 1500;\n    std::ofstream yansfile(\"yans-frame-success-rate-ax.plt\");\n    std::ofstream nistfile(\"nist-frame-success-rate-ax.plt\");\n    std::ofstream tablefile(\"table-frame-success-rate-ax.plt\");\n\n    const std::vector<std::string> modes{\n        \"HeMcs0\",\n        \"HeMcs1\",\n        \"HeMcs2\",\n        \"HeMcs3\",\n        \"HeMcs4\",\n        \"HeMcs5\",\n        \"HeMcs6\",\n        \"HeMcs7\",\n        \"HeMcs8\",\n        \"HeMcs9\",\n        \"HeMcs10\",\n        \"HeMcs11\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"FrameSize\", \"The frame size\", frameSizeBytes);\n    cmd.Parse(argc, argv);\n\n    Gnuplot yansplot = Gnuplot(\"yans-frame-success-rate-ax.eps\");\n    Gnuplot nistplot = Gnuplot(\"nist-frame-success-rate-ax.eps\");\n    Gnuplot tableplot = Gnuplot(\"table-frame-success-rate-ax.eps\");\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n    WifiTxVector txVector;\n\n    uint32_t frameSizeBits = frameSizeBytes * 8;\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset yansdataset(mode);\n        Gnuplot2dDataset nistdataset(mode);\n        Gnuplot2dDataset tabledataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -5.0; snrDb <= 40.0; snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double ps = yans->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            yansdataset.Add(snrDb, ps);\n\n            ps = nist->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            nistdataset.Add(snrDb, ps);\n\n            ps = table->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            tabledataset.Add(snrDb, ps);\n        }\n\n        yansplot.AddDataset(yansdataset);\n        nistplot.AddDataset(nistdataset);\n        tableplot.AddDataset(tabledataset);\n    }\n\n    yansplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    yansplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    yansplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style line 10 linewidth 5\\n\\\nset style line 11 linewidth 5\\n\\\nset style line 12 linewidth 5\\n\\\nset style increment user\");\n    yansplot.GenerateOutput(yansfile);\n    yansfile.close();\n\n    nistplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    nistplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    nistplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style line 10 linewidth 5\\n\\\nset style line 11 linewidth 5\\n\\\nset style line 12 linewidth 5\\n\\\nset style increment user\");\n\n    nistplot.GenerateOutput(nistfile);\n    nistfile.close();\n\n    tableplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    tableplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    tableplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style line 10 linewidth 5\\n\\\nset style line 11 linewidth 5\\n\\\nset style line 12 linewidth 5\\n\\\nset style increment user\");\n\n    tableplot.GenerateOutput(tablefile);\n    tablefile.close();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a CSMA network in NS-3 with three nodes using Ethernet with a data rate of 100Mbps and a delay of 2ms. Set up a UDP server on Node 3 and a UDP client on Node 1. The client should start sending data at 2s and stop at 10s. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ethernet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CSMANetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create three nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Set up CSMA channel\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on nodes\n    NetDeviceContainer devices;\n    devices = csma.Install(nodes);\n\n    // Install the internet stack on the nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 3\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(2));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(2), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ code implementation for the TCP Westwood(+) protocol in ns-3. The code should import necessary ns-3 modules like applications-module, core-module, and internet-module, among others. It should define congestion window, slow start threshold, RTT, and RTO tracing mechanisms using maps and output streams, connecting them to relevant TCP properties. Include functions to trace and log TCP performance metrics such as congestion window, slow start threshold, RTT, RTO, and in-flight bytes. Ensure the code includes commands for setting simulation parameters like bandwidth, delay, packet error rate, and TCP variant selection, with appropriate helper functions to configure the network topology, install applications, and set up tracing for multiple flows."}, {"role": "assistant", "content": "/*\n * \"TCP Westwood(+) Protocol Implementation in ns-3\"\n * Siddharth Gangadhar, Trúc Anh Ngọc Nguyễn , Greeshma Umapathi, and James P.G. Sterbenz,\n * ICST SIMUTools Workshop on ns-3 (WNS3), Cannes, France, March 2013\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/error-model.h\"\n#include \"ns3/event-id.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/tcp-header.h\"\n#include \"ns3/traffic-control-module.h\"\n#include \"ns3/udp-header.h\"\n\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpVariantsComparison\");\n\nstatic std::map<uint32_t, bool> firstCwnd;                      //!< First congestion window.\nstatic std::map<uint32_t, bool> firstSshThr;                    //!< First SlowStart threshold.\nstatic std::map<uint32_t, bool> firstRtt;                       //!< First RTT.\nstatic std::map<uint32_t, bool> firstRto;                       //!< First RTO.\nstatic std::map<uint32_t, Ptr<OutputStreamWrapper>> cWndStream; //!< Congstion window output stream.\nstatic std::map<uint32_t, Ptr<OutputStreamWrapper>>\n    ssThreshStream; //!< SlowStart threshold output stream.\nstatic std::map<uint32_t, Ptr<OutputStreamWrapper>> rttStream;      //!< RTT output stream.\nstatic std::map<uint32_t, Ptr<OutputStreamWrapper>> rtoStream;      //!< RTO output stream.\nstatic std::map<uint32_t, Ptr<OutputStreamWrapper>> nextTxStream;   //!< Next TX output stream.\nstatic std::map<uint32_t, Ptr<OutputStreamWrapper>> nextRxStream;   //!< Next RX output stream.\nstatic std::map<uint32_t, Ptr<OutputStreamWrapper>> inFlightStream; //!< In flight output stream.\nstatic std::map<uint32_t, uint32_t> cWndValue;                      //!< congestion window value.\nstatic std::map<uint32_t, uint32_t> ssThreshValue;                  //!< SlowStart threshold value.\n\n/**\n * Get the Node Id From Context.\n *\n * \\param context The context.\n * \\return the node ID.\n */\nstatic uint32_t\nGetNodeIdFromContext(std::string context)\n{\n    const std::size_t n1 = context.find_first_of('/', 1);\n    const std::size_t n2 = context.find_first_of('/', n1 + 1);\n    return std::stoul(context.substr(n1 + 1, n2 - n1 - 1));\n}\n\n/**\n * Congestion window tracer.\n *\n * \\param context The context.\n * \\param oldval Old value.\n * \\param newval New value.\n */\nstatic void\nCwndTracer(std::string context, uint32_t oldval, uint32_t newval)\n{\n    uint32_t nodeId = GetNodeIdFromContext(context);\n\n    if (firstCwnd[nodeId])\n    {\n        *cWndStream[nodeId]->GetStream() << \"0.0 \" << oldval << std::endl;\n        firstCwnd[nodeId] = false;\n    }\n    *cWndStream[nodeId]->GetStream() << Simulator::Now().GetSeconds() << \" \" << newval << std::endl;\n    cWndValue[nodeId] = newval;\n\n    if (!firstSshThr[nodeId])\n    {\n        *ssThreshStream[nodeId]->GetStream()\n            << Simulator::Now().GetSeconds() << \" \" << ssThreshValue[nodeId] << std::endl;\n    }\n}\n\n/**\n * Slow start threshold tracer.\n *\n * \\param context The context.\n * \\param oldval Old value.\n * \\param newval New value.\n */\nstatic void\nSsThreshTracer(std::string context, uint32_t oldval, uint32_t newval)\n{\n    uint32_t nodeId = GetNodeIdFromContext(context);\n\n    if (firstSshThr[nodeId])\n    {\n        *ssThreshStream[nodeId]->GetStream() << \"0.0 \" << oldval << std::endl;\n        firstSshThr[nodeId] = false;\n    }\n    *ssThreshStream[nodeId]->GetStream()\n        << Simulator::Now().GetSeconds() << \" \" << newval << std::endl;\n    ssThreshValue[nodeId] = newval;\n\n    if (!firstCwnd[nodeId])\n    {\n        *cWndStream[nodeId]->GetStream()\n            << Simulator::Now().GetSeconds() << \" \" << cWndValue[nodeId] << std::endl;\n    }\n}\n\n/**\n * RTT tracer.\n *\n * \\param context The context.\n * \\param oldval Old value.\n * \\param newval New value.\n */\nstatic void\nRttTracer(std::string context, Time oldval, Time newval)\n{\n    uint32_t nodeId = GetNodeIdFromContext(context);\n\n    if (firstRtt[nodeId])\n    {\n        *rttStream[nodeId]->GetStream() << \"0.0 \" << oldval.GetSeconds() << std::endl;\n        firstRtt[nodeId] = false;\n    }\n    *rttStream[nodeId]->GetStream()\n        << Simulator::Now().GetSeconds() << \" \" << newval.GetSeconds() << std::endl;\n}\n\n/**\n * RTO tracer.\n *\n * \\param context The context.\n * \\param oldval Old value.\n * \\param newval New value.\n */\nstatic void\nRtoTracer(std::string context, Time oldval, Time newval)\n{\n    uint32_t nodeId = GetNodeIdFromContext(context);\n\n    if (firstRto[nodeId])\n    {\n        *rtoStream[nodeId]->GetStream() << \"0.0 \" << oldval.GetSeconds() << std::endl;\n        firstRto[nodeId] = false;\n    }\n    *rtoStream[nodeId]->GetStream()\n        << Simulator::Now().GetSeconds() << \" \" << newval.GetSeconds() << std::endl;\n}\n\n/**\n * Next TX tracer.\n *\n * \\param context The context.\n * \\param old Old sequence number.\n * \\param nextTx Next sequence number.\n */\nstatic void\nNextTxTracer(std::string context, SequenceNumber32 old [[maybe_unused]], SequenceNumber32 nextTx)\n{\n    uint32_t nodeId = GetNodeIdFromContext(context);\n\n    *nextTxStream[nodeId]->GetStream()\n        << Simulator::Now().GetSeconds() << \" \" << nextTx << std::endl;\n}\n\n/**\n * In-flight tracer.\n *\n * \\param context The context.\n * \\param old Old value.\n * \\param inFlight In flight value.\n */\nstatic void\nInFlightTracer(std::string context, uint32_t old [[maybe_unused]], uint32_t inFlight)\n{\n    uint32_t nodeId = GetNodeIdFromContext(context);\n\n    *inFlightStream[nodeId]->GetStream()\n        << Simulator::Now().GetSeconds() << \" \" << inFlight << std::endl;\n}\n\n/**\n * Next RX tracer.\n *\n * \\param context The context.\n * \\param old Old sequence number.\n * \\param nextRx Next sequence number.\n */\nstatic void\nNextRxTracer(std::string context, SequenceNumber32 old [[maybe_unused]], SequenceNumber32 nextRx)\n{\n    uint32_t nodeId = GetNodeIdFromContext(context);\n\n    *nextRxStream[nodeId]->GetStream()\n        << Simulator::Now().GetSeconds() << \" \" << nextRx << std::endl;\n}\n\n/**\n * Congestion window trace connection.\n *\n * \\param cwnd_tr_file_name Congestion window trace file name.\n * \\param nodeId Node ID.\n */\nstatic void\nTraceCwnd(std::string cwnd_tr_file_name, uint32_t nodeId)\n{\n    AsciiTraceHelper ascii;\n    cWndStream[nodeId] = ascii.CreateFileStream(cwnd_tr_file_name);\n    Config::Connect(\"/NodeList/\" + std::to_string(nodeId) +\n                        \"/$ns3::TcpL4Protocol/SocketList/0/CongestionWindow\",\n                    MakeCallback(&CwndTracer));\n}\n\n/**\n * Slow start threshold trace connection.\n *\n * \\param ssthresh_tr_file_name Slow start threshold trace file name.\n * \\param nodeId Node ID.\n */\nstatic void\nTraceSsThresh(std::string ssthresh_tr_file_name, uint32_t nodeId)\n{\n    AsciiTraceHelper ascii;\n    ssThreshStream[nodeId] = ascii.CreateFileStream(ssthresh_tr_file_name);\n    Config::Connect(\"/NodeList/\" + std::to_string(nodeId) +\n                        \"/$ns3::TcpL4Protocol/SocketList/0/SlowStartThreshold\",\n                    MakeCallback(&SsThreshTracer));\n}\n\n/**\n * RTT trace connection.\n *\n * \\param rtt_tr_file_name RTT trace file name.\n * \\param nodeId Node ID.\n */\nstatic void\nTraceRtt(std::string rtt_tr_file_name, uint32_t nodeId)\n{\n    AsciiTraceHelper ascii;\n    rttStream[nodeId] = ascii.CreateFileStream(rtt_tr_file_name);\n    Config::Connect(\"/NodeList/\" + std::to_string(nodeId) + \"/$ns3::TcpL4Protocol/SocketList/0/RTT\",\n                    MakeCallback(&RttTracer));\n}\n\n/**\n * RTO trace connection.\n *\n * \\param rto_tr_file_name RTO trace file name.\n * \\param nodeId Node ID.\n */\nstatic void\nTraceRto(std::string rto_tr_file_name, uint32_t nodeId)\n{\n    AsciiTraceHelper ascii;\n    rtoStream[nodeId] = ascii.CreateFileStream(rto_tr_file_name);\n    Config::Connect(\"/NodeList/\" + std::to_string(nodeId) + \"/$ns3::TcpL4Protocol/SocketList/0/RTO\",\n                    MakeCallback(&RtoTracer));\n}\n\n/**\n * Next TX trace connection.\n *\n * \\param next_tx_seq_file_name Next TX trace file name.\n * \\param nodeId Node ID.\n */\nstatic void\nTraceNextTx(std::string& next_tx_seq_file_name, uint32_t nodeId)\n{\n    AsciiTraceHelper ascii;\n    nextTxStream[nodeId] = ascii.CreateFileStream(next_tx_seq_file_name);\n    Config::Connect(\"/NodeList/\" + std::to_string(nodeId) +\n                        \"/$ns3::TcpL4Protocol/SocketList/0/NextTxSequence\",\n                    MakeCallback(&NextTxTracer));\n}\n\n/**\n * In flight trace connection.\n *\n * \\param in_flight_file_name In flight trace file name.\n * \\param nodeId Node ID.\n */\nstatic void\nTraceInFlight(std::string& in_flight_file_name, uint32_t nodeId)\n{\n    AsciiTraceHelper ascii;\n    inFlightStream[nodeId] = ascii.CreateFileStream(in_flight_file_name);\n    Config::Connect(\"/NodeList/\" + std::to_string(nodeId) +\n                        \"/$ns3::TcpL4Protocol/SocketList/0/BytesInFlight\",\n                    MakeCallback(&InFlightTracer));\n}\n\n/**\n * Next RX trace connection.\n *\n * \\param next_rx_seq_file_name Next RX trace file name.\n * \\param nodeId Node ID.\n */\nstatic void\nTraceNextRx(std::string& next_rx_seq_file_name, uint32_t nodeId)\n{\n    AsciiTraceHelper ascii;\n    nextRxStream[nodeId] = ascii.CreateFileStream(next_rx_seq_file_name);\n    Config::Connect(\"/NodeList/\" + std::to_string(nodeId) +\n                        \"/$ns3::TcpL4Protocol/SocketList/1/RxBuffer/NextRxSequence\",\n                    MakeCallback(&NextRxTracer));\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string transport_prot = \"TcpWestwoodPlus\";\n    double error_p = 0.0;\n    std::string bandwidth = \"2Mbps\";\n    std::string delay = \"0.01ms\";\n    std::string access_bandwidth = \"10Mbps\";\n    std::string access_delay = \"45ms\";\n    bool tracing = false;\n    std::string prefix_file_name = \"TcpVariantsComparison\";\n    uint64_t data_mbytes = 0;\n    uint32_t mtu_bytes = 400;\n    uint16_t num_flows = 1;\n    double duration = 100.0;\n    uint32_t run = 0;\n    bool flow_monitor = false;\n    bool pcap = false;\n    bool sack = true;\n    std::string queue_disc_type = \"ns3::PfifoFastQueueDisc\";\n    std::string recovery = \"ns3::TcpClassicRecovery\";\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"transport_prot\",\n                 \"Transport protocol to use: TcpNewReno, TcpLinuxReno, \"\n                 \"TcpHybla, TcpHighSpeed, TcpHtcp, TcpVegas, TcpScalable, TcpVeno, \"\n                 \"TcpBic, TcpYeah, TcpIllinois, TcpWestwoodPlus, TcpLedbat, \"\n                 \"TcpLp, TcpDctcp, TcpCubic, TcpBbr\",\n                 transport_prot);\n    cmd.AddValue(\"error_p\", \"Packet error rate\", error_p);\n    cmd.AddValue(\"bandwidth\", \"Bottleneck bandwidth\", bandwidth);\n    cmd.AddValue(\"delay\", \"Bottleneck delay\", delay);\n    cmd.AddValue(\"access_bandwidth\", \"Access link bandwidth\", access_bandwidth);\n    cmd.AddValue(\"access_delay\", \"Access link delay\", access_delay);\n    cmd.AddValue(\"tracing\", \"Flag to enable/disable tracing\", tracing);\n    cmd.AddValue(\"prefix_name\", \"Prefix of output trace file\", prefix_file_name);\n    cmd.AddValue(\"data\", \"Number of Megabytes of data to transmit\", data_mbytes);\n    cmd.AddValue(\"mtu\", \"Size of IP packets to send in bytes\", mtu_bytes);\n    cmd.AddValue(\"num_flows\", \"Number of flows\", num_flows);\n    cmd.AddValue(\"duration\", \"Time to allow flows to run in seconds\", duration);\n    cmd.AddValue(\"run\", \"Run index (for setting repeatable seeds)\", run);\n    cmd.AddValue(\"flow_monitor\", \"Enable flow monitor\", flow_monitor);\n    cmd.AddValue(\"pcap_tracing\", \"Enable or disable PCAP tracing\", pcap);\n    cmd.AddValue(\"queue_disc_type\",\n                 \"Queue disc type for gateway (e.g. ns3::CoDelQueueDisc)\",\n                 queue_disc_type);\n    cmd.AddValue(\"sack\", \"Enable or disable SACK option\", sack);\n    cmd.AddValue(\"recovery\", \"Recovery algorithm type to use (e.g., ns3::TcpPrrRecovery\", recovery);\n    cmd.Parse(argc, argv);\n\n    transport_prot = std::string(\"ns3::\") + transport_prot;\n\n    SeedManager::SetSeed(1);\n    SeedManager::SetRun(run);\n\n    // User may find it convenient to enable logging\n    // LogComponentEnable(\"TcpVariantsComparison\", LOG_LEVEL_ALL);\n    // LogComponentEnable(\"BulkSendApplication\", LOG_LEVEL_INFO);\n    // LogComponentEnable(\"PfifoFastQueueDisc\", LOG_LEVEL_ALL);\n\n    // Calculate the ADU size\n    Header* temp_header = new Ipv4Header();\n    uint32_t ip_header = temp_header->GetSerializedSize();\n    NS_LOG_LOGIC(\"IP Header size is: \" << ip_header);\n    delete temp_header;\n    temp_header = new TcpHeader();\n    uint32_t tcp_header = temp_header->GetSerializedSize();\n    NS_LOG_LOGIC(\"TCP Header size is: \" << tcp_header);\n    delete temp_header;\n    uint32_t tcp_adu_size = mtu_bytes - 20 - (ip_header + tcp_header);\n    NS_LOG_LOGIC(\"TCP ADU size is: \" << tcp_adu_size);\n\n    // Set the simulation start and stop time\n    double start_time = 0.1;\n    double stop_time = start_time + duration;\n\n    // 2 MB of TCP buffer\n    Config::SetDefault(\"ns3::TcpSocket::RcvBufSize\", UintegerValue(1 << 21));\n    Config::SetDefault(\"ns3::TcpSocket::SndBufSize\", UintegerValue(1 << 21));\n    Config::SetDefault(\"ns3::TcpSocketBase::Sack\", BooleanValue(sack));\n\n    Config::SetDefault(\"ns3::TcpL4Protocol::RecoveryType\",\n                       TypeIdValue(TypeId::LookupByName(recovery)));\n    // Select TCP variant\n    TypeId tcpTid;\n    NS_ABORT_MSG_UNLESS(TypeId::LookupByNameFailSafe(transport_prot, &tcpTid),\n                        \"TypeId \" << transport_prot << \" not found\");\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\",\n                       TypeIdValue(TypeId::LookupByName(transport_prot)));\n\n    // Create gateways, sources, and sinks\n    NodeContainer gateways;\n    gateways.Create(1);\n    NodeContainer sources;\n    sources.Create(num_flows);\n    NodeContainer sinks;\n    sinks.Create(num_flows);\n\n    // Configure the error model\n    // Here we use RateErrorModel with packet error rate\n    Ptr<UniformRandomVariable> uv = CreateObject<UniformRandomVariable>();\n    uv->SetStream(50);\n    RateErrorModel error_model;\n    error_model.SetRandomVariable(uv);\n    error_model.SetUnit(RateErrorModel::ERROR_UNIT_PACKET);\n    error_model.SetRate(error_p);\n\n    PointToPointHelper UnReLink;\n    UnReLink.SetDeviceAttribute(\"DataRate\", StringValue(bandwidth));\n    UnReLink.SetChannelAttribute(\"Delay\", StringValue(delay));\n    UnReLink.SetDeviceAttribute(\"ReceiveErrorModel\", PointerValue(&error_model));\n\n    InternetStackHelper stack;\n    stack.InstallAll();\n\n    TrafficControlHelper tchPfifo;\n    tchPfifo.SetRootQueueDisc(\"ns3::PfifoFastQueueDisc\");\n\n    TrafficControlHelper tchCoDel;\n    tchCoDel.SetRootQueueDisc(\"ns3::CoDelQueueDisc\");\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n\n    // Configure the sources and sinks net devices\n    // and the channels between the sources/sinks and the gateways\n    PointToPointHelper LocalLink;\n    LocalLink.SetDeviceAttribute(\"DataRate\", StringValue(access_bandwidth));\n    LocalLink.SetChannelAttribute(\"Delay\", StringValue(access_delay));\n\n    Ipv4InterfaceContainer sink_interfaces;\n\n    DataRate access_b(access_bandwidth);\n    DataRate bottle_b(bandwidth);\n    Time access_d(access_delay);\n    Time bottle_d(delay);\n\n    uint32_t size = static_cast<uint32_t>((std::min(access_b, bottle_b).GetBitRate() / 8) *\n                                          ((access_d + bottle_d) * 2).GetSeconds());\n\n    Config::SetDefault(\"ns3::PfifoFastQueueDisc::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, size / mtu_bytes)));\n    Config::SetDefault(\"ns3::CoDelQueueDisc::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::BYTES, size)));\n\n    for (uint32_t i = 0; i < num_flows; i++)\n    {\n        NetDeviceContainer devices;\n        devices = LocalLink.Install(sources.Get(i), gateways.Get(0));\n        tchPfifo.Install(devices);\n        address.NewNetwork();\n        Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n        devices = UnReLink.Install(gateways.Get(0), sinks.Get(i));\n        if (queue_disc_type == \"ns3::PfifoFastQueueDisc\")\n        {\n            tchPfifo.Install(devices);\n        }\n        else if (queue_disc_type == \"ns3::CoDelQueueDisc\")\n        {\n            tchCoDel.Install(devices);\n        }\n        else\n        {\n            NS_FATAL_ERROR(\"Queue not recognized. Allowed values are ns3::CoDelQueueDisc or \"\n                           \"ns3::PfifoFastQueueDisc\");\n        }\n        address.NewNetwork();\n        interfaces = address.Assign(devices);\n        sink_interfaces.Add(interfaces.Get(1));\n    }\n\n    NS_LOG_INFO(\"Initialize Global Routing.\");\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    uint16_t port = 50000;\n    Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n\n    for (uint32_t i = 0; i < sources.GetN(); i++)\n    {\n        AddressValue remoteAddress(InetSocketAddress(sink_interfaces.GetAddress(i, 0), port));\n        Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(tcp_adu_size));\n        BulkSendHelper ftp(\"ns3::TcpSocketFactory\", Address());\n        ftp.SetAttribute(\"Remote\", remoteAddress);\n        ftp.SetAttribute(\"SendSize\", UintegerValue(tcp_adu_size));\n        ftp.SetAttribute(\"MaxBytes\", UintegerValue(data_mbytes * 1000000));\n\n        ApplicationContainer sourceApp = ftp.Install(sources.Get(i));\n        sourceApp.Start(Seconds(start_time * i));\n        sourceApp.Stop(Seconds(stop_time - 3));\n\n        sinkHelper.SetAttribute(\"Protocol\", TypeIdValue(TcpSocketFactory::GetTypeId()));\n        ApplicationContainer sinkApp = sinkHelper.Install(sinks.Get(i));\n        sinkApp.Start(Seconds(start_time * i));\n        sinkApp.Stop(Seconds(stop_time));\n    }\n\n    // Set up tracing if enabled\n    if (tracing)\n    {\n        std::ofstream ascii;\n        Ptr<OutputStreamWrapper> ascii_wrap;\n        ascii.open(prefix_file_name + \"-ascii\");\n        ascii_wrap = new OutputStreamWrapper(prefix_file_name + \"-ascii\", std::ios::out);\n        stack.EnableAsciiIpv4All(ascii_wrap);\n\n        for (uint16_t index = 0; index < num_flows; index++)\n        {\n            std::string flowString;\n            if (num_flows > 1)\n            {\n                flowString = \"-flow\" + std::to_string(index);\n            }\n\n            firstCwnd[index + 1] = true;\n            firstSshThr[index + 1] = true;\n            firstRtt[index + 1] = true;\n            firstRto[index + 1] = true;\n\n            Simulator::Schedule(Seconds(start_time * index + 0.00001),\n                                &TraceCwnd,\n                                prefix_file_name + flowString + \"-cwnd.data\",\n                                index + 1);\n            Simulator::Schedule(Seconds(start_time * index + 0.00001),\n                                &TraceSsThresh,\n                                prefix_file_name + flowString + \"-ssth.data\",\n                                index + 1);\n            Simulator::Schedule(Seconds(start_time * index + 0.00001),\n                                &TraceRtt,\n                                prefix_file_name + flowString + \"-rtt.data\",\n                                index + 1);\n            Simulator::Schedule(Seconds(start_time * index + 0.00001),\n                                &TraceRto,\n                                prefix_file_name + flowString + \"-rto.data\",\n                                index + 1);\n            Simulator::Schedule(Seconds(start_time * index + 0.00001),\n                                &TraceNextTx,\n                                prefix_file_name + flowString + \"-next-tx.data\",\n                                index + 1);\n            Simulator::Schedule(Seconds(start_time * index + 0.00001),\n                                &TraceInFlight,\n                                prefix_file_name + flowString + \"-inflight.data\",\n                                index + 1);\n            Simulator::Schedule(Seconds(start_time * index + 0.1),\n                                &TraceNextRx,\n                                prefix_file_name + flowString + \"-next-rx.data\",\n                                num_flows + index + 1);\n        }\n    }\n\n    if (pcap)\n    {\n        UnReLink.EnablePcapAll(prefix_file_name, true);\n        LocalLink.EnablePcapAll(prefix_file_name, true);\n    }\n\n    // Flow monitor\n    FlowMonitorHelper flowHelper;\n    if (flow_monitor)\n    {\n        flowHelper.InstallAll();\n    }\n\n    Simulator::Stop(Seconds(stop_time));\n    Simulator::Run();\n\n    if (flow_monitor)\n    {\n        flowHelper.SerializeToXmlFile(prefix_file_name + \".flowmonitor\", true, true);\n    }\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a simple C++ program using the ns-3 simulation library to set up a mesh topology with three nodes. Configure the nodes to communicate using a Wi-Fi mesh network and assign them static positions. Use UDP traffic to generate communication between the nodes. The simulation should run for 10 seconds, and it should output basic statistics such as packet transmission and reception. Additionally, enable PCAP tracing to capture the packet flow for analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"MeshTopologyExample\");\n\nint main (int argc, char *argv[])\n{\n    LogComponentEnable (\"MeshTopologyExample\", LOG_LEVEL_INFO);\n    \n    // Create 3 nodes\n    NodeContainer nodes;\n    nodes.Create (3);\n    \n    // Set up Wi-Fi mesh\n    WifiHelper wifi;\n    MeshHelper mesh;\n    mesh.SetStackInstaller (\"ns3::Dot11sStack\");  // 802.11s for mesh\n    mesh.SetSpreadInterfaceChannels (MeshHelper::SPREAD_CHANNELS);\n    mesh.SetMacType (\"RandomStart\", TimeValue (Seconds (0.1)));\n    NetDeviceContainer meshDevices = mesh.Install (wifi, nodes);\n    \n    // Position nodes in a simple line (static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                   \"MinX\", DoubleValue (0.0),\n                                   \"MinY\", DoubleValue (0.0),\n                                   \"DeltaX\", DoubleValue (100.0),\n                                   \"DeltaY\", DoubleValue (0.0),\n                                   \"GridWidth\", UintegerValue (3),\n                                   \"LayoutType\", StringValue (\"RowFirst\"));\n    mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install (nodes);\n    \n    // Install internet stack\n    InternetStackHelper internet;\n    internet.Install (nodes);\n    \n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase (\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign (meshDevices);\n    \n    // Create UDP Echo server on node 1\n    UdpEchoServerHelper echoServer (9);  // port number\n    ApplicationContainer serverApps = echoServer.Install (nodes.Get (0));\n    serverApps.Start (Seconds (1.0));\n    serverApps.Stop (Seconds (10.0));\n    \n    // Create UDP Echo client on node 2 to send data to node 1\n    UdpEchoClientHelper echoClient (interfaces.GetAddress (0), 9);\n    echoClient.SetAttribute (\"MaxPackets\", UintegerValue (10));\n    echoClient.SetAttribute (\"Interval\", TimeValue (Seconds (1.0)));\n    echoClient.SetAttribute (\"PacketSize\", UintegerValue (1024));\n    ApplicationContainer clientApps = echoClient.Install (nodes.Get (1));\n    clientApps.Start (Seconds (2.0));\n    clientApps.Stop (Seconds (10.0));\n    \n    // Enable PCAP tracing to capture packet flow\n    wifi.EnablePcapAll (\"mesh-topology\");\n\n    // Run the simulation\n    Simulator::Run ();\n    \n    // Print statistics (transmissions and receptions)\n    std::cout << \"Mesh simulation finished.\" << std::endl;\n\n    Simulator::Destroy ();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple wired CSMA network with four nodes. The network should have a data rate of 100 Mbps and a propagation delay of 6560 nanoseconds. Assign an IPv4 address range of 192.168.1.0/24. The last node should act as a UDP echo server on port 9, while the first node should act as a client, sending two packets of 1024 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    NodeContainer csmaNodes;\n    csmaNodes.Create(4); // Create 4 nodes\n\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    NetDeviceContainer csmaDevices;\n    csmaDevices = csma.Install(csmaNodes);\n\n    InternetStackHelper stack;\n    stack.Install(csmaNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer interfaces = address.Assign(csmaDevices);\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(csmaNodes.Get(3)); // Server on last node\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(3), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(2));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(csmaNodes.Get(0)); // Client on first node\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple LTE communication simulation between two nodes in NS-3, where one node acts as a UDP server (UE) and the other as a client (eNB). The server should accept UDP packets on port 12345, and the client sends 1000 packets at 20ms intervals."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/epc-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set the simulation time\n    Time::SetResolution(Time::MS);\n\n    // Create nodes\n    NodeContainer eNBNodes;\n    eNBNodes.Create(1);\n    NodeContainer ueNodes;\n    ueNodes.Create(1);\n\n    // Create LTE helper\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n\n    // Create EPC helper\n    Ptr<EpcHelper> epcHelper = CreateObject<EpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    // Install LTE devices\n    NetDeviceContainer enbDevs = lteHelper->InstallEnbDevice(eNBNodes);\n    NetDeviceContainer ueDevs = lteHelper->InstallUeDevice(ueNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(ueNodes);\n    stack.Install(eNBNodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(ueDevs);\n\n    // Attach UE to the eNB\n    lteHelper->Attach(ueDevs.Get(0), enbDevs.Get(0));\n\n    // Set up a UDP server on UE\n    uint16_t port = 12345;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(ueNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up a UDP client on eNB\n    UdpClientHelper client(ueIpIface.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(20)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = client.Install(eNBNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate C++ code for an ns-3 simulation experiment that measures Wi-Fi performance based on the distance between two nodes. The program should include Wi-Fi configuration using Ad-hoc mode, mobility for node placement, and statistics collection such as packet transmission, reception, and delay tracking. Use the `DataCollector` class to gather experiment data and support both OMNeT and SQLite output formats. Create callbacks for packet transmission and reception, and define command-line arguments for experiment configuration, including distance, format, and run identifiers."}, {"role": "assistant", "content": "#include \"wifi-example-apps.h\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/stats-module.h\"\n#include \"ns3/wifi-module.h\"\n\n#include <ctime>\n#include <sstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WiFiDistanceExperiment\");\n\n/**\n * Function called when a packet is transmitted.\n *\n * \\param datac The counter of the number of transmitted packets.\n * \\param path The callback context.\n * \\param packet The transmitted packet.\n */\nvoid\nTxCallback(Ptr<CounterCalculator<uint32_t>> datac, std::string path, Ptr<const Packet> packet)\n{\n    NS_LOG_INFO(\"Sent frame counted in \" << datac->GetKey());\n    datac->Update();\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double distance = 50.0;\n    std::string format(\"omnet\");\n\n    std::string experiment(\"wifi-distance-test\");\n    std::string strategy(\"wifi-default\");\n    std::string input;\n    std::string runID;\n\n    {\n        std::stringstream sstr;\n        sstr << \"run-\" << time(nullptr);\n        runID = sstr.str();\n    }\n\n    // Set up command line parameters used to control the experiment.\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"distance\", \"Distance apart to place nodes (in meters).\", distance);\n    cmd.AddValue(\"format\", \"Format to use for data output.\", format);\n    cmd.AddValue(\"experiment\", \"Identifier for experiment.\", experiment);\n    cmd.AddValue(\"strategy\", \"Identifier for strategy.\", strategy);\n    cmd.AddValue(\"run\", \"Identifier for run.\", runID);\n    cmd.Parse(argc, argv);\n\n    if (format != \"omnet\" && format != \"db\")\n    {\n        NS_LOG_ERROR(\"Unknown output format '\" << format << \"'\");\n        return -1;\n    }\n\n#ifndef HAVE_SQLITE3\n    if (format == \"db\")\n    {\n        NS_LOG_ERROR(\"sqlite support not compiled in.\");\n        return -1;\n    }\n#endif\n\n    {\n        std::stringstream sstr(\"\");\n        sstr << distance;\n        input = sstr.str();\n    }\n\n    //--------------------------------------------\n    //-- Create nodes and network stacks\n    //--------------------------------------------\n    NS_LOG_INFO(\"Creating nodes.\");\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    NS_LOG_INFO(\"Installing WiFi and Internet stack.\");\n    WifiHelper wifi;\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n    NetDeviceContainer nodeDevices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    InternetStackHelper internet;\n    internet.Install(nodes);\n    Ipv4AddressHelper ipAddrs;\n    ipAddrs.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n    ipAddrs.Assign(nodeDevices);\n\n    //--------------------------------------------\n    //-- Setup physical layout\n    //--------------------------------------------\n    NS_LOG_INFO(\"Installing static mobility; distance \" << distance << \" .\");\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(0.0, distance, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(nodes);\n\n    //--------------------------------------------\n    //-- Create a custom traffic source and sink\n    //--------------------------------------------\n    NS_LOG_INFO(\"Create traffic source & sink.\");\n    Ptr<Node> appSource = NodeList::GetNode(0);\n    Ptr<Sender> sender = CreateObject<Sender>();\n    appSource->AddApplication(sender);\n    sender->SetStartTime(Seconds(1));\n\n    Ptr<Node> appSink = NodeList::GetNode(1);\n    Ptr<Receiver> receiver = CreateObject<Receiver>();\n    appSink->AddApplication(receiver);\n    receiver->SetStartTime(Seconds(0));\n\n    Config::Set(\"/NodeList/*/ApplicationList/*/$Sender/Destination\",\n                Ipv4AddressValue(\"192.168.0.2\"));\n\n    //--------------------------------------------\n    //-- Setup stats and data collection\n    //--------------------------------------------\n\n    // Create a DataCollector object to hold information about this run.\n    DataCollector data;\n    data.DescribeRun(experiment, strategy, input, runID);\n\n    // Add any information we wish to record about this run.\n    data.AddMetadata(\"author\", \"tjkopena\");\n\n    // Create a counter to track how many frames are generated.  Updates\n    // are triggered by the trace signal generated by the WiFi MAC model\n    // object.  Here we connect the counter to the signal via the simple\n    // TxCallback() glue function defined above.\n    Ptr<CounterCalculator<uint32_t>> totalTx = CreateObject<CounterCalculator<uint32_t>>();\n    totalTx->SetKey(\"wifi-tx-frames\");\n    totalTx->SetContext(\"node[0]\");\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/Mac/MacTx\",\n                    MakeBoundCallback(&TxCallback, totalTx));\n    data.AddDataCalculator(totalTx);\n\n    // This is similar, but creates a counter to track how many frames\n    // are received.  Instead of our own glue function, this uses a\n    // method of an adapter class to connect a counter directly to the\n    // trace signal generated by the WiFi MAC.\n    Ptr<PacketCounterCalculator> totalRx = CreateObject<PacketCounterCalculator>();\n    totalRx->SetKey(\"wifi-rx-frames\");\n    totalRx->SetContext(\"node[1]\");\n    Config::Connect(\"/NodeList/1/DeviceList/*/$ns3::WifiNetDevice/Mac/MacRx\",\n                    MakeCallback(&PacketCounterCalculator::PacketUpdate, totalRx));\n    data.AddDataCalculator(totalRx);\n\n    // This counter tracks how many packets---as opposed to frames---are\n    // generated.  This is connected directly to a trace signal provided\n    // by our Sender class.\n    Ptr<PacketCounterCalculator> appTx = CreateObject<PacketCounterCalculator>();\n    appTx->SetKey(\"sender-tx-packets\");\n    appTx->SetContext(\"node[0]\");\n    Config::Connect(\"/NodeList/0/ApplicationList/*/$Sender/Tx\",\n                    MakeCallback(&PacketCounterCalculator::PacketUpdate, appTx));\n    data.AddDataCalculator(appTx);\n\n    // Here a counter for received packets is directly manipulated by\n    // one of the custom objects in our simulation, the Receiver\n    // Application.  The Receiver object is given a pointer to the\n    // counter and calls its Update() method whenever a packet arrives.\n    Ptr<CounterCalculator<>> appRx = CreateObject<CounterCalculator<>>();\n    appRx->SetKey(\"receiver-rx-packets\");\n    appRx->SetContext(\"node[1]\");\n    receiver->SetCounter(appRx);\n    data.AddDataCalculator(appRx);\n\n    // Just to show this is here...\n\n    /*\n    Ptr<MinMaxAvgTotalCalculator<uint32_t>> test =\n        CreateObject<MinMaxAvgTotalCalculator<uint32_t>>();\n    test->SetKey(\"test-dc\");\n    data.AddDataCalculator(test);\n\n    test->Update(4);\n    test->Update(8);\n    test->Update(24);\n    test->Update(12);\n    */\n\n    // This DataCalculator connects directly to the transmit trace\n    // provided by our Sender Application.  It records some basic\n    // statistics about the sizes of the packets received (min, max,\n    // avg, total # bytes), although in this scenario they're fixed.\n    Ptr<PacketSizeMinMaxAvgTotalCalculator> appTxPkts =\n        CreateObject<PacketSizeMinMaxAvgTotalCalculator>();\n    appTxPkts->SetKey(\"tx-pkt-size\");\n    appTxPkts->SetContext(\"node[0]\");\n    Config::Connect(\"/NodeList/0/ApplicationList/*/$Sender/Tx\",\n                    MakeCallback(&PacketSizeMinMaxAvgTotalCalculator::PacketUpdate, appTxPkts));\n    data.AddDataCalculator(appTxPkts);\n\n    // Here we directly manipulate another DataCollector tracking min,\n    // max, total, and average propagation delays.  Check out the Sender\n    // and Receiver classes to see how packets are tagged with\n    // timestamps to do this.\n    Ptr<TimeMinMaxAvgTotalCalculator> delayStat = CreateObject<TimeMinMaxAvgTotalCalculator>();\n    delayStat->SetKey(\"delay\");\n    delayStat->SetContext(\".\");\n    receiver->SetDelayTracker(delayStat);\n    data.AddDataCalculator(delayStat);\n\n    //--------------------------------------------\n    //-- Run the simulation\n    //--------------------------------------------\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n\n    //--------------------------------------------\n    //-- Generate statistics output.\n    //--------------------------------------------\n\n    // Pick an output writer based in the requested format.\n    Ptr<DataOutputInterface> output = nullptr;\n    if (format == \"omnet\")\n    {\n        NS_LOG_INFO(\"Creating omnet formatted data output.\");\n        output = CreateObject<OmnetDataOutput>();\n    }\n    else if (format == \"db\")\n    {\n#ifdef HAVE_SQLITE3\n        NS_LOG_INFO(\"Creating sqlite formatted data output.\");\n        output = CreateObject<SqliteDataOutput>();\n#endif\n    }\n    else\n    {\n        NS_LOG_ERROR(\"Unknown output format \" << format);\n    }\n\n    // Finally, have that writer interrogate the DataCollector and save\n    // the results.\n    if (output)\n    {\n        output->Output(data);\n    }\n\n    // Free any memory here at the end of this example.\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a TCP connection between two nodes over a Point-to-Point link. Use the TCP NewReno protocol for the connection. The script should measure the network throughput using a FlowMonitor and capture the FlowMonitor output in an XML file. The link between the nodes should have a 5Mbps data rate and 2ms delay. The simulation should run for 10 seconds, and the TCP server should be installed on Node 1, while the TCP client should be installed on Node 0."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpConnectionExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"TcpConnectionExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Point-to-Point link between nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack on nodes\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up TCP server on Node 1\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1)); // Node 1 as server\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on Node 0\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0)); // Node 0 as client\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up FlowMonitor to track throughput\n    FlowMonitorHelper flowMonitorHelper;\n    Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n    // Run simulation\n    Simulator::Run();\n\n    // Display FlowMonitor results\n    flowMonitor->CheckForLostPackets();\n    flowMonitor->SerializeToXmlFile(\"tcp_connection_flowmonitor.xml\", true, true);\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a TCP communication between two nodes. The simulation should include one node acting as a TCP server and the other node acting as a TCP client. The IPv4 protocol should be used for communication. The TCP server should be installed on Node 0, and the TCP client on Node 1. The client should send one 1024-byte packet to the server with a 1-second interval. The simulation should run for 10 seconds, starting the server at 1 second and the client at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpClientServerExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"TcpClientServerExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Install the internet stack (IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(nodes);\n\n    // Create and install the TCP server on Node 0\n    uint16_t port = 9; // Port number for TCP connection\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create and install the TCP client on Node 1\n    TcpClientHelper tcpClient(interfaces.GetAddress(0), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(1));      // Send 1 packet\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // Interval between packets\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // Packet size\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that creates a Wi-Fi network with one Access Point (AP) and three stations (STA). The AP runs a UDP server on port 9, and the stations act as UDP clients. The UDP clients send 1,000 UDP packets of 1024 bytes each with an interval of 0.01 seconds. The simulation runs for 10 seconds, with the server starting at 1 second and the clients starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWifiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleWifiExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: one Access Point (AP) and multiple stations (STA)\n    NodeContainer apNode, staNodes;\n    apNode.Create(1);\n    staNodes.Create(3);\n\n    // Set up Wi-Fi helper\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up Wi-Fi PHY and MAC layer\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    WifiMacHelper apMac;\n    apMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    // Install devices (Wi-Fi NICs) on nodes\n    NetDeviceContainer apDevice, staDevices;\n    apDevice = wifi.Install(wifiPhy, apMac, apNode);\n    staDevices = wifi.Install(wifiPhy, wifiMac, staNodes);\n\n    // Install the internet stack\n    InternetStackHelper stack;\n    stack.Install(apNode);\n    stack.Install(staNodes);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apInterfaces = ipv4.Assign(apDevice);\n    Ipv4InterfaceContainer staInterfaces = ipv4.Assign(staDevices);\n\n    // Set up UDP server on the AP node\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(apNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the stations\n    UdpClientHelper udpClient(apInterfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(staNodes);\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network in ns-3 with multiple stations (clients) connected to an access point (AP) in infrastructure mode. One client will act as a UDP server, while another will act as a UDP client sending traffic to the server. Configure a Wi-Fi channel with a data rate of 54 Mbps and a delay of 2ms. Enable pcap and ASCII tracing to analyze packet transmission and reception. Ensure the simulation runs for 10 seconds, and measure the throughput at the server."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for the simulation\n    LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n\n    // Create nodes for Wi-Fi stations (clients) and an access point (AP)\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2); // 2 stations (clients)\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1); // 1 AP node\n\n    // Set up the Wi-Fi physical layer and channel properties\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up the Wi-Fi MAC layer in infrastructure mode (AP + stations)\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n    WifiMacHelper mac;\n\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n\n    // Install Wi-Fi devices on the stations (clients)\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\", SsidValue(ssid));\n\n    // Install Wi-Fi device on the AP\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set up mobility models for the stations and AP\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Install the Internet stack (TCP/IP) on the nodes\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses to the Wi-Fi devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces;\n    staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface;\n    apInterface = address.Assign(apDevice);\n\n    // Set up a UDP server on one of the stations\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up a UDP client on another station\n    UdpClientHelper udpClient(staInterfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable packet tracing (pcap and ASCII)\n    phy.EnablePcap(\"wifi-udp\", apDevice.Get(0));\n    AsciiTraceHelper ascii;\n    phy.EnableAsciiAll(ascii.CreateFileStream(\"wifi-udp.tr\"));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple LTE network with one eNodeB and one User Equipment (UE). The eNodeB should be static, while the UE should move randomly within a 50x50 area using the Random Walk mobility model. Set up a basic LTE communication system with IP address assignment and install applications for HTTP communication. The eNodeB should have a UDP server running on port 80, and the UE should act as an HTTP client, sending 5 packets at 1-second intervals. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time resolution\n    Time::SetResolution(Time::NS);\n\n    // Create nodes: one eNodeB and one UE\n    NodeContainer enbNode, ueNode;\n    enbNode.Create(1);\n    ueNode.Create(1);\n\n    // Set up the LTE helper\n    LteHelper lteHelper;\n    Ptr<NrCellularNetDevice> enbDevice = lteHelper.InstallEnbDevice(enbNode.Get(0));\n    Ptr<NrCellularNetDevice> ueDevice = lteHelper.InstallUeDevice(ueNode.Get(0));\n\n    // Install IP stack for routing\n    InternetStackHelper internet;\n    internet.Install(enbNode);\n    internet.Install(ueNode);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface, enbIpIface;\n    ueIpIface = ipv4.Assign(ueDevice->GetObject<NetDevice>());\n    enbIpIface = ipv4.Assign(enbDevice->GetObject<NetDevice>());\n\n    // Set up the HTTP server on the eNodeB\n    uint16_t port = 80;\n    UdpServerHelper httpServer(port);\n    ApplicationContainer serverApp = httpServer.Install(enbNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the HTTP client on the UE\n    UdpClientHelper httpClient(enbIpIface.GetAddress(0), port);\n    httpClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    httpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    httpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = httpClient.Install(ueNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set the mobility model for the eNodeB and UE\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(enbNode);\n\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 50, 0, 50)));\n    mobility.Install(ueNode);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nYou will create a simulation in NS-3 to demonstrate the differences between the Nist, Yans, and Table-based error rate models. This program will generate plots comparing the Frame Error Rate (FER) to the Signal-to-Noise Ratio (SNR) for MCS values 0, 4, and 7. You will use the `Gnuplot` library to visualize the data. The simulation accepts command-line parameters such as frame size, MCS range, step values, and error model flags. You will configure and test different MCS values across a range of SNR values and calculate the FER for each error model. The results will be plotted, with Nist, Yans, and Table-based error rate models differentiated by color. After running the simulation, you will output a plot in `.eps` format showing the performance of each error model across the tested MCS values and SNR range."}, {"role": "assistant", "content": "// This example is to show difference among Nist, Yans and Table-based error rate models.\n//\n// It outputs plots of the Frame Error Rate versus the Signal-to-noise ratio for\n// Nist, Yans and Table-based error rate models and for MCS 0, 4 and 7 value.\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t size = 1500 * 8; // bits\n    bool tableErrorModelEnabled = true;\n    bool yansErrorModelEnabled = true;\n    bool nistErrorModelEnabled = true;\n    uint8_t beginMcs = 0;\n    uint8_t endMcs = 7;\n    uint8_t stepMcs = 4;\n    std::string format(\"Ht\");\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"size\", \"The size in bits\", size);\n    cmd.AddValue(\"frameFormat\", \"The frame format to use: Ht, Vht or He\", format);\n    cmd.AddValue(\"beginMcs\", \"The first MCS to test\", beginMcs);\n    cmd.AddValue(\"endMcs\", \"The last MCS to test\", endMcs);\n    cmd.AddValue(\"stepMcs\", \"The step between two MCSs to test\", stepMcs);\n    cmd.AddValue(\"includeTableErrorModel\",\n                 \"Flag to include/exclude Table-based error model\",\n                 tableErrorModelEnabled);\n    cmd.AddValue(\"includeYansErrorModel\",\n                 \"Flag to include/exclude Yans error model\",\n                 yansErrorModelEnabled);\n    cmd.AddValue(\"includeNistErrorModel\",\n                 \"Flag to include/exclude Nist error model\",\n                 nistErrorModelEnabled);\n    cmd.Parse(argc, argv);\n\n    std::ofstream errormodelfile(\"wifi-error-rate-models.plt\");\n    Gnuplot plot = Gnuplot(\"wifi-error-rate-models.eps\");\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n    WifiTxVector txVector;\n    std::vector<std::string> modes;\n\n    std::stringstream mode;\n    mode << format << \"Mcs\" << +beginMcs;\n    modes.push_back(mode.str());\n    for (uint8_t mcs = (beginMcs + stepMcs); mcs < endMcs; mcs += stepMcs)\n    {\n        mode.str(\"\");\n        mode << format << \"Mcs\" << +mcs;\n        modes.push_back(mode.str());\n    }\n    mode.str(\"\");\n    mode << format << \"Mcs\" << +endMcs;\n    modes.push_back(mode.str());\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset yansdataset(mode);\n        Gnuplot2dDataset nistdataset(mode);\n        Gnuplot2dDataset tabledataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -5.0; snrDb <= (endMcs * 5); snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double ps = yans->GetChunkSuccessRate(wifiMode, txVector, snr, size);\n            if (ps < 0 || ps > 1)\n            {\n                // error\n                exit(1);\n            }\n            yansdataset.Add(snrDb, 1 - ps);\n            ps = nist->GetChunkSuccessRate(wifiMode, txVector, snr, size);\n            if (ps < 0 || ps > 1)\n            {\n                // error\n                exit(1);\n            }\n            nistdataset.Add(snrDb, 1 - ps);\n            ps = table->GetChunkSuccessRate(wifiMode, txVector, snr, size);\n            if (ps < 0 || ps > 1)\n            {\n                // error\n                exit(1);\n            }\n            tabledataset.Add(snrDb, 1 - ps);\n        }\n\n        if (tableErrorModelEnabled)\n        {\n            std::stringstream ss;\n            ss << \"Table-\" << mode;\n            tabledataset.SetTitle(ss.str());\n            plot.AddDataset(tabledataset);\n        }\n        if (yansErrorModelEnabled)\n        {\n            std::stringstream ss;\n            ss << \"Yans-\" << mode;\n            yansdataset.SetTitle(ss.str());\n            plot.AddDataset(yansdataset);\n        }\n        if (nistErrorModelEnabled)\n        {\n            std::stringstream ss;\n            ss << \"Nist-\" << mode;\n            nistdataset.SetTitle(ss.str());\n            plot.AddDataset(nistdataset);\n        }\n    }\n\n    plot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    plot.SetLegend(\"SNR(dB)\", \"Frame Error Rate\");\n\n    std::stringstream plotExtra;\n    plotExtra << \"set xrange [-5:\" << endMcs * 5 << \"]\\n\\\nset log y\\n\\\nset yrange [0.0001:1]\\n\";\n\n    uint8_t lineNumber = 1;\n    for (uint32_t i = 0; i < modes.size(); i++)\n    {\n        if (tableErrorModelEnabled)\n        {\n            plotExtra << \"set style line \" << +lineNumber++\n                      << \" linewidth 5 linecolor rgb \\\"red\\\" \\n\";\n        }\n        if (yansErrorModelEnabled)\n        {\n            plotExtra << \"set style line \" << +lineNumber++\n                      << \" linewidth 5 linecolor rgb \\\"green\\\" \\n\";\n        }\n        if (nistErrorModelEnabled)\n        {\n            plotExtra << \"set style line \" << +lineNumber++\n                      << \" linewidth 5 linecolor rgb \\\"blue\\\" \\n\";\n        }\n    }\n\n    plotExtra << \"set style increment user\";\n    plot.SetExtra(plotExtra.str());\n\n    plot.GenerateOutput(errormodelfile);\n    errormodelfile.close();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to model a network topology that includes two nodes (n0 and n1) connected through a router (R) via a CSMA channel. Configure the router to send Router Advertisements (RAs) to both n0's subnet (2001:1::/64) and n1's subnet (2001:2::/64). Implement a Ping application where n0 sends ICMPv6 echo requests to n1. Include tracing of queues and packet receptions, saving the output to a file named 'radvd.tr'. Ensure to set up the IPv6 Internet stack, assign IPv6 addresses, and configure the Radvd application appropriately."}, {"role": "assistant", "content": "// Network topology\n// //\n// //             n0   R    n1\n// //             |    _    |\n// //             ====|_|====\n// //                router\n// // - R sends RA to n0's subnet (2001:1::/64);\n// // - R sends RA to n1's subnet (2001:2::/64);\n// // - n0 ping n1.\n// //\n// // - Tracing of queues and packet receptions to file \"radvd.tr\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/radvd-interface.h\"\n#include \"ns3/radvd-prefix.h\"\n#include \"ns3/radvd.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RadvdExample\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6RawSocketImpl\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"RadvdApplication\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ping\", LOG_LEVEL_ALL);\n    }\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> n0 = CreateObject<Node>();\n    Ptr<Node> r = CreateObject<Node>();\n    Ptr<Node> n1 = CreateObject<Node>();\n\n    NodeContainer net1(n0, r);\n    NodeContainer net2(r, n1);\n    NodeContainer all(n0, r, n1);\n\n    NS_LOG_INFO(\"Create IPv6 Internet Stack\");\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d1 = csma.Install(net1); /* n0 - R */\n    NetDeviceContainer d2 = csma.Install(net2); /* R - n1 */\n\n    NS_LOG_INFO(\"Create networks and assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n\n    /* first subnet */\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    NetDeviceContainer tmp;\n    tmp.Add(d1.Get(0));                                           /* n0 */\n    Ipv6InterfaceContainer iic1 = ipv6.AssignWithoutAddress(tmp); /* n0 interface */\n\n    NetDeviceContainer tmp2;\n    tmp2.Add(d1.Get(1)); /* R */\n    Ipv6InterfaceContainer iicr1 =\n        ipv6.Assign(tmp2); /* R interface to the first subnet is just statically assigned */\n    iicr1.SetForwarding(0, true);\n    iic1.Add(iicr1);\n\n    /* second subnet R - n1 */\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    NetDeviceContainer tmp3;\n    tmp3.Add(d2.Get(0));                              /* R */\n    Ipv6InterfaceContainer iicr2 = ipv6.Assign(tmp3); /* R interface */\n    iicr2.SetForwarding(0, true);\n\n    NetDeviceContainer tmp4;\n    tmp4.Add(d2.Get(1)); /* n1 */\n    Ipv6InterfaceContainer iic2 = ipv6.AssignWithoutAddress(tmp4);\n    iic2.Add(iicr2);\n\n    /* radvd configuration */\n    RadvdHelper radvdHelper;\n\n    /* R interface (n0 - R) */\n    /* n0 will receive unsolicited (periodic) RA */\n    radvdHelper.AddAnnouncedPrefix(iic1.GetInterfaceIndex(1), Ipv6Address(\"2001:1::0\"), 64);\n\n    /* R interface (R - n1) */\n    /* n1 will have to use RS, as RA are not sent automatically */\n    radvdHelper.AddAnnouncedPrefix(iic2.GetInterfaceIndex(1), Ipv6Address(\"2001:2::0\"), 64);\n    radvdHelper.GetRadvdInterface(iic2.GetInterfaceIndex(1))->SetSendAdvert(false);\n\n    ApplicationContainer radvdApps = radvdHelper.Install(r);\n    radvdApps.Start(Seconds(1.0));\n    radvdApps.Stop(Seconds(10.0));\n\n    /* Create a Ping application to send ICMPv6 echo request from n0 to n1 via R */\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 5;\n    PingHelper ping(\n        Ipv6Address(\"2001:2::200:ff:fe00:4\")); /* should be n1 address after autoconfiguration */\n\n    ping.SetAttribute(\"Count\", UintegerValue(maxPacketCount));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    ApplicationContainer apps = ping.Install(net1.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(7.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"radvd.tr\"));\n    csma.EnablePcapAll(std::string(\"radvd\"), true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Vehicular Ad-hoc Network (VANET) using DSDV (Destination-Sequenced Distance-Vector Routing) in ns-3. The simulation will model vehicles moving along a straight road, with each vehicle acting as a mobile node. These nodes communicate via WiFi and use the DSDV routing protocol to maintain routes between them. The simulation will track packet delivery, node mobility, and the overall network performance using DSDV."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/dsdv-helper.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/animation-interface.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"VanetDsdvExample\");\n\nint main(int argc, char *argv[])\n{\n    // Log configuration\n    LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n\n    // Set up 10 nodes (vehicles)\n    NodeContainer vehicles;\n    vehicles.Create(10);\n\n    // Set up WiFi network with Ad-Hoc mode\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, vehicles);\n\n    // Set mobility for vehicles (moving along a straight road)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(50.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(10),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(vehicles);\n\n    for (uint32_t i = 0; i < vehicles.GetN(); ++i)\n    {\n        Ptr<ConstantVelocityMobilityModel> mob = vehicles.Get(i)->GetObject<ConstantVelocityMobilityModel>();\n        mob->SetVelocity(Vector(20.0, 0.0, 0.0)); // Vehicles move at 20 m/s along the x-axis\n    }\n\n    // Install DSDV routing protocol\n    DsdvHelper dsdv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(dsdv);\n    internet.Install(vehicles);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Create a UDP server on the last vehicle\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(vehicles.Get(9));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Create a UDP client on the first vehicle to send packets to the server\n    UdpClientHelper udpClient(interfaces.GetAddress(9), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(vehicles.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(20.0));\n\n    // Enable tracing\n    wifiPhy.EnablePcap(\"vanet-dsdv\", devices);\n    AnimationInterface anim(\"vanet-dsdv.xml\");\n\n    // Flow Monitor to track performance\n    FlowMonitorHelper flowMonitor;\n    Ptr<FlowMonitor> monitor = flowMonitor.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(20.0));\n    Simulator::Run();\n\n    // Output flow monitor statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitor.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"  Lost Packets: \" << i->second.lostPackets);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 /\n                                            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n                                            1024 / 1024 << \" Mbps\");\n    }\n\n    // End the simulation\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 network simulator to compare three WiFi rate control mechanisms: `ParfWifiManager`, `AparfWifiManager`, and `RrpaaWifiManager`. The program should simulate a simple WiFi network consisting of two nodes: an access point (AP) and a station (STA). The AP should generate UDP traffic at a constant bit rate (CBR) of 54 Mbps towards the STA. The STA will move away from the AP by 1 meter every second, and you should log the changes in transmit power and rate, as well as plot average throughput and average transmit power as functions of distance. Your program should output Gnuplot-compatible files and allow the user to specify parameters such as the rate control mechanism, RTS threshold, and output filenames through command-line arguments."}, {"role": "assistant", "content": "/**\n * This example program is designed to illustrate the behavior of three\n * power/rate-adaptive WiFi rate controls; namely, ns3::ParfWifiManager,\n * ns3::AparfWifiManager and ns3::RrpaaWifiManager.\n *\n * The output of this is typically two plot files, named throughput-parf.plt\n * (or throughput-aparf.plt, if Aparf is used) and power-parf.plt. If\n * Gnuplot program is available, one can use it to convert the plt file\n * into an eps file, by running:\n * \\code{.sh}\n *   gnuplot throughput-parf.plt\n * \\endcode\n * Also, to enable logging of rate and power changes to the terminal, set this\n * environment variable:\n * \\code{.sh}\n *   export NS_LOG=PowerAdaptationDistance=level_info\n * \\endcode\n *\n * This simulation consist of 2 nodes, one AP and one STA.\n * The AP generates UDP traffic with a CBR of 54 Mbps to the STA.\n * The AP can use any power and rate control mechanism and the STA uses\n * only Minstrel rate control.\n * The STA can be configured to move away from (or towards to) the AP.\n * By default, the AP is at coordinate (0,0,0) and the STA starts at\n * coordinate (5,0,0) (meters) and moves away on the x axis by 1 meter every\n * second.\n *\n * The output consists of:\n * - A plot of average throughput vs. distance.\n * - A plot of average transmit power vs. distance.\n * - (if logging is enabled) the changes of power and rate to standard output.\n *\n * The Average Transmit Power is defined as an average of the power\n * consumed per measurement interval, expressed in milliwatts.  The\n * power level for each frame transmission is reported by the simulator,\n * and the energy consumed is obtained by multiplying the power by the\n * frame duration.  At every 'stepTime' (defaulting to 1 second), the\n * total energy for the collection period is divided by the step time\n * and converted from dbm to milliwatt units, and this average is\n * plotted against time.\n *\n * When neither Parf, Aparf or Rrpaa is selected as the rate control, the\n * generation of the plot of average transmit power vs distance is suppressed\n * since the other Wifi rate controls do not support the necessary callbacks\n * for computing the average power.\n *\n * To display all the possible arguments and their defaults:\n * \\code{.sh}\n *   ./ns3 run \"wifi-power-adaptation-distance --help\"\n * \\endcode\n *\n * Example usage (selecting Aparf rather than Parf):\n * \\code{.sh}\n *   ./ns3 run \"wifi-power-adaptation-distance --manager=ns3::AparfWifiManager\n * --outputFileName=aparf\" \\endcode\n *\n * Another example (moving towards the AP):\n * \\code{.sh}\n *   ./ns3 run \"wifi-power-adaptation-distance --manager=ns3::AparfWifiManager\n * --outputFileName=aparf --stepsSize=-1 --STA1_x=200\" \\endcode\n *\n * To enable the log of rate and power changes:\n * \\code{.sh}\n *   export NS_LOG=PowerAdaptationDistance=level_info\n * \\endcode\n */\n\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/wifi-mac-header.h\"\n#include \"ns3/wifi-mac.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PowerAdaptationDistance\");\n\n/// Packet size generated at the AP\nstatic const uint32_t packetSize = 1420;\n\n/**\n * \\brief Class to collect node statistics.\n */\nclass NodeStatistics\n{\n  public:\n    /**\n     * \\brief Constructor.\n     *\n     * \\param aps Access points\n     * \\param stas WiFi Stations.\n     */\n    NodeStatistics(NetDeviceContainer aps, NetDeviceContainer stas);\n\n    /**\n     * \\brief Callback called by WifiNetDevice/Phy/PhyTxBegin.\n     *\n     * \\param path The trace path.\n     * \\param packet The sent packet.\n     * \\param powerW The Tx power.\n     */\n    void PhyCallback(std::string path, Ptr<const Packet> packet, double powerW);\n    /**\n     * \\brief Callback called by PacketSink/Rx.\n     *\n     * \\param path The trace path.\n     * \\param packet The received packet.\n     * \\param from The sender address.\n     */\n    void RxCallback(std::string path, Ptr<const Packet> packet, const Address& from);\n    /**\n     * \\brief Callback called by WifiNetDevice/RemoteStationManager/x/PowerChange.\n     *\n     * \\param path The trace path.\n     * \\param oldPower Old Tx power.\n     * \\param newPower Actual Tx power.\n     * \\param dest Destination of the transmission.\n     */\n    void PowerCallback(std::string path, double oldPower, double newPower, Mac48Address dest);\n    /**\n     * \\brief Callback called by WifiNetDevice/RemoteStationManager/x/RateChange.\n     *\n     * \\param path The trace path.\n     * \\param oldRate Old rate.\n     * \\param newRate Actual rate.\n     * \\param dest Destination of the transmission.\n     */\n    void RateCallback(std::string path, DataRate oldRate, DataRate newRate, Mac48Address dest);\n    /**\n     * \\brief Set the Position of a node.\n     *\n     * \\param node The node.\n     * \\param position The position.\n     */\n    void SetPosition(Ptr<Node> node, Vector position);\n    /**\n     * Move a node.\n     * \\param node The node.\n     * \\param stepsSize The step size.\n     * \\param stepsTime Time on each step.\n     */\n    void AdvancePosition(Ptr<Node> node, int stepsSize, Time stepsTime);\n    /**\n     * \\brief Get the Position of a node.\n     *\n     * \\param node The node.\n     * \\return the position of the node.\n     */\n    Vector GetPosition(Ptr<Node> node);\n\n    /**\n     * \\brief Get the Throughput output data\n     *\n     * \\return the Throughput output data.\n     */\n    Gnuplot2dDataset GetDatafile();\n    /**\n     * \\brief Get the Power output data.\n     *\n     * \\return the Power output data.\n     */\n    Gnuplot2dDataset GetPowerDatafile();\n\n  private:\n    /// Time, DataRate pair vector.\n    typedef std::vector<std::pair<Time, DataRate>> TxTime;\n    /**\n     * \\brief Setup the WifiPhy object.\n     *\n     * \\param phy The WifiPhy to setup.\n     */\n    void SetupPhy(Ptr<WifiPhy> phy);\n    /**\n     * \\brief Get the time at which a given datarate has been recorded.\n     *\n     * \\param rate The datarate to search.\n     * \\return the time.\n     */\n    Time GetCalcTxTime(DataRate rate);\n\n    std::map<Mac48Address, dBm_u> m_currentPower;   //!< Current Tx power for each sender.\n    std::map<Mac48Address, DataRate> m_currentRate; //!< Current Tx rate for each sender.\n    uint32_t m_bytesTotal;                          //!< Number of received bytes on a given state.\n    double m_totalEnergy;                           //!< Energy used on a given state.\n    double m_totalTime;                             //!< Time spent on a given state.\n    TxTime m_timeTable;                             //!< Time, DataRate table.\n    Gnuplot2dDataset m_output;                      //!< Throughput output data.\n    Gnuplot2dDataset m_output_power;                //!< Power output data.\n};\n\nNodeStatistics::NodeStatistics(NetDeviceContainer aps, NetDeviceContainer stas)\n{\n    Ptr<NetDevice> device = aps.Get(0);\n    Ptr<WifiNetDevice> wifiDevice = DynamicCast<WifiNetDevice>(device);\n    Ptr<WifiPhy> phy = wifiDevice->GetPhy();\n    SetupPhy(phy);\n    DataRate dataRate = DataRate(phy->GetDefaultMode().GetDataRate(phy->GetChannelWidth()));\n    const auto power = phy->GetTxPowerEnd();\n    for (uint32_t j = 0; j < stas.GetN(); j++)\n    {\n        Ptr<NetDevice> staDevice = stas.Get(j);\n        Ptr<WifiNetDevice> wifiStaDevice = DynamicCast<WifiNetDevice>(staDevice);\n        Mac48Address addr = wifiStaDevice->GetMac()->GetAddress();\n        m_currentPower[addr] = power;\n        m_currentRate[addr] = dataRate;\n    }\n    m_currentRate[Mac48Address(\"ff:ff:ff:ff:ff:ff\")] = dataRate;\n    m_totalEnergy = 0;\n    m_totalTime = 0;\n    m_bytesTotal = 0;\n    m_output.SetTitle(\"Throughput Mbits/s\");\n    m_output_power.SetTitle(\"Average Transmit Power\");\n}\n\nvoid\nNodeStatistics::SetupPhy(Ptr<WifiPhy> phy)\n{\n    for (const auto& mode : phy->GetModeList())\n    {\n        WifiTxVector txVector;\n        txVector.SetMode(mode);\n        txVector.SetPreambleType(WIFI_PREAMBLE_LONG);\n        txVector.SetChannelWidth(phy->GetChannelWidth());\n        DataRate dataRate(mode.GetDataRate(phy->GetChannelWidth()));\n        Time time = phy->CalculateTxDuration(packetSize, txVector, phy->GetPhyBand());\n        NS_LOG_DEBUG(mode.GetUniqueName() << \" \" << time.GetSeconds() << \" \" << dataRate);\n        m_timeTable.emplace_back(time, dataRate);\n    }\n}\n\nTime\nNodeStatistics::GetCalcTxTime(DataRate rate)\n{\n    for (auto i = m_timeTable.begin(); i != m_timeTable.end(); i++)\n    {\n        if (rate == i->second)\n        {\n            return i->first;\n        }\n    }\n    NS_ASSERT(false);\n    return Seconds(0);\n}\n\nvoid\nNodeStatistics::PhyCallback(std::string path, Ptr<const Packet> packet, double powerW)\n{\n    WifiMacHeader head;\n    packet->PeekHeader(head);\n    Mac48Address dest = head.GetAddr1();\n\n    if (head.GetType() == WIFI_MAC_DATA)\n    {\n        m_totalEnergy += pow(10.0, m_currentPower[dest] / 10.0) *\n                         GetCalcTxTime(m_currentRate[dest]).GetSeconds();\n        m_totalTime += GetCalcTxTime(m_currentRate[dest]).GetSeconds();\n    }\n}\n\nvoid\nNodeStatistics::PowerCallback(std::string path, double oldPower, double newPower, Mac48Address dest)\n{\n    m_currentPower[dest] = newPower;\n}\n\nvoid\nNodeStatistics::RateCallback(std::string path,\n                             DataRate oldRate,\n                             DataRate newRate,\n                             Mac48Address dest)\n{\n    m_currentRate[dest] = newRate;\n}\n\nvoid\nNodeStatistics::RxCallback(std::string path, Ptr<const Packet> packet, const Address& from)\n{\n    m_bytesTotal += packet->GetSize();\n}\n\nvoid\nNodeStatistics::SetPosition(Ptr<Node> node, Vector position)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    mobility->SetPosition(position);\n}\n\nVector\nNodeStatistics::GetPosition(Ptr<Node> node)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    return mobility->GetPosition();\n}\n\nvoid\nNodeStatistics::AdvancePosition(Ptr<Node> node, int stepsSize, Time stepsTime)\n{\n    Vector pos = GetPosition(node);\n    double mbs = ((m_bytesTotal * 8.0) / stepsTime.GetMicroSeconds());\n    m_bytesTotal = 0;\n    double atp = m_totalEnergy / stepsTime.GetSeconds();\n    m_totalEnergy = 0;\n    m_totalTime = 0;\n    m_output_power.Add(pos.x, atp);\n    m_output.Add(pos.x, mbs);\n    pos.x += stepsSize;\n    SetPosition(node, pos);\n    NS_LOG_INFO(\"At time \" << Simulator::Now().GetSeconds() << \" sec; setting new position to \"\n                           << pos);\n    Simulator::Schedule(stepsTime,\n                        &NodeStatistics::AdvancePosition,\n                        this,\n                        node,\n                        stepsSize,\n                        stepsTime);\n}\n\nGnuplot2dDataset\nNodeStatistics::GetDatafile()\n{\n    return m_output;\n}\n\nGnuplot2dDataset\nNodeStatistics::GetPowerDatafile()\n{\n    return m_output_power;\n}\n\n/**\n * Callback called by WifiNetDevice/RemoteStationManager/x/PowerChange.\n *\n * \\param path The trace path.\n * \\param oldPower Old Tx power.\n * \\param newPower Actual Tx power.\n * \\param dest Destination of the transmission.\n */\nvoid\nPowerCallback(std::string path, double oldPower, double newPower, Mac48Address dest)\n{\n    NS_LOG_INFO((Simulator::Now()).GetSeconds()\n                << \" \" << dest << \" Old power=\" << oldPower << \" New power=\" << newPower);\n}\n\n/**\n * \\brief Callback called by WifiNetDevice/RemoteStationManager/x/RateChange.\n *\n * \\param path The trace path.\n * \\param oldRate Old rate.\n * \\param newRate Actual rate.\n * \\param dest Destination of the transmission.\n */\nvoid\nRateCallback(std::string path, DataRate oldRate, DataRate newRate, Mac48Address dest)\n{\n    NS_LOG_INFO((Simulator::Now()).GetSeconds()\n                << \" \" << dest << \" Old rate=\" << oldRate << \" New rate=\" << newRate);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    dBm_u maxPower{17};\n    dBm_u minPower{0};\n    uint32_t powerLevels{18};\n\n    uint32_t rtsThreshold{2346};\n    std::string manager{\"ns3::ParfWifiManager\"};\n    std::string outputFileName{\"parf\"};\n    int ap1_x{0};\n    int ap1_y{0};\n    int sta1_x{5};\n    int sta1_y{0};\n    uint32_t steps{200};\n    meter_u stepsSize{1};\n    Time stepsTime{\"1s\"};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"manager\", \"PRC Manager\", manager);\n    cmd.AddValue(\"rtsThreshold\", \"RTS threshold\", rtsThreshold);\n    cmd.AddValue(\"outputFileName\", \"Output filename\", outputFileName);\n    cmd.AddValue(\"steps\", \"How many different distances to try\", steps);\n    cmd.AddValue(\"stepsTime\", \"Time on each step\", stepsTime);\n    cmd.AddValue(\"stepsSize\", \"Distance between steps\", stepsSize);\n    cmd.AddValue(\"maxPower\", \"Maximum available transmission level (dbm).\", maxPower);\n    cmd.AddValue(\"minPower\", \"Minimum available transmission level (dbm).\", minPower);\n    cmd.AddValue(\"powerLevels\",\n                 \"Number of transmission power levels available between \"\n                 \"TxPowerStart and TxPowerEnd included.\",\n                 powerLevels);\n    cmd.AddValue(\"AP1_x\", \"Position of AP1 in x coordinate\", ap1_x);\n    cmd.AddValue(\"AP1_y\", \"Position of AP1 in y coordinate\", ap1_y);\n    cmd.AddValue(\"STA1_x\", \"Position of STA1 in x coordinate\", sta1_x);\n    cmd.AddValue(\"STA1_y\", \"Position of STA1 in y coordinate\", sta1_y);\n    cmd.Parse(argc, argv);\n\n    if (steps == 0)\n    {\n        std::cout << \"Exiting without running simulation; steps value of 0\" << std::endl;\n    }\n\n    Time simuTime = (steps + 1) * stepsTime;\n\n    // Define the APs\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(1);\n\n    // Define the STAs\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(1);\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n    WifiMacHelper wifiMac;\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    NetDeviceContainer wifiApDevices;\n    NetDeviceContainer wifiStaDevices;\n    NetDeviceContainer wifiDevices;\n\n    // Configure the STA node\n    wifi.SetRemoteStationManager(\"ns3::MinstrelWifiManager\",\n                                 \"RtsCtsThreshold\",\n                                 UintegerValue(rtsThreshold));\n    wifiPhy.Set(\"TxPowerStart\", DoubleValue(maxPower));\n    wifiPhy.Set(\"TxPowerEnd\", DoubleValue(maxPower));\n\n    Ssid ssid = Ssid(\"AP\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    wifiStaDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiStaNodes.Get(0)));\n\n    // Configure the AP node\n    wifi.SetRemoteStationManager(manager,\n                                 \"DefaultTxPowerLevel\",\n                                 UintegerValue(powerLevels - 1),\n                                 \"RtsCtsThreshold\",\n                                 UintegerValue(rtsThreshold));\n    wifiPhy.Set(\"TxPowerStart\", DoubleValue(minPower));\n    wifiPhy.Set(\"TxPowerEnd\", DoubleValue(maxPower));\n    wifiPhy.Set(\"TxPowerLevels\", UintegerValue(powerLevels));\n\n    ssid = Ssid(\"AP\");\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    wifiApDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiApNodes.Get(0)));\n\n    wifiDevices.Add(wifiStaDevices);\n    wifiDevices.Add(wifiApDevices);\n\n    // Configure the mobility.\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    // Initial position of AP and STA\n    positionAlloc->Add(Vector(ap1_x, ap1_y, 0.0));\n    NS_LOG_INFO(\"Setting initial AP position to \" << Vector(ap1_x, ap1_y, 0.0));\n    positionAlloc->Add(Vector(sta1_x, sta1_y, 0.0));\n    NS_LOG_INFO(\"Setting initial STA position to \" << Vector(sta1_x, sta1_y, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNodes.Get(0));\n    mobility.Install(wifiStaNodes.Get(0));\n\n    // Statistics counter\n    NodeStatistics statistics = NodeStatistics(wifiApDevices, wifiStaDevices);\n\n    // Move the STA by stepsSize meters every stepsTime seconds\n    Simulator::Schedule(Seconds(0.5) + stepsTime,\n                        &NodeStatistics::AdvancePosition,\n                        &statistics,\n                        wifiStaNodes.Get(0),\n                        stepsSize,\n                        stepsTime);\n\n    // Configure the IP stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes);\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = address.Assign(wifiDevices);\n    Ipv4Address sinkAddress = i.GetAddress(0);\n    uint16_t port = 9;\n\n    // Configure the CBR generator\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress, port));\n    ApplicationContainer apps_sink = sink.Install(wifiStaNodes.Get(0));\n\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress, port));\n    onoff.SetConstantRate(DataRate(\"54Mb/s\"), packetSize);\n    onoff.SetAttribute(\"StartTime\", TimeValue(Seconds(0.5)));\n    onoff.SetAttribute(\"StopTime\", TimeValue(simuTime));\n    ApplicationContainer apps_source = onoff.Install(wifiApNodes.Get(0));\n\n    apps_sink.Start(Seconds(0.5));\n    apps_sink.Stop(simuTime);\n\n    //------------------------------------------------------------\n    //-- Setup stats and data collection\n    //--------------------------------------------\n\n    // Register packet receptions to calculate throughput\n    Config::Connect(\"/NodeList/1/ApplicationList/*/$ns3::PacketSink/Rx\",\n                    MakeCallback(&NodeStatistics::RxCallback, &statistics));\n\n    // Register power and rate changes to calculate the Average Transmit Power\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/PowerChange\",\n                    MakeCallback(&NodeStatistics::PowerCallback, &statistics));\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/RateChange\",\n                    MakeCallback(&NodeStatistics::RateCallback, &statistics));\n\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/Phy/PhyTxBegin\",\n                    MakeCallback(&NodeStatistics::PhyCallback, &statistics));\n\n    // Callbacks to print every change of power and rate\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/PowerChange\",\n                    MakeCallback(PowerCallback));\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/RateChange\",\n                    MakeCallback(RateCallback));\n\n    Simulator::Stop(simuTime);\n    Simulator::Run();\n\n    std::ofstream outfile(\"throughput-\" + outputFileName + \".plt\");\n    Gnuplot gnuplot = Gnuplot(\"throughput-\" + outputFileName + \".eps\", \"Throughput\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Throughput (Mb/s)\");\n    gnuplot.SetTitle(\"Throughput (AP to STA) vs time\");\n    gnuplot.AddDataset(statistics.GetDatafile());\n    gnuplot.GenerateOutput(outfile);\n\n    if (manager == \"ns3::ParfWifiManager\" || manager == \"ns3::AparfWifiManager\" ||\n        manager == \"ns3::RrpaaWifiManager\")\n    {\n        std::ofstream outfile2(\"power-\" + outputFileName + \".plt\");\n        gnuplot = Gnuplot(\"power-\" + outputFileName + \".eps\", \"Average Transmit Power\");\n        gnuplot.SetTerminal(\"post eps color enhanced\");\n        gnuplot.SetLegend(\"Time (seconds)\", \"Power (mW)\");\n        gnuplot.SetTitle(\"Average transmit power (AP to STA) vs time\");\n        gnuplot.AddDataset(statistics.GetPowerDatafile());\n        gnuplot.GenerateOutput(outfile2);\n    }\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a program in C++ using the ns-3 library that reads an upper triangular adjacency matrix from a file (e.g., `adjacency_matrix.txt`) and node coordinates from a file (e.g., `node_coordinates.txt`). The program should set up a wired network topology with point-to-point (P2P) links according to the adjacency matrix and establish constant bit rate (CBR) traffic flows between nodes. Each node should have a unique traffic flow towards every other node, except itself, resulting in `n*(n-1)` CBR flows, where `n` is the number of nodes. The network topology, CBR traffic, and positions of nodes should be visualized in NetAnim, and simulation outputs should be logged."}, {"role": "assistant", "content": "/*\n * This program reads an upper triangular adjacency matrix (e.g. adjacency_matrix.txt) and\n * node coordinates file (e.g. node_coordinates.txt). The program also set-ups a\n * wired network topology with P2P links according to the adjacency matrix with\n * nx(n-1) CBR traffic flows, in which n is the number of nodes in the adjacency matrix.\n */\n\n// ---------- Header Includes -------------------------------------------------\n#include \"ns3/applications-module.h\"\n#include \"ns3/assert.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/global-route-manager.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace ns3;\n\n// ---------- Prototypes ------------------------------------------------------\n\nstd::vector<std::vector<bool>> readNxNMatrix(std::string adj_mat_file_name);\nstd::vector<std::vector<double>> readCoordinatesFile(std::string node_coordinates_file_name);\nvoid printCoordinateArray(const char* description, std::vector<std::vector<double>> coord_array);\nvoid printMatrix(const char* description, std::vector<std::vector<bool>> array);\n\nNS_LOG_COMPONENT_DEFINE(\"GenericTopologyCreation\");\n\nint\nmain(int argc, char* argv[])\n{\n    // ---------- Simulation Variables ------------------------------------------\n\n    // Change the variables and file names only in this block!\n\n    double SimTime = 3.00;\n    double SinkStartTime = 1.0001;\n    double SinkStopTime = 2.90001;\n    double AppStartTime = 2.0001;\n    double AppStopTime = 2.80001;\n\n    std::string AppPacketRate(\"40Kbps\");\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", StringValue(\"1000\"));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(AppPacketRate));\n    std::string LinkRate(\"10Mbps\");\n    std::string LinkDelay(\"2ms\");\n    //  DropTailQueue::MaxPackets affects the # of dropped packets, default value:100\n    //  Config::SetDefault (\"ns3::DropTailQueue::MaxPackets\", UintegerValue (1000));\n\n    srand((unsigned)time(nullptr)); // generate different seed each time\n\n    std::string tr_name(\"n-node-ppp.tr\");\n    std::string pcap_name(\"n-node-ppp\");\n    std::string flow_name(\"n-node-ppp.xml\");\n    std::string anim_name(\"n-node-ppp.anim.xml\");\n\n    std::string adj_mat_file_name(\"examples/matrix-topology/adjacency_matrix.txt\");\n    std::string node_coordinates_file_name(\"examples/matrix-topology/node_coordinates.txt\");\n\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    // ---------- End of Simulation Variables ----------------------------------\n\n    // ---------- Read Adjacency Matrix ----------------------------------------\n\n    std::vector<std::vector<bool>> Adj_Matrix;\n    Adj_Matrix = readNxNMatrix(adj_mat_file_name);\n\n    // Optionally display 2-dimensional adjacency matrix (Adj_Matrix) array\n    // printMatrix (adj_mat_file_name.c_str (),Adj_Matrix);\n\n    // ---------- End of Read Adjacency Matrix ---------------------------------\n\n    // ---------- Read Node Coordinates File -----------------------------------\n\n    std::vector<std::vector<double>> coord_array;\n    coord_array = readCoordinatesFile(node_coordinates_file_name);\n\n    // Optionally display node coordinates file\n    // printCoordinateArray (node_coordinates_file_name.c_str (),coord_array);\n\n    int n_nodes = coord_array.size();\n    int matrixDimension = Adj_Matrix.size();\n\n    if (matrixDimension != n_nodes)\n    {\n        NS_FATAL_ERROR(\"The number of lines in coordinate file is: \"\n                       << n_nodes << \" not equal to the number of nodes in adjacency matrix size \"\n                       << matrixDimension);\n    }\n\n    // ---------- End of Read Node Coordinates File ----------------------------\n\n    // ---------- Network Setup ------------------------------------------------\n\n    NS_LOG_INFO(\"Create Nodes.\");\n\n    NodeContainer nodes; // Declare nodes objects\n    nodes.Create(n_nodes);\n\n    NS_LOG_INFO(\"Create P2P Link Attributes.\");\n\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(LinkRate));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(LinkDelay));\n\n    NS_LOG_INFO(\"Install Internet Stack to Nodes.\");\n\n    InternetStackHelper internet;\n    internet.Install(NodeContainer::GetGlobal());\n\n    NS_LOG_INFO(\"Assign Addresses to Nodes.\");\n\n    Ipv4AddressHelper ipv4_n;\n    ipv4_n.SetBase(\"10.0.0.0\", \"255.255.255.252\");\n\n    NS_LOG_INFO(\"Create Links Between Nodes.\");\n\n    uint32_t linkCount = 0;\n\n    for (size_t i = 0; i < Adj_Matrix.size(); i++)\n    {\n        for (size_t j = 0; j < Adj_Matrix[i].size(); j++)\n        {\n            if (Adj_Matrix[i][j])\n            {\n                NodeContainer n_links = NodeContainer(nodes.Get(i), nodes.Get(j));\n                NetDeviceContainer n_devs = p2p.Install(n_links);\n                ipv4_n.Assign(n_devs);\n                ipv4_n.NewNetwork();\n                linkCount++;\n                NS_LOG_INFO(\"matrix element [\" << i << \"][\" << j << \"] is 1\");\n            }\n            else\n            {\n                NS_LOG_INFO(\"matrix element [\" << i << \"][\" << j << \"] is 0\");\n            }\n        }\n    }\n    NS_LOG_INFO(\"Number of links in the adjacency matrix is: \" << linkCount);\n    NS_LOG_INFO(\"Number of all nodes is: \" << nodes.GetN());\n\n    NS_LOG_INFO(\"Initialize Global Routing.\");\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // ---------- End of Network Set-up ----------------------------------------\n\n    // ---------- Allocate Node Positions --------------------------------------\n\n    NS_LOG_INFO(\"Allocate Positions to Nodes.\");\n\n    MobilityHelper mobility_n;\n    Ptr<ListPositionAllocator> positionAlloc_n = CreateObject<ListPositionAllocator>();\n\n    for (size_t m = 0; m < coord_array.size(); m++)\n    {\n        positionAlloc_n->Add(Vector(coord_array[m][0], coord_array[m][1], 0));\n        Ptr<Node> n0 = nodes.Get(m);\n        Ptr<ConstantPositionMobilityModel> nLoc = n0->GetObject<ConstantPositionMobilityModel>();\n        if (!nLoc)\n        {\n            nLoc = CreateObject<ConstantPositionMobilityModel>();\n            n0->AggregateObject(nLoc);\n        }\n        // y-coordinates are negated for correct display in NetAnim\n        // NetAnim's (0,0) reference coordinates are located on upper left corner\n        // by negating the y coordinates, we declare the reference (0,0) coordinate\n        // to the bottom left corner\n        Vector nVec(coord_array[m][0], -coord_array[m][1], 0);\n        nLoc->SetPosition(nVec);\n    }\n    mobility_n.SetPositionAllocator(positionAlloc_n);\n    mobility_n.Install(nodes);\n\n    // ---------- End of Allocate Node Positions -------------------------------\n\n    // ---------- Create n*(n-1) CBR Flows -------------------------------------\n\n    NS_LOG_INFO(\"Setup Packet Sinks.\");\n\n    uint16_t port = 9;\n\n    for (int i = 0; i < n_nodes; i++)\n    {\n        PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                              InetSocketAddress(Ipv4Address::GetAny(), port));\n        ApplicationContainer apps_sink =\n            sink.Install(nodes.Get(i)); // sink is installed on all nodes\n        apps_sink.Start(Seconds(SinkStartTime));\n        apps_sink.Stop(Seconds(SinkStopTime));\n    }\n\n    NS_LOG_INFO(\"Setup CBR Traffic Sources.\");\n\n    for (int i = 0; i < n_nodes; i++)\n    {\n        for (int j = 0; j < n_nodes; j++)\n        {\n            if (i != j)\n            {\n                // We needed to generate a random number (rn) to be used to eliminate\n                // the artificial congestion caused by sending the packets at the\n                // same time. This rn is added to AppStartTime to have the sources\n                // start at different time, however they will still send at the same rate.\n\n                Ptr<UniformRandomVariable> x = CreateObject<UniformRandomVariable>();\n                x->SetAttribute(\"Min\", DoubleValue(0));\n                x->SetAttribute(\"Max\", DoubleValue(1));\n                double rn = x->GetValue();\n                Ptr<Node> n = nodes.Get(j);\n                Ptr<Ipv4> ipv4 = n->GetObject<Ipv4>();\n                Ipv4InterfaceAddress ipv4_int_addr = ipv4->GetAddress(1, 0);\n                Ipv4Address ip_addr = ipv4_int_addr.GetLocal();\n                OnOffHelper onoff(\n                    \"ns3::UdpSocketFactory\",\n                    InetSocketAddress(ip_addr, port)); // traffic flows from node[i] to node[j]\n                onoff.SetConstantRate(DataRate(AppPacketRate));\n                ApplicationContainer apps =\n                    onoff.Install(nodes.Get(i)); // traffic sources are installed on all nodes\n                apps.Start(Seconds(AppStartTime + rn));\n                apps.Stop(Seconds(AppStopTime));\n            }\n        }\n    }\n\n    // ---------- End of Create n*(n-1) CBR Flows ------------------------------\n\n    // ---------- Simulation Monitoring ----------------------------------------\n\n    NS_LOG_INFO(\"Configure Tracing.\");\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(tr_name));\n    // p2p.EnablePcapAll(pcap_name);\n\n    // Ptr<FlowMonitor> flowmon;\n    // FlowMonitorHelper flowmonHelper;\n    // flowmon = flowmonHelper.InstallAll();\n\n    // Configure animator with default settings\n\n    AnimationInterface anim(anim_name);\n    NS_LOG_INFO(\"Run Simulation.\");\n\n    Simulator::Stop(Seconds(SimTime));\n    Simulator::Run();\n    // flowmon->SerializeToXmlFile(flow_name, true, true);\n    Simulator::Destroy();\n\n    // ---------- End of Simulation Monitoring ---------------------------------\n\n    return 0;\n}\n\n// ---------- Function Definitions -------------------------------------------\n\nstd::vector<std::vector<bool>>\nreadNxNMatrix(std::string adj_mat_file_name)\n{\n    std::ifstream adj_mat_file;\n    adj_mat_file.open(adj_mat_file_name, std::ios::in);\n    if (adj_mat_file.fail())\n    {\n        NS_FATAL_ERROR(\"File \" << adj_mat_file_name << \" not found\");\n    }\n    std::vector<std::vector<bool>> array;\n    int i = 0;\n    int n_nodes = 0;\n\n    while (!adj_mat_file.eof())\n    {\n        std::string line;\n        getline(adj_mat_file, line);\n        if (line.empty())\n        {\n            NS_LOG_WARN(\"WARNING: Ignoring blank row in the array: \" << i);\n            break;\n        }\n\n        std::istringstream iss(line);\n        bool element;\n        std::vector<bool> row;\n        int j = 0;\n\n        while (iss >> element)\n        {\n            row.push_back(element);\n            j++;\n        }\n\n        if (i == 0)\n        {\n            n_nodes = j;\n        }\n\n        if (j != n_nodes)\n        {\n            NS_LOG_ERROR(\"ERROR: Number of elements in line \"\n                         << i << \": \" << j\n                         << \" not equal to number of elements in line 0: \" << n_nodes);\n            NS_FATAL_ERROR(\"ERROR: The number of rows is not equal to the number of columns! in \"\n                           \"the adjacency matrix\");\n        }\n        else\n        {\n            array.push_back(row);\n        }\n        i++;\n    }\n\n    if (i != n_nodes)\n    {\n        NS_LOG_ERROR(\"There are \" << i << \" rows and \" << n_nodes << \" columns.\");\n        NS_FATAL_ERROR(\"ERROR: The number of rows is not equal to the number of columns! in the \"\n                       \"adjacency matrix\");\n    }\n\n    adj_mat_file.close();\n    return array;\n}\n\nstd::vector<std::vector<double>>\nreadCoordinatesFile(std::string node_coordinates_file_name)\n{\n    std::ifstream node_coordinates_file;\n    node_coordinates_file.open(node_coordinates_file_name, std::ios::in);\n    if (node_coordinates_file.fail())\n    {\n        NS_FATAL_ERROR(\"File \" << node_coordinates_file_name << \" not found\");\n    }\n    std::vector<std::vector<double>> coord_array;\n    int m = 0;\n\n    while (!node_coordinates_file.eof())\n    {\n        std::string line;\n        getline(node_coordinates_file, line);\n\n        if (line.empty())\n        {\n            NS_LOG_WARN(\"WARNING: Ignoring blank row: \" << m);\n            break;\n        }\n\n        std::istringstream iss(line);\n        double coordinate;\n        std::vector<double> row;\n        int n = 0;\n        while (iss >> coordinate)\n        {\n            row.push_back(coordinate);\n            n++;\n        }\n\n        if (n != 2)\n        {\n            NS_LOG_ERROR(\"ERROR: Number of elements at line#\"\n                         << m << \" is \" << n\n                         << \" which is not equal to 2 for node coordinates file\");\n            exit(1);\n        }\n\n        else\n        {\n            coord_array.push_back(row);\n        }\n        m++;\n    }\n    node_coordinates_file.close();\n    return coord_array;\n}\n\nvoid\nprintMatrix(const char* description, std::vector<std::vector<bool>> array)\n{\n    std::cout << \"**** Start \" << description << \"********\" << std::endl;\n    for (size_t m = 0; m < array.size(); m++)\n    {\n        for (size_t n = 0; n < array[m].size(); n++)\n        {\n            std::cout << array[m][n] << ' ';\n        }\n        std::cout << std::endl;\n    }\n    std::cout << \"**** End \" << description << \"********\" << std::endl;\n}\n\nvoid\nprintCoordinateArray(const char* description, std::vector<std::vector<double>> coord_array)\n{\n    std::cout << \"**** Start \" << description << \"********\" << std::endl;\n    for (size_t m = 0; m < coord_array.size(); m++)\n    {\n        for (size_t n = 0; n < coord_array[m].size(); n++)\n        {\n            std::cout << coord_array[m][n] << ' ';\n        }\n        std::cout << std::endl;\n    }\n    std::cout << \"**** End \" << description << \"********\" << std::endl;\n}\n\n// ---------- End of Function Definitions ------------------------------------"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a code in NS-3 that simulates a wireless network using WifiHelper and MobilityHelper where two stations (stas) communicate with an access point (ap). Install packet socket capabilities on the nodes, configure the wifi settings with StaWifiMac for stations and ApWifiMac for the access point using the same SSID, and set up mobility for both stations and the access point. Include tracing for MAC and PHY-level events such as TX, RX, PHY RX OK, PHY RX error, and state transitions, and use a helper function to move the access point along the x-axis by 5 meters every second. The stations should communicate with a data rate of 500kbps, and the simulation should run for 44 seconds, starting the communication after 0.5 seconds."}, {"role": "assistant", "content": "#include \"ns3/athstats-helper.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-socket-address.h\"\n#include \"ns3/packet-socket-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\n/// True for verbose output.\nstatic bool g_verbose = true;\n\n/**\n * MAC-level TX trace.\n *\n * \\param context The context.\n * \\param p The packet.\n */\nvoid\nDevTxTrace(std::string context, Ptr<const Packet> p)\n{\n    if (g_verbose)\n    {\n        std::cout << \" TX p: \" << *p << std::endl;\n    }\n}\n\n/**\n * MAC-level RX trace.\n *\n * \\param context The context.\n * \\param p The packet.\n */\nvoid\nDevRxTrace(std::string context, Ptr<const Packet> p)\n{\n    if (g_verbose)\n    {\n        std::cout << \" RX p: \" << *p << std::endl;\n    }\n}\n\n/**\n * PHY-level RX OK trace\n *\n * \\param context The context.\n * \\param packet The packet.\n * \\param snr The SNR.\n * \\param mode The wifi mode.\n * \\param preamble The preamble.\n */\nvoid\nPhyRxOkTrace(std::string context,\n             Ptr<const Packet> packet,\n             double snr,\n             WifiMode mode,\n             WifiPreamble preamble)\n{\n    if (g_verbose)\n    {\n        std::cout << \"PHYRXOK mode=\" << mode << \" snr=\" << snr << \" \" << *packet << std::endl;\n    }\n}\n\n/**\n * PHY-level RX error trace\n *\n * \\param context The context.\n * \\param packet The packet.\n * \\param snr The SNR.\n */\nvoid\nPhyRxErrorTrace(std::string context, Ptr<const Packet> packet, double snr)\n{\n    if (g_verbose)\n    {\n        std::cout << \"PHYRXERROR snr=\" << snr << \" \" << *packet << std::endl;\n    }\n}\n\n/**\n * PHY-level TX trace.\n *\n * \\param context The context.\n * \\param packet The packet.\n * \\param mode The wifi mode.\n * \\param preamble The preamble.\n * \\param txPower The TX power.\n */\nvoid\nPhyTxTrace(std::string context,\n           Ptr<const Packet> packet,\n           WifiMode mode,\n           WifiPreamble preamble,\n           uint8_t txPower)\n{\n    if (g_verbose)\n    {\n        std::cout << \"PHYTX mode=\" << mode << \" \" << *packet << std::endl;\n    }\n}\n\n/**\n * PHY state trace.\n *\n * \\param context The context.\n * \\param start Start time of the state.\n * \\param duration Duration of the state.\n * \\param state The state.\n */\nvoid\nPhyStateTrace(std::string context, Time start, Time duration, WifiPhyState state)\n{\n    if (g_verbose)\n    {\n        std::cout << \" state=\" << state << \" start=\" << start << \" duration=\" << duration\n                  << std::endl;\n    }\n}\n\n/**\n * Move a node position by 5m on the x axis every second, up to 210m.\n *\n * \\param node The node.\n */\nstatic void\nAdvancePosition(Ptr<Node> node)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    Vector pos = mobility->GetPosition();\n    pos.x += 5.0;\n    if (pos.x >= 210.0)\n    {\n        return;\n    }\n    mobility->SetPosition(pos);\n\n    Simulator::Schedule(Seconds(1.0), &AdvancePosition, node);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"Print trace information if true\", g_verbose);\n    cmd.Parse(argc, argv);\n\n    Packet::EnablePrinting();\n\n    WifiHelper wifi;\n    MobilityHelper mobility;\n    NodeContainer stas;\n    NodeContainer ap;\n    NetDeviceContainer staDevs;\n    PacketSocketHelper packetSocket;\n\n    stas.Create(2);\n    ap.Create(1);\n\n    // give packet socket powers to nodes.\n    packetSocket.Install(stas);\n    packetSocket.Install(ap);\n\n    WifiMacHelper wifiMac;\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n    Ssid ssid = Ssid(\"wifi-default\");\n    // setup stas.\n    wifiMac.SetType(\"ns3::StaWifiMac\",\n                    \"ActiveProbing\",\n                    BooleanValue(true),\n                    \"Ssid\",\n                    SsidValue(ssid));\n    staDevs = wifi.Install(wifiPhy, wifiMac, stas);\n    // setup ap.\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    wifi.Install(wifiPhy, wifiMac, ap);\n\n    // mobility.\n    mobility.Install(stas);\n    mobility.Install(ap);\n\n    Simulator::Schedule(Seconds(1.0), &AdvancePosition, ap.Get(0));\n\n    PacketSocketAddress socket;\n    socket.SetSingleDevice(staDevs.Get(0)->GetIfIndex());\n    socket.SetPhysicalAddress(staDevs.Get(1)->GetAddress());\n    socket.SetProtocol(1);\n\n    OnOffHelper onoff(\"ns3::PacketSocketFactory\", Address(socket));\n    onoff.SetConstantRate(DataRate(\"500kb/s\"));\n\n    ApplicationContainer apps = onoff.Install(stas.Get(0));\n    apps.Start(Seconds(0.5));\n    apps.Stop(Seconds(43.0));\n\n    Simulator::Stop(Seconds(44.0));\n\n    Config::Connect(\"/NodeList/*/DeviceList/*/Mac/MacTx\", MakeCallback(&DevTxTrace));\n    Config::Connect(\"/NodeList/*/DeviceList/*/Mac/MacRx\", MakeCallback(&DevRxTrace));\n    Config::Connect(\"/NodeList/*/DeviceList/*/Phy/State/RxOk\", MakeCallback(&PhyRxOkTrace));\n    Config::Connect(\"/NodeList/*/DeviceList/*/Phy/State/RxError\", MakeCallback(&PhyRxErrorTrace));\n    Config::Connect(\"/NodeList/*/DeviceList/*/Phy/State/Tx\", MakeCallback(&PhyTxTrace));\n    Config::Connect(\"/NodeList/*/DeviceList/*/Phy/State/State\", MakeCallback(&PhyStateTrace));\n\n    AthstatsHelper athstats;\n    athstats.EnableAthstats(\"athstats-sta\", stas);\n    athstats.EnableAthstats(\"athstats-ap\", ap);\n\n    Simulator::Run();\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script for a Wi-Fi network with two nodes, using the 802.11n 5GHz standard. The nodes should be 5 meters apart. One node should run a UDP Echo server on port 9, starting at 1 second. The other node should act as a UDP Echo client, sending 10 packets of 1024 bytes each at 1-second intervals, starting at 2 seconds. The simulation should run for 10 seconds. The IP network should be 192.168.1.x, and nodes should have fixed positions."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Set up Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, wifiNodes);\n\n    // Set mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a UDP Echo server on Node 1\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(wifiNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on Node 0\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(wifiNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 network simulator to create a simple LAN (CSMA) connecting two nodes, n0 and n1. Implement a UDP flow from n0 to n1, where packets of 1024 bytes are sent at 50 ms intervals, with a maximum of 320 packets transmitted or limited by simulation duration. Provide options to enable either IPv4 or IPv6 addressing, as well as to toggle logging of the simulation events. Simulate the network for 10 seconds, starting the client after a 2-second delay."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1\n//       |     |\n//       =======\n//         LAN (CSMA)\n//\n// - UDP flow from n0 to n1 of 1024 byte packets at intervals of 50 ms\n//   - maximum of 320 packets sent (or limited by simulation duration)\n//   - option to use IPv4 or IPv6 addressing\n//   - option to disable logging statements\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpClientServerExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Declare variables used in command-line arguments\n    bool useV6 = false;\n    bool logging = true;\n    Address serverAddress;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"useIpv6\", \"Use Ipv6\", useV6);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.Parse(argc, argv);\n\n    if (logging)\n    {\n        LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n    }\n\n    NS_LOG_INFO(\"Create nodes in above topology.\");\n    NodeContainer n;\n    n.Create(2);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    NS_LOG_INFO(\"Create channel between the two nodes.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    if (!useV6)\n    {\n        Ipv4AddressHelper ipv4;\n        ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer i = ipv4.Assign(d);\n        serverAddress = Address(i.GetAddress(1));\n    }\n    else\n    {\n        Ipv6AddressHelper ipv6;\n        ipv6.SetBase(\"2001:0000:f00d:cafe::\", Ipv6Prefix(64));\n        Ipv6InterfaceContainer i6 = ipv6.Assign(d);\n        serverAddress = Address(i6.GetAddress(1, 1));\n    }\n\n    NS_LOG_INFO(\"Create UdpServer application on node 1.\");\n    uint16_t port = 4000;\n    UdpServerHelper server(port);\n    ApplicationContainer apps = server.Install(n.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Create UdpClient application on node 0 to send to node 1.\");\n    uint32_t MaxPacketSize = 1024;\n    Time interPacketInterval = Seconds(0.05);\n    uint32_t maxPacketCount = 320;\n    UdpClientHelper client(serverAddress, port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    client.SetAttribute(\"PacketSize\", UintegerValue(MaxPacketSize));\n    apps = client.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a hybrid topology network using ns-3 with both TCP and UDP protocols. The network consists of two parts: (1) a star topology using TCP where multiple clients communicate with a central server and (2) a mesh topology using UDP where multiple nodes communicate with each other in an ad-hoc manner. Measure the performance of both protocols, including throughput, latency, and packet loss, and visualize the simulation using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"HybridTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n  // Log setup\n  LogComponentEnable(\"TcpL4Protocol\", LOG_LEVEL_INFO);\n  LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n  LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n  \n  // Part 1: Star topology using TCP\n  NodeContainer starNodes;\n  starNodes.Create(6); // Central node + 5 client nodes\n  \n  PointToPointHelper p2p;\n  p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n  p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n  \n  // Install point-to-point devices between central node and client nodes\n  NetDeviceContainer p2pDevices;\n  for (uint32_t i = 1; i < starNodes.GetN(); ++i)\n  {\n    NodeContainer link = NodeContainer(starNodes.Get(0), starNodes.Get(i));\n    NetDeviceContainer devices = p2p.Install(link);\n    p2pDevices.Add(devices);\n  }\n  \n  // Part 2: Mesh topology using UDP\n  NodeContainer meshNodes;\n  meshNodes.Create(4); // 4 mesh nodes\n\n  MeshHelper mesh;\n  mesh.SetStackInstaller(\"ns3::Dot11sStack\");\n  mesh.SetSpreadInterfaceChannels(MeshHelper::SPREAD_CHANNELS);\n  mesh.SetMacType(\"RandomStart\", TimeValue(Seconds(0.1)));\n  mesh.SetNumberOfInterfaces(1);\n\n  NetDeviceContainer meshDevices = mesh.Install(meshNodes);\n\n  // Internet stack\n  InternetStackHelper internet;\n  internet.Install(starNodes);\n  internet.Install(meshNodes);\n\n  // Assign IP addresses\n  Ipv4AddressHelper address;\n  address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n  address.Assign(p2pDevices);\n  \n  address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer meshInterfaces = address.Assign(meshDevices);\n\n  // TCP Application (Star topology)\n  uint16_t tcpPort = 9; // Well-known port for TCP\n  Address tcpServerAddress(InetSocketAddress(Ipv4Address::GetAny(), tcpPort));\n  \n  PacketSinkHelper tcpSinkHelper(\"ns3::TcpSocketFactory\", tcpServerAddress);\n  ApplicationContainer tcpServerApp = tcpSinkHelper.Install(starNodes.Get(0)); // Central node as server\n  tcpServerApp.Start(Seconds(1.0));\n  tcpServerApp.Stop(Seconds(20.0));\n  \n  OnOffHelper tcpClientHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(starNodes.Get(0)->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal(), tcpPort));\n  tcpClientHelper.SetAttribute(\"DataRate\", StringValue(\"2Mbps\"));\n  tcpClientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n  \n  ApplicationContainer tcpClientApps;\n  for (uint32_t i = 1; i < starNodes.GetN(); ++i)\n  {\n    tcpClientHelper.SetAttribute(\"StartTime\", TimeValue(Seconds(2.0 + i)));\n    tcpClientHelper.SetAttribute(\"StopTime\", TimeValue(Seconds(20.0)));\n    tcpClientApps.Add(tcpClientHelper.Install(starNodes.Get(i)));\n  }\n\n  // UDP Application (Mesh topology)\n  uint16_t udpPort = 8080; // UDP echo port\n  UdpEchoServerHelper udpServer(udpPort);\n  ApplicationContainer udpServerApp = udpServer.Install(meshNodes.Get(0)); // First node as server\n  udpServerApp.Start(Seconds(1.0));\n  udpServerApp.Stop(Seconds(20.0));\n\n  UdpEchoClientHelper udpClient(meshInterfaces.GetAddress(0), udpPort);\n  udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n  udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n  udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n  ApplicationContainer udpClientApps;\n  for (uint32_t i = 1; i < meshNodes.GetN(); ++i)\n  {\n    udpClient.SetAttribute(\"StartTime\", TimeValue(Seconds(2.0 + i)));\n    udpClient.SetAttribute(\"StopTime\", TimeValue(Seconds(20.0)));\n    udpClientApps.Add(udpClient.Install(meshNodes.Get(i)));\n  }\n\n  // Flow monitor\n  FlowMonitorHelper flowMonitor;\n  Ptr<FlowMonitor> monitor = flowMonitor.InstallAll();\n\n  // Set up NetAnim for visualization\n  AnimationInterface anim(\"hybrid_topology.xml\");\n  anim.SetConstantPosition(starNodes.Get(0), 50, 50); // Central node position\n  for (uint32_t i = 1; i < starNodes.GetN(); ++i)\n  {\n    anim.SetConstantPosition(starNodes.Get(i), 20 + i * 10, 50);\n  }\n  for (uint32_t i = 0; i < meshNodes.GetN(); ++i)\n  {\n    anim.SetConstantPosition(meshNodes.Get(i), 50, 20 + i * 10);\n  }\n\n  Simulator::Stop(Seconds(20.0));\n  Simulator::Run();\n  \n  monitor->SerializeToXmlFile(\"hybrid_flowmon.xml\", true, true);\n  \n  Simulator::Destroy();\n  return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a simple Wi-Fi network with two stations (STA) and one access point (AP). The AP should have a fixed position, and the STA devices should move randomly within a defined area. The STA 0 should act as a UDP server listening on port 9, while STA 1 should act as a UDP client, sending 1,000 packets of 1024 bytes each, with a packet interval of 0.01 seconds. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ssid.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWifiExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create nodes: 2 stations (STA) and 1 access point (AP)\n    NodeContainer wifiStaNodes, wifiApNode;\n    wifiStaNodes.Create(2);\n    wifiApNode.Create(1);\n\n    // Set up Wi-Fi devices (STA and AP)\n    WifiHelper wifi;\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns3-ssid\");\n\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Install Wi-Fi devices on stations\n    NetDeviceContainer staDevices = wifi.Install(wifiMac, wifi, wifiStaNodes);\n\n    // Install Wi-Fi devices on the access point\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(wifiMac, wifi, wifiApNode);\n\n    // Mobility model: Fixed position for AP, random for STA\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0), \"DeltaX\", DoubleValue(5.0), \"DeltaY\", DoubleValue(10.0), \"GridWidth\", UintegerValue(3), \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\", \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=100]\"), \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=100]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Time\", StringValue(\"1s\"), \"Distance\", StringValue(\"10m\"));\n    mobility.Install(wifiStaNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(wifiStaNodes);\n    internet.Install(wifiApNode);\n\n    // Assign IP addresses to all devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = ipv4.Assign(staDevices);\n    Ipv4InterfaceContainer apInterfaces = ipv4.Assign(apDevice);\n\n    // Set up a UDP server on STA 0\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up a UDP client on STA 1\n    UdpClientHelper udpClient(apInterfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a network in NS-3 where VLANs are configured on a Layer 3 switch, and a router is used to route between them (inter-VLAN routing). Also, configure a DHCP server that dynamically assigns IP addresses to each VLAN. The network should consist of three VLANs, where each VLAN has its own subnet. Generate traffic between hosts in different VLANs and verify that inter-VLAN communication is working. Capture pcap traces of DHCP request/offer packets."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/dhcp-helper.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/bridge-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"InterVLANRoutingWithDHCP\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create 6 nodes: 1 router, 2 nodes for each of the 3 VLANs\n    NodeContainer router;\n    router.Create(1); // Router node\n\n    NodeContainer vlan1Hosts, vlan2Hosts, vlan3Hosts;\n    vlan1Hosts.Create(2);\n    vlan2Hosts.Create(2);\n    vlan3Hosts.Create(2);\n\n    // Create point-to-point links between the router and each VLAN switch\n    NodeContainer vlan1Switch, vlan2Switch, vlan3Switch;\n    vlan1Switch.Create(1);\n    vlan2Switch.Create(1);\n    vlan3Switch.Create(1);\n\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer vlan1RouterDevices, vlan2RouterDevices, vlan3RouterDevices;\n    vlan1RouterDevices = p2p.Install(router.Get(0), vlan1Switch.Get(0));\n    vlan2RouterDevices = p2p.Install(router.Get(0), vlan2Switch.Get(0));\n    vlan3RouterDevices = p2p.Install(router.Get(0), vlan3Switch.Get(0));\n\n    // Add bridges for the VLANs\n    NetDeviceContainer vlan1Devices, vlan2Devices, vlan3Devices;\n    BridgeHelper bridge;\n    vlan1Devices.Add(vlan1RouterDevices.Get(1));\n    vlan2Devices.Add(vlan2RouterDevices.Get(1));\n    vlan3Devices.Add(vlan3RouterDevices.Get(1));\n\n    NetDeviceContainer vlan1HostDevices = bridge.Install(vlan1Switch.Get(0), vlan1Devices);\n    NetDeviceContainer vlan2HostDevices = bridge.Install(vlan2Switch.Get(0), vlan2Devices);\n    NetDeviceContainer vlan3HostDevices = bridge.Install(vlan3Switch.Get(0), vlan3Devices);\n\n    // Install Internet Stack\n    InternetStackHelper internet;\n    internet.Install(router);\n    internet.Install(vlan1Hosts);\n    internet.Install(vlan2Hosts);\n    internet.Install(vlan3Hosts);\n\n    // Assign IP addresses to the router's interfaces\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vlan1Interfaces = ipv4.Assign(vlan1RouterDevices.Get(0));\n\n    ipv4.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vlan2Interfaces = ipv4.Assign(vlan2RouterDevices.Get(0));\n\n    ipv4.SetBase(\"192.168.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vlan3Interfaces = ipv4.Assign(vlan3RouterDevices.Get(0));\n\n    // Create DHCP server and client configuration\n    DhcpHelper dhcp;\n    dhcp.SetRouter(router.Get(0));\n\n    dhcp.InstallDhcpServer(vlan1RouterDevices.Get(1), Ipv4Address(\"192.168.1.1\"));\n    dhcp.InstallDhcpServer(vlan2RouterDevices.Get(1), Ipv4Address(\"192.168.2.1\"));\n    dhcp.InstallDhcpServer(vlan3RouterDevices.Get(1), Ipv4Address(\"192.168.3.1\"));\n\n    dhcp.InstallDhcpClient(vlan1HostDevices);\n    dhcp.InstallDhcpClient(vlan2HostDevices);\n    dhcp.InstallDhcpClient(vlan3HostDevices);\n\n    // Enable pcap tracing to capture DHCP traffic\n    p2p.EnablePcapAll(\"inter-vlan-dhcp\");\n\n    // Create UDP Echo server on one of the VLAN3 hosts\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(vlan3Hosts.Get(1));\n    serverApp.Start(Seconds(2.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create a UDP Echo client on VLAN1 to send requests to the server in VLAN3\n    UdpEchoClientHelper echoClient(vlan3Interfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(vlan1Hosts.Get(0));\n    clientApp.Start(Seconds(3.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Configure routing on the router for inter-VLAN routing\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> routerStaticRouting = ipv4RoutingHelper.GetStaticRouting(router.Get(0)->GetObject<Ipv4>());\n    routerStaticRouting->SetDefaultRoute(\"192.168.1.1\", 1);\n    routerStaticRouting->SetDefaultRoute(\"192.168.2.1\", 2);\n    routerStaticRouting->SetDefaultRoute(\"192.168.3.1\", 3);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate UDP communication between two nodes. One node should act as a UDP server and the other as a UDP client. Both nodes should use IPv4 addresses. The UDP server should be installed on Node 0, and the UDP client on Node 1. The client should send 10 packets of size 1024 bytes at a rate of 1 packet per second. The simulation should run for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpClientServerExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"UdpClientServerExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Install the internet stack (IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(nodes);\n\n    // Create and install the UDP server on Node 0\n    uint16_t port = 9; // Port number for UDP connection\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create and install the UDP client on Node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // Send 10 packets\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // Interval between packets\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // Packet size\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a complete NS-3 simulation example that demonstrates the use of the 802.11n compressed block acknowledgment mechanism. Create a network topology with an access point and two stations, where a QoS station sends UDP packets to the access point, which replies with ICMP frames. Configure the block acknowledgment parameters, including setting a block acknowledgment threshold and a timeout for block acknowledgment inactivity. Implement the necessary NS-3 classes, such as YansWifiChannelHelper, YansWifiPhyHelper, WifiHelper, and others, to create nodes, install devices, and set up mobility models. Also, set up the Internet stack and routing tables, and define applications for packet transmission with specified data rates and timing attributes. Finally, enable packet capture for the access point and run the simulation."}, {"role": "assistant", "content": "/**\n * This is a simple example in order to show how 802.11n compressed block ack mechanism could be\n * used.\n *\n * Network topology:\n *\n *  Wifi 192.168.1.0\n *\n *        AP\n *   *    *\n *   |    |\n *   n1   n2\n *\n * In this example a QoS sta sends UDP datagram packets to access point. On the access point\n * there is no application installed so it replies to every packet with an ICMP frame. However\n * our attention is on originator sta n1. We have set blockAckThreshold (minimum number of packets\n * to use block ack) to 2 so if there are in the BestEffort queue more than 2 packets a block ack\n * will be negotiated. We also set a timeout for block ack inactivity to 3 blocks of 1024\n * microseconds. This timer is reset when:\n *    - the originator receives a block ack frame.\n *    - the recipient receives a block ack request or a MPDU with ack policy Block Ack.\n */\n\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/rectangle.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Test-block-ack\");\n\nint\nmain(int argc, char* argv[])\n{\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    LogComponentEnable(\"QosTxop\", LOG_LEVEL_DEBUG);\n    LogComponentEnable(\"BlockAckManager\", LOG_LEVEL_INFO);\n\n    Ptr<Node> sta = CreateObject<Node>();\n    Ptr<Node> ap = CreateObject<Node>();\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    WifiMacHelper mac;\n    /* disable fragmentation */\n    wifi.SetRemoteStationManager(\"ns3::IdealWifiManager\",\n                                 \"FragmentationThreshold\",\n                                 UintegerValue(2500));\n\n    Ssid ssid(\"My-network\");\n\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"QosSupported\",\n                BooleanValue(true),\n                \"Ssid\",\n                SsidValue(ssid),\n                /* setting blockack threshold for sta's BE queue */\n                \"BE_BlockAckThreshold\",\n                UintegerValue(2),\n                /* setting block inactivity timeout to 3*1024 = 3072 microseconds */\n                \"BE_BlockAckInactivityTimeout\",\n                UintegerValue(3));\n    NetDeviceContainer staDevice = wifi.Install(phy, mac, sta);\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"QosSupported\",\n                BooleanValue(true),\n                \"Ssid\",\n                SsidValue(ssid),\n                \"BE_BlockAckThreshold\",\n                UintegerValue(0));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, ap);\n\n    /* Setting mobility model */\n    MobilityHelper mobility;\n\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\",\n                                  DoubleValue(0.0),\n                                  \"MinY\",\n                                  DoubleValue(0.0),\n                                  \"DeltaX\",\n                                  DoubleValue(5.0),\n                                  \"DeltaY\",\n                                  DoubleValue(10.0),\n                                  \"GridWidth\",\n                                  UintegerValue(3),\n                                  \"LayoutType\",\n                                  StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\",\n                              RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(sta);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(ap);\n\n    /* Internet stack*/\n    InternetStackHelper stack;\n    stack.Install(sta);\n    stack.Install(ap);\n\n    Ipv4AddressHelper address;\n\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staIf;\n    Ipv4InterfaceContainer apIf;\n    staIf = address.Assign(staDevice);\n    apIf = address.Assign(apDevice);\n\n    /* Setting applications */\n\n    uint16_t port = 9;\n    DataRate dataRate(\"1Mb/s\");\n    OnOffHelper onOff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(apIf.GetAddress(0), port)));\n    onOff.SetAttribute(\"DataRate\", DataRateValue(dataRate));\n    onOff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0.01]\"));\n    onOff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=8]\"));\n    onOff.SetAttribute(\"PacketSize\", UintegerValue(50));\n\n    ApplicationContainer staApps = onOff.Install(sta);\n\n    staApps.Start(Seconds(1.0));\n    staApps.Stop(Seconds(10.0));\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    Simulator::Stop(Seconds(10.0));\n\n    phy.EnablePcap(\"test-blockack\", ap->GetId(), 0);\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ script for an NS-3 simulation that integrates traffic control, network devices, and application setup. Start by configuring the network topology with nodes, point-to-point devices, and traffic control queues. Use the InternetStackHelper to install the traffic control layer and override the default queue configuration to explicitly configure FqCoDelQueueDiscs and dynamic queue limits on devices. Assign IPv4 addresses to devices using Ipv4AddressHelper and set up global routing tables. Implement PingHelper for sending ICMP echo requests and BulkSendHelper for TCP communication between clients and servers, configuring MaxBytes for TCP and PacketSinkHelpers for each client. Also, install queue disc tracers on the bottleneck device to monitor packet drops, marks, and queue lengths, scheduling RTT, CWND, and throughput traces. Schedule TCP traces for DCTCP if enabled, and ensure PCAP tracing if requested. Set simulation stop time, run the simulation, and close all streams after validation."}, {"role": "assistant", "content": "// This program is designed to observe long-running TCP congestion control\n// behavior over a configurable bottleneck link.  The program is also\n// instrumented to check program data against validated results, when\n// the validation option is enabled.\n//\n// ---> downstream (primary data transfer from servers to clients)\n// <--- upstream (return acks and ICMP echo response)\n//\n//              ----   bottleneck link    ----\n//  servers ---| WR |--------------------| LR |--- clients\n//              ----                      ----\n//  ns-3 node IDs:\n//  nodes 0-2    3                         4        5-7\n//\n// - The box WR is notionally a WAN router, aggregating all server links\n// - The box LR is notionally a LAN router, aggregating all client links\n// - Three servers are connected to WR, three clients are connected to LR\n//\n// clients and servers are configured for ICMP measurements and TCP throughput\n// and latency measurements in the downstream direction\n//\n// All link rates are enforced by a point-to-point (P2P) ns-3 model with full\n// duplex operation.  Dynamic queue limits\n// (BQL) are enabled to allow for queueing to occur at the priority queue layer;\n// the notional P2P hardware device queue is limited to three packets.\n//\n// One-way link delays and link rates\n// -----------------------------------\n// (1) server to WR links, 1000 Mbps, 1us delay\n// (2) bottleneck link:  configurable rate, configurable delay\n// (3) client to LR links, 1000 Mbps, 1us delay\n//\n// By default, ns-3 FQ-CoDel model is installed on all interfaces, but\n// the bottleneck queue uses CoDel by default and is configurable.\n//\n// The ns-3 FQ-CoDel model uses ns-3 defaults:\n// - 100ms interval\n// - 5ms target\n// - drop batch size of 64 packets\n// - minbytes of 1500\n//\n// Default simulation time is 70 sec.  For single flow experiments, the flow is\n// started at simulation time 5 sec; if a second flow is used, it starts\n// at 15 sec.\n//\n// ping frequency is set at 100ms.\n//\n// A command-line option to enable a step-threshold CE threshold\n// from the CoDel queue model is provided.\n//\n// Measure:\n//  - ping RTT\n//  - TCP RTT estimate\n//  - TCP throughput\n//\n// IPv4 addressing\n// ----------------------------\n// pingServer       10.1.1.2 (ping source)\n// firstServer      10.1.2.2 (data sender)\n// secondServer     10.1.3.2 (data sender)\n// pingClient       192.168.1.2\n// firstClient      192.168.2.2\n// secondClient     192.168.3.2\n//\n// Program Options:\n// ---------------\n//    --firstTcpType:   first TCP type (cubic, dctcp, or reno) [cubic]\n//    --secondTcpType:  second TCP type (cubic, dctcp, or reno) []\n//    --queueType:      bottleneck queue type (fq, codel, pie, or red) [codel]\n//    --baseRtt:        base RTT [+80ms]\n//    --ceThreshold:    CoDel CE threshold (for DCTCP) [+1ms]\n//    --linkRate:       data rate of bottleneck link [50000000bps]\n//    --stopTime:       simulation stop time [+1.16667min]\n//    --queueUseEcn:    use ECN on queue [false]\n//    --enablePcap:     enable Pcap [false]\n//    --validate:       validation case to run []\n//\n// validation cases (and syntax of how to run):\n// ------------\n// Case 'dctcp-10ms':  DCTCP single flow, 10ms base RTT, 50 Mbps link, ECN enabled, CoDel:\n//     ./ns3 run 'tcp-validation --firstTcpType=dctcp --linkRate=50Mbps --baseRtt=10ms\n//     --queueUseEcn=1 --stopTime=15s --validate=1 --validation=dctcp-10ms'\n//    - Throughput between 48 Mbps and 49 Mbps for time greater than 5.6s\n//    - DCTCP alpha below 0.1 for time greater than 5.4s\n//    - DCTCP alpha between 0.06 and 0.085 for time greater than 7s\n//\n// Case 'dctcp-80ms': DCTCP single flow, 80ms base RTT, 50 Mbps link, ECN enabled, CoDel:\n//     ./ns3 run 'tcp-validation --firstTcpType=dctcp --linkRate=50Mbps --baseRtt=80ms\n//     --queueUseEcn=1 --stopTime=40s --validate=1 --validation=dctcp-80ms'\n//    - Throughput less than 20 Mbps for time less than 14s\n//    - Throughput less than 48 Mbps for time less than 30s\n//    - Throughput between 47.5 Mbps and 48.5 for time greater than 32s\n//    - DCTCP alpha above 0.1 for time less than 7.5\n//    - DCTCP alpha below 0.01 for time greater than 11 and less than 30\n//    - DCTCP alpha between 0.015 and 0.025 for time greater than 34\n//\n// Case 'cubic-50ms-no-ecn': CUBIC single flow, 50ms base RTT, 50 Mbps link, ECN disabled, CoDel:\n//     ./ns3 run 'tcp-validation --firstTcpType=cubic --linkRate=50Mbps --baseRtt=50ms\n//     --queueUseEcn=0 --stopTime=20s --validate=1 --validation=cubic-50ms-no-ecn'\n//    - Maximum value of cwnd is 511 segments at 5.4593 seconds\n//    - cwnd decreases to 173 segments at 5.80304 seconds\n//    - cwnd reaches another local maxima around 14.2815 seconds of 236 segments\n//    - cwnd reaches a second maximum around 18.048 seconds of 234 segments\n//\n// Case 'cubic-50ms-ecn': CUBIC single flow, 50ms base RTT, 50 Mbps link, ECN enabled, CoDel:\n//     ./ns3 run 'tcp-validation --firstTcpType=cubic --linkRate=50Mbps --baseRtt=50ms\n//     --queueUseEcn=0 --stopTime=20s --validate=1 --validation=cubic-50ms-no-ecn'\n//    - Maximum value of cwnd is 511 segments at 5.4593 seconds\n//    - cwnd decreases to 173 segments at 5.7939 seconds\n//    - cwnd reaches another local maxima around 14.3477 seconds of 236 segments\n//    - cwnd reaches a second maximum around 18.064 seconds of 234 segments\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpValidation\");\n\n// These variables are declared outside of main() so that they can\n// be used in trace sinks.\nuint32_t g_firstBytesReceived = 0;  //!< First received packet size.\nuint32_t g_secondBytesReceived = 0; //!< Second received packet size.\nuint32_t g_marksObserved = 0;       //!< Number of marked packets observed.\nuint32_t g_dropsObserved = 0;       //!< Number of dropped packets observed.\nstd::string g_validate = \"\";        //!< Empty string disables validation.\nbool g_validationFailed = false;    //!< True if validation failed.\n\n/**\n * Trace first congestion window.\n *\n * \\param ofStream Output filestream.\n * \\param oldCwnd Old value.\n * \\param newCwnd new value.\n */\nvoid\nTraceFirstCwnd(std::ofstream* ofStream, uint32_t oldCwnd, uint32_t newCwnd)\n{\n    // TCP segment size is configured below to be 1448 bytes\n    // so that we can report cwnd in units of segments\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << static_cast<double>(newCwnd) / 1448\n                  << std::endl;\n    }\n    // Validation checks; both the ECN enabled and disabled cases are similar\n    if (g_validate == \"cubic-50ms-no-ecn\" || g_validate == \"cubic-50ms-ecn\")\n    {\n        double now = Simulator::Now().GetSeconds();\n        double cwnd = static_cast<double>(newCwnd) / 1448;\n        if ((now > 5.43) && (now < 5.465) && (cwnd < 500))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" cwnd \" << cwnd << \" (expected >= 500)\");\n            g_validationFailed = true;\n        }\n        else if ((now > 5.795) && (now < 6) && (cwnd > 190))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" cwnd \" << cwnd << \" (expected <= 190)\");\n            g_validationFailed = true;\n        }\n        else if ((now > 14) && (now < 14.197) && (cwnd < 224))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" cwnd \" << cwnd << \" (expected >= 224)\");\n            g_validationFailed = true;\n        }\n        else if ((now > 17) && (now < 18.026) && (cwnd < 212))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" cwnd \" << cwnd << \" (expected >= 212)\");\n            g_validationFailed = true;\n        }\n    }\n}\n\n/**\n * Trace first TcpDctcp.\n *\n * \\param ofStream Output filestream.\n * \\param bytesMarked Bytes marked.\n * \\param bytesAcked Bytes ACKed.\n * \\param alpha Alpha.\n */\nvoid\nTraceFirstDctcp(std::ofstream* ofStream, uint32_t bytesMarked, uint32_t bytesAcked, double alpha)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << alpha << std::endl;\n    }\n    // Validation checks\n    if (g_validate == \"dctcp-80ms\")\n    {\n        double now = Simulator::Now().GetSeconds();\n        if ((now < 7.5) && (alpha < 0.1))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" alpha \" << alpha << \" (expected >= 0.1)\");\n            g_validationFailed = true;\n        }\n        else if ((now > 11) && (now < 30) && (alpha > 0.01))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" alpha \" << alpha << \" (expected <= 0.01)\");\n            g_validationFailed = true;\n        }\n        else if ((now > 34) && (alpha < 0.015) && (alpha > 0.025))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" alpha \" << alpha\n                               << \" (expected 0.015 <= alpha <= 0.025)\");\n            g_validationFailed = true;\n        }\n    }\n    else if (g_validate == \"dctcp-10ms\")\n    {\n        double now = Simulator::Now().GetSeconds();\n        if ((now > 5.6) && (alpha > 0.1))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" alpha \" << alpha << \" (expected <= 0.1)\");\n            g_validationFailed = true;\n        }\n        if ((now > 7) && ((alpha > 0.09) || (alpha < 0.055)))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" alpha \" << alpha\n                               << \" (expected 0.09 <= alpha <= 0.055)\");\n            g_validationFailed = true;\n        }\n    }\n}\n\n/**\n * Trace first RTT.\n *\n * \\param ofStream Output filestream.\n * \\param oldRtt Old value.\n * \\param newRtt New value.\n */\nvoid\nTraceFirstRtt(std::ofstream* ofStream, Time oldRtt, Time newRtt)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << newRtt.GetSeconds() * 1000\n                  << std::endl;\n    }\n}\n\n/**\n * Trace second congestion window.\n *\n * \\param ofStream Output filestream.\n * \\param oldCwnd Old value.\n * \\param newCwnd new value.\n */\nvoid\nTraceSecondCwnd(std::ofstream* ofStream, uint32_t oldCwnd, uint32_t newCwnd)\n{\n    // TCP segment size is configured below to be 1448 bytes\n    // so that we can report cwnd in units of segments\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << static_cast<double>(newCwnd) / 1448\n                  << std::endl;\n    }\n}\n\n/**\n * Trace second RTT.\n *\n * \\param ofStream Output filestream.\n * \\param oldRtt Old value.\n * \\param newRtt New value.\n */\nvoid\nTraceSecondRtt(std::ofstream* ofStream, Time oldRtt, Time newRtt)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << newRtt.GetSeconds() * 1000\n                  << std::endl;\n    }\n}\n\n/**\n * Trace second TcpDctcp.\n *\n * \\param ofStream Output filestream.\n * \\param bytesMarked Bytes marked.\n * \\param bytesAcked Bytes ACKed.\n * \\param alpha Alpha.\n */\nvoid\nTraceSecondDctcp(std::ofstream* ofStream, uint32_t bytesMarked, uint32_t bytesAcked, double alpha)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << alpha << std::endl;\n    }\n}\n\n/**\n * Trace ping RTT.\n *\n * \\param ofStream Output filestream.\n * \\param rtt RTT value.\n */\nvoid\nTracePingRtt(std::ofstream* ofStream, uint16_t, Time rtt)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << rtt.GetSeconds() * 1000 << std::endl;\n    }\n}\n\n/**\n * Trace first Rx.\n *\n * \\param packet The packet.\n * \\param address The sender address.\n */\nvoid\nTraceFirstRx(Ptr<const Packet> packet, const Address& address)\n{\n    g_firstBytesReceived += packet->GetSize();\n}\n\n/**\n * Trace second Rx.\n *\n * \\param packet The packet.\n * \\param address The sender address.\n */\nvoid\nTraceSecondRx(Ptr<const Packet> packet, const Address& address)\n{\n    g_secondBytesReceived += packet->GetSize();\n}\n\n/**\n * Trace queue drop.\n *\n * \\param ofStream Output filestream.\n * \\param item The dropped QueueDiscItem.\n */\nvoid\nTraceQueueDrop(std::ofstream* ofStream, Ptr<const QueueDiscItem> item)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << std::hex << item->Hash() << std::endl;\n    }\n    g_dropsObserved++;\n}\n\n/**\n * Trace queue marks.\n *\n * \\param ofStream Output filestream.\n * \\param item The marked QueueDiscItem.\n * \\param reason The reason.\n */\nvoid\nTraceQueueMark(std::ofstream* ofStream, Ptr<const QueueDiscItem> item, const char* reason)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << std::hex << item->Hash() << std::endl;\n    }\n    g_marksObserved++;\n}\n\n/**\n * Trace queue length.\n *\n * \\param ofStream Output filestream.\n * \\param queueLinkRate Queue link rate.\n * \\param oldVal Old value.\n * \\param newVal New value.\n */\nvoid\nTraceQueueLength(std::ofstream* ofStream, DataRate queueLinkRate, uint32_t oldVal, uint32_t newVal)\n{\n    // output in units of ms\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << std::fixed\n                  << static_cast<double>(newVal * 8) / (queueLinkRate.GetBitRate() / 1000)\n                  << std::endl;\n    }\n}\n\n/**\n * Trace marks frequency.\n *\n * \\param ofStream Output filestream.\n * \\param marksSamplingInterval The mark sampling interval.\n */\nvoid\nTraceMarksFrequency(std::ofstream* ofStream, Time marksSamplingInterval)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << g_marksObserved << std::endl;\n    }\n    g_marksObserved = 0;\n    Simulator::Schedule(marksSamplingInterval,\n                        &TraceMarksFrequency,\n                        ofStream,\n                        marksSamplingInterval);\n}\n\n/**\n * Trace the first throughput.\n *\n * \\param ofStream Output filestream.\n * \\param throughputInterval The throughput interval.\n */\nvoid\nTraceFirstThroughput(std::ofstream* ofStream, Time throughputInterval)\n{\n    double throughput = g_firstBytesReceived * 8 / throughputInterval.GetSeconds() / 1e6;\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << throughput << std::endl;\n    }\n    g_firstBytesReceived = 0;\n    Simulator::Schedule(throughputInterval, &TraceFirstThroughput, ofStream, throughputInterval);\n    if (g_validate == \"dctcp-80ms\")\n    {\n        double now = Simulator::Now().GetSeconds();\n        if ((now < 14) && (throughput > 20))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" throughput \" << throughput\n                               << \" (expected <= 20)\");\n            g_validationFailed = true;\n        }\n        if ((now < 30) && (throughput > 48))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" throughput \" << throughput\n                               << \" (expected <= 48)\");\n            g_validationFailed = true;\n        }\n        if ((now > 32) && ((throughput < 47.5) || (throughput > 48.5)))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" throughput \" << throughput\n                               << \" (expected 47.5 <= throughput <= 48.5)\");\n            g_validationFailed = true;\n        }\n    }\n    else if (g_validate == \"dctcp-10ms\")\n    {\n        double now = Simulator::Now().GetSeconds();\n        if ((now > 5.6) && ((throughput < 48) || (throughput > 49)))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" throughput \" << throughput\n                               << \" (expected 48 <= throughput <= 49)\");\n            g_validationFailed = true;\n        }\n    }\n}\n\n/**\n * Trace the second throughput.\n *\n * \\param ofStream Output filestream.\n * \\param throughputInterval The throughput interval.\n */\nvoid\nTraceSecondThroughput(std::ofstream* ofStream, Time throughputInterval)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \"\n                  << g_secondBytesReceived * 8 / throughputInterval.GetSeconds() / 1e6 << std::endl;\n    }\n    g_secondBytesReceived = 0;\n    Simulator::Schedule(throughputInterval, &TraceSecondThroughput, ofStream, throughputInterval);\n}\n\n/**\n * Schedule trace connection.\n *\n * \\param ofStream Output filestream.\n */\nvoid\nScheduleFirstTcpCwndTraceConnection(std::ofstream* ofStream)\n{\n    Config::ConnectWithoutContextFailSafe(\n        \"/NodeList/1/$ns3::TcpL4Protocol/SocketList/0/CongestionWindow\",\n        MakeBoundCallback(&TraceFirstCwnd, ofStream));\n}\n\n/**\n * Schedule trace connection.\n *\n * \\param ofStream Output filestream.\n */\nvoid\nScheduleFirstTcpRttTraceConnection(std::ofstream* ofStream)\n{\n    Config::ConnectWithoutContextFailSafe(\"/NodeList/1/$ns3::TcpL4Protocol/SocketList/0/RTT\",\n                                          MakeBoundCallback(&TraceFirstRtt, ofStream));\n}\n\n/**\n * Schedule trace connection.\n *\n * \\param ofStream Output filestream.\n */\nvoid\nScheduleFirstDctcpTraceConnection(std::ofstream* ofStream)\n{\n    Config::ConnectWithoutContextFailSafe(\"/NodeList/1/$ns3::TcpL4Protocol/SocketList/0/\"\n                                          \"CongestionOps/$ns3::TcpDctcp/CongestionEstimate\",\n                                          MakeBoundCallback(&TraceFirstDctcp, ofStream));\n}\n\n/**\n * Schedule trace connection.\n *\n * \\param ofStream Output filestream.\n */\nvoid\nScheduleSecondDctcpTraceConnection(std::ofstream* ofStream)\n{\n    Config::ConnectWithoutContextFailSafe(\"/NodeList/2/$ns3::TcpL4Protocol/SocketList/0/\"\n                                          \"CongestionOps/$ns3::TcpDctcp/CongestionEstimate\",\n                                          MakeBoundCallback(&TraceSecondDctcp, ofStream));\n}\n\n/**\n * Schedule trace connection.\n */\nvoid\nScheduleFirstPacketSinkConnection()\n{\n    Config::ConnectWithoutContextFailSafe(\"/NodeList/6/ApplicationList/*/$ns3::PacketSink/Rx\",\n                                          MakeCallback(&TraceFirstRx));\n}\n\n/**\n * Schedule trace connection.\n *\n * \\param ofStream Output filestream.\n */\nvoid\nScheduleSecondTcpCwndTraceConnection(std::ofstream* ofStream)\n{\n    Config::ConnectWithoutContext(\"/NodeList/2/$ns3::TcpL4Protocol/SocketList/0/CongestionWindow\",\n                                  MakeBoundCallback(&TraceSecondCwnd, ofStream));\n}\n\n/**\n * Schedule trace connection.\n *\n * \\param ofStream Output filestream.\n */\nvoid\nScheduleSecondTcpRttTraceConnection(std::ofstream* ofStream)\n{\n    Config::ConnectWithoutContext(\"/NodeList/2/$ns3::TcpL4Protocol/SocketList/0/RTT\",\n                                  MakeBoundCallback(&TraceSecondRtt, ofStream));\n}\n\n/**\n * Schedule trace connection.\n */\nvoid\nScheduleSecondPacketSinkConnection()\n{\n    Config::ConnectWithoutContext(\"/NodeList/7/ApplicationList/*/$ns3::PacketSink/Rx\",\n                                  MakeCallback(&TraceSecondRx));\n}\n\nint\nmain(int argc, char* argv[])\n{\n    ////////////////////////////////////////////////////////////\n    // variables not configured at command line               //\n    ////////////////////////////////////////////////////////////\n    uint32_t pingSize = 100; // bytes\n    bool enableSecondTcp = false;\n    bool enableLogging = false;\n    Time pingInterval = MilliSeconds(100);\n    Time marksSamplingInterval = MilliSeconds(100);\n    Time throughputSamplingInterval = MilliSeconds(200);\n    std::string pingTraceFile = \"tcp-validation-ping.dat\";\n    std::string firstTcpRttTraceFile = \"tcp-validation-first-tcp-rtt.dat\";\n    std::string firstTcpCwndTraceFile = \"tcp-validation-first-tcp-cwnd.dat\";\n    std::string firstDctcpTraceFile = \"tcp-validation-first-dctcp-alpha.dat\";\n    std::string firstTcpThroughputTraceFile = \"tcp-validation-first-tcp-throughput.dat\";\n    std::string secondTcpRttTraceFile = \"tcp-validation-second-tcp-rtt.dat\";\n    std::string secondTcpCwndTraceFile = \"tcp-validation-second-tcp-cwnd.dat\";\n    std::string secondTcpThroughputTraceFile = \"tcp-validation-second-tcp-throughput.dat\";\n    std::string secondDctcpTraceFile = \"tcp-validation-second-dctcp-alpha.dat\";\n    std::string queueMarkTraceFile = \"tcp-validation-queue-mark.dat\";\n    std::string queueDropTraceFile = \"tcp-validation-queue-drop.dat\";\n    std::string queueMarksFrequencyTraceFile = \"tcp-validation-queue-marks-frequency.dat\";\n    std::string queueLengthTraceFile = \"tcp-validation-queue-length.dat\";\n\n    ////////////////////////////////////////////////////////////\n    // variables configured at command line                   //\n    ////////////////////////////////////////////////////////////\n    std::string firstTcpType = \"cubic\";\n    std::string secondTcpType = \"\";\n    std::string queueType = \"codel\";\n    Time stopTime = Seconds(70);\n    Time baseRtt = MilliSeconds(80);\n    DataRate linkRate(\"50Mbps\");\n    bool queueUseEcn = false;\n    Time ceThreshold = MilliSeconds(1);\n    bool enablePcap = false;\n\n    ////////////////////////////////////////////////////////////\n    // Override ns-3 defaults                                 //\n    ////////////////////////////////////////////////////////////\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(1448));\n    // Increase default buffer sizes to improve throughput over long delay paths\n    // Config::SetDefault (\"ns3::TcpSocket::SndBufSize\",UintegerValue (8192000));\n    // Config::SetDefault (\"ns3::TcpSocket::RcvBufSize\",UintegerValue (8192000));\n    Config::SetDefault(\"ns3::TcpSocket::SndBufSize\", UintegerValue(32768000));\n    Config::SetDefault(\"ns3::TcpSocket::RcvBufSize\", UintegerValue(32768000));\n    Config::SetDefault(\"ns3::TcpSocket::InitialCwnd\", UintegerValue(10));\n    Config::SetDefault(\"ns3::TcpL4Protocol::RecoveryType\",\n                       TypeIdValue(TcpPrrRecovery::GetTypeId()));\n    // Validation criteria were written for TCP Cubic without Reno-friendly behavior, so disable it\n    // for these tests\n    Config::SetDefault(\"ns3::TcpCubic::TcpFriendliness\", BooleanValue(false));\n\n    ////////////////////////////////////////////////////////////\n    // command-line argument parsing                          //\n    ////////////////////////////////////////////////////////////\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"firstTcpType\", \"first TCP type (cubic, dctcp, or reno)\", firstTcpType);\n    cmd.AddValue(\"secondTcpType\", \"second TCP type (cubic, dctcp, or reno)\", secondTcpType);\n    cmd.AddValue(\"queueType\", \"bottleneck queue type (fq, codel, pie, or red)\", queueType);\n    cmd.AddValue(\"baseRtt\", \"base RTT\", baseRtt);\n    cmd.AddValue(\"ceThreshold\", \"CoDel CE threshold (for DCTCP)\", ceThreshold);\n    cmd.AddValue(\"linkRate\", \"data rate of bottleneck link\", linkRate);\n    cmd.AddValue(\"stopTime\", \"simulation stop time\", stopTime);\n    cmd.AddValue(\"queueUseEcn\", \"use ECN on queue\", queueUseEcn);\n    cmd.AddValue(\"enablePcap\", \"enable Pcap\", enablePcap);\n    cmd.AddValue(\"validate\", \"validation case to run\", g_validate);\n    cmd.Parse(argc, argv);\n\n    // If validation is selected, perform some configuration checks\n    if (!g_validate.empty())\n    {\n        NS_ABORT_MSG_UNLESS(g_validate == \"dctcp-10ms\" || g_validate == \"dctcp-80ms\" ||\n                                g_validate == \"cubic-50ms-no-ecn\" || g_validate == \"cubic-50ms-ecn\",\n                            \"Unknown test\");\n        if (g_validate == \"dctcp-10ms\" || g_validate == \"dctcp-80ms\")\n        {\n            NS_ABORT_MSG_UNLESS(firstTcpType == \"dctcp\", \"Incorrect TCP\");\n            NS_ABORT_MSG_UNLESS(secondTcpType.empty(), \"Incorrect TCP\");\n            NS_ABORT_MSG_UNLESS(linkRate == DataRate(\"50Mbps\"), \"Incorrect data rate\");\n            NS_ABORT_MSG_UNLESS(queueUseEcn == true, \"Incorrect ECN configuration\");\n            NS_ABORT_MSG_UNLESS(stopTime >= Seconds(15), \"Incorrect stopTime\");\n            if (g_validate == \"dctcp-10ms\")\n            {\n                NS_ABORT_MSG_UNLESS(baseRtt == MilliSeconds(10), \"Incorrect RTT\");\n            }\n            else if (g_validate == \"dctcp-80ms\")\n            {\n                NS_ABORT_MSG_UNLESS(baseRtt == MilliSeconds(80), \"Incorrect RTT\");\n            }\n        }\n        else if (g_validate == \"cubic-50ms-no-ecn\" || g_validate == \"cubic-50ms-ecn\")\n        {\n            NS_ABORT_MSG_UNLESS(firstTcpType == \"cubic\", \"Incorrect TCP\");\n            NS_ABORT_MSG_UNLESS(secondTcpType.empty(), \"Incorrect TCP\");\n            NS_ABORT_MSG_UNLESS(baseRtt == MilliSeconds(50), \"Incorrect RTT\");\n            NS_ABORT_MSG_UNLESS(linkRate == DataRate(\"50Mbps\"), \"Incorrect data rate\");\n            NS_ABORT_MSG_UNLESS(stopTime >= Seconds(20), \"Incorrect stopTime\");\n            if (g_validate == \"cubic-50ms-no-ecn\")\n            {\n                NS_ABORT_MSG_UNLESS(queueUseEcn == false, \"Incorrect ECN configuration\");\n            }\n            else if (g_validate == \"cubic-50ms-ecn\")\n            {\n                NS_ABORT_MSG_UNLESS(queueUseEcn == true, \"Incorrect ECN configuration\");\n            }\n        }\n    }\n\n    if (enableLogging)\n    {\n        LogComponentEnable(\n            \"TcpSocketBase\",\n            (LogLevel)(LOG_PREFIX_FUNC | LOG_PREFIX_NODE | LOG_PREFIX_TIME | LOG_LEVEL_ALL));\n        LogComponentEnable(\n            \"TcpDctcp\",\n            (LogLevel)(LOG_PREFIX_FUNC | LOG_PREFIX_NODE | LOG_PREFIX_TIME | LOG_LEVEL_ALL));\n    }\n\n    Time oneWayDelay = baseRtt / 2;\n\n    TypeId firstTcpTypeId;\n    if (firstTcpType == \"reno\")\n    {\n        firstTcpTypeId = TcpLinuxReno::GetTypeId();\n    }\n    else if (firstTcpType == \"cubic\")\n    {\n        firstTcpTypeId = TcpCubic::GetTypeId();\n    }\n    else if (firstTcpType == \"dctcp\")\n    {\n        firstTcpTypeId = TcpDctcp::GetTypeId();\n        Config::SetDefault(\"ns3::CoDelQueueDisc::CeThreshold\", TimeValue(ceThreshold));\n        Config::SetDefault(\"ns3::FqCoDelQueueDisc::CeThreshold\", TimeValue(ceThreshold));\n        if (!queueUseEcn)\n        {\n            std::cout << \"Warning: using DCTCP with queue ECN disabled\" << std::endl;\n        }\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Fatal error:  tcp unsupported\");\n    }\n    TypeId secondTcpTypeId;\n    if (secondTcpType == \"reno\")\n    {\n        enableSecondTcp = true;\n        secondTcpTypeId = TcpLinuxReno::GetTypeId();\n    }\n    else if (secondTcpType == \"cubic\")\n    {\n        enableSecondTcp = true;\n        secondTcpTypeId = TcpCubic::GetTypeId();\n    }\n    else if (secondTcpType == \"dctcp\")\n    {\n        enableSecondTcp = true;\n        secondTcpTypeId = TcpDctcp::GetTypeId();\n    }\n    else if (secondTcpType.empty())\n    {\n        enableSecondTcp = false;\n        NS_LOG_DEBUG(\"No second TCP selected\");\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Fatal error:  tcp unsupported\");\n    }\n    TypeId queueTypeId;\n    if (queueType == \"fq\")\n    {\n        queueTypeId = FqCoDelQueueDisc::GetTypeId();\n    }\n    else if (queueType == \"codel\")\n    {\n        queueTypeId = CoDelQueueDisc::GetTypeId();\n    }\n    else if (queueType == \"pie\")\n    {\n        queueTypeId = PieQueueDisc::GetTypeId();\n    }\n    else if (queueType == \"red\")\n    {\n        queueTypeId = RedQueueDisc::GetTypeId();\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Fatal error:  queueType unsupported\");\n    }\n\n    if (queueUseEcn)\n    {\n        Config::SetDefault(\"ns3::CoDelQueueDisc::UseEcn\", BooleanValue(true));\n        Config::SetDefault(\"ns3::FqCoDelQueueDisc::UseEcn\", BooleanValue(true));\n        Config::SetDefault(\"ns3::PieQueueDisc::UseEcn\", BooleanValue(true));\n        Config::SetDefault(\"ns3::RedQueueDisc::UseEcn\", BooleanValue(true));\n    }\n    // Enable TCP to use ECN regardless\n    Config::SetDefault(\"ns3::TcpSocketBase::UseEcn\", StringValue(\"On\"));\n\n    // Report on configuration\n    if (enableSecondTcp)\n    {\n        NS_LOG_DEBUG(\"first TCP: \" << firstTcpTypeId.GetName()\n                                   << \"; second TCP: \" << secondTcpTypeId.GetName()\n                                   << \"; queue: \" << queueTypeId.GetName()\n                                   << \"; ceThreshold: \" << ceThreshold.GetSeconds() * 1000 << \"ms\");\n    }\n    else\n    {\n        NS_LOG_DEBUG(\"first TCP: \" << firstTcpTypeId.GetName()\n                                   << \"; queue: \" << queueTypeId.GetName()\n                                   << \"; ceThreshold: \" << ceThreshold.GetSeconds() * 1000 << \"ms\");\n    }\n\n    // Write traces only if we are not in validation mode (g_validate == \"\")\n    std::ofstream pingOfStream;\n    std::ofstream firstTcpRttOfStream;\n    std::ofstream firstTcpCwndOfStream;\n    std::ofstream firstTcpThroughputOfStream;\n    std::ofstream firstTcpDctcpOfStream;\n    std::ofstream secondTcpRttOfStream;\n    std::ofstream secondTcpCwndOfStream;\n    std::ofstream secondTcpThroughputOfStream;\n    std::ofstream secondTcpDctcpOfStream;\n    std::ofstream queueDropOfStream;\n    std::ofstream queueMarkOfStream;\n    std::ofstream queueMarksFrequencyOfStream;\n    std::ofstream queueLengthOfStream;\n    if (g_validate.empty())\n    {\n        pingOfStream.open(pingTraceFile, std::ofstream::out);\n        firstTcpRttOfStream.open(firstTcpRttTraceFile, std::ofstream::out);\n        firstTcpCwndOfStream.open(firstTcpCwndTraceFile, std::ofstream::out);\n        firstTcpThroughputOfStream.open(firstTcpThroughputTraceFile, std::ofstream::out);\n        if (firstTcpType == \"dctcp\")\n        {\n            firstTcpDctcpOfStream.open(firstDctcpTraceFile, std::ofstream::out);\n        }\n        if (enableSecondTcp)\n        {\n            secondTcpRttOfStream.open(secondTcpRttTraceFile, std::ofstream::out);\n            secondTcpCwndOfStream.open(secondTcpCwndTraceFile, std::ofstream::out);\n            secondTcpThroughputOfStream.open(secondTcpThroughputTraceFile, std::ofstream::out);\n            if (secondTcpType == \"dctcp\")\n            {\n                secondTcpDctcpOfStream.open(secondDctcpTraceFile, std::ofstream::out);\n            }\n        }\n        queueDropOfStream.open(queueDropTraceFile, std::ofstream::out);\n        queueMarkOfStream.open(queueMarkTraceFile, std::ofstream::out);\n        queueMarksFrequencyOfStream.open(queueMarksFrequencyTraceFile, std::ofstream::out);\n        queueLengthOfStream.open(queueLengthTraceFile, std::ofstream::out);\n    }\n\n    ////////////////////////////////////////////////////////////\n    // scenario setup                                         //\n    ////////////////////////////////////////////////////////////\n    Ptr<Node> pingServer = CreateObject<Node>();\n    Ptr<Node> firstServer = CreateObject<Node>();\n    Ptr<Node> secondServer = CreateObject<Node>();\n    Ptr<Node> wanRouter = CreateObject<Node>();\n    Ptr<Node> lanRouter = CreateObject<Node>();\n    Ptr<Node> pingClient = CreateObject<Node>();\n    Ptr<Node> firstClient = CreateObject<Node>();\n    Ptr<Node> secondClient = CreateObject<Node>();\n\n    // Device containers\n    NetDeviceContainer pingServerDevices;\n    NetDeviceContainer firstServerDevices;\n    NetDeviceContainer secondServerDevices;\n    NetDeviceContainer wanLanDevices;\n    NetDeviceContainer pingClientDevices;\n    NetDeviceContainer firstClientDevices;\n    NetDeviceContainer secondClientDevices;\n\n    PointToPointHelper p2p;\n    p2p.SetQueue(\"ns3::DropTailQueue\", \"MaxSize\", QueueSizeValue(QueueSize(\"3p\")));\n    p2p.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"1000Mbps\")));\n    // Add delay only on the WAN links\n    p2p.SetChannelAttribute(\"Delay\", TimeValue(MicroSeconds(1)));\n    pingServerDevices = p2p.Install(wanRouter, pingServer);\n    firstServerDevices = p2p.Install(wanRouter, firstServer);\n    secondServerDevices = p2p.Install(wanRouter, secondServer);\n    p2p.SetChannelAttribute(\"Delay\", TimeValue(oneWayDelay));\n    wanLanDevices = p2p.Install(wanRouter, lanRouter);\n    p2p.SetQueue(\"ns3::DropTailQueue\", \"MaxSize\", QueueSizeValue(QueueSize(\"3p\")));\n    p2p.SetChannelAttribute(\"Delay\", TimeValue(MicroSeconds(1)));\n    pingClientDevices = p2p.Install(lanRouter, pingClient);\n    firstClientDevices = p2p.Install(lanRouter, firstClient);\n    secondClientDevices = p2p.Install(lanRouter, secondClient);\n\n    // Limit the bandwidth on the wanRouter->lanRouter interface\n    Ptr<PointToPointNetDevice> p = wanLanDevices.Get(0)->GetObject<PointToPointNetDevice>();\n    p->SetAttribute(\"DataRate\", DataRateValue(linkRate));\n\n    InternetStackHelper stackHelper;\n    stackHelper.Install(pingServer);\n    Ptr<TcpL4Protocol> proto;\n    stackHelper.Install(firstServer);\n    proto = firstServer->GetObject<TcpL4Protocol>();\n    proto->SetAttribute(\"SocketType\", TypeIdValue(firstTcpTypeId));\n    stackHelper.Install(secondServer);\n    stackHelper.Install(wanRouter);\n    stackHelper.Install(lanRouter);\n    stackHelper.Install(pingClient);\n\n    stackHelper.Install(firstClient);\n    // Set the per-node TCP type here\n    proto = firstClient->GetObject<TcpL4Protocol>();\n    proto->SetAttribute(\"SocketType\", TypeIdValue(firstTcpTypeId));\n    stackHelper.Install(secondClient);\n\n    if (enableSecondTcp)\n    {\n        proto = secondClient->GetObject<TcpL4Protocol>();\n        proto->SetAttribute(\"SocketType\", TypeIdValue(secondTcpTypeId));\n        proto = secondServer->GetObject<TcpL4Protocol>();\n        proto->SetAttribute(\"SocketType\", TypeIdValue(secondTcpTypeId));\n    }\n\n    // InternetStackHelper will install a base TrafficControlLayer on the node,\n    // but the Ipv4AddressHelper below will install the default FqCoDelQueueDisc\n    // on all single device nodes.  The below code overrides the configuration\n    // that is normally done by the Ipv4AddressHelper::Install() method by\n    // instead explicitly configuring the queue discs we want on each device.\n    TrafficControlHelper tchFq;\n    tchFq.SetRootQueueDisc(\"ns3::FqCoDelQueueDisc\");\n    tchFq.SetQueueLimits(\"ns3::DynamicQueueLimits\", \"HoldTime\", StringValue(\"1ms\"));\n    tchFq.Install(pingServerDevices);\n    tchFq.Install(firstServerDevices);\n    tchFq.Install(secondServerDevices);\n    tchFq.Install(wanLanDevices.Get(1));\n    tchFq.Install(pingClientDevices);\n    tchFq.Install(firstClientDevices);\n    tchFq.Install(secondClientDevices);\n    // Install queue for bottleneck link\n    TrafficControlHelper tchBottleneck;\n    tchBottleneck.SetRootQueueDisc(queueTypeId.GetName());\n    tchBottleneck.SetQueueLimits(\"ns3::DynamicQueueLimits\", \"HoldTime\", StringValue(\"1ms\"));\n    tchBottleneck.Install(wanLanDevices.Get(0));\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer pingServerIfaces = ipv4.Assign(pingServerDevices);\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer firstServerIfaces = ipv4.Assign(firstServerDevices);\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer secondServerIfaces = ipv4.Assign(secondServerDevices);\n    ipv4.SetBase(\"172.16.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer wanLanIfaces = ipv4.Assign(wanLanDevices);\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer pingClientIfaces = ipv4.Assign(pingClientDevices);\n    ipv4.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer firstClientIfaces = ipv4.Assign(firstClientDevices);\n    ipv4.SetBase(\"192.168.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer secondClientIfaces = ipv4.Assign(secondClientDevices);\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    ////////////////////////////////////////////////////////////\n    // application setup                                      //\n    ////////////////////////////////////////////////////////////\n    PingHelper pingHelper(Ipv4Address(\"192.168.1.2\"));\n    pingHelper.SetAttribute(\"Interval\", TimeValue(pingInterval));\n    pingHelper.SetAttribute(\"Size\", UintegerValue(pingSize));\n    pingHelper.SetAttribute(\"VerboseMode\", EnumValue(Ping::VerboseMode::SILENT));\n    ApplicationContainer pingContainer = pingHelper.Install(pingServer);\n    Ptr<Ping> ping = pingContainer.Get(0)->GetObject<Ping>();\n    ping->TraceConnectWithoutContext(\"Rtt\", MakeBoundCallback(&TracePingRtt, &pingOfStream));\n    pingContainer.Start(Seconds(1));\n    pingContainer.Stop(stopTime - Seconds(1));\n\n    ApplicationContainer firstApp;\n    uint16_t firstPort = 5000;\n    BulkSendHelper tcp(\"ns3::TcpSocketFactory\", Address());\n    // set to large value:  e.g. 1000 Mb/s for 60 seconds = 7500000000 bytes\n    tcp.SetAttribute(\"MaxBytes\", UintegerValue(7500000000));\n    // Configure first TCP client/server pair\n    InetSocketAddress firstDestAddress(firstClientIfaces.GetAddress(1), firstPort);\n    tcp.SetAttribute(\"Remote\", AddressValue(firstDestAddress));\n    firstApp = tcp.Install(firstServer);\n    firstApp.Start(Seconds(5));\n    firstApp.Stop(stopTime - Seconds(1));\n\n    Address firstSinkAddress(InetSocketAddress(Ipv4Address::GetAny(), firstPort));\n    ApplicationContainer firstSinkApp;\n    PacketSinkHelper firstSinkHelper(\"ns3::TcpSocketFactory\", firstSinkAddress);\n    firstSinkApp = firstSinkHelper.Install(firstClient);\n    firstSinkApp.Start(Seconds(5));\n    firstSinkApp.Stop(stopTime - MilliSeconds(500));\n\n    // Configure second TCP client/server pair\n    if (enableSecondTcp)\n    {\n        BulkSendHelper tcp(\"ns3::TcpSocketFactory\", Address());\n        uint16_t secondPort = 5000;\n        ApplicationContainer secondApp;\n        InetSocketAddress secondDestAddress(secondClientIfaces.GetAddress(1), secondPort);\n        tcp.SetAttribute(\"Remote\", AddressValue(secondDestAddress));\n        secondApp = tcp.Install(secondServer);\n        secondApp.Start(Seconds(15));\n        secondApp.Stop(stopTime - Seconds(1));\n\n        Address secondSinkAddress(InetSocketAddress(Ipv4Address::GetAny(), secondPort));\n        PacketSinkHelper secondSinkHelper(\"ns3::TcpSocketFactory\", secondSinkAddress);\n        ApplicationContainer secondSinkApp;\n        secondSinkApp = secondSinkHelper.Install(secondClient);\n        secondSinkApp.Start(Seconds(15));\n        secondSinkApp.Stop(stopTime - MilliSeconds(500));\n    }\n\n    // Setup traces that can be hooked now\n    Ptr<TrafficControlLayer> tc;\n    Ptr<QueueDisc> qd;\n    // Trace drops and marks for bottleneck\n    tc = wanLanDevices.Get(0)->GetNode()->GetObject<TrafficControlLayer>();\n    qd = tc->GetRootQueueDiscOnDevice(wanLanDevices.Get(0));\n    qd->TraceConnectWithoutContext(\"Drop\", MakeBoundCallback(&TraceQueueDrop, &queueDropOfStream));\n    qd->TraceConnectWithoutContext(\"Mark\", MakeBoundCallback(&TraceQueueMark, &queueMarkOfStream));\n    qd->TraceConnectWithoutContext(\n        \"BytesInQueue\",\n        MakeBoundCallback(&TraceQueueLength, &queueLengthOfStream, linkRate));\n\n    // Setup scheduled traces; TCP traces must be hooked after socket creation\n    Simulator::Schedule(Seconds(5) + MilliSeconds(100),\n                        &ScheduleFirstTcpRttTraceConnection,\n                        &firstTcpRttOfStream);\n    Simulator::Schedule(Seconds(5) + MilliSeconds(100),\n                        &ScheduleFirstTcpCwndTraceConnection,\n                        &firstTcpCwndOfStream);\n    Simulator::Schedule(Seconds(5) + MilliSeconds(100), &ScheduleFirstPacketSinkConnection);\n    if (firstTcpType == \"dctcp\")\n    {\n        Simulator::Schedule(Seconds(5) + MilliSeconds(100),\n                            &ScheduleFirstDctcpTraceConnection,\n                            &firstTcpDctcpOfStream);\n    }\n    Simulator::Schedule(throughputSamplingInterval,\n                        &TraceFirstThroughput,\n                        &firstTcpThroughputOfStream,\n                        throughputSamplingInterval);\n    if (enableSecondTcp)\n    {\n        // Setup scheduled traces; TCP traces must be hooked after socket creation\n        Simulator::Schedule(Seconds(15) + MilliSeconds(100),\n                            &ScheduleSecondTcpRttTraceConnection,\n                            &secondTcpRttOfStream);\n        Simulator::Schedule(Seconds(15) + MilliSeconds(100),\n                            &ScheduleSecondTcpCwndTraceConnection,\n                            &secondTcpCwndOfStream);\n        Simulator::Schedule(Seconds(15) + MilliSeconds(100), &ScheduleSecondPacketSinkConnection);\n        Simulator::Schedule(throughputSamplingInterval,\n                            &TraceSecondThroughput,\n                            &secondTcpThroughputOfStream,\n                            throughputSamplingInterval);\n        if (secondTcpType == \"dctcp\")\n        {\n            Simulator::Schedule(Seconds(15) + MilliSeconds(100),\n                                &ScheduleSecondDctcpTraceConnection,\n                                &secondTcpDctcpOfStream);\n        }\n    }\n    Simulator::Schedule(marksSamplingInterval,\n                        &TraceMarksFrequency,\n                        &queueMarksFrequencyOfStream,\n                        marksSamplingInterval);\n\n    if (enablePcap)\n    {\n        p2p.EnablePcapAll(\"tcp-validation\", false);\n    }\n\n    Simulator::Stop(stopTime);\n    Simulator::Run();\n    Simulator::Destroy();\n\n    if (g_validate.empty())\n    {\n        pingOfStream.close();\n        firstTcpCwndOfStream.close();\n        firstTcpRttOfStream.close();\n        if (firstTcpType == \"dctcp\")\n        {\n            firstTcpDctcpOfStream.close();\n        }\n        firstTcpThroughputOfStream.close();\n        if (enableSecondTcp)\n        {\n            secondTcpCwndOfStream.close();\n            secondTcpRttOfStream.close();\n            secondTcpThroughputOfStream.close();\n            if (secondTcpType == \"dctcp\")\n            {\n                secondTcpDctcpOfStream.close();\n            }\n        }\n        queueDropOfStream.close();\n        queueMarkOfStream.close();\n        queueMarksFrequencyOfStream.close();\n        queueLengthOfStream.close();\n    }\n\n    if (g_validationFailed)\n    {\n        NS_FATAL_ERROR(\"Validation failed\");\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Mobile Ad-Hoc Network (MANET) with 5 nodes using the AODV routing protocol. The nodes should move randomly within a 100x100 area using the Random Walk mobility model. Assign IP addresses in the 10.1.1.0/24 subnet. Create a UDP echo server on node 4 and a UDP echo client on node 0 to send five 512-byte packets at 1-second intervals. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create 5 nodes\n    NodeContainer nodes;\n    nodes.Create(5);\n\n    // Set up the mobility model for nodes (random walk)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(nodes);\n\n    // Install the AODV routing protocol on the nodes\n    AodvHelper aodv;\n    Ipv4ListRoutingHelper list;\n    list.Add(aodv, 10);\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(list);\n    internet.Install(nodes);\n\n    // Install the Internet stack on the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(nodes);\n\n    // Create a UDP application on node 0 (sender)\n    UdpEchoClientHelper client(interfaces.GetAddress(4), 9); // Node 4 as receiver\n    client.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    client.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp = client.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Create a UDP echo server on node 4 (receiver)\n    UdpEchoServerHelper server(9);\n    ApplicationContainer serverApp = server.Install(nodes.Get(4));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless ad-hoc network using ns-3 with 5 nodes using WiFi. Nodes communicate via peer-to-peer ad-hoc mode, with random mobility applied to the nodes. One of the nodes will generate UDP traffic to be sent to another node, and the simulation will track packet loss and throughput. The output will be saved in a file for further analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocWifiSimulation\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Enable logging for UDP\n    LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n\n    // Create 5 nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(5);\n\n    // Set up Wifi PHY and MAC for ad-hoc mode\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer wifiDevices = wifi.Install(wifiPhy, wifiMac, wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer wifiInterfaces = address.Assign(wifiDevices);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(wifiNodes);\n\n    // Install UDP server on node 1\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Install UDP client on node 0\n    UdpClientHelper udpClient(wifiInterfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up FlowMonitor to track traffic\n    FlowMonitorHelper flowmonHelper;\n    Ptr<FlowMonitor> monitor = flowmonHelper.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Print FlowMonitor statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow ID: \" << i->first << \" Src Addr \" << t.sourceAddress << \" Dst Addr \" << t.destinationAddress);\n        NS_LOG_UNCOND(\"Tx Packets = \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"Rx Packets = \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"Throughput: \" << i->second.rxBytes * 8.0 / (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) / 1024 / 1024 << \" Mbps\");\n    }\n\n    // Clean up and exit\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple star topology network using ns-3, where a central server communicates with multiple client nodes. The communication protocol used is TCP, and each client sends a series of data packets to the server. Measure the throughput, latency, and packet loss, and visualize the simulation using NetAnim. The network consists of one central server and 5 clients connected through point-to-point links."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"StarTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n  LogComponentEnable(\"TcpL4Protocol\", LOG_LEVEL_INFO);\n  LogComponentEnable(\"PacketSink\", LOG_LEVEL_INFO);\n\n  // Create the central node (server) and 5 client nodes\n  NodeContainer centralNode;\n  centralNode.Create(1);\n\n  NodeContainer clientNodes;\n  clientNodes.Create(5);\n\n  // Set up point-to-point links between the central node and each client\n  PointToPointHelper p2p;\n  p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n  p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n  NetDeviceContainer serverDevices, clientDevices;\n  for (uint32_t i = 0; i < clientNodes.GetN(); ++i)\n  {\n    NodeContainer link = NodeContainer(centralNode.Get(0), clientNodes.Get(i));\n    NetDeviceContainer devices = p2p.Install(link);\n    serverDevices.Add(devices.Get(0));\n    clientDevices.Add(devices.Get(1));\n  }\n\n  // Install Internet stack\n  InternetStackHelper stack;\n  stack.Install(centralNode);\n  stack.Install(clientNodes);\n\n  // Assign IP addresses\n  Ipv4AddressHelper address;\n  address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer serverInterfaces;\n  serverInterfaces = address.Assign(serverDevices);\n\n  Ipv4InterfaceContainer clientInterfaces;\n  clientInterfaces = address.Assign(clientDevices);\n\n  // Create a TCP server on the central node\n  uint16_t port = 9; // Well-known port for TCP\n  Address serverAddress(InetSocketAddress(serverInterfaces.GetAddress(0), port));\n  PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n  ApplicationContainer serverApp = sinkHelper.Install(centralNode.Get(0));\n  serverApp.Start(Seconds(1.0));\n  serverApp.Stop(Seconds(10.0));\n\n  // Create TCP client applications on each client node\n  OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", serverAddress);\n  clientHelper.SetAttribute(\"DataRate\", StringValue(\"2Mbps\"));\n  clientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n  ApplicationContainer clientApps;\n  for (uint32_t i = 0; i < clientNodes.GetN(); ++i)\n  {\n    clientHelper.SetAttribute(\"StartTime\", TimeValue(Seconds(2.0 + i)));\n    clientHelper.SetAttribute(\"StopTime\", TimeValue(Seconds(10.0)));\n    clientApps.Add(clientHelper.Install(clientNodes.Get(i)));\n  }\n\n  // Enable Flow Monitor for performance analysis\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n  // Set up NetAnim for visualization\n  AnimationInterface anim(\"star_topology.xml\");\n  anim.SetConstantPosition(centralNode.Get(0), 50, 50);\n  for (uint32_t i = 0; i < clientNodes.GetN(); ++i)\n  {\n    anim.SetConstantPosition(clientNodes.Get(i), 20 + i * 20, 20);\n  }\n\n  // Run the simulation\n  Simulator::Stop(Seconds(10.0));\n  Simulator::Run();\n\n  // Flow Monitor analysis\n  monitor->SerializeToXmlFile(\"star_flowmon.xml\", true, true);\n\n  Simulator::Destroy();\n  return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to model an ad hoc wireless network with two nodes. Configure the nodes to use the IEEE 802.11 protocol in ad hoc mode and set up a mobility model where nodes move randomly within defined boundaries. Install the Internet stack on the nodes and assign IPv4 addresses from the subnet 192.9.39.0/24. Implement UDP echo server and client applications on both nodes to facilitate bidirectional communication, allowing each node to send echo requests to the other. Incorporate flow monitoring to capture network statistics, including packet delivery ratios, end-to-end delays, and throughput. Generate an animation file to visualize the network activity during the simulation. Finally, output the collected flow statistics and performance metrics after running the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/propagation-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"AdhocNetworkExample\");\n\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable (\"AdhocNetworkExample\", LOG_LEVEL_INFO);\n\n  // Create two wireless nodes\n  NodeContainer nodes;\n  nodes.Create (2);\n\n  // Configure wireless parameters\n  WifiHelper wifi;\n\n  WifiMacHelper mac;\n  mac.SetType (\"ns3::AdhocWifiMac\");\n  \n\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default(); //define channel default configuration\n  YansWifiPhyHelper phy; //configure wifiPHY\n  phy.SetChannel(channel.Create());\n\n  NetDeviceContainer devices = wifi.Install (phy, mac, nodes); //create wifiNetDevice\n  \n\n  // Set up mobility model\n  MobilityHelper mobility; //to set position of nodes\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0), //starting node x axis\n                                 \"MinY\", DoubleValue (0.0), //starting node y axis\n                                 \"DeltaX\", DoubleValue (5.0), //gap before next node in row\n                                 \"DeltaY\", DoubleValue (5.0), //gap before next node in column\n                                 \"GridWidth\", UintegerValue (2), // max number of nodes based on the layout type\n                                 \"LayoutType\", StringValue (\"RowFirst\")); //nodes will first fill up the rows then columns\n                                 \n                                \n  mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue(Rectangle(-25, 25, -25, 25))); //nodes over randomly in 2D\n                                                                                          //nodes movement bound in rectangle   (Xmin,Xmax,Ymin,Ymax)        \n  mobility.Install (nodes); //install the nodes\n  \n  // Set up network stack\n  InternetStackHelper stack;\n  stack.Install (nodes);\n\n  // Assign IPv4 addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"192.9.39.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  UdpEchoServerHelper server10(9);\n  ApplicationContainer serverApps10 = server10.Install (nodes.Get (1));\n  serverApps10.Start (Seconds (1.0));\n  serverApps10.Stop (Seconds (100.0));\n\n  // Create a UDP echo client application on node 0\n  UdpEchoClientHelper client10 (interfaces.GetAddress (1), 9);\n  client10.SetAttribute (\"MaxPackets\", UintegerValue (10));\n  client10.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client10.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps10 = client10.Install (nodes.Get (0));\n  clientApps10.Start (Seconds (2.0));\n  clientApps10.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server01(10);\n  ApplicationContainer serverApps01 = server01.Install (nodes.Get (0));\n  serverApps10.Start (Seconds (1.0));\n  serverApps10.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client01 (interfaces.GetAddress (0), 10);\n  client01.SetAttribute (\"MaxPackets\", UintegerValue (10));\n  client01.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client01.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps01 = client01.Install (nodes.Get (1));\n  clientApps01.Start (Seconds (2.0));\n  clientApps01.Stop (Seconds (100.0));\n  \n  // Define a flow monitor object\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();\n  Simulator::Stop(Seconds(100.0));\n  \n  \n  // Animation\n  AnimationInterface anim(\"239_task1.xml\");\n  \n\n  // Run simulation\n  Simulator::Run ();\n  \n \n  \n Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());\n std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats ();\nfor (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n{\n // Calculate packet delivery ratio and end to end delay and throughput\n  uint32_t packetsDelivered = 0;\n  uint32_t totalPackets = 0;\n  double totalDelay = 0;\n Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);\nstd::cout << \"FlowId: \" << i->first << \"\\n\";\nstd::cout << \"Sender: \"<< t.sourceAddress << \"\\n\"; \nstd::cout << \"Receiver: \"<< t.destinationAddress << \"\\n\"; \nstd::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\nstd::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n\nstd::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\nstd::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\nif(i->second.rxPackets > 0)\n  \t{\n  \t\tpacketsDelivered += i->second.rxPackets;\n  \t\ttotalPackets += i->second.txPackets;\n  \t\ttotalDelay += (i->second.delaySum.ToDouble(ns3::Time::S) / i->second.rxPackets);\n  \t}\n       \n  double packetDeliveryRatio = (double) packetsDelivered / totalPackets;\n  double averageEndToEndDelay = totalDelay / packetsDelivered;\n  double throughput = (double) packetsDelivered * 1024 * 8 / (100.0 - 0.0) / 1000000;\n  \n  // Printing the results\n  std::cout << \"Packets Delivered Ratio: \" << packetDeliveryRatio << std::endl;\n  std::cout << \"Average End-to-End Delay: \" << averageEndToEndDelay << std::endl;\n  std::cout << \"Throughput: \" << throughput << std::endl;\n   }\n  \n \n  \n  Simulator::Destroy ();\n\n  return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a simple LTE network with one eNodeB (LTE base station) and two UE devices. The eNodeB should be attached to both UEs. One UE (UE 0) should act as a TCP server on port 8080, and the other UE (UE 1) should act as a TCP client, sending 1,000,000 bytes of data. The server should start at 1 second, and the client should start at 2 seconds. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleLTEExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create nodes: 1 eNodeB (LTE base station) + 2 UE (User Equipments)\n    NodeContainer ueNodes, enbNode;\n    ueNodes.Create(2);\n    enbNode.Create(1);\n\n    // Install LTE stack\n    LteHelper lte;\n    NetDeviceContainer ueDevices, enbDevices;\n\n    // Install LTE devices on UE and eNodeB\n    enbDevices = lte.InstallEnbDevice(enbNode);\n    ueDevices = lte.InstallUeDevice(ueNodes);\n\n    // Install the Internet stack\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    internet.Install(enbNode);\n\n    // Assign IP addresses\n    Ipv4InterfaceContainer ueIpInterface;\n    ueIpInterface = lte.AssignUeIpv4Address(ueDevices);\n\n    // Attach the UEs to the eNodeB\n    lte.Attach(ueDevices.Get(0), enbDevices.Get(0));\n    lte.Attach(ueDevices.Get(1), enbDevices.Get(0));\n\n    // Configure the TCP server on UE 0\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper tcpSink(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = tcpSink.Install(ueNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Configure the TCP client on UE 1\n    BulkSendHelper tcpClient(\"ns3::TcpSocketFactory\", InetSocketAddress(ueIpInterface.GetAddress(0), port));\n    tcpClient.SetAttribute(\"MaxBytes\", UintegerValue(1000000));\n    ApplicationContainer clientApp = tcpClient.Install(ueNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a network topology in ns3 using a star-shaped configuration where each node acts as both a client and a server, similar to a ring topology. Use point-to-point links for connectivity, with the network address 192.9.39.0/24. Each client should generate 4 packets, and only one client-server pair should communicate at a time, ensuring all packets are delivered to the server. The UDP echo server and client applications should be used, with nodes sending packets at specific intervals. The central node connects to all other nodes using point-to-point links. Provide a solution that configures the IP addresses, links, and applications accordingly, ensuring that the network is animated using NetAnim. Additionally, configure the link data rate to 5Mbps and a delay of 2ms."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"StarTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    NodeContainer starNodes;\n    starNodes.Create(4); // Create 4 nodes in a star topology\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer device1, device2, device3;\n    device1.Add(pointToPoint.Install(starNodes.Get(0), starNodes.Get(1)));\n    device2.Add(pointToPoint.Install(starNodes.Get(0), starNodes.Get(2)));\n    device3.Add(pointToPoint.Install(starNodes.Get(0), starNodes.Get(3)));\n\n    InternetStackHelper stack;\n    stack.Install(starNodes);\n\n    Ipv4AddressHelper address1, address2, address3;\n    address1.SetBase(\"192.9.39.0\", \"255.255.255.252\");\n    address2.SetBase(\"192.9.39.4\", \"255.255.255.252\");\n    address3.SetBase(\"192.9.39.8\", \"255.255.255.252\");\n\n    Ipv4InterfaceContainer interface1, interface2, interface3;\n    interface1 = address1.Assign(device1);\n    interface2 = address2.Assign(device2);\n    interface3 = address3.Assign(device3);\n\n    UdpEchoServerHelper echoServer(9);\n\n    // Server 0, Client 1\n    ApplicationContainer serverApps01 = echoServer.Install(starNodes.Get(0));\n    serverApps01.Start(Seconds(1.0));\n    serverApps01.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient01(interface1.GetAddress(0), 9);\n    echoClient01.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient01.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient01.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp01 = echoClient01.Install(starNodes.Get(1));\n    clientApp01.Start(Seconds(2.0));\n    clientApp01.Stop(Seconds(10.0));\n\n    // Server 1, Client 0\n    ApplicationContainer serverApps10 = echoServer.Install(starNodes.Get(1));\n    serverApps10.Start(Seconds(11.0));\n    serverApps10.Stop(Seconds(20.0));\n\n    UdpEchoClientHelper echoClient10(interface1.GetAddress(1), 9);\n    echoClient10.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient10.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient10.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp10 = echoClient10.Install(starNodes.Get(0));\n    clientApp10.Start(Seconds(12.0));\n    clientApp10.Stop(Seconds(20.0));\n\n    // Server 0, Client 2\n    ApplicationContainer serverApps02 = echoServer.Install(starNodes.Get(0));\n    serverApps02.Start(Seconds(21.0));\n    serverApps02.Stop(Seconds(30.0));\n\n    UdpEchoClientHelper echoClient02(interface2.GetAddress(0), 9);\n    echoClient02.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient02.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient02.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp02 = echoClient02.Install(starNodes.Get(2));\n    clientApp02.Start(Seconds(22.0));\n    clientApp02.Stop(Seconds(30.0));\n\n    // Server 2, Client 0\n    ApplicationContainer serverApps20 = echoServer.Install(starNodes.Get(2));\n    serverApps20.Start(Seconds(31.0));\n    serverApps20.Stop(Seconds(40.0));\n\n    UdpEchoClientHelper echoClient20(interface2.GetAddress(1), 9);\n    echoClient20.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient20.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient20.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp20 = echoClient20.Install(starNodes.Get(0));\n    clientApp20.Start(Seconds(32.0));\n    clientApp20.Stop(Seconds(40.0));\n\n    // Server 0, Client 3\n    ApplicationContainer serverApps03 = echoServer.Install(starNodes.Get(0));\n    serverApps03.Start(Seconds(41.0));\n    serverApps03.Stop(Seconds(50.0));\n\n    UdpEchoClientHelper echoClient03(interface3.GetAddress(0), 9);\n    echoClient03.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient03.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient03.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp03 = echoClient03.Install(starNodes.Get(3));\n    clientApp03.Start(Seconds(42.0));\n    clientApp03.Stop(Seconds(50.0));\n\n    // Server 3, Client 0\n    ApplicationContainer serverApps30 = echoServer.Install(starNodes.Get(3));\n    serverApps30.Start(Seconds(51.0));\n    serverApps30.Stop(Seconds(60.0));\n\n    UdpEchoClientHelper echoClient30(interface3.GetAddress(1), 9);\n    echoClient30.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient30.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient30.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp30 = echoClient30.Install(starNodes.Get(0));\n    clientApp30.Start(Seconds(52.0));\n    clientApp30.Stop(Seconds(60.0));\n\n    AnimationInterface anim(\"StarTopologyExample.xml\");\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network with two nodes: one as a TCP server and the other as a TCP client using the TCP Reno protocol. The client sends TCP packets (size 1024 bytes) at an interval of 100ms to the server. Configure the nodes with static mobility and assign them IP addresses. The server listens on port 9."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for debugging\n    LogComponentEnable(\"WifiTcpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Set up Wi-Fi devices\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::RenoWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"wifi-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer staDevice;\n    staDevice = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevice);\n    Ipv4InterfaceContainer apInterfaces = address.Assign(apDevice);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0), \"DeltaY\", DoubleValue(5.0), \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Set up TCP server (on the STA)\n    uint16_t port = 9;\n    TcpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client (on the AP)\n    TcpClientHelper client(staInterfaces.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation for a wireless network where four mobile nodes are connected via an Ad-Hoc network. Use the AODV (Ad hoc On-Demand Distance Vector) routing protocol to manage routing in the network. The nodes should move randomly within a predefined area during the simulation, and UDP traffic is generated between the nodes. Track the movement and interactions of the nodes using NetAnim. Measure and analyze packet delivery ratio, throughput, and average end-to-end delay using FlowMonitor, and visualize the nodes' mobility and communication using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"AdhocNetworkSimulation\");\n\nint main (int argc, char *argv[])\n{\n    // Set simulation time\n    double simTime = 20.0;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Set up WiFi for Ad-Hoc network\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, nodes);\n\n    // Install Internet stack with AODV routing\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Mobility model for random movement\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", StringValue(\"ns3::ConstantRandomVariable[Constant=20.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=2.0]\"),\n                              \"PositionAllocator\", StringValue(\"ns3::RandomRectanglePositionAllocator\"));\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(50.0),\n                                  \"DeltaY\", DoubleValue(50.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.Install(nodes);\n\n    // Set up UDP traffic\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(3));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simTime));\n\n    UdpClientHelper udpClient(interfaces.GetAddress(3), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simTime));\n\n    // Set up FlowMonitor\n    FlowMonitorHelper flowMonitorHelper;\n    Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n    // NetAnim setup\n    AnimationInterface anim(\"adhoc_network.xml\");\n    anim.SetConstantPosition(nodes.Get(0), 10.0, 10.0);\n    anim.SetConstantPosition(nodes.Get(1), 30.0, 10.0);\n    anim.SetConstantPosition(nodes.Get(2), 10.0, 30.0);\n    anim.SetConstantPosition(nodes.Get(3), 30.0, 30.0);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n\n    // Flow monitor statistics\n    flowMonitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitorHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n\n    for (auto it = stats.begin(); it != stats.end(); ++it)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(it->first);\n        std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n        std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n        std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n        std::cout << \"  Throughput: \" << it->second.rxBytes * 8.0 / simTime / 1000 / 1000 << \" Mbps\" << std::endl;\n        std::cout << \"  Packet Delivery Ratio: \" << (double)it->second.rxPackets / it->second.txPackets * 100 << \"%\" << std::endl;\n        std::cout << \"  Delay: \" << it->second.delaySum.GetSeconds() << \" seconds\" << std::endl;\n    }\n\n    // Clean up and destroy simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that generates a dataset for a simple ring topology with 4 nodes, where each node communicates with its neighbor using UDP. The dataset should capture the source node, destination node, packet size, transmission time, and reception time for each packet. Save the information to a CSV file."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RingTopologyDataset\");\n\nvoid RecordUdpData(Ptr<FlowMonitor> flowMonitor, std::string filename)\n{\n    std::ofstream outFile;\n    outFile.open(filename, std::ios::out | std::ios::app);\n    outFile << \"FlowID,SrcAddr,DestAddr,PacketSize,TxTime,RxTime\\n\"; // CSV headers\n\n    // Retrieve statistics from flow monitor\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n    for (auto &flow : stats)\n    {\n        FlowId id = flow.first;\n        FlowMonitor::FlowStats flowStats = flow.second;\n        Ipv4FlowClassifier::FiveTuple t = flowMonitor->GetClassifier()->FindFlow(id);\n\n        for (uint32_t i = 0; i < flowStats.txPackets; i++)\n        {\n            outFile << id << \",\"\n                    << t.sourceAddress << \",\"\n                    << t.destinationAddress << \",\"\n                    << flowStats.txBytes << \",\"\n                    << flowStats.timeFirstTxPacket.GetSeconds() << \",\"\n                    << flowStats.timeLastRxPacket.GetSeconds() << \"\\n\";\n        }\n    }\n    outFile.close();\n}\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"RingTopologyDataset\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes in a ring topology\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Set up point-to-point links between nodes in a ring\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices.Add(p2p.Install(nodes.Get(0), nodes.Get(1)));\n    devices.Add(p2p.Install(nodes.Get(1), nodes.Get(2)));\n    devices.Add(p2p.Install(nodes.Get(2), nodes.Get(3)));\n    devices.Add(p2p.Install(nodes.Get(3), nodes.Get(0))); // Connect back to node 0 to form a ring\n\n    // Install Internet stack on nodes\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Setup UDP server on node 0\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup UDP clients on nodes 1-3 to send data to node 0\n    UdpClientHelper udpClient(interfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 1; i < nodes.GetN(); ++i)\n    {\n        clientApps.Add(udpClient.Install(nodes.Get(i)));\n    }\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(9.0));\n\n    // Enable flow monitor\n    FlowMonitorHelper flowHelper;\n    Ptr<FlowMonitor> flowMonitor = flowHelper.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Record UDP data to a CSV file\n    RecordUdpData(flowMonitor, \"udp_dataset_ring.csv\");\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSet up a point-to-point network in NS-3 with two nodes. Configure a point-to-point link with a data rate of 5Mbps and a delay of 2ms. Node 1 sends UDP packets to Node 2, with a server running on Node 2. The simulation should run for 10 seconds, starting the server at 1s and the client at 2s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 2\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(1), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a minimal NS-3 simulation in C++ where two nodes communicate using UDP over a point-to-point link. The client should send a small UDP packet to the server, which will log the reception. Keep the simulation simple and short."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MinimalUdpExample\");\n\n// Function to receive packets at the server\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a packet!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"MinimalUdpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes (client and server)\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up a point-to-point connection\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    uint16_t port = 4000; // UDP port\n\n    // Setup UDP Server on node 1\n    Ptr<Socket> serverSocket = Socket::CreateSocket(nodes.Get(1), UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client on node 0\n    Ptr<Socket> clientSocket = Socket::CreateSocket(nodes.Get(0), UdpSocketFactory::GetTypeId());\n    Ptr<Packet> packet = Create<Packet>(128); // 128-byte packet\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, clientSocket, packet, 0, InetSocketAddress(interfaces.GetAddress(1), port));\n\n    // Run the simulation\n    Simulator::Stop(Seconds(2.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where vehicles in a VANET (Vehicular Ad Hoc Network) communicate using UDP over a Wi-Fi network. The vehicles should follow a realistic mobility model using the SUMO (Simulation of Urban MObility) tool and the ns-3 Mobility module. Use the DSR (Dynamic Source Routing) protocol to establish routes between vehicles dynamically. The simulation should run for 80 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/dsr-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpVANETExample\");\n\n// Function to send UDP packets from vehicles to the RSU\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address rsuAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(256); // 256-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(rsuAddr, port));\n    Simulator::Schedule(Seconds(3.0), &SendPacket, socket, rsuAddr, port); // Schedule next packet\n}\n\n// Function to receive packets at the RSU\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"RSU received a packet from a vehicle!\");\n    }\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpVANETExample\", LOG_LEVEL_INFO);\n\n    int numVehicles = 10;\n    double simTime = 80.0;\n\n    // Create nodes (Vehicles + 1 Roadside Unit)\n    NodeContainer vehicles;\n    vehicles.Create(numVehicles);\n\n    NodeContainer rsu;\n    rsu.Create(1);\n\n    // Configure Wi-Fi (Ad-Hoc Mode for VANET)\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211p); // 802.11p for VANET communication\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer vehicleDevices = wifi.Install(phy, mac, vehicles);\n    NetDeviceContainer rsuDevice = wifi.Install(phy, mac, rsu);\n\n    // Set up mobility model for vehicles (simulate road movement)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::GaussMarkovMobilityModel\",\n                              \"Bounds\", BoxValue(Box(0, 500, 0, 500, 0, 0)),\n                              \"TimeStep\", TimeValue(Seconds(1.0)),\n                              \"Alpha\", DoubleValue(0.85),\n                              \"MeanVelocity\", StringValue(\"ns3::UniformRandomVariable[Min=10.0|Max=20.0]\"),\n                              \"MeanDirection\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=360]\"),\n                              \"MeanPitch\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    mobility.Install(vehicles);\n\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(250.0, 250.0, 0.0)); // RSU fixed at center\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(rsu);\n\n    // Install Internet stack with DSR routing\n    DsrMainHelper dsrMain;\n    DsrHelper dsr;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(dsr);\n    internet.Install(vehicles);\n    internet.Install(rsu);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.5.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vehicleInterfaces = address.Assign(vehicleDevices);\n    Ipv4InterfaceContainer rsuInterface = address.Assign(rsuDevice);\n\n    uint16_t port = 8080; // UDP port\n\n    // Setup UDP Server at RSU\n    Ptr<Socket> rsuSocket = Socket::CreateSocket(rsu.Get(0), UdpSocketFactory::GetTypeId());\n    rsuSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    rsuSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Clients in Vehicles\n    for (int i = 0; i < numVehicles; i++) {\n        Ptr<Socket> vehicleSocket = Socket::CreateSocket(vehicles.Get(i), UdpSocketFactory::GetTypeId());\n        Simulator::Schedule(Seconds(2.0 + i * 1.0), &SendPacket, vehicleSocket, rsuInterface.GetAddress(0), port);\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a Wi-Fi network with two nodes. The first node (Node A) sends 128-byte UDP packets to the second node (Node B) every 100ms. The simulation should run for 10 seconds. Use 802.11 Wi-Fi communication and set up the nodes with constant position mobility. Enable PCAP tracing for Wi-Fi communication, and install an UDP server on Node B and a UDP client on Node A."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"WifiExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Setup Wi-Fi helper\n    WifiHelper wifiHelper;\n    wifiHelper.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Setup Wi-Fi PHY and MAC layers\n    YansWifiPhyHelper wifiPhyHelper = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannelHelper = YansWifiChannelHelper::Default();\n    wifiPhyHelper.SetChannel(wifiChannelHelper.Create());\n\n    WifiMacHelper wifiMacHelper;\n    wifiMacHelper.SetType(\"ns3::StaWifiMac\",\n                          \"ActiveProbing\", BooleanValue(false));\n\n    // Install Wi-Fi devices on nodes\n    NetDeviceContainer devices = wifiHelper.Install(wifiPhyHelper, wifiMacHelper, nodes);\n\n    // Setup mobility model for nodes\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node B\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1)); // Node B\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node A\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(128));\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0)); // Node A\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable tracing\n    wifiPhyHelper.EnablePcap(\"wifi_network\", devices);\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a CSMA (Ethernet) wired network with four nodes. The nodes should be connected using a CSMA channel with a data rate of 100 Mbps and a propagation delay of 6560 nanoseconds. Each node should have a unique IPv4 address in the 192.168.1.0/24 subnet. The last node should run a UDP echo server on port 9, while the first node acts as a client sending five packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create nodes\n    NodeContainer csmaNodes;\n    csmaNodes.Create(4); // 4 devices connected via CSMA\n\n    // Set up CSMA channel\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install CSMA devices\n    NetDeviceContainer csmaDevices;\n    csmaDevices = csma.Install(csmaNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(csmaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer csmaInterfaces = address.Assign(csmaDevices);\n\n    // Set up UDP echo server on last node\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(csmaNodes.Get(3));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP echo client on first node\n    UdpEchoClientHelper echoClient(csmaInterfaces.GetAddress(3), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(csmaNodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a ring topology network using ns3 where four nodes are connected in a circular manner with point-to-point links between adjacent nodes. Assign IP addresses within the 192.9.39.0/24 network, and use the UDP Echo Client-Server application for communication. Each node should act as both a client and a server at least once, but only one pair of client-server applications should run at any given time. Ensure that each client sends exactly 4 packets, with a transmission interval of 1 second, and configure the server to respond to the client's requests. Additionally, configure the link data rate to 5Mbps and a delay of 2ms."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RingTopologyExample\");\n\nint main(int argc, char* argv[])\n{\n    // Parse command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    // Set time resolution to nanoseconds\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create four nodes for the ring topology\n    NodeContainer ring;\n    ring.Create(4);\n\n    // Configure point-to-point links with 5Mbps data rate and 2ms delay\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create devices for each pair of adjacent nodes in the ring\n    NetDeviceContainer device1, device2, device3, device4;\n    device1.Add(pointToPoint.Install(ring.Get(0), ring.Get(1)));\n    device2.Add(pointToPoint.Install(ring.Get(1), ring.Get(2)));\n    device3.Add(pointToPoint.Install(ring.Get(2), ring.Get(3)));\n    device4.Add(pointToPoint.Install(ring.Get(3), ring.Get(0)));\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(ring);\n\n    // Assign IP addresses for each point-to-point link\n    Ipv4AddressHelper address1, address2, address3, address4;\n    address1.SetBase(\"192.9.39.0\", \"255.255.255.252\");  // Subnet for node 0-1 link\n    address2.SetBase(\"192.9.39.4\", \"255.255.255.252\");  // Subnet for node 1-2 link\n    address3.SetBase(\"192.9.39.8\", \"255.255.255.252\");  // Subnet for node 2-3 link\n    address4.SetBase(\"192.9.39.12\", \"255.255.255.252\"); // Subnet for node 3-0 link\n\n    // Assign IP addresses to each device's interface\n    Ipv4InterfaceContainer interface1, interface2, interface3, interface4;\n    interface1 = address1.Assign(device1);\n    interface2 = address2.Assign(device2);\n    interface3 = address3.Assign(device3);\n    interface4 = address4.Assign(device4);\n\n    // Create a UDP echo server on each node in sequence\n    UdpEchoServerHelper echoServer(9);  // All servers listen on port 9\n\n    // Configure server on node 1 and client on node 0\n    ApplicationContainer serverApps10 = echoServer.Install(ring.Get(1));\n    serverApps10.Start(Seconds(1.0));\n    serverApps10.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient10(interface1.GetAddress(1), 9); // Node 1 as server\n    echoClient10.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient10.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient10.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp10 = echoClient10.Install(ring.Get(0)); // Node 0 as client\n    clientApp10.Start(Seconds(2.0));\n    clientApp10.Stop(Seconds(10.0));\n\n    // Configure server on node 2 and client on node 1\n    ApplicationContainer serverApps21 = echoServer.Install(ring.Get(2));\n    serverApps21.Start(Seconds(11.0));\n    serverApps21.Stop(Seconds(20.0));\n\n    UdpEchoClientHelper echoClient21(interface2.GetAddress(1), 9); // Node 2 as server\n    echoClient21.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient21.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient21.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp21 = echoClient21.Install(ring.Get(1)); // Node 1 as client\n    clientApp21.Start(Seconds(12.0));\n    clientApp21.Stop(Seconds(20.0));\n\n    // Configure server on node 3 and client on node 2\n    ApplicationContainer serverApps32 = echoServer.Install(ring.Get(3));\n    serverApps32.Start(Seconds(21.0));\n    serverApps32.Stop(Seconds(30.0));\n\n    UdpEchoClientHelper echoClient32(interface3.GetAddress(1), 9); // Node 3 as server\n    echoClient32.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient32.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient32.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp32 = echoClient32.Install(ring.Get(2)); // Node 2 as client\n    clientApp32.Start(Seconds(22.0));\n    clientApp32.Stop(Seconds(30.0));\n\n    // Configure server on node 0 and client on node 3\n    ApplicationContainer serverApps03 = echoServer.Install(ring.Get(0));\n    serverApps03.Start(Seconds(31.0));\n    serverApps03.Stop(Seconds(40.0));\n\n    UdpEchoClientHelper echoClient03(interface4.GetAddress(1), 9); // Node 0 as server\n    echoClient03.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient03.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient03.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp03 = echoClient03.Install(ring.Get(3)); // Node 3 as client\n    clientApp03.Start(Seconds(32.0));\n    clientApp03.Stop(Seconds(40.0));\n\n    // Enable NetAnim animation output\n    AnimationInterface anim(\"RingTopologyExample.xml\");\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a mesh network in NS-3 with three nodes. Set up mesh routing with Random Access for the MAC and YansWifiPhy for the physical layer. Node 1 sends UDP packets to Node 2, and Node 2 forwards the packets to Node 3. Run the simulation for 10 seconds, starting the server at 1s and the client at 2s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MeshNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Install mesh stack on all nodes\n    MeshHelper mesh;\n    mesh.SetStackInstall(true);\n    mesh.SetMacType(\"RandomAccess\");\n    mesh.SetPhyType(\"YansWifiPhy\");\n\n    // Set up mesh devices\n    NetDeviceContainer devices = mesh.Install(nodes);\n\n    // Install internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 2\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(1), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a Wi-Fi network in NS-3 with two nodes. The first node (AP) and the second node (STA) communicate via UDP packets. Set the Wi-Fi data rate to default and use 10.1.1.0/24 IP addresses. The client sends packets at 0.1s intervals starting at 2s, and the server runs from 1s to 10s. Use default Wi-Fi PHY and MAC models and run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Set up Wi-Fi PHY and MAC layers\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiChannelHelper channel;\n    channel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    channel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::StaWifiMac\");\n\n    NetDeviceContainer staDevice = wifi.Install(phy, mac, wifiNodes.Get(1));\n\n    mac.SetType(\"ns3::ApWifiMac\");\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiNodes.Get(0));\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(staDevice);\n    address.Assign(apDevice);\n\n    // Set up UDP server on AP\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on STA\n    UdpClientHelper udpClient(interfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a wireless mesh network using the IEEE 802.11s standard. The network should consist of three mesh nodes configured with the ns-3 MeshHelper using the Dot11s stack. Nodes should be arranged in a grid layout with 5-meter spacing. Each node should have an IP address in the 10.1.1.0/24 subnet. The last node should act as a UDP echo server on port 9, while the first node should be a UDP echo client sending five packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create 3 mesh nodes\n    NodeContainer meshNodes;\n    meshNodes.Create(3);\n\n    // Configure mesh helper\n    MeshHelper mesh;\n    mesh.SetStackInstaller(\"ns3::Dot11sStack\");\n    mesh.SetSpreadInterfaceChannels(MeshHelper::SPREAD_CHANNELS);\n    mesh.SetMacType(\"ns3::MeshPointDevice\");\n    mesh.SetNumberOfInterfaces(1);\n\n    // Configure Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Install mesh devices on nodes\n    NetDeviceContainer meshDevices = mesh.Install(phy, meshNodes);\n\n    // Set mobility models (static grid layout)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(meshNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(meshNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer meshInterfaces = address.Assign(meshDevices);\n\n    // Set up a UDP echo server on the last node\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(meshNodes.Get(2));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP echo client on the first node\n    UdpEchoClientHelper echoClient(meshInterfaces.GetAddress(2), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(meshNodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a WiFi ad-hoc network with two nodes. The network consists of Node 0 (sender) and Node 1 (receiver). Use 802.11b WiFi standard in ad-hoc mode (no access point). Node 0 sends UDP packets to Node 1 on port 9 starting at 2 seconds and stops at 10 seconds. Node 1 receives UDP packets starting at 1 second and stops at 10 seconds. The packets are sent at an interval of 1 second, with each packet having a size of 1024 bytes, and the sender sends a total of 10 packets."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiAdhocExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"WifiAdhocExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the network\n    NodeContainer nodes;\n    nodes.Create(2); // Two nodes: Sender and Receiver\n\n    // Set up mobility model (place nodes at fixed positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Set up WiFi helper for wireless communication\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    // Set up WiFi PHY (physical layer)\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(YansWifiChannelHelper::Default().Create());\n\n    // Set up WiFi MAC (media access control) for ad-hoc mode\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    // Install WiFi devices on nodes\n    NetDeviceContainer devices;\n    devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up the UDP receiver application on Node 1 (Receiver)\n    UdpServerHelper udpServer(9);                                     // UDP port 9\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1)); // Install on Node 1 (Receiver)\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the UDP sender application on Node 0 (Sender)\n    UdpClientHelper udpClient(interfaces.GetAddress(1), 9);      // Send to Node 1\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // Number of packets to send\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // Interval between packets\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // Packet size in bytes\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0)); // Install on Node 0 (Sender)\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\n// Default network topology includes some number of AP nodes specified by\n// the variable nWifis (defaults to two).  Off of each AP node, there are some\n// number of STA nodes specified by the variable nStas (defaults to two).\n// Each AP talks to its associated STA nodes.  There are bridge net devices\n// on each AP node that bridge the whole thing into one network.\n//\n//      +-----+      +-----+            +-----+      +-----+\n//      | STA |      | STA |            | STA |      | STA |\n//      +-----+      +-----+            +-----+      +-----+\n//    192.168.0.2  192.168.0.3        192.168.0.5  192.168.0.6\n//      --------     --------           --------     --------\n//      WIFI STA     WIFI STA           WIFI STA     WIFI STA\n//      --------     --------           --------     --------\n//        ((*))       ((*))       |      ((*))        ((*))\n//                                |\n//              ((*))             |             ((*))\n//             -------                         -------\n//             WIFI AP   CSMA ========= CSMA   WIFI AP\n//             -------   ----           ----   -------\n//             ##############           ##############\n//                 BRIDGE                   BRIDGE\n//             ##############           ##############\n//               192.168.0.1              192.168.0.4\n//               +---------+              +---------+\n//               | AP Node |              | AP Node |\n//               +---------+              +---------+\n\n#include \"ns3/bridge-helper.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/csma-helper.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-socket-address.h\"\n#include \"ns3/rectangle.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t nWifis = 2;\n    uint32_t nStas = 2;\n    bool sendIp = true;\n    bool writeMobility = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nWifis\", \"Number of wifi networks\", nWifis);\n    cmd.AddValue(\"nStas\", \"Number of stations per wifi network\", nStas);\n    cmd.AddValue(\"SendIp\", \"Send Ipv4 or raw packets\", sendIp);\n    cmd.AddValue(\"writeMobility\", \"Write mobility trace\", writeMobility);\n    cmd.Parse(argc, argv);\n\n    NodeContainer backboneNodes;\n    NetDeviceContainer backboneDevices;\n    Ipv4InterfaceContainer backboneInterfaces;\n    std::vector<NodeContainer> staNodes;\n    std::vector<NetDeviceContainer> staDevices;\n    std::vector<NetDeviceContainer> apDevices;\n    std::vector<Ipv4InterfaceContainer> staInterfaces;\n    std::vector<Ipv4InterfaceContainer> apInterfaces;\n\n    InternetStackHelper stack;\n    CsmaHelper csma;\n    Ipv4AddressHelper ip;\n    ip.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n\n    backboneNodes.Create(nWifis);\n    stack.Install(backboneNodes);\n\n    backboneDevices = csma.Install(backboneNodes);\n\n    meter_u wifiX = 0.0;\n\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    for (uint32_t i = 0; i < nWifis; ++i)\n    {\n        // calculate ssid for wifi subnetwork\n        std::ostringstream oss;\n        oss << \"wifi-default-\" << i;\n        Ssid ssid = Ssid(oss.str());\n\n        NodeContainer sta;\n        NetDeviceContainer staDev;\n        NetDeviceContainer apDev;\n        Ipv4InterfaceContainer staInterface;\n        Ipv4InterfaceContainer apInterface;\n        MobilityHelper mobility;\n        BridgeHelper bridge;\n        WifiHelper wifi;\n        WifiMacHelper wifiMac;\n        YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n        wifiPhy.SetChannel(wifiChannel.Create());\n\n        sta.Create(nStas);\n        mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                      \"MinX\",\n                                      DoubleValue(wifiX),\n                                      \"MinY\",\n                                      DoubleValue(0.0),\n                                      \"DeltaX\",\n                                      DoubleValue(5.0),\n                                      \"DeltaY\",\n                                      DoubleValue(5.0),\n                                      \"GridWidth\",\n                                      UintegerValue(1),\n                                      \"LayoutType\",\n                                      StringValue(\"RowFirst\"));\n\n        // setup the AP.\n        mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n        mobility.Install(backboneNodes.Get(i));\n        wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n        apDev = wifi.Install(wifiPhy, wifiMac, backboneNodes.Get(i));\n\n        NetDeviceContainer bridgeDev;\n        bridgeDev =\n            bridge.Install(backboneNodes.Get(i), NetDeviceContainer(apDev, backboneDevices.Get(i)));\n\n        // assign AP IP address to bridge, not wifi\n        apInterface = ip.Assign(bridgeDev);\n\n        // setup the STAs\n        stack.Install(sta);\n        mobility.SetMobilityModel(\n            \"ns3::RandomWalk2dMobilityModel\",\n            \"Mode\",\n            StringValue(\"Time\"),\n            \"Time\",\n            StringValue(\"2s\"),\n            \"Speed\",\n            StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"),\n            \"Bounds\",\n            RectangleValue(Rectangle(wifiX, wifiX + 5.0, 0.0, (nStas + 1) * 5.0)));\n        mobility.Install(sta);\n        wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n        staDev = wifi.Install(wifiPhy, wifiMac, sta);\n        staInterface = ip.Assign(staDev);\n\n        // save everything in containers.\n        staNodes.push_back(sta);\n        apDevices.push_back(apDev);\n        apInterfaces.push_back(apInterface);\n        staDevices.push_back(staDev);\n        staInterfaces.push_back(staInterface);\n\n        wifiX += 20.0;\n    }\n\n    Address dest;\n    std::string protocol;\n    if (sendIp)\n    {\n        dest = InetSocketAddress(staInterfaces[1].GetAddress(1), 1025);\n        protocol = \"ns3::UdpSocketFactory\";\n    }\n    else\n    {\n        PacketSocketAddress tmp;\n        tmp.SetSingleDevice(staDevices[0].Get(0)->GetIfIndex());\n        tmp.SetPhysicalAddress(staDevices[1].Get(0)->GetAddress());\n        tmp.SetProtocol(0x807);\n        dest = tmp;\n        protocol = \"ns3::PacketSocketFactory\";\n    }\n\n    OnOffHelper onoff = OnOffHelper(protocol, dest);\n    onoff.SetConstantRate(DataRate(\"500kb/s\"));\n    ApplicationContainer apps = onoff.Install(staNodes[0].Get(0));\n    apps.Start(Seconds(0.5));\n    apps.Stop(Seconds(3.0));\n\n    wifiPhy.EnablePcap(\"wifi-wired-bridging\", apDevices[0]);\n    wifiPhy.EnablePcap(\"wifi-wired-bridging\", apDevices[1]);\n\n    if (writeMobility)\n    {\n        AsciiTraceHelper ascii;\n        MobilityHelper::EnableAsciiAll(ascii.CreateFileStream(\"wifi-wired-bridging.mob\"));\n    }\n\n    Simulator::Stop(Seconds(5.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}, {"role": "assistant", "content": "// Default network topology includes some number of AP nodes specified by\n// the variable nWifis (defaults to two).  Off of each AP node, there are some\n// number of STA nodes specified by the variable nStas (defaults to two).\n// Each AP talks to its associated STA nodes.  There are bridge net devices\n// on each AP node that bridge the whole thing into one network.\n//\n//      +-----+      +-----+            +-----+      +-----+\n//      | STA |      | STA |            | STA |      | STA |\n//      +-----+      +-----+            +-----+      +-----+\n//    192.168.0.2  192.168.0.3        192.168.0.5  192.168.0.6\n//      --------     --------           --------     --------\n//      WIFI STA     WIFI STA           WIFI STA     WIFI STA\n//      --------     --------           --------     --------\n//        ((*))       ((*))       |      ((*))        ((*))\n//                                |\n//              ((*))             |             ((*))\n//             -------                         -------\n//             WIFI AP   CSMA ========= CSMA   WIFI AP\n//             -------   ----           ----   -------\n//             ##############           ##############\n//                 BRIDGE                   BRIDGE\n//             ##############           ##############\n//               192.168.0.1              192.168.0.4\n//               +---------+              +---------+\n//               | AP Node |              | AP Node |\n//               +---------+              +---------+\n\n#include \"ns3/bridge-helper.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/csma-helper.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-socket-address.h\"\n#include \"ns3/rectangle.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t nWifis = 2;\n    uint32_t nStas = 2;\n    bool sendIp = true;\n    bool writeMobility = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nWifis\", \"Number of wifi networks\", nWifis);\n    cmd.AddValue(\"nStas\", \"Number of stations per wifi network\", nStas);\n    cmd.AddValue(\"SendIp\", \"Send Ipv4 or raw packets\", sendIp);\n    cmd.AddValue(\"writeMobility\", \"Write mobility trace\", writeMobility);\n    cmd.Parse(argc, argv);\n\n    NodeContainer backboneNodes;\n    NetDeviceContainer backboneDevices;\n    Ipv4InterfaceContainer backboneInterfaces;\n    std::vector<NodeContainer> staNodes;\n    std::vector<NetDeviceContainer> staDevices;\n    std::vector<NetDeviceContainer> apDevices;\n    std::vector<Ipv4InterfaceContainer> staInterfaces;\n    std::vector<Ipv4InterfaceContainer> apInterfaces;\n\n    InternetStackHelper stack;\n    CsmaHelper csma;\n    Ipv4AddressHelper ip;\n    ip.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n\n    backboneNodes.Create(nWifis);\n    stack.Install(backboneNodes);\n\n    backboneDevices = csma.Install(backboneNodes);\n\n    meter_u wifiX = 0.0;\n\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    for (uint32_t i = 0; i < nWifis; ++i)\n    {\n        // calculate ssid for wifi subnetwork\n        std::ostringstream oss;\n        oss << \"wifi-default-\" << i;\n        Ssid ssid = Ssid(oss.str());\n\n        NodeContainer sta;\n        NetDeviceContainer staDev;\n        NetDeviceContainer apDev;\n        Ipv4InterfaceContainer staInterface;\n        Ipv4InterfaceContainer apInterface;\n        MobilityHelper mobility;\n        BridgeHelper bridge;\n        WifiHelper wifi;\n        WifiMacHelper wifiMac;\n        YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n        wifiPhy.SetChannel(wifiChannel.Create());\n\n        sta.Create(nStas);\n        mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                      \"MinX\",\n                                      DoubleValue(wifiX),\n                                      \"MinY\",\n                                      DoubleValue(0.0),\n                                      \"DeltaX\",\n                                      DoubleValue(5.0),\n                                      \"DeltaY\",\n                                      DoubleValue(5.0),\n                                      \"GridWidth\",\n                                      UintegerValue(1),\n                                      \"LayoutType\",\n                                      StringValue(\"RowFirst\"));\n\n        // setup the AP.\n        mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n        mobility.Install(backboneNodes.Get(i));\n        wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n        apDev = wifi.Install(wifiPhy, wifiMac, backboneNodes.Get(i));\n\n        NetDeviceContainer bridgeDev;\n        bridgeDev =\n            bridge.Install(backboneNodes.Get(i), NetDeviceContainer(apDev, backboneDevices.Get(i)));\n\n        // assign AP IP address to bridge, not wifi\n        apInterface = ip.Assign(bridgeDev);\n\n        // setup the STAs\n        stack.Install(sta);\n        mobility.SetMobilityModel(\n            \"ns3::RandomWalk2dMobilityModel\",\n            \"Mode\",\n            StringValue(\"Time\"),\n            \"Time\",\n            StringValue(\"2s\"),\n            \"Speed\",\n            StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"),\n            \"Bounds\",\n            RectangleValue(Rectangle(wifiX, wifiX + 5.0, 0.0, (nStas + 1) * 5.0)));\n        mobility.Install(sta);\n        wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n        staDev = wifi.Install(wifiPhy, wifiMac, sta);\n        staInterface = ip.Assign(staDev);\n\n        // save everything in containers.\n        staNodes.push_back(sta);\n        apDevices.push_back(apDev);\n        apInterfaces.push_back(apInterface);\n        staDevices.push_back(staDev);\n        staInterfaces.push_back(staInterface);\n\n        wifiX += 20.0;\n    }\n\n    Address dest;\n    std::string protocol;\n    if (sendIp)\n    {\n        dest = InetSocketAddress(staInterfaces[1].GetAddress(1), 1025);\n        protocol = \"ns3::UdpSocketFactory\";\n    }\n    else\n    {\n        PacketSocketAddress tmp;\n        tmp.SetSingleDevice(staDevices[0].Get(0)->GetIfIndex());\n        tmp.SetPhysicalAddress(staDevices[1].Get(0)->GetAddress());\n        tmp.SetProtocol(0x807);\n        dest = tmp;\n        protocol = \"ns3::PacketSocketFactory\";\n    }\n\n    OnOffHelper onoff = OnOffHelper(protocol, dest);\n    onoff.SetConstantRate(DataRate(\"500kb/s\"));\n    ApplicationContainer apps = onoff.Install(staNodes[0].Get(0));\n    apps.Start(Seconds(0.5));\n    apps.Stop(Seconds(3.0));\n\n    wifiPhy.EnablePcap(\"wifi-wired-bridging\", apDevices[0]);\n    wifiPhy.EnablePcap(\"wifi-wired-bridging\", apDevices[1]);\n\n    if (writeMobility)\n    {\n        AsciiTraceHelper ascii;\n        MobilityHelper::EnableAsciiAll(ascii.CreateFileStream(\"wifi-wired-bridging.mob\"));\n    }\n\n    Simulator::Stop(Seconds(5.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless ad-hoc network using the AODV (Ad hoc On-Demand Distance Vector) routing protocol in ns-3. The network consists of 5 nodes, all of which are randomly placed in a 100x100 meter area. UDP traffic will be sent from one node to another, and the simulation will track the packet transmission, route discovery, and delivery using the AODV protocol. Pcap traces will also be enabled for further analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/udp-echo-helper.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AODVAdhocNetwork\");\n\nint main(int argc, char *argv[])\n{\n    // Set up logging for AODV\n    LogComponentEnable(\"AodvRoutingProtocol\", LOG_LEVEL_INFO);\n\n    // Create 5 nodes\n    NodeContainer nodes;\n    nodes.Create(5);\n\n    // Set up wireless channel and PHY layer\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Configure WiFi (non-infrastructure mode)\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set mobility model (random placement of nodes)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install internet stack with AODV routing protocol\n    AodvHelper aodv;\n    Ipv4ListRoutingHelper list;\n    list.Add(aodv, 100);\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(list);\n    internet.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP Echo Server on node 1\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP Echo Client on node 0 to send packets to node 1\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable pcap tracing\n    phy.EnablePcap(\"aodv-adhoc\", devices);\n\n    // Set up flow monitor to track network performance\n    FlowMonitorHelper flowmonHelper;\n    Ptr<FlowMonitor> monitor = flowmonHelper.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Print flow monitor statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 /\n                                            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n                                            1024 / 1024 << \" Mbps\");\n    }\n\n    // Clean up and exit\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 simulation library to model a simple network topology consisting of two nodes (n0 and n1) connected via a LAN using a CSMA channel. Implement ICMPv6 echo requests flowing from n0 to n1 and back, simulating echo replies. Configure the network with DropTail queues and set up tracing of queues and packet receptions, outputting to a file named 'ping6.tr'. Include the installation of the IPv6 stack, address assignment, and the creation of a Ping application that sends a specified number of echo requests from n0 to n1."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1\n//       |     |\n//       =================\n//              LAN\n//\n// - ICMPv6 echo request flows from n0 to n1 and back with ICMPv6 echo reply\n// - DropTail queues\n// - Tracing of queues and packet receptions to file \"ping6.tr\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Ping6Example\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n    bool allNodes = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.AddValue(\"allNodes\", \"Ping all the nodes (true) or just one neighbor (false)\", allNodes);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Ping6Example\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"Ipv6EndPointDemux\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6ListRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ping\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"NdiscCache\", LOG_LEVEL_ALL);\n    }\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer n;\n    n.Create(4);\n\n    /* Install IPv4/IPv6 stack */\n    InternetStackHelper internetv6;\n    internetv6.SetIpv4StackInstall(false);\n    internetv6.Install(n);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d = csma.Install(n);\n\n    Ipv6AddressHelper ipv6;\n    NS_LOG_INFO(\"Assign IPv6 Addresses.\");\n    Ipv6InterfaceContainer i = ipv6.Assign(d);\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    // Create a Ping application to send ICMPv6 echo request from node zero\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 5;\n\n    Ipv6Address destination = allNodes ? Ipv6Address::GetAllNodesMulticast() : i.GetAddress(1, 0);\n    PingHelper ping(destination);\n\n    ping.SetAttribute(\"Count\", UintegerValue(maxPacketCount));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    ping.SetAttribute(\"InterfaceAddress\", AddressValue(i.GetAddress(0, 0)));\n\n    ApplicationContainer apps = ping.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"ping6.tr\"));\n    csma.EnablePcapAll(std::string(\"ping6\"), true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSet up a simple Wi-Fi network with two nodes in NS-3. Node 0 (sender) sends UDP packets to Node 1 (receiver). Both nodes are statically placed with positions (0, 0) and (5, 5). Use the AARF Wi-Fi manager and configure the communication to last for 10 seconds. The server (Node 1) listens on port 9 and the client (Node 0) sends packets every 1 millisecond."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Install Wi-Fi devices\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::StaWifiMac\", \"Active\", BooleanValue(true));\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Set up mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server (Receiver) on Node 1\n    UdpServerHelper server(9);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP client (Sender) on Node 0\n    UdpClientHelper client(interfaces.GetAddress(1), 9);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(1)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Wi-Fi network with one access point (AP) and one client station (STA). The AP and client should use the 802.11 standard with a single SSID. The client should be stationary and should send UDP packets to the AP. The UDP client should send 100 packets of 512 bytes at 0.1-second intervals to the UDP server running on the AP. The network should use the 192.168.1.0/24 subnet. The server should start at 1 second, and the client should start at 2 seconds, running until 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/wifi-mac-helper.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiSimpleExample\", LOG_LEVEL_INFO);\n\n    // Create Wi-Fi nodes (1 AP, 1 client)\n    NodeContainer wifiStaNode, wifiApNode;\n    wifiStaNode.Create(1);\n    wifiApNode.Create(1);\n\n    // Set up the Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Configure Wi-Fi devices\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up MAC layers\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-ssid\");\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set up mobility\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNode);\n    mobility.Install(wifiApNode);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNode);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterface = address.Assign(staDevice);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Create UDP server on the AP\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create UDP client on the station\n    UdpClientHelper udpClient(apInterface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple Ethernet network using CSMA in NS-3 with two nodes. Node 0 (sender) sends UDP packets to Node 1 (receiver) over a shared CSMA channel with a data rate of 100 Mbps and a delay of 2 milliseconds. Both nodes are assigned IP addresses in the 10.1.1.0/24 network, and the communication lasts for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/csma-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CsmaExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the CSMA channel\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(\"100Mbps\")));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n\n    NetDeviceContainer devices = csma.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server (Receiver) on Node 1\n    UdpServerHelper server(9);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP client (Sender) on Node 0\n    UdpClientHelper client(interfaces.GetAddress(1), 9);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(1)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ simulation using ns-3 to simulate a star topology with 3 nodes. There should be a central node connected to 2 other nodes with point-to-point links. Set the link data rate to 5Mbps and delay to 1ms. Install the Internet stack, assign IP addresses, and simulate packet transmission between the peripheral nodes via the central node. Use logging to track packet transmissions."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"StarTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"StarTopologyExample\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes: centralNode and two peripheral nodes\n    NodeContainer centralNode;\n    centralNode.Create(1);\n    \n    NodeContainer peripheralNodes;\n    peripheralNodes.Create(2);\n\n    // Create a point-to-point link helper\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    // Install devices and set up point-to-point links\n    NetDeviceContainer devicesCentralToNode1, devicesCentralToNode2;\n    devicesCentralToNode1 = pointToPoint.Install(centralNode.Get(0), peripheralNodes.Get(0)); // Central to Node 1\n    devicesCentralToNode2 = pointToPoint.Install(centralNode.Get(0), peripheralNodes.Get(1)); // Central to Node 2\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(centralNode);\n    stack.Install(peripheralNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfacesCentralToNode1, interfacesCentralToNode2;\n\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    interfacesCentralToNode1 = address.Assign(devicesCentralToNode1);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    interfacesCentralToNode2 = address.Assign(devicesCentralToNode2);\n\n    // Application: Sending packets from Node 1 to Node 2 via the central node\n    uint16_t port = 9; // Port for communication\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(interfacesCentralToNode2.GetAddress(1), port));\n    onoff.SetConstantRate(DataRate(\"2Mbps\"), 1024); // 2Mbps data rate, 1024-byte packets\n    ApplicationContainer app = onoff.Install(peripheralNodes.Get(0)); // Install on Node 1\n    app.Start(Seconds(1.0)); // Start at 1 second\n    app.Stop(Seconds(10.0)); // Stop at 10 seconds\n\n    // Set up a PacketSink on Node 2 to receive packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sink.Install(peripheralNodes.Get(1)); // Install sink on Node 2\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Enable routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 code that simulates a Wi-Fi network with backward compatibility between different 802.11 versions, where the access point (AP) and station (STA) use different Wi-Fi standards. Include a function that converts Wi-Fi version strings like \"80211a\" or \"80211ac\" into a corresponding Wi-Fi standard and physical band. Configure the AP and STA to use separate Wi-Fi standards, assign rate adaptation algorithms, and set up traffic generation from either the AP, STA, or both. The simulation should output the throughput and include node mobility, IP addressing, UDP server and client setup, and global routing table population."}, {"role": "assistant", "content": "#include \"ns3/attribute-container.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/tuple.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This is an example to show how to configure an IEEE 802.11 Wi-Fi\n// network where the AP and the station use different 802.11 standards.\n//\n// It outputs the throughput for a given configuration: user can specify\n// the 802.11 versions for the AP and the station as well as their rate\n// adaptation algorithms. It also allows to decide whether the station,\n// the AP or both has/have traffic to send.\n//\n// Example for an IEEE 802.11ac station sending traffic to an 802.11a AP using Ideal rate adaptation\n// algorithm:\n// ./ns3 run \"wifi-backward-compatibility --apVersion=80211a --staVersion=80211ac --staRaa=Ideal\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"wifi-backward-compatibility\");\n\n/**\n * Convert a string (e.g., \"80211a\") to a pair {WifiStandard, WifiPhyBand}\n *\n * \\param version The WiFi standard version.\n * \\return a pair of WifiStandard, WifiPhyBand\n */\nstd::pair<WifiStandard, WifiPhyBand>\nConvertStringToStandardAndBand(std::string version)\n{\n    WifiStandard standard = WIFI_STANDARD_80211a;\n    WifiPhyBand band = WIFI_PHY_BAND_5GHZ;\n    if (version == \"80211a\")\n    {\n        standard = WIFI_STANDARD_80211a;\n        band = WIFI_PHY_BAND_5GHZ;\n    }\n    else if (version == \"80211b\")\n    {\n        standard = WIFI_STANDARD_80211b;\n        band = WIFI_PHY_BAND_2_4GHZ;\n    }\n    else if (version == \"80211g\")\n    {\n        standard = WIFI_STANDARD_80211g;\n        band = WIFI_PHY_BAND_2_4GHZ;\n    }\n    else if (version == \"80211p\")\n    {\n        standard = WIFI_STANDARD_80211p;\n        band = WIFI_PHY_BAND_5GHZ;\n    }\n    else if (version == \"80211n_2_4GHZ\")\n    {\n        standard = WIFI_STANDARD_80211n;\n        band = WIFI_PHY_BAND_2_4GHZ;\n    }\n    else if (version == \"80211n_5GHZ\")\n    {\n        standard = WIFI_STANDARD_80211n;\n        band = WIFI_PHY_BAND_5GHZ;\n    }\n    else if (version == \"80211ac\")\n    {\n        standard = WIFI_STANDARD_80211ac;\n        band = WIFI_PHY_BAND_5GHZ;\n    }\n    else if (version == \"80211ax_2_4GHZ\")\n    {\n        standard = WIFI_STANDARD_80211ax;\n        band = WIFI_PHY_BAND_2_4GHZ;\n    }\n    else if (version == \"80211ax_5GHZ\")\n    {\n        standard = WIFI_STANDARD_80211ax;\n        band = WIFI_PHY_BAND_5GHZ;\n    }\n    return {standard, band};\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t payloadSize{1472}; // bytes\n    Time simulationTime{\"10s\"};\n    std::string apVersion{\"80211a\"};\n    std::string staVersion{\"80211n_5GHZ\"};\n    std::string apRaa{\"Minstrel\"};\n    std::string staRaa{\"MinstrelHt\"};\n    bool apHasTraffic{false};\n    bool staHasTraffic{true};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"apVersion\",\n                 \"The standard version used by the AP: 80211a, 80211b, 80211g, 80211p, \"\n                 \"80211n_2_4GHZ, 80211n_5GHZ, 80211ac, 80211ax_2_4GHZ or 80211ax_5GHZ\",\n                 apVersion);\n    cmd.AddValue(\"staVersion\",\n                 \"The standard version used by the station: 80211a, 80211b, 80211g, 80211_10MHZ, \"\n                 \"80211_5MHZ, 80211n_2_4GHZ, 80211n_5GHZ, 80211ac, 80211ax_2_4GHZ or 80211ax_5GHZ\",\n                 staVersion);\n    cmd.AddValue(\"apRaa\", \"Rate adaptation algorithm used by the AP\", apRaa);\n    cmd.AddValue(\"staRaa\", \"Rate adaptation algorithm used by the station\", staRaa);\n    cmd.AddValue(\"apHasTraffic\", \"Enable/disable traffic on the AP\", apHasTraffic);\n    cmd.AddValue(\"staHasTraffic\", \"Enable/disable traffic on the station\", staHasTraffic);\n    cmd.Parse(argc, argv);\n\n    NodeContainer wifiStaNode;\n    wifiStaNode.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    WifiHelper wifi;\n    Ssid ssid = Ssid(\"ns3\");\n    AttributeContainerValue<\n        TupleValue<UintegerValue, UintegerValue, EnumValue<WifiPhyBand>, UintegerValue>,\n        ';'>\n        channelValue;\n\n    const auto& [staStandard, staBand] = ConvertStringToStandardAndBand(staVersion);\n    wifi.SetStandard(staStandard);\n    wifi.SetRemoteStationManager(\"ns3::\" + staRaa + \"WifiManager\");\n\n    mac.SetType(\"ns3::StaWifiMac\", \"QosSupported\", BooleanValue(true), \"Ssid\", SsidValue(ssid));\n\n    // Workaround needed as long as we do not fully support channel bonding\n    uint16_t width = (staVersion == \"80211ac\" ? 20 : 0);\n    channelValue.Set(WifiPhy::ChannelSegments{{0, width, staBand, 0}});\n    phy.Set(\"ChannelSettings\", channelValue);\n\n    NetDeviceContainer staDevice;\n    staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n    const auto& [apStandard, apBand] = ConvertStringToStandardAndBand(apVersion);\n    wifi.SetStandard(apStandard);\n    wifi.SetRemoteStationManager(\"ns3::\" + apRaa + \"WifiManager\");\n\n    mac.SetType(\"ns3::ApWifiMac\", \"QosSupported\", BooleanValue(true), \"Ssid\", SsidValue(ssid));\n\n    // Workaround needed as long as we do not fully support channel bonding\n    width = (apVersion == \"80211ac\" ? 20 : 0);\n    channelValue.Set(WifiPhy::ChannelSegments{{0, width, apBand, 0}});\n    phy.Set(\"ChannelSettings\", channelValue);\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNode);\n\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNode);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staNodeInterface;\n    Ipv4InterfaceContainer apNodeInterface;\n\n    staNodeInterface = address.Assign(staDevice);\n    apNodeInterface = address.Assign(apDevice);\n\n    UdpServerHelper apServer(9);\n    ApplicationContainer apServerApp = apServer.Install(wifiApNode.Get(0));\n    apServerApp.Start(Seconds(0.0));\n    apServerApp.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper staServer(5001);\n    ApplicationContainer staServerApp = staServer.Install(wifiStaNode.Get(0));\n    staServerApp.Start(Seconds(0.0));\n    staServerApp.Stop(simulationTime + Seconds(1.0));\n\n    if (apHasTraffic)\n    {\n        UdpClientHelper apClient(staNodeInterface.GetAddress(0), 5001);\n        apClient.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n        apClient.SetAttribute(\"Interval\", TimeValue(Time(\"0.00001\")));   // packets/s\n        apClient.SetAttribute(\"PacketSize\", UintegerValue(payloadSize)); // bytes\n        ApplicationContainer apClientApp = apClient.Install(wifiApNode.Get(0));\n        apClientApp.Start(Seconds(1.0));\n        apClientApp.Stop(simulationTime + Seconds(1.0));\n    }\n\n    if (staHasTraffic)\n    {\n        UdpClientHelper staClient(apNodeInterface.GetAddress(0), 9);\n        staClient.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n        staClient.SetAttribute(\"Interval\", TimeValue(Time(\"0.00001\")));   // packets/s\n        staClient.SetAttribute(\"PacketSize\", UintegerValue(payloadSize)); // bytes\n        ApplicationContainer staClientApp = staClient.Install(wifiStaNode.Get(0));\n        staClientApp.Start(Seconds(1.0));\n        staClientApp.Stop(simulationTime + Seconds(1.0));\n    }\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    Simulator::Stop(simulationTime + Seconds(1.0));\n    Simulator::Run();\n\n    double rxBytes;\n    double throughput;\n    bool error = false;\n    if (apHasTraffic)\n    {\n        rxBytes = payloadSize * DynamicCast<UdpServer>(staServerApp.Get(0))->GetReceived();\n        throughput = (rxBytes * 8) / simulationTime.GetMicroSeconds(); // Mbit/s\n        std::cout << \"AP Throughput: \" << throughput << \" Mbit/s\" << std::endl;\n        if (throughput == 0)\n        {\n            error = true;\n        }\n    }\n    if (staHasTraffic)\n    {\n        rxBytes = payloadSize * DynamicCast<UdpServer>(apServerApp.Get(0))->GetReceived();\n        throughput = (rxBytes * 8) / simulationTime.GetMicroSeconds(); // Mbit/s\n        std::cout << \"STA Throughput: \" << throughput << \" Mbit/s\" << std::endl;\n        if (throughput == 0)\n        {\n            error = true;\n        }\n    }\n\n    Simulator::Destroy();\n\n    if (error)\n    {\n        NS_LOG_ERROR(\"No traffic received!\");\n        exit(1);\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple Point-to-Point (P2P) network with two nodes. The nodes should be connected via a P2P link with a data rate of 5 Mbps and a propagation delay of 2 milliseconds. Each node should have a unique IPv4 address in the 10.1.1.0/24 subnet. The second node should run a UDP echo server on port 9, while the first node acts as a client sending five packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure Point-to-Point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install P2P devices on nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP echo server on the second node\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP echo client on the first node\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a simple LTE network with one User Equipment (UE), one eNodeB (base station), and the Evolved Packet Core (EPC). The eNodeB should communicate with the UE using UDP. The UE should run a UDP server on port 9, and the eNodeB should send 1,000 UDP packets of 1024 bytes each, with a packet interval of 0.01 seconds. The simulation should run for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleLteExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleLteExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: UE (User Equipment), eNodeB (LTE base station), and EPC\n    NodeContainer ueNodes, enbNodes, epcNodes;\n    ueNodes.Create(1);\n    enbNodes.Create(1);\n    epcNodes.Create(1);\n\n    // Set up LTE helpers\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<EpcHelper> epcHelper = CreateObject<EpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    // Set up the eNodeB (base station) and UE\n    NetDeviceContainer ueDevices, enbDevices;\n    enbDevices = lteHelper->InstallEnbDevice(enbNodes);\n    ueDevices = lteHelper->InstallUeDevice(ueNodes);\n\n    // Install the internet stack (IP, TCP, UDP)\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    internet.Install(enbNodes);\n    internet.Install(epcNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface = ipv4.Assign(ueDevices);\n    Ipv4InterfaceContainer enbIpIface = ipv4.Assign(enbDevices);\n\n    // Attach UE to the eNodeB\n    lteHelper->Attach(ueDevices.Get(0), enbDevices.Get(0));\n\n    // Set up UDP server on the UE node (User Equipment)\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ueNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the eNodeB node\n    UdpClientHelper udpClient(ueIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(enbNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite me a code that simulates a mixed wired and wireless network topology using ns-3. The network should consist of multiple backbone routers connected by an ad hoc WiFi network, with each backbone router having a local 802.11 infrastructure network and being connected to a local LAN. The nodes should use TCP/IP stacks, with OLSR routing on the backbone network. There should be a UDP flow from a wired LAN node to a wireless STA in the last infrastructure network. Ensure the simulation parameters like number of backbone routers, LAN nodes, and wireless nodes can be configured via command line arguments. Additionally, set up mobility for the nodes, and configure options to generate packet traces and enable course change callbacks for the mobility models."}, {"role": "assistant", "content": "//\n// This ns-3 example demonstrates the use of helper functions to ease\n// the construction of simulation scenarios.\n//\n// The simulation topology consists of a mixed wired and wireless\n// scenario in which a hierarchical mobility model is used.\n//\n// The simulation layout consists of N backbone routers interconnected\n// by an ad hoc wifi network.\n// Each backbone router also has a local 802.11 network and is connected\n// to a local LAN.  An additional set of (K-1) nodes are connected to\n// this backbone.  Finally, a local LAN is connected to each router\n// on the backbone, with L-1 additional hosts.\n//\n// The nodes are populated with TCP/IP stacks, and OLSR unicast routing\n// on the backbone.  An example UDP transfer is shown.  The simulator\n// be configured to output tcpdumps or traces from different nodes.\n//\n//\n//          +--------------------------------------------------------+\n//          |                                                        |\n//          |              802.11 ad hoc, ns-2 mobility              |\n//          |                                                        |\n//          +--------------------------------------------------------+\n//                   |       o o o (N backbone routers)       |\n//               +--------+                               +--------+\n//     wired LAN | mobile |                     wired LAN | mobile |\n//    -----------| router |                    -----------| router |\n//               ---------                                ---------\n//                   |                                        |\n//          +----------------+                       +----------------+\n//          |     802.11     |                       |     802.11     |\n//          |   infra net    |                       |   infra net    |\n//          |   K-1 hosts    |                       |   K-1 hosts    |\n//          +----------------+                       +----------------+\n//\n// We'll send data from the first wired LAN node on the first wired LAN\n// to the last wireless STA on the last infrastructure net, thereby\n// causing packets to traverse CSMA to adhoc to infrastructure links\n//\n// Note that certain mobility patterns may cause packet forwarding\n// to fail (if nodes become disconnected)\n\n#include \"ns3/animation-interface.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/csma-helper.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/olsr-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/qos-txop.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\n//\n// Define logging keyword for this file\n//\nNS_LOG_COMPONENT_DEFINE(\"MixedWireless\");\n\n/**\n * This function will be used below as a trace sink, if the command-line\n * argument or default value \"useCourseChangeCallback\" is set to true\n *\n * \\param path The callback path.\n * \\param model The mobility model.\n */\nstatic void\nCourseChangeCallback(std::string path, Ptr<const MobilityModel> model)\n{\n    Vector position = model->GetPosition();\n    std::cout << \"CourseChange \" << path << \" x=\" << position.x << \", y=\" << position.y\n              << \", z=\" << position.z << std::endl;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    //\n    // First, we declare and initialize a few local variables that control some\n    // simulation parameters.\n    //\n    uint32_t backboneNodes = 10;\n    uint32_t infraNodes = 2;\n    uint32_t lanNodes = 2;\n    uint32_t stopTime = 20;\n    bool useCourseChangeCallback = false;\n\n    //\n    // Simulation defaults are typically set next, before command line\n    // arguments are parsed.\n    //\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", StringValue(\"1472\"));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(\"100kb/s\"));\n\n    //\n    // For convenience, we add the local variables to the command line argument\n    // system so that they can be overridden with flags such as\n    // \"--backboneNodes=20\"\n    //\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"backboneNodes\", \"number of backbone nodes\", backboneNodes);\n    cmd.AddValue(\"infraNodes\", \"number of leaf nodes\", infraNodes);\n    cmd.AddValue(\"lanNodes\", \"number of LAN nodes\", lanNodes);\n    cmd.AddValue(\"stopTime\", \"simulation stop time (seconds)\", stopTime);\n    cmd.AddValue(\"useCourseChangeCallback\",\n                 \"whether to enable course change tracing\",\n                 useCourseChangeCallback);\n\n    //\n    // The system global variables and the local values added to the argument\n    // system can be overridden by command line arguments by using this call.\n    //\n    cmd.Parse(argc, argv);\n\n    if (stopTime < 10)\n    {\n        std::cout << \"Use a simulation stop time >= 10 seconds\" << std::endl;\n        exit(1);\n    }\n    ///////////////////////////////////////////////////////////////////////////\n    //                                                                       //\n    // Construct the backbone                                                //\n    //                                                                       //\n    ///////////////////////////////////////////////////////////////////////////\n\n    //\n    // Create a container to manage the nodes of the adhoc (backbone) network.\n    // Later we'll create the rest of the nodes we'll need.\n    //\n    NodeContainer backbone;\n    backbone.Create(backboneNodes);\n    //\n    // Create the backbone wifi net devices and install them into the nodes in\n    // our container\n    //\n    WifiHelper wifi;\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate54Mbps\"));\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n    NetDeviceContainer backboneDevices = wifi.Install(wifiPhy, mac, backbone);\n\n    // We enable OLSR (which will be consulted at a higher priority than\n    // the global routing) on the backbone ad hoc nodes\n    NS_LOG_INFO(\"Enabling OLSR routing on all backbone nodes\");\n    OlsrHelper olsr;\n    //\n    // Add the IPv4 protocol stack to the nodes in our container\n    //\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(olsr); // has effect on the next Install ()\n    internet.Install(backbone);\n\n    //\n    // Assign IPv4 addresses to the device drivers (actually to the associated\n    // IPv4 interfaces) we just created.\n    //\n    Ipv4AddressHelper ipAddrs;\n    ipAddrs.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n    ipAddrs.Assign(backboneDevices);\n\n    //\n    // The ad-hoc network nodes need a mobility model so we aggregate one to\n    // each of the nodes we just finished building.\n    //\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\",\n                                  DoubleValue(20.0),\n                                  \"MinY\",\n                                  DoubleValue(20.0),\n                                  \"DeltaX\",\n                                  DoubleValue(20.0),\n                                  \"DeltaY\",\n                                  DoubleValue(20.0),\n                                  \"GridWidth\",\n                                  UintegerValue(5),\n                                  \"LayoutType\",\n                                  StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomDirection2dMobilityModel\",\n                              \"Bounds\",\n                              RectangleValue(Rectangle(-500, 500, -500, 500)),\n                              \"Speed\",\n                              StringValue(\"ns3::ConstantRandomVariable[Constant=2]\"),\n                              \"Pause\",\n                              StringValue(\"ns3::ConstantRandomVariable[Constant=0.2]\"));\n    mobility.Install(backbone);\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                                                                       //\n    // Construct the LANs                                                    //\n    //                                                                       //\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Reset the address base-- all of the CSMA networks will be in\n    // the \"172.16 address space\n    ipAddrs.SetBase(\"172.16.0.0\", \"255.255.255.0\");\n\n    for (uint32_t i = 0; i < backboneNodes; ++i)\n    {\n        NS_LOG_INFO(\"Configuring local area network for backbone node \" << i);\n        //\n        // Create a container to manage the nodes of the LAN.  We need\n        // two containers here; one with all of the new nodes, and one\n        // with all of the nodes including new and existing nodes\n        //\n        NodeContainer newLanNodes;\n        newLanNodes.Create(lanNodes - 1);\n        // Now, create the container with all nodes on this link\n        NodeContainer lan(backbone.Get(i), newLanNodes);\n        //\n        // Create the CSMA net devices and install them into the nodes in our\n        // collection.\n        //\n        CsmaHelper csma;\n        csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n        csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n        NetDeviceContainer lanDevices = csma.Install(lan);\n        //\n        // Add the IPv4 protocol stack to the new LAN nodes\n        //\n        internet.Install(newLanNodes);\n        //\n        // Assign IPv4 addresses to the device drivers (actually to the\n        // associated IPv4 interfaces) we just created.\n        //\n        ipAddrs.Assign(lanDevices);\n        //\n        // Assign a new network prefix for the next LAN, according to the\n        // network mask initialized above\n        //\n        ipAddrs.NewNetwork();\n        //\n        // The new LAN nodes need a mobility model so we aggregate one\n        // to each of the nodes we just finished building.\n        //\n        MobilityHelper mobilityLan;\n        Ptr<ListPositionAllocator> subnetAlloc = CreateObject<ListPositionAllocator>();\n        for (uint32_t j = 0; j < newLanNodes.GetN(); ++j)\n        {\n            subnetAlloc->Add(Vector(0.0, j * 10 + 10, 0.0));\n        }\n        mobilityLan.PushReferenceMobilityModel(backbone.Get(i));\n        mobilityLan.SetPositionAllocator(subnetAlloc);\n        mobilityLan.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n        mobilityLan.Install(newLanNodes);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                                                                       //\n    // Construct the mobile networks                                         //\n    //                                                                       //\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Reset the address base-- all of the 802.11 networks will be in\n    // the \"10.0\" address space\n    ipAddrs.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n\n    for (uint32_t i = 0; i < backboneNodes; ++i)\n    {\n        NS_LOG_INFO(\"Configuring wireless network for backbone node \" << i);\n        //\n        // Create a container to manage the nodes of the LAN.  We need\n        // two containers here; one with all of the new nodes, and one\n        // with all of the nodes including new and existing nodes\n        //\n        NodeContainer stas;\n        stas.Create(infraNodes - 1);\n        // Now, create the container with all nodes on this link\n        NodeContainer infra(backbone.Get(i), stas);\n        //\n        // Create an infrastructure network\n        //\n        WifiHelper wifiInfra;\n        WifiMacHelper macInfra;\n        wifiPhy.SetChannel(wifiChannel.Create());\n        // Create unique ssids for these networks\n        std::string ssidString(\"wifi-infra\");\n        std::stringstream ss;\n        ss << i;\n        ssidString += ss.str();\n        Ssid ssid = Ssid(ssidString);\n        // setup stas\n        macInfra.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n        NetDeviceContainer staDevices = wifiInfra.Install(wifiPhy, macInfra, stas);\n        // setup ap.\n        macInfra.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n        NetDeviceContainer apDevices = wifiInfra.Install(wifiPhy, macInfra, backbone.Get(i));\n        // Collect all of these new devices\n        NetDeviceContainer infraDevices(apDevices, staDevices);\n\n        // Add the IPv4 protocol stack to the nodes in our container\n        //\n        internet.Install(stas);\n        //\n        // Assign IPv4 addresses to the device drivers (actually to the associated\n        // IPv4 interfaces) we just created.\n        //\n        ipAddrs.Assign(infraDevices);\n        //\n        // Assign a new network prefix for each mobile network, according to\n        // the network mask initialized above\n        //\n        ipAddrs.NewNetwork();\n        //\n        // The new wireless nodes need a mobility model so we aggregate one\n        // to each of the nodes we just finished building.\n        //\n        Ptr<ListPositionAllocator> subnetAlloc = CreateObject<ListPositionAllocator>();\n        for (uint32_t j = 0; j < infra.GetN(); ++j)\n        {\n            subnetAlloc->Add(Vector(0.0, j, 0.0));\n        }\n        mobility.PushReferenceMobilityModel(backbone.Get(i));\n        mobility.SetPositionAllocator(subnetAlloc);\n        mobility.SetMobilityModel(\"ns3::RandomDirection2dMobilityModel\",\n                                  \"Bounds\",\n                                  RectangleValue(Rectangle(-10, 10, -10, 10)),\n                                  \"Speed\",\n                                  StringValue(\"ns3::ConstantRandomVariable[Constant=3]\"),\n                                  \"Pause\",\n                                  StringValue(\"ns3::ConstantRandomVariable[Constant=0.4]\"));\n        mobility.Install(stas);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                                                                       //\n    // Application configuration                                             //\n    //                                                                       //\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 10 Kb/s, between two nodes\n    // We'll send data from the first wired LAN node on the first wired LAN\n    // to the last wireless STA on the last infrastructure net, thereby\n    // causing packets to traverse CSMA to adhoc to infrastructure links\n\n    NS_LOG_INFO(\"Create Applications.\");\n    uint16_t port = 9; // Discard port (RFC 863)\n\n    // Let's make sure that the user does not define too few nodes\n    // to make this example work.  We need lanNodes > 1  and infraNodes > 1\n    NS_ASSERT(lanNodes > 1 && infraNodes > 1);\n    // We want the source to be the first node created outside of the backbone\n    // Conveniently, the variable \"backboneNodes\" holds this node index value\n    Ptr<Node> appSource = NodeList::GetNode(backboneNodes);\n    // We want the sink to be the last node created in the topology.\n    uint32_t lastNodeIndex =\n        backboneNodes + backboneNodes * (lanNodes - 1) + backboneNodes * (infraNodes - 1) - 1;\n    Ptr<Node> appSink = NodeList::GetNode(lastNodeIndex);\n    // Let's fetch the IP address of the last node, which is on Ipv4Interface 1\n    Ipv4Address remoteAddr = appSink->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal();\n\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", Address(InetSocketAddress(remoteAddr, port)));\n\n    ApplicationContainer apps = onoff.Install(appSource);\n    apps.Start(Seconds(3));\n    apps.Stop(Seconds(stopTime - 1));\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    apps = sink.Install(appSink);\n    apps.Start(Seconds(3));\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                                                                       //\n    // Tracing configuration                                                 //\n    //                                                                       //\n    ///////////////////////////////////////////////////////////////////////////\n\n    NS_LOG_INFO(\"Configure Tracing.\");\n    CsmaHelper csma;\n\n    //\n    // Let's set up some ns-2-like ascii traces, using another helper class\n    //\n    AsciiTraceHelper ascii;\n    Ptr<OutputStreamWrapper> stream = ascii.CreateFileStream(\"mixed-wireless.tr\");\n    wifiPhy.EnableAsciiAll(stream);\n    csma.EnableAsciiAll(stream);\n    internet.EnableAsciiIpv4All(stream);\n\n    // Csma captures in non-promiscuous mode\n    csma.EnablePcapAll(\"mixed-wireless\", false);\n    // pcap captures on the backbone wifi devices\n    wifiPhy.EnablePcap(\"mixed-wireless\", backboneDevices, false);\n    // pcap trace on the application data sink\n    wifiPhy.EnablePcap(\"mixed-wireless\", appSink->GetId(), 0);\n\n    if (useCourseChangeCallback)\n    {\n        Config::Connect(\"/NodeList/*/$ns3::MobilityModel/CourseChange\",\n                        MakeCallback(&CourseChangeCallback));\n    }\n\n    AnimationInterface anim(\"mixed-wireless.xml\");\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                                                                       //\n    // Run simulation                                                        //\n    //                                                                       //\n    ///////////////////////////////////////////////////////////////////////////\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Stop(Seconds(stopTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a mobile LTE network with two eNodeBs (base stations) and one user equipment (UE). The UE performs TCP data transfer while moving between the two eNodeBs. The simulation should demonstrate handover as the UE moves, and it should run for 10 seconds with a UDP server on the first eNodeB and a UDP client on the UE. The mobility of the UE should be modeled with a random walk between the eNodeBs. The LTE stack should be installed, and the handover should occur during the data transfer."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/epc-helper.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"LteTcpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: two eNodeBs (base stations) and one UE (user equipment)\n    NodeContainer eNodeBs, ueNodes;\n    eNodeBs.Create(2);\n    ueNodes.Create(1);\n\n    // Create EPC helper and LTE helper\n    Ptr<EpcHelper> epcHelper = CreateObject<EpcHelper>();\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n\n    // Install LTE stack\n    lteHelper->Install(eNodeBs);\n    lteHelper->Install(ueNodes);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(eNodeBs);\n\n    // Set mobility for UE to move between eNodeBs\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\");\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(50.0),\n                                  \"DeltaY\", DoubleValue(50.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.Install(ueNodes);\n\n    // Install Internet stack on UE\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n\n    // Assign IP addresses to the LTE interfaces\n    Ipv4InterfaceContainer ueIpIface = epcHelper->AssignUeIpv4Address(DevicesContainer(ueNodes));\n\n    // Install applications on UE and eNodeB\n    uint16_t port = 8080;\n    ApplicationContainer serverApp;\n    UdpServerHelper udpServer(port);\n    serverApp = udpServer.Install(eNodeBs.Get(0)); // eNodeB 1 as server\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    UdpClientHelper udpClient(ueIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp = udpClient.Install(ueNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Handover between two eNodeBs during the simulation\n    lteHelper->ActivateHandover(ueNodes.Get(0), eNodeBs.Get(0), eNodeBs.Get(1));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where multiple IoT devices communicate with a central server using a Low-Power Wireless Personal Area Network (6LoWPAN) over IEEE 802.15.4. The IoT devices should send UDP packets to the server periodically."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/sixlowpan-module.h\"\n#include \"ns3/lr-wpan-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SixLowpanIoTExample\");\n\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"IoT Server received a UDP packet from an IoT device!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"SixLowpanIoTExample\", LOG_LEVEL_INFO);\n\n    uint16_t port = 5000;\n\n    // Create nodes (IoT Devices + Server)\n    NodeContainer nodes;\n    nodes.Create(4);  // 3 IoT devices + 1 server\n\n    Ptr<Node> server = nodes.Get(3);\n\n    // Setup IEEE 802.15.4 (Low-Power Wireless)\n    LrWpanHelper lrWpan;\n    NetDeviceContainer lrDevices = lrWpan.Install(nodes);\n\n    // Enable 6LoWPAN over IEEE 802.15.4\n    SixLowPanHelper sixlowpan;\n    NetDeviceContainer sixlowpanDevices = sixlowpan.Install(lrDevices);\n\n    // Mobility model (static nodes)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IPv6 addresses\n    Ipv6AddressHelper ipv6;\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer interfaces = ipv6.Assign(sixlowpanDevices);\n\n    // Setup UDP Receiver (IoT Server)\n    Ptr<Socket> serverSocket = Socket::CreateSocket(server, UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(Inet6SocketAddress(Ipv6Address::GetAny(), port));\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Senders (IoT Devices)\n    for (uint32_t i = 0; i < 3; i++) {\n        Ptr<Socket> deviceSocket = Socket::CreateSocket(nodes.Get(i), UdpSocketFactory::GetTypeId());\n        Inet6SocketAddress serverAddress(interfaces.GetAddress(3, 1), port);\n\n        Simulator::Schedule(Seconds(1.0 + i), &Socket::SendTo, deviceSocket, Create<Packet>(64), 0, serverAddress);\n        Simulator::Schedule(Seconds(3.0 + i), &Socket::SendTo, deviceSocket, Create<Packet>(64), 0, serverAddress);\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(6.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a point-to-point network with two nodes in NS-3. Node 0 sends UDP packets to Node 1 starting at 2s and stopping at 10s. Use a data rate of 10Mbps, a delay of 5ms, and assign IP addresses starting with 192.168.1.0/24. The server on Node 1 starts at 1s and the simulation runs for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    // Install point-to-point devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 1 (Receiver)\n    uint16_t port = 12345;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 0 (Sender)\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a simple C++ program using the ns-3 simulation library to set up a mesh topology with four nodes. Configure the nodes to communicate using a Wi-Fi mesh network, assign them static positions in a 2x2 grid layout, and use UDP traffic to generate communication between the nodes. The simulation should run for 15 seconds, and basic statistics such as packet transmission and reception should be recorded. Additionally, enable PCAP tracing to capture the packet flow for analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"MeshTopology4Nodes\");\n\nint main (int argc, char *argv[])\n{\n    LogComponentEnable (\"MeshTopology4Nodes\", LOG_LEVEL_INFO);\n    \n    // Create 4 nodes\n    NodeContainer nodes;\n    nodes.Create (4);\n    \n    // Set up Wi-Fi mesh\n    WifiHelper wifi;\n    MeshHelper mesh;\n    mesh.SetStackInstaller (\"ns3::Dot11sStack\");  // 802.11s for mesh\n    mesh.SetSpreadInterfaceChannels (MeshHelper::SPREAD_CHANNELS);\n    mesh.SetMacType (\"RandomStart\", TimeValue (Seconds (0.1)));\n    NetDeviceContainer meshDevices = mesh.Install (wifi, nodes);\n    \n    // Position nodes in a 2x2 grid layout\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                   \"MinX\", DoubleValue (0.0),\n                                   \"MinY\", DoubleValue (0.0),\n                                   \"DeltaX\", DoubleValue (50.0),   // X distance between nodes\n                                   \"DeltaY\", DoubleValue (50.0),   // Y distance between nodes\n                                   \"GridWidth\", UintegerValue (2), // Two columns for 2x2 grid\n                                   \"LayoutType\", StringValue (\"RowFirst\"));\n    mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install (nodes);\n    \n    // Install internet stack\n    InternetStackHelper internet;\n    internet.Install (nodes);\n    \n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase (\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign (meshDevices);\n    \n    // Create UDP Echo server on node 0\n    UdpEchoServerHelper echoServer (9);  // Port number\n    ApplicationContainer serverApps = echoServer.Install (nodes.Get (0));\n    serverApps.Start (Seconds (1.0));\n    serverApps.Stop (Seconds (15.0));\n    \n    // Create UDP Echo client on node 1 to send data to node 0\n    UdpEchoClientHelper echoClient (interfaces.GetAddress (0), 9);\n    echoClient.SetAttribute (\"MaxPackets\", UintegerValue (20));\n    echoClient.SetAttribute (\"Interval\", TimeValue (Seconds (1.0)));\n    echoClient.SetAttribute (\"PacketSize\", UintegerValue (1024));\n    ApplicationContainer clientApps = echoClient.Install (nodes.Get (1));\n    clientApps.Start (Seconds (2.0));\n    clientApps.Stop (Seconds (15.0));\n    \n    // Create another UDP Echo client on node 2 to send data to node 3\n    UdpEchoClientHelper echoClient2 (interfaces.GetAddress (3), 9);\n    echoClient2.SetAttribute (\"MaxPackets\", UintegerValue (20));\n    echoClient2.SetAttribute (\"Interval\", TimeValue (Seconds (1.0)));\n    echoClient2.SetAttribute (\"PacketSize\", UintegerValue (1024));\n    ApplicationContainer clientApps2 = echoClient2.Install (nodes.Get (2));\n    clientApps2.Start (Seconds (3.0));\n    clientApps2.Stop (Seconds (15.0));\n    \n    // Enable PCAP tracing to capture packet flow\n    wifi.EnablePcapAll (\"mesh-topology-4-nodes\");\n\n    // Run the simulation\n    Simulator::Run ();\n    \n    // Print basic statistics\n    std::cout << \"Mesh simulation with 4 nodes finished.\" << std::endl;\n\n    Simulator::Destroy ();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a wired network with two hosts connected via Point-to-Point links. The link should have a data rate of 5 Mbps and a delay of 2 ms. The first host (Node 0) should act as a TCP server on port 8080, while the second host (Node 1) should act as a TCP client, sending 1,000,000 bytes of data. The simulation should start at 1 second for the server and 2 seconds for the client, running for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWiredNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes (Hosts)\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the Point-to-Point link between the two hosts\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack (TCP/IP)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a TCP server on Node 0\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper tcpSink(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = tcpSink.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up a TCP client on Node 1\n    BulkSendHelper tcpClient(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(0), port));\n    tcpClient.SetAttribute(\"MaxBytes\", UintegerValue(1000000));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a WiFi network with one access point (AP) and three station (STA) nodes. The AP should act as a UDP server on port 4000, while the station nodes should be UDP clients sending packets at 512 bytes every 10ms. The network should use 802.11g WiFi, and the STAs should have random mobility within a 50x50 area. The simulation should last 10 seconds, with PCAP tracing enabled for the AP."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WiFiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"WiFiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: 1 Access Point (AP) and 3 Stations (STA)\n    NodeContainer wifiStaNodes, wifiApNode;\n    wifiStaNodes.Create(3);\n    wifiApNode.Create(1);\n\n    // Set up WiFi PHY and MAC layer\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211g);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Set up STAs (Stations)\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Set up AP (Access Point)\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set mobility for AP and STAs\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(wifiStaNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Set up a UDP server on the Access Point\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP clients on the stations\n    UdpClientHelper udpClient(apInterface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < wifiStaNodes.GetN(); ++i)\n    {\n        clientApps.Add(udpClient.Install(wifiStaNodes.Get(i)));\n    }\n\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable packet capture for analysis\n    phy.EnablePcap(\"wifi-udp\", apDevice.Get(0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script for a wired point-to-point network with two nodes, connected by a link with a data rate of 5 Mbps and 2 ms delay. The first node should send TCP traffic using a BulkSend application, and the second node should act as a TCP receiver (sink). The receiver should start at 1 second, and the sender should start at 2 seconds. The simulation should run for 10 seconds. The TCP sink should listen on port 9, and the BulkSend application should send unlimited data."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up a point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a TCP receiver (Sink) on Node 1\n    uint16_t port = 9;\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\",\n                                InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sinkHelper.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Set up a TCP sender on Node 0\n    BulkSendHelper sender(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(interfaces.GetAddress(1), port));\n    sender.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n    ApplicationContainer senderApp = sender.Install(nodes.Get(0));\n    senderApp.Start(Seconds(2.0));\n    senderApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that demonstrates a wireless network with Wi-Fi communication between three nodes. One node acts as a Wi-Fi access point (AP), while the other two are Wi-Fi stations (STA) communicating through the AP. The simulation will include the setup of Wi-Fi standards, Internet stack installation, and enable NetAnim visualization to capture the network behavior and packet exchanges."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiNetAnimExample\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"WifiNetAnimExample\", LOG_LEVEL_INFO);\n\n    // Configure the default Wi-Fi standard\n    std::string phyMode(\"DsssRate1Mbps\");\n    double simulationTime = 10.0; // Simulation time in seconds\n\n    // Create 3 nodes: 1 Access Point (AP) and 2 Stations (STAs)\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Set up the Wi-Fi PHY and MAC layers\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\", \"DataMode\", StringValue(phyMode), \"ControlMode\", StringValue(phyMode));\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Set up STA MAC and devices\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Set up AP MAC and devices\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Configure mobility for the nodes\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Set up UDP echo server on the AP node\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Set up UDP echo client on one STA node\n    UdpEchoClientHelper echoClient(apInterface.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(wifiStaNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Set up NetAnim for visualization\n    AnimationInterface anim(\"wifi_netanim.xml\");\n\n    // Set constant positions for NetAnim visualization\n    anim.SetConstantPosition(wifiStaNodes.Get(0), 0, 0);  // STA 1\n    anim.SetConstantPosition(wifiStaNodes.Get(1), 5, 0);  // STA 2\n    anim.SetConstantPosition(wifiApNode.Get(0), 2.5, 5);  // AP\n\n    // Enable packet metadata in NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate Split Horizon in a simple network using Distance Vector (DV) routing in NS-3. The network consists of three nodes arranged in a linear topology, where Node A is connected to Node B, and Node B is connected to Node C. Use Distance Vector routing to allow traffic to flow between the nodes. Demonstrate that the Split Horizon rule is preventing routing loops by ensuring that routes are not advertised back to the node from which they were learned."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/distance-vector-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SplitHorizonSimulation\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for the components involved\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes: A, B, C\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Create point-to-point links between A-B and B-C\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install links\n    NetDeviceContainer ab = p2p.Install(nodes.Get(0), nodes.Get(1)); // Link A-B\n    NetDeviceContainer bc = p2p.Install(nodes.Get(1), nodes.Get(2)); // Link B-C\n\n    // Install Internet stack (with Distance Vector and Split Horizon)\n    InternetStackHelper internet;\n    DistanceVectorHelper dvRouting;\n    dvRouting.Set(\"SplitHorizon\", BooleanValue(true)); // Enabling Split Horizon\n    internet.SetRoutingHelper(dvRouting);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer abIf = ipv4.Assign(ab); // A-B\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer bcIf = ipv4.Assign(bc); // B-C\n\n    // Create UDP echo server on node C\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(2)); // C as server\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Create UDP echo client on node A\n    UdpEchoClientHelper echoClient(bcIf.GetAddress(1), 9); // Sending to C\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0)); // A as client\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable pcap tracing to observe packet flow\n    p2p.EnablePcapAll(\"split-horizon\");\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate C++ code implementing a basic Wi-Fi sender and receiver application using the ns-3 simulator. The sender transmits a defined number of packets at regular intervals, while the receiver listens for these packets, calculates statistics like delay, and logs relevant information. The sender should utilize attributes such as packet size, destination address, port, and interval. The receiver should have attributes like the listening port and must handle incoming packets by tracing timestamps to calculate the delay. Both sender and receiver must be derived from the `Application` class and include necessary ns-3 modules."}, {"role": "assistant", "content": "#include \"wifi-example-apps.h\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/stats-module.h\"\n\n#include <ostream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WiFiDistanceApps\");\n\n// ==============================================\n// SENDER\n// ==============================================\n\nTypeId\nSender::GetTypeId()\n{\n    static TypeId tid = TypeId(\"Sender\")\n                            .SetParent<Application>()\n                            .AddConstructor<Sender>()\n                            .AddAttribute(\"PacketSize\",\n                                          \"The size of packets transmitted.\",\n                                          UintegerValue(64),\n                                          MakeUintegerAccessor(&Sender::m_packetSize),\n                                          MakeUintegerChecker<uint32_t>(1))\n                            .AddAttribute(\"Destination\",\n                                          \"Target host address.\",\n                                          Ipv4AddressValue(\"255.255.255.255\"),\n                                          MakeIpv4AddressAccessor(&Sender::m_destAddr),\n                                          MakeIpv4AddressChecker())\n                            .AddAttribute(\"Port\",\n                                          \"Destination app port.\",\n                                          UintegerValue(1603),\n                                          MakeUintegerAccessor(&Sender::m_destPort),\n                                          MakeUintegerChecker<uint32_t>())\n                            .AddAttribute(\"NumPackets\",\n                                          \"Total number of packets to send.\",\n                                          UintegerValue(30),\n                                          MakeUintegerAccessor(&Sender::m_nPackets),\n                                          MakeUintegerChecker<uint32_t>(1))\n                            .AddAttribute(\"Interval\",\n                                          \"Delay between transmissions.\",\n                                          StringValue(\"ns3::ConstantRandomVariable[Constant=0.5]\"),\n                                          MakePointerAccessor(&Sender::m_interval),\n                                          MakePointerChecker<RandomVariableStream>())\n                            .AddTraceSource(\"Tx\",\n                                            \"A new packet is created and is sent\",\n                                            MakeTraceSourceAccessor(&Sender::m_txTrace),\n                                            \"ns3::Packet::TracedCallback\");\n    return tid;\n}\n\nSender::Sender()\n{\n    NS_LOG_FUNCTION_NOARGS();\n    m_interval = CreateObject<ConstantRandomVariable>();\n}\n\nSender::~Sender()\n{\n    NS_LOG_FUNCTION_NOARGS();\n}\n\nvoid\nSender::DoDispose()\n{\n    NS_LOG_FUNCTION_NOARGS();\n\n    m_socket = nullptr;\n    // chain up\n    Application::DoDispose();\n}\n\nvoid\nSender::StartApplication()\n{\n    NS_LOG_FUNCTION_NOARGS();\n\n    if (!m_socket)\n    {\n        Ptr<SocketFactory> socketFactory =\n            GetNode()->GetObject<SocketFactory>(UdpSocketFactory::GetTypeId());\n        m_socket = socketFactory->CreateSocket();\n        m_socket->Bind();\n    }\n\n    m_count = 0;\n\n    Simulator::Cancel(m_sendEvent);\n    m_sendEvent = Simulator::ScheduleNow(&Sender::SendPacket, this);\n}\n\nvoid\nSender::StopApplication()\n{\n    NS_LOG_FUNCTION_NOARGS();\n    Simulator::Cancel(m_sendEvent);\n}\n\nvoid\nSender::SendPacket()\n{\n    // NS_LOG_FUNCTION_NOARGS();\n    NS_LOG_INFO(\"Sending packet at \" << Simulator::Now() << \" to \" << m_destAddr);\n\n    Ptr<Packet> packet = Create<Packet>(m_packetSize);\n\n    TimestampTag timestamp;\n    timestamp.SetTimestamp(Simulator::Now());\n    packet->AddByteTag(timestamp);\n\n    // Could connect the socket since the address never changes; using SendTo\n    // here simply because all of the standard apps do not.\n    m_socket->SendTo(packet, 0, InetSocketAddress(m_destAddr, m_destPort));\n\n    // Report the event to the trace.\n    m_txTrace(packet);\n\n    if (++m_count < m_nPackets)\n    {\n        m_sendEvent =\n            Simulator::Schedule(Seconds(m_interval->GetValue()), &Sender::SendPacket, this);\n    }\n}\n\n// ==============================================\n// RECEIVER\n// ==============================================\n\nTypeId\nReceiver::GetTypeId()\n{\n    static TypeId tid = TypeId(\"Receiver\")\n                            .SetParent<Application>()\n                            .AddConstructor<Receiver>()\n                            .AddAttribute(\"Port\",\n                                          \"Listening port.\",\n                                          UintegerValue(1603),\n                                          MakeUintegerAccessor(&Receiver::m_port),\n                                          MakeUintegerChecker<uint32_t>());\n    return tid;\n}\n\nReceiver::Receiver()\n{\n    NS_LOG_FUNCTION_NOARGS();\n}\n\nReceiver::~Receiver()\n{\n    NS_LOG_FUNCTION_NOARGS();\n}\n\nvoid\nReceiver::DoDispose()\n{\n    NS_LOG_FUNCTION_NOARGS();\n\n    m_socket = nullptr;\n    // chain up\n    Application::DoDispose();\n}\n\nvoid\nReceiver::StartApplication()\n{\n    NS_LOG_FUNCTION_NOARGS();\n\n    if (!m_socket)\n    {\n        Ptr<SocketFactory> socketFactory =\n            GetNode()->GetObject<SocketFactory>(UdpSocketFactory::GetTypeId());\n        m_socket = socketFactory->CreateSocket();\n        InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), m_port);\n        m_socket->Bind(local);\n    }\n\n    m_socket->SetRecvCallback(MakeCallback(&Receiver::Receive, this));\n}\n\nvoid\nReceiver::StopApplication()\n{\n    NS_LOG_FUNCTION_NOARGS();\n\n    if (m_socket)\n    {\n        m_socket->SetRecvCallback(MakeNullCallback<void, Ptr<Socket>>());\n    }\n}\n\nvoid\nReceiver::SetCounter(Ptr<CounterCalculator<>> calc)\n{\n    m_calc = calc;\n}\n\nvoid\nReceiver::SetDelayTracker(Ptr<TimeMinMaxAvgTotalCalculator> delay)\n{\n    m_delay = delay;\n}\n\nvoid\nReceiver::Receive(Ptr<Socket> socket)\n{\n    // NS_LOG_FUNCTION (this << socket << packet << from);\n\n    Ptr<Packet> packet;\n    Address from;\n    while ((packet = socket->RecvFrom(from)))\n    {\n        if (InetSocketAddress::IsMatchingType(from))\n        {\n            NS_LOG_INFO(\"Received \" << packet->GetSize() << \" bytes from \"\n                                    << InetSocketAddress::ConvertFrom(from).GetIpv4());\n        }\n\n        TimestampTag timestamp;\n        // Should never not be found since the sender is adding it, but\n        // you never know.\n        if (packet->FindFirstMatchingByteTag(timestamp))\n        {\n            Time tx = timestamp.GetTimestamp();\n\n            if (m_delay)\n            {\n                m_delay->Update(Simulator::Now() - tx);\n            }\n        }\n\n        if (m_calc)\n        {\n            m_calc->Update();\n        }\n    }\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a simple TCP communication between two nodes. One node runs a TCP server on port 8080, and the other node acts as a TCP client. The client sends 10 TCP packets of 1024 bytes each, with a packet interval of 1 second. The simulation runs for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleTcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes: one for the TCP client, one for the TCP server\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Install internet stack (IP, TCP, UDP)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Set up TCP server on the second node\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on the first node\n    InetSocketAddress remoteAddress = InetSocketAddress(Ipv4Address(\"10.1.1.2\"), port);\n    TcpClientHelper tcpClient(remoteAddress);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(nodes.Get(0)->GetDevice(0));\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    ipv4.Assign(nodes.Get(1)->GetDevice(0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Wi-Fi network with one Access Point (AP) and three Stations (STAs). A UDP server should be installed on the Access Point, and a UDP client should be installed on one of the stations. The stations should have random mobility while the Access Point remains stationary. The simulation should run for 10 seconds, and the Wi-Fi protocol should be used with AarfWifiManager. The link should have a constant position for the AP and random walk mobility for the STAs. The UDP client sends packets to the UDP server during the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"WifiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: one AP and three STAs\n    NodeContainer wifiNodes;\n    wifiNodes.Create(4); // 1 AP and 3 STAs\n\n    // Set up Wi-Fi Helper\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up Wi-Fi MAC and PHY attributes\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns3-ssid\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices = wifi.Install(wifiPhy, wifiMac, wifiNodes.Get(1, 2, 3));\n\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(wifiPhy, wifiMac, wifiNodes.Get(0));\n\n    // Set up mobility model for AP and STAs\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes.Get(0)); // AP position\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\");\n    mobility.Install(wifiNodes.Get(1, 2, 3)); // STA positions\n\n    // Install Internet stack on all nodes\n    InternetStackHelper internet;\n    internet.Install(wifiNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = ipv4.Assign(apDevice);\n\n    // Set up UDP server on the Access Point\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiNodes.Get(0)); // AP as server\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on one of the STAs\n    UdpClientHelper udpClient(apInterface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(wifiNodes.Get(1)); // STA as client\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for an LTE network with a single eNodeB and two UEs. The UEs should be assigned IPv4 addresses via an EPC core. The first UE should act as a UDP client sending two packets of 512 bytes each to the second UE, which should act as a UDP server on port 9. The nodes should be placed in a grid layout, and the simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n\n    NodeContainer ueNodes, enbNodes;\n    ueNodes.Create(2);  // Two UEs (User Devices)\n    enbNodes.Create(1); // One eNodeB (Base Station)\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(enbNodes);\n\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.Install(ueNodes);\n\n    NetDeviceContainer enbLteDevices = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueLteDevices = lteHelper->InstallUeDevice(ueNodes);\n\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n\n    Ipv4InterfaceContainer ueIpInterfaces = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLteDevices));\n\n    lteHelper->Attach(ueLteDevices, enbLteDevices.Get(0));\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(ueNodes.Get(1)); // Second UE is the server\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(ueIpInterfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(2));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(ueNodes.Get(0)); // First UE is the client\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using ns-3 that simulates two hidden stations in an 802.11n Wi-Fi network with MPDU aggregation support. The simulation should allow the user to specify whether RTS/CTS is enabled and control the number of aggregated MPDUs via command-line arguments. The program should set up a network topology with one access point (AP) and two stations (n1 and n2), where the stations are hidden from each other due to limited wireless range. The payload size, simulation time, and expected throughput bounds can also be adjusted via command-line arguments. The stations send UDP traffic to the AP, and the simulation logs throughput and generates trace files (PCAP and ASCII)."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/rng-seed-manager.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This example considers two hidden stations in an 802.11n network which supports MPDU aggregation.\n// The user can specify whether RTS/CTS is used and can set the number of aggregated MPDUs.\n//\n// Example: ./ns3 run \"wifi-simple-ht-hidden-stations --enableRts=1 --nMpdus=8\"\n//\n// Network topology:\n//\n//   Wifi 192.168.1.0\n//\n//        AP\n//   *    *    *\n//   |    |    |\n//   n1   n2   n3\n//\n// Packets in this simulation belong to BestEffort Access Class (AC_BE).\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimplesHtHiddenStations\");\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t payloadSize{1472}; // bytes\n    Time simulationTime{\"10s\"};\n    uint32_t nMpdus{1};\n    uint32_t maxAmpduSize{0};\n    bool enableRts{false};\n    double minExpectedThroughput{0};\n    double maxExpectedThroughput{0};\n\n    RngSeedManager::SetSeed(1);\n    RngSeedManager::SetRun(7);\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nMpdus\", \"Number of aggregated MPDUs\", nMpdus);\n    cmd.AddValue(\"payloadSize\", \"Payload size in bytes\", payloadSize);\n    cmd.AddValue(\"enableRts\", \"Enable RTS/CTS\", enableRts);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"minExpectedThroughput\",\n                 \"if set, simulation fails if the lowest throughput is below this value\",\n                 minExpectedThroughput);\n    cmd.AddValue(\"maxExpectedThroughput\",\n                 \"if set, simulation fails if the highest throughput is above this value\",\n                 maxExpectedThroughput);\n    cmd.Parse(argc, argv);\n\n    if (!enableRts)\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"999999\"));\n    }\n    else\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"0\"));\n    }\n\n    // Set the maximum size for A-MPDU with regards to the payload size\n    maxAmpduSize = nMpdus * (payloadSize + 200);\n\n    // Set the maximum wireless range to 5 meters in order to reproduce a hidden nodes scenario,\n    // i.e. the distance between hidden stations is larger than 5 meters\n    Config::SetDefault(\"ns3::RangePropagationLossModel::MaxRange\", DoubleValue(5));\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    channel.AddPropagationLoss(\n        \"ns3::RangePropagationLossModel\"); // wireless range limited to 5 meters!\n\n    YansWifiPhyHelper phy;\n    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    phy.SetChannel(channel.Create());\n    phy.Set(\"ChannelSettings\", StringValue(\"{36, 0, BAND_5GHZ, 0}\"));\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"HtMcs7\"),\n                                 \"ControlMode\",\n                                 StringValue(\"HtMcs0\"));\n    WifiMacHelper mac;\n\n    Ssid ssid = Ssid(\"simple-mpdu-aggregation\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/BE_MaxAmpduSize\",\n                UintegerValue(maxAmpduSize));\n\n    int64_t streamNumber = 20;\n    streamNumber += WifiHelper::AssignStreams(apDevice, streamNumber);\n    streamNumber += WifiHelper::AssignStreams(staDevices, streamNumber);\n\n    // Setting mobility model\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n    // AP is between the two stations, each station being located at 5 meters from the AP.\n    // The distance between the two stations is thus equal to 10 meters.\n    // Since the wireless range is limited to 5 meters, the two stations are hidden from each other.\n    positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(10.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNodes);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n    streamNumber += stack.AssignStreams(wifiApNode, streamNumber);\n    streamNumber += stack.AssignStreams(wifiStaNodes, streamNumber);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterface;\n    StaInterface = address.Assign(staDevices);\n    Ipv4InterfaceContainer ApInterface;\n    ApInterface = address.Assign(apDevice);\n\n    // Setting applications\n    uint16_t port = 9;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiApNode);\n    serverApp.Start(Seconds(0.0));\n    serverApp.Stop(simulationTime + Seconds(1.0));\n    streamNumber += server.AssignStreams(wifiApNode, streamNumber);\n\n    UdpClientHelper client(ApInterface.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    client.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    // Saturated UDP traffic from stations to AP\n    ApplicationContainer clientApp1 = client.Install(wifiStaNodes);\n    clientApp1.Start(Seconds(1.0));\n    clientApp1.Stop(simulationTime + Seconds(1.0));\n    streamNumber += client.AssignStreams(wifiStaNodes, streamNumber);\n\n    phy.EnablePcap(\"SimpleHtHiddenStations_Ap\", apDevice.Get(0));\n    phy.EnablePcap(\"SimpleHtHiddenStations_Sta1\", staDevices.Get(0));\n    phy.EnablePcap(\"SimpleHtHiddenStations_Sta2\", staDevices.Get(1));\n\n    AsciiTraceHelper ascii;\n    phy.EnableAsciiAll(ascii.CreateFileStream(\"SimpleHtHiddenStations.tr\"));\n\n    Simulator::Stop(simulationTime + Seconds(1.0));\n\n    Simulator::Run();\n\n    double totalPacketsThrough = DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n\n    Simulator::Destroy();\n\n    auto throughput = totalPacketsThrough * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s\" << '\\n';\n    if (throughput < minExpectedThroughput ||\n        (maxExpectedThroughput > 0 && throughput > maxExpectedThroughput))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 network simulation library that defines a simple RIP routing topology. The network consists of nodes SRC and DST, connected via four routers: A, B, C, and D. Configure each router and specify that all network links have a cost of 1, except for the link between routers C and D, which has a cost of 10. Enable split horizon routing with Poison Reverse and allow command-line arguments for verbosity, routing table printing, and ping visibility. The network should simulate link failure between routers B and D at 40 seconds, followed by recovery after 44 seconds. The program should print routing tables at regular intervals and optionally display ping results."}, {"role": "assistant", "content": "// Network topology\n//\n//    SRC\n//     |<=== source network\n//     A-----B\n//      \\   / \\   all networks have cost 1, except\n//       \\ /  |   for the direct link from C to D, which\n//        C  /    has cost 10\n//        | /\n//        |/\n//        D\n//        |<=== target network\n//       DST\n//\n//\n// A, B, C and D are RIPng routers.\n// A and D are configured with static addresses.\n// SRC and DST will exchange packets.\n//\n// After about 3 seconds, the topology is built, and Echo Reply will be received.\n// After 40 seconds, the link between B and D will break, causing a route failure.\n// After 44 seconds from the failure, the routers will recovery from the failure.\n// Split Horizoning should affect the recovery time, but it is not. See the manual\n// for an explanation of this effect.\n//\n// If \"showPings\" is enabled, the user will see:\n// 1) if the ping has been acknowledged\n// 2) if a Destination Unreachable has been received by the sender\n// 3) nothing, when the Echo Request has been received by the destination but\n//    the Echo Reply is unable to reach the sender.\n// Examining the .pcap files with Wireshark can confirm this effect.\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-routing-table-entry.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RipSimpleRouting\");\n\nvoid\nTearDownLink(Ptr<Node> nodeA, Ptr<Node> nodeB, uint32_t interfaceA, uint32_t interfaceB)\n{\n    nodeA->GetObject<Ipv4>()->SetDown(interfaceA);\n    nodeB->GetObject<Ipv4>()->SetDown(interfaceB);\n}\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n    bool printRoutingTables = false;\n    bool showPings = false;\n    std::string SplitHorizon(\"PoisonReverse\");\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.AddValue(\"printRoutingTables\",\n                 \"Print routing tables at 30, 60 and 90 seconds\",\n                 printRoutingTables);\n    cmd.AddValue(\"showPings\", \"Show Ping reception\", showPings);\n    cmd.AddValue(\"splitHorizonStrategy\",\n                 \"Split Horizon strategy to use (NoSplitHorizon, SplitHorizon, PoisonReverse)\",\n                 SplitHorizon);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnableAll(LogLevel(LOG_PREFIX_TIME | LOG_PREFIX_NODE));\n        LogComponentEnable(\"RipSimpleRouting\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"Rip\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv4Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv4L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv4L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"ArpCache\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ping\", LOG_LEVEL_ALL);\n    }\n\n    if (SplitHorizon == \"NoSplitHorizon\")\n    {\n        Config::SetDefault(\"ns3::Rip::SplitHorizon\", EnumValue(Rip::NO_SPLIT_HORIZON));\n    }\n    else if (SplitHorizon == \"SplitHorizon\")\n    {\n        Config::SetDefault(\"ns3::Rip::SplitHorizon\", EnumValue(Rip::SPLIT_HORIZON));\n    }\n    else\n    {\n        Config::SetDefault(\"ns3::Rip::SplitHorizon\", EnumValue(Rip::POISON_REVERSE));\n    }\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> src = CreateObject<Node>();\n    Names::Add(\"SrcNode\", src);\n    Ptr<Node> dst = CreateObject<Node>();\n    Names::Add(\"DstNode\", dst);\n    Ptr<Node> a = CreateObject<Node>();\n    Names::Add(\"RouterA\", a);\n    Ptr<Node> b = CreateObject<Node>();\n    Names::Add(\"RouterB\", b);\n    Ptr<Node> c = CreateObject<Node>();\n    Names::Add(\"RouterC\", c);\n    Ptr<Node> d = CreateObject<Node>();\n    Names::Add(\"RouterD\", d);\n    NodeContainer net1(src, a);\n    NodeContainer net2(a, b);\n    NodeContainer net3(a, c);\n    NodeContainer net4(b, c);\n    NodeContainer net5(c, d);\n    NodeContainer net6(b, d);\n    NodeContainer net7(d, dst);\n    NodeContainer routers(a, b, c, d);\n    NodeContainer nodes(src, dst);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer ndc1 = csma.Install(net1);\n    NetDeviceContainer ndc2 = csma.Install(net2);\n    NetDeviceContainer ndc3 = csma.Install(net3);\n    NetDeviceContainer ndc4 = csma.Install(net4);\n    NetDeviceContainer ndc5 = csma.Install(net5);\n    NetDeviceContainer ndc6 = csma.Install(net6);\n    NetDeviceContainer ndc7 = csma.Install(net7);\n\n    NS_LOG_INFO(\"Create IPv4 and routing\");\n    RipHelper ripRouting;\n\n    // Rule of thumb:\n    // Interfaces are added sequentially, starting from 0\n    // However, interface 0 is always the loopback...\n    ripRouting.ExcludeInterface(a, 1);\n    ripRouting.ExcludeInterface(d, 3);\n\n    ripRouting.SetInterfaceMetric(c, 3, 10);\n    ripRouting.SetInterfaceMetric(d, 1, 10);\n\n    Ipv4ListRoutingHelper listRH;\n    listRH.Add(ripRouting, 0);\n    //  Ipv4StaticRoutingHelper staticRh;\n    //  listRH.Add (staticRh, 5);\n\n    InternetStackHelper internet;\n    internet.SetIpv6StackInstall(false);\n    internet.SetRoutingHelper(listRH);\n    internet.Install(routers);\n\n    InternetStackHelper internetNodes;\n    internetNodes.SetIpv6StackInstall(false);\n    internetNodes.Install(nodes);\n\n    // Assign addresses.\n    // The source and destination networks have global addresses\n    // The \"core\" network just needs link-local addresses for routing.\n    // We assign global addresses to the routers as well to receive\n    // ICMPv6 errors.\n    NS_LOG_INFO(\"Assign IPv4 Addresses.\");\n    Ipv4AddressHelper ipv4;\n\n    ipv4.SetBase(Ipv4Address(\"10.0.0.0\"), Ipv4Mask(\"255.255.255.0\"));\n    Ipv4InterfaceContainer iic1 = ipv4.Assign(ndc1);\n\n    ipv4.SetBase(Ipv4Address(\"10.0.1.0\"), Ipv4Mask(\"255.255.255.0\"));\n    Ipv4InterfaceContainer iic2 = ipv4.Assign(ndc2);\n\n    ipv4.SetBase(Ipv4Address(\"10.0.2.0\"), Ipv4Mask(\"255.255.255.0\"));\n    Ipv4InterfaceContainer iic3 = ipv4.Assign(ndc3);\n\n    ipv4.SetBase(Ipv4Address(\"10.0.3.0\"), Ipv4Mask(\"255.255.255.0\"));\n    Ipv4InterfaceContainer iic4 = ipv4.Assign(ndc4);\n\n    ipv4.SetBase(Ipv4Address(\"10.0.4.0\"), Ipv4Mask(\"255.255.255.0\"));\n    Ipv4InterfaceContainer iic5 = ipv4.Assign(ndc5);\n\n    ipv4.SetBase(Ipv4Address(\"10.0.5.0\"), Ipv4Mask(\"255.255.255.0\"));\n    Ipv4InterfaceContainer iic6 = ipv4.Assign(ndc6);\n\n    ipv4.SetBase(Ipv4Address(\"10.0.6.0\"), Ipv4Mask(\"255.255.255.0\"));\n    Ipv4InterfaceContainer iic7 = ipv4.Assign(ndc7);\n\n    Ptr<Ipv4StaticRouting> staticRouting;\n    staticRouting = Ipv4RoutingHelper::GetRouting<Ipv4StaticRouting>(\n        src->GetObject<Ipv4>()->GetRoutingProtocol());\n    staticRouting->SetDefaultRoute(\"10.0.0.2\", 1);\n    staticRouting = Ipv4RoutingHelper::GetRouting<Ipv4StaticRouting>(\n        dst->GetObject<Ipv4>()->GetRoutingProtocol());\n    staticRouting->SetDefaultRoute(\"10.0.6.1\", 1);\n\n    if (printRoutingTables)\n    {\n        Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);\n\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(30.0), a, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(30.0), b, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(30.0), c, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(30.0), d, routingStream);\n\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(60.0), a, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(60.0), b, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(60.0), c, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(60.0), d, routingStream);\n\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(90.0), a, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(90.0), b, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(90.0), c, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(90.0), d, routingStream);\n    }\n\n    NS_LOG_INFO(\"Create Applications.\");\n    uint32_t packetSize = 1024;\n    Time interPacketInterval = Seconds(1.0);\n    PingHelper ping(Ipv4Address(\"10.0.6.2\"));\n\n    ping.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    if (showPings)\n    {\n        ping.SetAttribute(\"VerboseMode\", EnumValue(Ping::VerboseMode::VERBOSE));\n    }\n    ApplicationContainer apps = ping.Install(src);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(110.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"rip-simple-routing.tr\"));\n    csma.EnablePcapAll(\"rip-simple-routing\", true);\n\n    Simulator::Schedule(Seconds(40), &TearDownLink, b, d, 3, 2);\n\n    /* Now, do the actual simulation. */\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Stop(Seconds(131.0));\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that generates a dataset for a simple star topology network with 5 nodes, where one central node (node 0) communicates with four peripheral nodes (nodes 1 to 4) using TCP. The dataset should capture the source node, destination node, packet size, transmission time, and reception time for each packet. Save the information to a CSV file."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"StarTopologyDataset\");\n\nvoid RecordTcpData(Ptr<FlowMonitor> flowMonitor, std::string filename)\n{\n    std::ofstream outFile;\n    outFile.open(filename, std::ios::out | std::ios::app);\n    outFile << \"FlowID,SrcAddr,DestAddr,PacketSize,TxTime,RxTime\\n\"; // CSV headers\n\n    // Retrieve statistics from flow monitor\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n    for (auto &flow : stats)\n    {\n        FlowId id = flow.first;\n        FlowMonitor::FlowStats flowStats = flow.second;\n        Ipv4FlowClassifier::FiveTuple t = flowMonitor->GetClassifier()->FindFlow(id);\n\n        for (uint32_t i = 0; i < flowStats.txPackets; i++)\n        {\n            outFile << id << \",\"\n                    << t.sourceAddress << \",\"\n                    << t.destinationAddress << \",\"\n                    << flowStats.txBytes << \",\"\n                    << flowStats.timeFirstTxPacket.GetSeconds() << \",\"\n                    << flowStats.timeLastRxPacket.GetSeconds() << \"\\n\";\n        }\n    }\n    outFile.close();\n}\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"StarTopologyDataset\", LOG_LEVEL_INFO);\n\n    // Create 5 nodes (1 central node and 4 peripheral nodes)\n    NodeContainer centralNode;\n    centralNode.Create(1);\n\n    NodeContainer peripheralNodes;\n    peripheralNodes.Create(4);\n\n    NodeContainer allNodes;\n    allNodes.Add(centralNode);\n    allNodes.Add(peripheralNodes);\n\n    // Set up point-to-point links between central node and peripheral nodes\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    for (uint32_t i = 0; i < peripheralNodes.GetN(); ++i)\n    {\n        devices.Add(p2p.Install(centralNode.Get(0), peripheralNodes.Get(i)));\n    }\n\n    // Install Internet stack on nodes\n    InternetStackHelper internet;\n    internet.Install(allNodes);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Setup TCP server on central node (node 0)\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(interfaces.GetAddress(0), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = packetSinkHelper.Install(centralNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup TCP clients on peripheral nodes (nodes 1-4)\n    OnOffHelper onOffHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    onOffHelper.SetAttribute(\"DataRate\", StringValue(\"500kbps\"));\n    onOffHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    onOffHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < peripheralNodes.GetN(); ++i)\n    {\n        onOffHelper.SetAttribute(\"Remote\", AddressValue(InetSocketAddress(interfaces.GetAddress(0), port)));\n        clientApps.Add(onOffHelper.Install(peripheralNodes.Get(i)));\n    }\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(9.0));\n\n    // Enable flow monitor\n    FlowMonitorHelper flowHelper;\n    Ptr<FlowMonitor> flowMonitor = flowHelper.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Record TCP data to a CSV file\n    RecordTcpData(flowMonitor, \"tcp_dataset.csv\");\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a UDP client communicates with a server over an ad-hoc Wi-Fi network. The client should send packets to the server at regular intervals, and the server should log the received packets. Configure a Wi-Fi ad-hoc network where both the client and server communicate directly without an access point. Implement custom UDP socket applications instead of using NS-3’s built-in UdpEchoClient and UdpEchoServer. The simulation should run for 10 seconds"}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpAdhocWifiExample\");\n\n// Server function to receive packets\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a packet over Wi-Fi Ad-Hoc!\");\n    }\n}\n\n// Client function to send packets\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address dstAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(512); // 512-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(dstAddr, port));\n    Simulator::Schedule(Seconds(1.0), &SendPacket, socket, dstAddr, port); // Schedule next packet\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpAdhocWifiExample\", LOG_LEVEL_INFO);\n\n    // Create nodes (1 Client, 1 Server)\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Configure Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Configure Wi-Fi MAC (Ad-Hoc Mode)\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(phy, mac, wifiNodes);\n\n    // Set mobility model (nodes move randomly)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(wifiNodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    uint16_t port = 8080; // UDP port\n\n    // Setup UDP Server\n    Ptr<Socket> serverSocket = Socket::CreateSocket(wifiNodes.Get(1), UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client\n    Ptr<Socket> clientSocket = Socket::CreateSocket(wifiNodes.Get(0), UdpSocketFactory::GetTypeId());\n    Simulator::Schedule(Seconds(2.0), &SendPacket, clientSocket, interfaces.GetAddress(1), port);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Vehicular Ad-Hoc Network (VANET) using the IEEE 802.11p (WAVE) protocol. The network should consist of three vehicles, each with a unique IPv4 address in the 10.1.1.0/24 subnet. Vehicles should use the ConstantVelocityMobilityModel with speeds of 20 m/s, 15 m/s, and 25 m/s, respectively. The last vehicle should act as a UDP echo server on port 9, while the first vehicle should be a client sending five packets of 1024 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wave-helper.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    NodeContainer vehicles;\n    vehicles.Create(3); // Create 3 vehicles\n\n    YansWifiChannelHelper waveChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wavePhy = YansWifiPhyHelper::Default();\n    wavePhy.SetChannel(waveChannel.Create());\n\n    NqosWaveMacHelper waveMac = NqosWaveMacHelper::Default();\n    WaveHelper wave;\n    NetDeviceContainer devices = wave.Install(wavePhy, waveMac, vehicles);\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(vehicles);\n\n    Ptr<ConstantVelocityMobilityModel> mobility1 = vehicles.Get(0)->GetObject<ConstantVelocityMobilityModel>();\n    Ptr<ConstantVelocityMobilityModel> mobility2 = vehicles.Get(1)->GetObject<ConstantVelocityMobilityModel>();\n    Ptr<ConstantVelocityMobilityModel> mobility3 = vehicles.Get(2)->GetObject<ConstantVelocityMobilityModel>();\n\n    mobility1->SetVelocity(Vector(20, 0, 0)); // Vehicle 1 moves at 20 m/s\n    mobility2->SetVelocity(Vector(15, 0, 0)); // Vehicle 2 moves at 15 m/s\n    mobility3->SetVelocity(Vector(25, 0, 0)); // Vehicle 3 moves at 25 m/s\n\n    InternetStackHelper internet;\n    internet.Install(vehicles);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(vehicles.Get(2)); // Last vehicle as server\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(2), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(vehicles.Get(0)); // First vehicle as client\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Wi-Fi network with two nodes, where Node 0 is a Wi-Fi Access Point (AP) and Node 1 is a Wi-Fi Station (STA). The Wi-Fi communication should use the 802.11n standard, and both nodes should be placed within a grid of 2x2 meters. Install an Internet stack on both nodes and assign IP addresses to the devices. Use a UDP Echo Server on the AP and a UDP Echo Client on the STA. The simulation should run for 10 seconds, with the client sending one 1024-byte packet every 1 second to the server, starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiApStaExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiApStaExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Set up Wi-Fi devices for AP and STA\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n\n    // Install Wi-Fi devices\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiNodes.Get(1));\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevices = wifi.Install(phy, mac, wifiNodes.Get(0));\n\n    // Install mobility model for the nodes\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0), \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2), \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install the Internet stack (IP stack)\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(staDevices);\n    address.Assign(apDevices);\n\n    // Install a simple UDP client on STA node\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(wifiNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an NS-3 C++ point-to-point network with two nodes. The first node (client) sends TCP packets to the second node (server). Use a 5Mbps data rate and a 2ms delay. The client sends packets at 0.1s intervals, and the server runs from 1s to 10s. Assign IPs in the 10.1.1.0/24 range. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP server on node 1\n    uint16_t port = 9;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on node 0\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using ns-3 to simulate a network with three nodes connected by point-to-point links with 10 Mbps bandwidth and 10 ms delay between n0, n1, and n2. Install a PacketSinkApplication on node n2 to receive data sent over TCP from node n0. Use a socket to implement the sender directly at node n0. Set the simulation to send 2,000,000 bytes and track the congestion window using a callback. Enable tracing of queues and packet receptions, saving traces in an ASCII file 'tcp-large-transfer.tr' and generating pcap files named 'tcp-large-transfer-$n-$i.pcap'."}, {"role": "assistant", "content": "//\n// Network topology\n//\n//           10Mb/s, 10ms       10Mb/s, 10ms\n//       n0-----------------n1-----------------n2\n//\n//\n// - Tracing of queues and packet receptions to file\n//   \"tcp-large-transfer.tr\"\n// - pcap traces also generated in the following files\n//   \"tcp-large-transfer-$n-$i.pcap\" where n and i represent node and interface\n// numbers respectively\n//  Usage (e.g.): ./ns3 run tcp-large-transfer\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpLargeTransfer\");\n\n/// The number of bytes to send in this simulation.\nstatic const uint32_t totalTxBytes = 2000000;\n/// The actual number of sent bytes.\nstatic uint32_t currentTxBytes = 0;\n\n// Perform series of 1040 byte writes (this is a multiple of 26 since\n// we want to detect data splicing in the output stream)\n/// Write size.\nstatic const uint32_t writeSize = 1040;\n/// Data to be written.\nuint8_t data[writeSize];\n\n// These are for starting the writing process, and handling the sending\n// socket's notification upcalls (events).  These two together more or less\n// implement a sending \"Application\", although not a proper ns3::Application\n// subclass.\n\n/**\n * Start a flow.\n *\n * \\param localSocket The local (sending) socket.\n * \\param servAddress The server address.\n * \\param servPort The server port.\n */\nvoid StartFlow(Ptr<Socket> localSocket, Ipv4Address servAddress, uint16_t servPort);\n\n/**\n * Write to the buffer, filling it.\n *\n * \\param localSocket The socket.\n * \\param txSpace The number of bytes to write.\n */\nvoid WriteUntilBufferFull(Ptr<Socket> localSocket, uint32_t txSpace);\n\n/**\n * Congestion window tracker function.\n *\n * \\param oldval Old value.\n * \\param newval New value.\n */\nstatic void\nCwndTracer(uint32_t oldval, uint32_t newval)\n{\n    NS_LOG_INFO(\"Moving cwnd from \" << oldval << \" to \" << newval);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    // Users may find it convenient to turn on explicit debugging\n    // for selected modules; the below lines suggest how to do this\n    //  LogComponentEnable(\"TcpL4Protocol\", LOG_LEVEL_ALL);\n    //  LogComponentEnable(\"TcpSocketImpl\", LOG_LEVEL_ALL);\n    //  LogComponentEnable(\"PacketSink\", LOG_LEVEL_ALL);\n    //  LogComponentEnable(\"TcpLargeTransfer\", LOG_LEVEL_ALL);\n\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    // initialize the tx buffer.\n    for (uint32_t i = 0; i < writeSize; ++i)\n    {\n        char m = toascii(97 + i % 26);\n        data[i] = m;\n    }\n\n    // Here, we will explicitly create three nodes.  The first container contains\n    // nodes 0 and 1 from the diagram above, and the second one contains nodes\n    // 1 and 2.  This reflects the channel connectivity, and will be used to\n    // install the network interfaces and connect them with a channel.\n    NodeContainer n0n1;\n    n0n1.Create(2);\n\n    NodeContainer n1n2;\n    n1n2.Add(n0n1.Get(1));\n    n1n2.Create(1);\n\n    // We create the channels first without any IP addressing information\n    // First make and configure the helper, so that it will put the appropriate\n    // attributes on the network interfaces and channels we are about to install.\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(10000000)));\n    p2p.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(10)));\n\n    // And then install devices and channels connecting our topology.\n    NetDeviceContainer dev0 = p2p.Install(n0n1);\n    NetDeviceContainer dev1 = p2p.Install(n1n2);\n\n    // Now add ip/tcp stack to all nodes.\n    InternetStackHelper internet;\n    internet.InstallAll();\n\n    // Later, we add IP addresses.\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    ipv4.Assign(dev0);\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfs = ipv4.Assign(dev1);\n\n    // and setup ip routing tables to get total ip-level connectivity.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Simulation 1\n    //\n    // Send 2000000 bytes over a connection to server port 50000 at time 0\n    // Should observe SYN exchange, a lot of data segments and ACKS, and FIN\n    // exchange.  FIN exchange isn't quite compliant with TCP spec (see release\n    // notes for more info)\n    //\n    ///////////////////////////////////////////////////////////////////////////\n\n    uint16_t servPort = 50000;\n\n    // Create a packet sink to receive these packets on n2...\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(Ipv4Address::GetAny(), servPort));\n\n    ApplicationContainer apps = sink.Install(n1n2.Get(1));\n    apps.Start(Seconds(0.0));\n    apps.Stop(Seconds(3.0));\n\n    // Create a source to send packets from n0.  Instead of a full Application\n    // and the helper APIs you might see in other example files, this example\n    // will use sockets directly and register some socket callbacks as a sending\n    // \"Application\".\n\n    // Create and bind the socket...\n    Ptr<Socket> localSocket = Socket::CreateSocket(n0n1.Get(0), TcpSocketFactory::GetTypeId());\n    localSocket->Bind();\n\n    // Trace changes to the congestion window\n    Config::ConnectWithoutContext(\"/NodeList/0/$ns3::TcpL4Protocol/SocketList/0/CongestionWindow\",\n                                  MakeCallback(&CwndTracer));\n\n    // ...and schedule the sending \"Application\"; This is similar to what an\n    // ns3::Application subclass would do internally.\n    Simulator::ScheduleNow(&StartFlow, localSocket, ipInterfs.GetAddress(1), servPort);\n\n    // One can toggle the comment for the following line on or off to see the\n    // effects of finite send buffer modelling.  One can also change the size of\n    // said buffer.\n\n    // localSocket->SetAttribute(\"SndBufSize\", UintegerValue(4096));\n\n    // Ask for ASCII and pcap traces of network traffic\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"tcp-large-transfer.tr\"));\n    p2p.EnablePcapAll(\"tcp-large-transfer\");\n\n    // Finally, set up the simulator to run.  The 1000 second hard limit is a\n    // failsafe in case some change above causes the simulation to never end\n    Simulator::Stop(Seconds(1000));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}\n\n//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n// begin implementation of sending \"Application\"\nvoid\nStartFlow(Ptr<Socket> localSocket, Ipv4Address servAddress, uint16_t servPort)\n{\n    NS_LOG_LOGIC(\"Starting flow at time \" << Simulator::Now().GetSeconds());\n    localSocket->Connect(InetSocketAddress(servAddress, servPort)); // connect\n\n    // tell the tcp implementation to call WriteUntilBufferFull again\n    // if we blocked and new tx buffer space becomes available\n    localSocket->SetSendCallback(MakeCallback(&WriteUntilBufferFull));\n    WriteUntilBufferFull(localSocket, localSocket->GetTxAvailable());\n}\n\nvoid\nWriteUntilBufferFull(Ptr<Socket> localSocket, uint32_t txSpace)\n{\n    while (currentTxBytes < totalTxBytes && localSocket->GetTxAvailable() > 0)\n    {\n        uint32_t left = totalTxBytes - currentTxBytes;\n        uint32_t dataOffset = currentTxBytes % writeSize;\n        uint32_t toWrite = writeSize - dataOffset;\n        toWrite = std::min(toWrite, left);\n        toWrite = std::min(toWrite, localSocket->GetTxAvailable());\n        int amountSent = localSocket->Send(&data[dataOffset], toWrite, 0);\n        if (amountSent < 0)\n        {\n            // we will be called again when new tx space becomes available.\n            return;\n        }\n        currentTxBytes += amountSent;\n    }\n    if (currentTxBytes >= totalTxBytes)\n    {\n        localSocket->Close();\n    }\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a program in ns-3 that simulates a three-router network scenario using global routing. The topology includes three nodes: A, B, and C. Node A has a /32 IP address (a.a.a.a/32), node B connects to both A and C through point-to-point links with subnets x.x.x.0/30 and y.y.y.0/30, and node C has a /32 IP address (c.c.c.c/32). Establish point-to-point links between A and B, and between B and C, each with a data rate of 5 Mbps and 2 ms delay. Add CsmaNetDevices to nodes A and C, assigning /32 IP addresses (172.16.1.1 and 192.168.1.1) to their interfaces. Set up UDP traffic from A to C, with a sending application on A and a packet sink on C, using a constant rate. Enable tracing and packet capturing for analysis."}, {"role": "assistant", "content": "// Test program for this 3-router scenario, using global routing\n//\n// (a.a.a.a/32)A<--x.x.x.0/30-->B<--y.y.y.0/30-->C(c.c.c.c/32)\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-net-device.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"GlobalRouterSlash32Test\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Ptr<Node> nA = CreateObject<Node>();\n    Ptr<Node> nB = CreateObject<Node>();\n    Ptr<Node> nC = CreateObject<Node>();\n\n    NodeContainer c = NodeContainer(nA, nB, nC);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // Point-to-point links\n    NodeContainer nAnB = NodeContainer(nA, nB);\n    NodeContainer nBnC = NodeContainer(nB, nC);\n\n    // We create the channels first without any IP addressing information\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer dAdB = p2p.Install(nAnB);\n\n    NetDeviceContainer dBdC = p2p.Install(nBnC);\n\n    Ptr<CsmaNetDevice> deviceA = CreateObject<CsmaNetDevice>();\n    deviceA->SetAddress(Mac48Address::Allocate());\n    nA->AddDevice(deviceA);\n    deviceA->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    Ptr<CsmaNetDevice> deviceC = CreateObject<CsmaNetDevice>();\n    deviceC->SetAddress(Mac48Address::Allocate());\n    nC->AddDevice(deviceC);\n    deviceC->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    // Later, we add IP addresses.\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iAiB = ipv4.Assign(dAdB);\n\n    ipv4.SetBase(\"10.1.1.4\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iBiC = ipv4.Assign(dBdC);\n\n    Ptr<Ipv4> ipv4A = nA->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4C = nC->GetObject<Ipv4>();\n\n    int32_t ifIndexA = ipv4A->AddInterface(deviceA);\n    int32_t ifIndexC = ipv4C->AddInterface(deviceC);\n\n    Ipv4InterfaceAddress ifInAddrA =\n        Ipv4InterfaceAddress(Ipv4Address(\"172.16.1.1\"), Ipv4Mask(\"255.255.255.255\"));\n    ipv4A->AddAddress(ifIndexA, ifInAddrA);\n    ipv4A->SetMetric(ifIndexA, 1);\n    ipv4A->SetUp(ifIndexA);\n\n    Ipv4InterfaceAddress ifInAddrC =\n        Ipv4InterfaceAddress(Ipv4Address(\"192.168.1.1\"), Ipv4Mask(\"255.255.255.255\"));\n    ipv4C->AddAddress(ifIndexC, ifInAddrC);\n    ipv4C->SetMetric(ifIndexC, 1);\n    ipv4C->SetUp(ifIndexC);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(ifInAddrC.GetLocal(), port)));\n    onoff.SetConstantRate(DataRate(6000));\n    ApplicationContainer apps = onoff.Install(nA);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(nC);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"global-routing-slash32.tr\"));\n    p2p.EnablePcapAll(\"global-routing-slash32\");\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 that simulates the Routing Information Protocol (RIP) over a network with multiple nodes. The simulation should create a simple network topology where RIP is used to exchange routing information between routers. Implement a star topology with one central node (the main router) and four edge nodes (subnet routers). Assign IP addresses to each node and use RIP for dynamic routing. Capture and trace the routing tables as the simulation runs."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/rip-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RipExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Step 1: Create nodes\n    NodeContainer centralRouter;\n    centralRouter.Create(1); // The central router\n\n    NodeContainer edgeRouters;\n    edgeRouters.Create(4); // 4 edge routers\n\n    // Step 2: Create point-to-point links\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create links between central router and each edge router\n    NetDeviceContainer devices[4];\n    for (int i = 0; i < 4; ++i)\n    {\n        devices[i] = p2p.Install(centralRouter.Get(0), edgeRouters.Get(i));\n    }\n\n    // Step 3: Install internet stacks\n    RipHelper ripRouting;\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(ripRouting); // Set RIP as the routing protocol\n    internet.Install(centralRouter);\n    internet.Install(edgeRouters);\n\n    // Step 4: Assign IP addresses\n    Ipv4AddressHelper ipv4;\n\n    Ipv4InterfaceContainer interfaces[4];\n    for (int i = 0; i < 4; ++i)\n    {\n        std::ostringstream subnet;\n        subnet << \"10.1.\" << i + 1 << \".0\";\n        ipv4.SetBase(subnet.str().c_str(), \"255.255.255.0\");\n        interfaces[i] = ipv4.Assign(devices[i]);\n    }\n\n    // Step 5: Set up routing information protocol (RIP)\n    for (int i = 0; i < 4; ++i)\n    {\n        ripRouting.AddNetworkRouteTo(centralRouter.Get(0), interfaces[i].GetAddress(0), interfaces[i].GetAddress(1), 1);\n    }\n\n    // Step 6: Add a simple UDP Echo application\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(edgeRouters.Get(0)); // Install the server on the first edge router\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces[0].GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(edgeRouters.Get(1)); // Install the client on the second edge router\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Step 7: Enable tracing (pcap trace)\n    p2p.EnablePcapAll(\"rip-routing\");\n\n    // Step 8: Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a TCP connection between two Wi-Fi nodes: one as a TCP server and the other as a TCP client. The client sends packets of size 1024 bytes at a rate of 100ms interval to the server. The server listens on port 9."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Set up Wi-Fi devices\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::ArfWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"wifi-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer staDevice;\n    staDevice = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevice);\n    Ipv4InterfaceContainer apInterfaces = address.Assign(apDevice);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0), \"DeltaY\", DoubleValue(5.0), \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Set up TCP server (on the STA)\n    uint16_t port = 9;\n    TcpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client (on the AP)\n    TcpClientHelper client(staInterfaces.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an Ethernet-based TCP communication network in NS-3 with two nodes. One node sends TCP packets to the other using a point-to-point link with 100Mbps and 2ms delay. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"EthernetTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link with a 100Mbps speed and 2ms delay\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install point-to-point devices on nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP client application on node 0 (client)\n    uint16_t port = 8080;\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up TCP server application on node 1 (server)\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to create a simple Wi-Fi network with a UDP communication between two nodes: Station (STA) and Access Point (AP). The STA sends 10 UDP packets of 1024 bytes each, with a 1-second interval to the AP, which listens on port 9. The station has a random mobility model in a 100x100 m² area, while the AP remains stationary. The IP address range used for both devices is 10.1.1.0/24."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for AP and STA\n    NodeContainer wifiStaNode, wifiApNode;\n    wifiStaNode.Create(1); // Station (STA)\n    wifiApNode.Create(1);  // Access Point (AP)\n\n    // Install Wi-Fi devices on both the AP and STA\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ); // 802.11n standard\n\n    WifiMacHelper mac;\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(Ssid(\"ns3-ssid\")));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNode);\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(Ssid(\"ns3-ssid\")));\n    NetDeviceContainer apDevices = wifi.Install(phy, mac, wifiApNode);\n\n    // Set up the mobility model for the STA (it moves around)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(wifiStaNode); // Install mobility on the STA node\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode); // Install stationary AP\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(wifiStaNode);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterfaces = address.Assign(apDevices);\n\n    // Set up UDP server on AP\n    UdpServerHelper udpServer(9); // Listening on port 9\n    ApplicationContainer serverApp = udpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on STA\n    UdpClientHelper udpClient(apInterfaces.GetAddress(0), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // 10 packets to send\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // 1 second interval\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // 1024 byte packets\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate an LTE network with one eNodeB (base station) and one UE (user equipment). The eNodeB and UE should communicate using the LTE interface. Set up a UDP server on the UE and a UDP client on the eNodeB, with a data transfer interval of 100ms and a packet size of 1024 bytes. The simulation should run for 10 seconds. The eNodeB should be stationary, and the UE should have random mobility."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/epc-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set default values for command line arguments\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"LteUdpExample\", LOG_LEVEL_INFO);\n\n    // Create the nodes\n    NodeContainer ueNodes, enbNodes;\n    enbNodes.Create(1); // One eNodeB\n    ueNodes.Create(1);  // One UE\n\n    // Set up LTE helper and EPC helper\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<EpcHelper> epcHelper = CreateObject<EpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(enbNodes); // eNodeB position\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\");\n    mobility.Install(ueNodes); // UE position\n\n    // Install LTE devices\n    NetDeviceContainer enbDevs = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueDevs = lteHelper->InstallUeDevice(ueNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    internet.Install(enbNodes);\n\n    // Assign IP addresses to UE and eNodeB devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface = ipv4.Assign(ueDevs);\n\n    // Attach the UE to the eNodeB\n    lteHelper->Attach(ueDevs.Get(0), enbDevs.Get(0));\n\n    // Set up the UDP server on the UE (acting as the receiver)\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ueNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the eNodeB (acting as the sender)\n    UdpClientHelper udpClient(ueIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(enbNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and organizes them in a bus topology. The program should connect all nodes sequentially to a shared channel using CSMA (Carrier Sense Multiple Access). The program should then print confirmation of the established connections. Keep the example simple, focusing only on node creation and topology setup."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/csma-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"BusTopologyExample\", LOG_LEVEL_INFO);\n\n    // Define the number of nodes in the bus topology\n    uint32_t numNodes = 5;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(numNodes);\n\n    // CSMA Helper (Shared Medium)\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(5)));\n\n    // Install CSMA on all nodes\n    NetDeviceContainer devices = csma.Install(nodes);\n\n    // Log established connections\n    for (uint32_t i = 0; i < numNodes; ++i) {\n        NS_LOG_INFO(\"Node \" << i << \" connected to the shared CSMA channel.\");\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a client communicates with multiple servers using UDP. The client should send packets to two different servers at regular intervals. Each server should listen on a different port and log the received packets. Set up a simple point-to-point network where the client is connected to both servers via a switch (CSMA network). Implement custom UDP socket applications instead of using NS-3’s built-in UdpEchoClient and UdpEchoServer. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpMultiServerExample\");\n\n// Server function to receive packets\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a packet!\");\n    }\n}\n\n// Client function to send packets to a specific server\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address dstAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(512); // 512-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(dstAddr, port));\n    Simulator::Schedule(Seconds(1.0), &SendPacket, socket, dstAddr, port); // Schedule next packet\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpMultiServerExample\", LOG_LEVEL_INFO);\n\n    // Create nodes (1 Client + 2 Servers)\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Configure CSMA network (Ethernet-like)\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(5000)));\n\n    NetDeviceContainer devices = csma.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    uint16_t port1 = 8080; // Server 1 port\n    uint16_t port2 = 9090; // Server 2 port\n\n    // Setup UDP Server 1\n    Ptr<Socket> serverSocket1 = Socket::CreateSocket(nodes.Get(1), UdpSocketFactory::GetTypeId());\n    serverSocket1->Bind(InetSocketAddress(Ipv4Address::GetAny(), port1));\n    serverSocket1->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Server 2\n    Ptr<Socket> serverSocket2 = Socket::CreateSocket(nodes.Get(2), UdpSocketFactory::GetTypeId());\n    serverSocket2->Bind(InetSocketAddress(Ipv4Address::GetAny(), port2));\n    serverSocket2->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client\n    Ptr<Socket> clientSocket1 = Socket::CreateSocket(nodes.Get(0), UdpSocketFactory::GetTypeId());\n    Ptr<Socket> clientSocket2 = Socket::CreateSocket(nodes.Get(0), UdpSocketFactory::GetTypeId());\n\n    // Schedule packet sending to both servers\n    Simulator::Schedule(Seconds(2.0), &SendPacket, clientSocket1, interfaces.GetAddress(1), port1);\n    Simulator::Schedule(Seconds(2.5), &SendPacket, clientSocket2, interfaces.GetAddress(2), port2);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate an ad-hoc wireless network using ns-3 with the AODV routing protocol. Create 10 mobile nodes that move randomly within a 500m x 500m area. Simulate UDP traffic between nodes, starting at random times, and run the simulation for 30 seconds. Use pcap tracing to capture the packet transmissions. Measure and display the packet delivery ratio (PDR) and average end-to-end delay at the end of the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocAodvExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation parameters\n    double simulationTime = 30.0; // seconds\n    uint32_t numNodes = 10;\n    double txPower = 16.0; // dBm\n    double nodeSpeed = 20.0; // m/s (random speed for mobility)\n\n    // Create nodes\n    NodeContainer adhocNodes;\n    adhocNodes.Create(numNodes);\n\n    // Set up Wi-Fi for ad-hoc network\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.Set(\"TxPowerStart\", DoubleValue(txPower));\n    phy.Set(\"TxPowerEnd\", DoubleValue(txPower));\n\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::RangePropagationLossModel\", \"MaxRange\", DoubleValue(100.0));\n    phy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, adhocNodes);\n\n    // Set up mobility\n    MobilityHelper mobility;\n    Ptr<UniformRandomVariable> speed = CreateObject<UniformRandomVariable>();\n    speed->SetAttribute(\"Min\", DoubleValue(0.0));\n    speed->SetAttribute(\"Max\", DoubleValue(nodeSpeed));\n\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", PointerValue(speed),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=2.0]\"),\n                              \"PositionAllocator\", StringValue(\"ns3::RandomRectanglePositionAllocator\"),\n                              \"X\", DoubleValue(500.0), // Area of 500x500 meters\n                              \"Y\", DoubleValue(500.0));\n\n    mobility.Install(adhocNodes);\n\n    // Install internet stack and AODV routing protocol\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv); // AODV as the routing protocol\n    internet.Install(adhocNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP traffic: a UdpEchoServer on one node and a UdpEchoClient on another\n    uint16_t port = 9;\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApp = echoServer.Install(adhocNodes.Get(0)); // Server on node 0\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(0), port); // Client to node 0\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(adhocNodes.Get(numNodes - 1)); // Client on last node\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Enable pcap tracing\n    phy.EnablePcapAll(\"aodv-adhoc\");\n\n    // Install FlowMonitor for traffic statistics\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n\n    // Output flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    uint32_t sentPackets = 0;\n    uint32_t receivedPackets = 0;\n    double delaySum = 0.0;\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        sentPackets += i->second.txPackets;\n        receivedPackets += i->second.rxPackets;\n        delaySum += i->second.delaySum.GetSeconds();\n    }\n\n    double pdr = double(receivedPackets) / sentPackets * 100;\n    double averageDelay = delaySum / receivedPackets;\n\n    NS_LOG_UNCOND(\"Packet Delivery Ratio: \" << pdr << \"%\");\n    NS_LOG_UNCOND(\"Average End-to-End Delay: \" << averageDelay << \" s\");\n\n    // Clean up\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Mobile Ad Hoc Network (MANET) in ns-3 with 3 mobile nodes moving in a random direction. The nodes should communicate using UDP traffic, and the simulation should track the movement of nodes and packet transmission. Include metrics like packet delivery ratio and latency, and use NetAnim to visualize the node mobility and communication."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/udp-echo-helper.h\"\n#include \"ns3/animation-interface.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ManetExample\");\n\nint main(int argc, char *argv[])\n{\n    double simulationTime = 10.0; // seconds\n\n    // Create 3 mobile nodes\n    NodeContainer manetNodes;\n    manetNodes.Create(3);\n\n    // Configure WiFi settings\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"manet-ssid\");\n    mac.SetType(\"ns3::AdhocWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, manetNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(manetNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP Echo Server on node 0\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(manetNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Set up UDP Echo Client on node 2 to communicate with node 0\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(manetNodes.Get(2));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Configure mobility for the nodes\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(manetNodes);\n\n    // Enable NetAnim for visualization\n    AnimationInterface anim(\"manet.xml\");\n    anim.SetConstantPosition(manetNodes.Get(0), 0.0, 0.0);\n    anim.SetConstantPosition(manetNodes.Get(1), 10.0, 20.0);\n    anim.SetConstantPosition(manetNodes.Get(2), 20.0, 40.0);\n\n    // Enable FlowMonitor to capture packet delivery and delay metrics\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n\n    // Output FlowMonitor results\n    monitor->SerializeToXmlFile(\"manet-flowmon.xml\", true, true);\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 network simulator that sets up a dumbbell topology with configurable parameters for the number of leaf nodes, queue types (either RED or Feng's Adaptive RED), and other network settings such as packet size and data rates. The program should use command-line arguments to adjust parameters like the number of packets allowed in the queue, packet size, data rate, and RED queue thresholds. Include default settings for RED queue parameters, link bandwidth, and delay, and install a TCP OnOff application on all right-side nodes with a uniform random variable for On/Off times. The simulation should display the final queue disc statistics and check for expected packet drops."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-layout-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <iomanip>\n#include <iostream>\n#include <map>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t nLeaf = 10;\n    uint32_t maxPackets = 100;\n    bool modeBytes = false;\n    uint32_t queueDiscLimitPackets = 1000;\n    double minTh = 5;\n    double maxTh = 15;\n    uint32_t pktSize = 512;\n    std::string appDataRate = \"10Mbps\";\n    std::string queueDiscType = \"RED\";\n    uint16_t port = 5001;\n    std::string bottleNeckLinkBw = \"1Mbps\";\n    std::string bottleNeckLinkDelay = \"50ms\";\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nLeaf\", \"Number of left and right side leaf nodes\", nLeaf);\n    cmd.AddValue(\"maxPackets\", \"Max Packets allowed in the device queue\", maxPackets);\n    cmd.AddValue(\"queueDiscLimitPackets\",\n                 \"Max Packets allowed in the queue disc\",\n                 queueDiscLimitPackets);\n    cmd.AddValue(\"queueDiscType\", \"Set Queue disc type to RED or FengAdaptive\", queueDiscType);\n    cmd.AddValue(\"appPktSize\", \"Set OnOff App Packet Size\", pktSize);\n    cmd.AddValue(\"appDataRate\", \"Set OnOff App DataRate\", appDataRate);\n    cmd.AddValue(\"modeBytes\", \"Set Queue disc mode to Packets (false) or bytes (true)\", modeBytes);\n\n    cmd.AddValue(\"redMinTh\", \"RED queue minimum threshold\", minTh);\n    cmd.AddValue(\"redMaxTh\", \"RED queue maximum threshold\", maxTh);\n    cmd.Parse(argc, argv);\n\n    if ((queueDiscType != \"RED\") && (queueDiscType != \"FengAdaptive\"))\n    {\n        std::cout\n            << \"Invalid queue disc type: Use --queueDiscType=RED or --queueDiscType=FengAdaptive\"\n            << std::endl;\n        exit(1);\n    }\n\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(pktSize));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(appDataRate));\n\n    Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, maxPackets)));\n\n    if (!modeBytes)\n    {\n        Config::SetDefault(\n            \"ns3::RedQueueDisc::MaxSize\",\n            QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, queueDiscLimitPackets)));\n    }\n    else\n    {\n        Config::SetDefault(\n            \"ns3::RedQueueDisc::MaxSize\",\n            QueueSizeValue(QueueSize(QueueSizeUnit::BYTES, queueDiscLimitPackets * pktSize)));\n        minTh *= pktSize;\n        maxTh *= pktSize;\n    }\n\n    Config::SetDefault(\"ns3::RedQueueDisc::MinTh\", DoubleValue(minTh));\n    Config::SetDefault(\"ns3::RedQueueDisc::MaxTh\", DoubleValue(maxTh));\n    Config::SetDefault(\"ns3::RedQueueDisc::LinkBandwidth\", StringValue(bottleNeckLinkBw));\n    Config::SetDefault(\"ns3::RedQueueDisc::LinkDelay\", StringValue(bottleNeckLinkDelay));\n    Config::SetDefault(\"ns3::RedQueueDisc::MeanPktSize\", UintegerValue(pktSize));\n\n    if (queueDiscType == \"FengAdaptive\")\n    {\n        // Turn on Feng's Adaptive RED\n        Config::SetDefault(\"ns3::RedQueueDisc::FengAdaptive\", BooleanValue(true));\n    }\n\n    // Create the point-to-point link helpers\n    PointToPointHelper bottleNeckLink;\n    bottleNeckLink.SetDeviceAttribute(\"DataRate\", StringValue(bottleNeckLinkBw));\n    bottleNeckLink.SetChannelAttribute(\"Delay\", StringValue(bottleNeckLinkDelay));\n\n    PointToPointHelper pointToPointLeaf;\n    pointToPointLeaf.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPointLeaf.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    PointToPointDumbbellHelper d(nLeaf, pointToPointLeaf, nLeaf, pointToPointLeaf, bottleNeckLink);\n\n    // Install Stack\n    InternetStackHelper stack;\n    for (uint32_t i = 0; i < d.LeftCount(); ++i)\n    {\n        stack.Install(d.GetLeft(i));\n    }\n    for (uint32_t i = 0; i < d.RightCount(); ++i)\n    {\n        stack.Install(d.GetRight(i));\n    }\n\n    stack.Install(d.GetLeft());\n    stack.Install(d.GetRight());\n    TrafficControlHelper tchBottleneck;\n    QueueDiscContainer queueDiscs;\n    tchBottleneck.SetRootQueueDisc(\"ns3::RedQueueDisc\");\n    tchBottleneck.Install(d.GetLeft()->GetDevice(0));\n    queueDiscs = tchBottleneck.Install(d.GetRight()->GetDevice(0));\n\n    // Assign IP Addresses\n    d.AssignIpv4Addresses(Ipv4AddressHelper(\"10.1.1.0\", \"255.255.255.0\"),\n                          Ipv4AddressHelper(\"10.2.1.0\", \"255.255.255.0\"),\n                          Ipv4AddressHelper(\"10.3.1.0\", \"255.255.255.0\"));\n\n    // Install on/off app on all right side nodes\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", Address());\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::UniformRandomVariable[Min=0.|Max=1.]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::UniformRandomVariable[Min=0.|Max=1.]\"));\n    Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n    ApplicationContainer sinkApps;\n    for (uint32_t i = 0; i < d.LeftCount(); ++i)\n    {\n        sinkApps.Add(packetSinkHelper.Install(d.GetLeft(i)));\n    }\n    sinkApps.Start(Seconds(0.0));\n    sinkApps.Stop(Seconds(30.0));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < d.RightCount(); ++i)\n    {\n        // Create an on/off app sending packets to the left side\n        AddressValue remoteAddress(InetSocketAddress(d.GetLeftIpv4Address(i), port));\n        clientHelper.SetAttribute(\"Remote\", remoteAddress);\n        clientApps.Add(clientHelper.Install(d.GetRight(i)));\n    }\n    clientApps.Start(Seconds(1.0)); // Start 1 second after sink\n    clientApps.Stop(Seconds(15.0)); // Stop before the sink\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    std::cout << \"Running the simulation\" << std::endl;\n    Simulator::Run();\n\n    QueueDisc::Stats st = queueDiscs.Get(0)->GetStats();\n\n    if (st.GetNDroppedPackets(RedQueueDisc::UNFORCED_DROP) == 0)\n    {\n        std::cout << \"There should be some unforced drops\" << std::endl;\n        exit(1);\n    }\n\n    if (st.GetNDroppedPackets(QueueDisc::INTERNAL_QUEUE_DROP) != 0)\n    {\n        std::cout << \"There should be zero drops due to queue full\" << std::endl;\n        exit(1);\n    }\n\n    std::cout << \"*** Stats from the bottleneck queue disc ***\" << std::endl;\n    std::cout << st << std::endl;\n    std::cout << \"Destroying the simulation\" << std::endl;\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate code that validates NIST, YANS, and Table-based error rate models for HE (High Efficiency) rates in NS-3. The program should generate Gnuplot plots of Frame Success Rate versus Signal-to-Noise Ratio (SNR) for each error rate model and for all HE MCS values. It should iterate over SNR values, compute the frame success rate for each mode and model, and output the results as Gnuplot datasets. The frame size should also be configurable via command-line arguments."}, {"role": "assistant", "content": "// This example is used to validate Nist, Yans and Table-based error rate models for HE rates.\n//\n// It outputs plots of the Frame Success Rate versus the Signal-to-noise ratio for\n// Nist, Yans and Table-based error rate models and for every HE MCS value.\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t frameSizeBytes = 1500;\n    std::ofstream yansfile(\"yans-frame-success-rate-ax.plt\");\n    std::ofstream nistfile(\"nist-frame-success-rate-ax.plt\");\n    std::ofstream tablefile(\"table-frame-success-rate-ax.plt\");\n\n    const std::vector<std::string> modes{\n        \"HeMcs0\",\n        \"HeMcs1\",\n        \"HeMcs2\",\n        \"HeMcs3\",\n        \"HeMcs4\",\n        \"HeMcs5\",\n        \"HeMcs6\",\n        \"HeMcs7\",\n        \"HeMcs8\",\n        \"HeMcs9\",\n        \"HeMcs10\",\n        \"HeMcs11\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"FrameSize\", \"The frame size\", frameSizeBytes);\n    cmd.Parse(argc, argv);\n\n    Gnuplot yansplot = Gnuplot(\"yans-frame-success-rate-ax.eps\");\n    Gnuplot nistplot = Gnuplot(\"nist-frame-success-rate-ax.eps\");\n    Gnuplot tableplot = Gnuplot(\"table-frame-success-rate-ax.eps\");\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n    WifiTxVector txVector;\n\n    uint32_t frameSizeBits = frameSizeBytes * 8;\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset yansdataset(mode);\n        Gnuplot2dDataset nistdataset(mode);\n        Gnuplot2dDataset tabledataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -5.0; snrDb <= 40.0; snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double ps = yans->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            yansdataset.Add(snrDb, ps);\n\n            ps = nist->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            nistdataset.Add(snrDb, ps);\n\n            ps = table->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            tabledataset.Add(snrDb, ps);\n        }\n\n        yansplot.AddDataset(yansdataset);\n        nistplot.AddDataset(nistdataset);\n        tableplot.AddDataset(tabledataset);\n    }\n\n    yansplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    yansplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    yansplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style line 10 linewidth 5\\n\\\nset style line 11 linewidth 5\\n\\\nset style line 12 linewidth 5\\n\\\nset style increment user\");\n    yansplot.GenerateOutput(yansfile);\n    yansfile.close();\n\n    nistplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    nistplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    nistplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style line 10 linewidth 5\\n\\\nset style line 11 linewidth 5\\n\\\nset style line 12 linewidth 5\\n\\\nset style increment user\");\n\n    nistplot.GenerateOutput(nistfile);\n    nistfile.close();\n\n    tableplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    tableplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    tableplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style line 10 linewidth 5\\n\\\nset style line 11 linewidth 5\\n\\\nset style line 12 linewidth 5\\n\\\nset style increment user\");\n\n    tableplot.GenerateOutput(tablefile);\n    tablefile.close();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nDevelop an NS-3 simulation to validate error rate models for DSSS rates by calculating and plotting the Frame Success Rate against the Signal-to-Noise Ratio for various DSSS modes. In the `main` function, set the frame size and configure Gnuplot for output. Create instances of different error rate models, including Yans, Nist, and Table-based models, and loop through the defined DSSS modes. For each mode, compute the success rates based on varying SNR values and validate the results against expected ranges. Collect the data in a Gnuplot dataset and generate a visual output in EPS format, depicting the relationship between SNR and Frame Success Rate."}, {"role": "assistant", "content": "// This example is used to validate error rate models for DSSS rates.\n//\n// It outputs plots of the Frame Success Rate versus the Signal-to-noise ratio\n// for the DSSS error rate models and for every DSSS mode.\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t frameSizeBytes = 1500;\n    std::ofstream file(\"frame-success-rate-dsss.plt\");\n\n    const std::vector<std::string> modes{\n        \"DsssRate1Mbps\",\n        \"DsssRate2Mbps\",\n        \"DsssRate5_5Mbps\",\n        \"DsssRate11Mbps\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"FrameSize\", \"The frame size in bytes\", frameSizeBytes);\n    cmd.Parse(argc, argv);\n\n    Gnuplot plot = Gnuplot(\"frame-success-rate-dsss.eps\");\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n    WifiTxVector txVector;\n\n    uint32_t frameSizeBits = frameSizeBytes * 8;\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset dataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -10.0; snrDb <= 20.0; snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double psYans = yans->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (psYans < 0.0 || psYans > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            double psNist = nist->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (psNist < 0.0 || psNist > 1.0)\n            {\n                std::cout << psNist << std::endl;\n                // error\n                exit(1);\n            }\n            if (psNist != psYans)\n            {\n                exit(1);\n            }\n            double psTable = table->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (psTable < 0.0 || psTable > 1.0)\n            {\n                std::cout << psTable << std::endl;\n                // error\n                exit(1);\n            }\n            if (psTable != psYans)\n            {\n                exit(1);\n            }\n            dataset.Add(snrDb, psYans);\n        }\n\n        plot.AddDataset(dataset);\n    }\n\n    plot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    plot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    plot.SetExtra(\"set xrange [-10:20]\\n\\\nset yrange [0:1.2]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style increment user\");\n    plot.GenerateOutput(file);\n    file.close();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a TCP connection between two nodes over a point-to-point link. The first node should act as the TCP client, and the second node should act as the TCP server. The client should send UDP packets to the server with a packet size of 1024 bytes, a maximum of 100 packets, and an interval of 100ms. The link should have a data rate of 5 Mbps and a delay of 2ms. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpConnectionExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set default values for command line arguments\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"TcpConnectionExample\", LOG_LEVEL_INFO);\n\n    // Create the nodes\n    NodeContainer nodes;\n    nodes.Create(2); // Create two nodes\n\n    // Set up point-to-point link between the two nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack on the nodes\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up the TCP server on the second node\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1)); // Second node as server\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the TCP client on the first node\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port); // Connecting to the second node\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0)); // First node as client\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a script in ns-3 that sets up a wireless network with three nodes operating on an 802.11b physical layer, where one node is a transmitter, another a receiver, and the third an interferer. The transmitter sends a packet to the receiver with a configurable RSS (defaulting to -80 dBm), while the interferer also sends a packet without carrier sense, interfering with the primary packet. Configurable parameters include primary and interfering RSS, the time offset between the primary and interfering signals, and packet sizes for both transmissions. The script should allow the user to enable verbose Wi-Fi logging and produce a pcap trace file for analysis."}, {"role": "assistant", "content": "// This script configures three nodes on an 802.11b physical layer, with\n// 802.11b NICs in adhoc mode.  There is a transmitter, receiver, and\n// interferer.  The transmitter sends one packet to the receiver and\n// the receiver receives it with a certain configurable RSS (by default,\n// -80 dBm).  The interferer does not do carrier sense and also sends\n// the packet to interfere with the primary packet.  The channel model\n// is clear channel.\n//\n// Therefore, at the receiver, the reception looks like this:\n//\n//     ------------------time---------------->\n//     t0\n//\n//     |------------------------------------|\n//     |                                    |\n//     | primary received frame (time t0)   |\n//     |                                    |\n//     |------------------------------------|\n//\n//\n//         t1\n//         |-----------------------------------|\n//         |                                   |\n//         |  interfering frame (time t1)      |\n//         |                                   |\n//         |-----------------------------------|\n//\n// The orientation is:\n//     n2  ---------> n0 <---------- n1\n//  interferer      receiver       transmitter\n//\n// The configurable parameters are:\n//   - Prss (primary rss) (-80 dBm default)\n//   - Irss (interfering rss) (-95 dBm default)\n//   - delta (t1-t0, may be negative, default 0ns)\n//   - PpacketSize (primary packet size) (bytes, default 1000)\n//   - IpacketSize (interferer packet size) (bytes, default 1000)\n//\n// For instance, for this configuration, the interfering frame arrives\n// at -90 dBm with a time offset of 3.2 microseconds:\n//\n// ./ns3 run \"wifi-simple-interference --Irss=-90 --delta=3.2ns\"\n//\n// Note that all ns-3 attributes (not just the ones exposed in the below\n// script) can be changed at command line; see the documentation.\n//\n// This script can also be helpful to put the Wifi layer into verbose\n// logging mode; this command will turn on all wifi logging:\n//\n// ./ns3 run \"wifi-simple-interference --verbose=1\"\n//\n// When you are done, you will notice a pcap trace file in your directory.\n// If you have tcpdump installed, you can try this:\n//\n// tcpdump -r wifi-simple-interference-0-0.pcap -nn -tt\n// reading from file wifi-simple-interference-0-0.pcap, link-type IEEE802_11_RADIO (802.11 plus BSD\n// radio information header) 10.008704 10008704us tsft 1.0 Mb/s 2437 MHz (0x00c0) -80dB signal -98dB\n// noise IP 10.1.1.2.49153 > 10.1.1.255.80: UDP, length 1000\n//\n// Next, try this command and look at the tcpdump-- you should see two packets\n// that are no longer interfering:\n// ./ns3 run \"wifi-simple-interference --delta=30000ns\"\n\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleInterference\");\n\n/**\n * Print a packer that has been received.\n *\n * \\param socket The receiving socket.\n * \\return a string with the packet details.\n */\nstatic inline std::string\nPrintReceivedPacket(Ptr<Socket> socket)\n{\n    Address addr;\n\n    std::ostringstream oss;\n\n    while (socket->Recv())\n    {\n        socket->GetSockName(addr);\n        InetSocketAddress iaddr = InetSocketAddress::ConvertFrom(addr);\n\n        oss << \"Received one packet!  Socket: \" << iaddr.GetIpv4() << \" port: \" << iaddr.GetPort();\n    }\n\n    return oss.str();\n}\n\n/**\n * Function called when a packet is received.\n *\n * \\param socket The receiving socket.\n */\nstatic void\nReceivePacket(Ptr<Socket> socket)\n{\n    NS_LOG_UNCOND(PrintReceivedPacket(socket));\n}\n\n/**\n * Generate traffic\n *\n * \\param socket The seding socket.\n * \\param pktSize The packet size.\n * \\param pktCount The packet counter.\n * \\param pktInterval The interval between two packets.\n */\nstatic void\nGenerateTraffic(Ptr<Socket> socket, uint32_t pktSize, uint32_t pktCount, Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval,\n                            &GenerateTraffic,\n                            socket,\n                            pktSize,\n                            pktCount - 1,\n                            pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string phyMode{\"DsssRate1Mbps\"};\n    dBm_u Prss{-80};\n    dBm_u Irss{-95};\n    Time delta{\"0ns\"};\n    uint32_t PpacketSize{1000}; // bytes\n    uint32_t IpacketSize{1000}; // bytes\n    bool verbose{false};\n\n    // these are not command line arguments for this version\n    uint32_t numPackets{1};\n    Time interPacketInterval{\"1s\"};\n    Time startTime{\"10s\"};\n    meter_u distanceToRx{100.0};\n\n    double offset{91}; // This is a magic number used to set the\n                       // transmit power, based on other configuration\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"phyMode\", \"Wifi Phy mode\", phyMode);\n    cmd.AddValue(\"Prss\", \"Intended primary received signal strength (dBm)\", Prss);\n    cmd.AddValue(\"Irss\", \"Intended interfering received signal strength (dBm)\", Irss);\n    cmd.AddValue(\"delta\", \"time offset for interfering signal\", delta);\n    cmd.AddValue(\"PpacketSize\", \"size of application packet sent\", PpacketSize);\n    cmd.AddValue(\"IpacketSize\", \"size of interfering packet sent\", IpacketSize);\n    cmd.AddValue(\"verbose\", \"turn on all WifiNetDevice log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    // Fix non-unicast data rate to be the same as that of unicast\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(phyMode));\n\n    NodeContainer c;\n    c.Create(3);\n\n    // The below set of helpers will help us to put together the wifi NICs we want\n    WifiHelper wifi;\n    if (verbose)\n    {\n        WifiHelper::EnableLogComponents(); // Turn on all Wifi logging\n    }\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy;\n\n    // ns-3 supports RadioTap and Prism tracing extensions for 802.11b\n    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::LogDistancePropagationLossModel\");\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Add a mac and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n    // Set it to adhoc mode\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, c.Get(0));\n    // This will disable these sending devices from detecting a signal\n    // so that they do not backoff\n    wifiPhy.Set(\"TxGain\", DoubleValue(offset + Prss));\n    devices.Add(wifi.Install(wifiPhy, wifiMac, c.Get(1)));\n    wifiPhy.Set(\"TxGain\", DoubleValue(offset + Irss));\n    devices.Add(wifi.Install(wifiPhy, wifiMac, c.Get(2)));\n\n    // Note that with FixedRssLossModel, the positions below are not\n    // used for received signal strength.\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(distanceToRx, 0.0, 0.0));\n    positionAlloc->Add(Vector(-1 * distanceToRx, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(c.Get(0), tid);\n    InetSocketAddress local = InetSocketAddress(Ipv4Address(\"10.1.1.1\"), 80);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    Ptr<Socket> source = Socket::CreateSocket(c.Get(1), tid);\n    InetSocketAddress remote = InetSocketAddress(Ipv4Address(\"255.255.255.255\"), 80);\n    source->SetAllowBroadcast(true);\n    source->Connect(remote);\n\n    // Interferer will send to a different port; we will not see a\n    // \"Received packet\" message\n    Ptr<Socket> interferer = Socket::CreateSocket(c.Get(2), tid);\n    InetSocketAddress interferingAddr = InetSocketAddress(Ipv4Address(\"255.255.255.255\"), 49000);\n    interferer->SetAllowBroadcast(true);\n    interferer->Connect(interferingAddr);\n\n    // Tracing\n    wifiPhy.EnablePcap(\"wifi-simple-interference\", devices.Get(0));\n\n    // Output what we are doing\n    NS_LOG_UNCOND(\"Primary packet RSS=\" << Prss << \" dBm and interferer RSS=\" << Irss\n                                        << \" dBm at time offset=\" << delta.As(Time::US));\n\n    Simulator::ScheduleWithContext(source->GetNode()->GetId(),\n                                   startTime,\n                                   &GenerateTraffic,\n                                   source,\n                                   PpacketSize,\n                                   numPackets,\n                                   interPacketInterval);\n\n    Simulator::ScheduleWithContext(interferer->GetNode()->GetId(),\n                                   startTime + delta,\n                                   &GenerateTraffic,\n                                   interferer,\n                                   IpacketSize,\n                                   numPackets,\n                                   interPacketInterval);\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library that tests the creation of IPv6 addresses by autoconfiguring them from a set of MAC addresses. Initialize an array of 10 MAC addresses and set them to specific values. Use two different IPv6 prefixes, '2001:1::' and '2002:1:1::', and for each prefix, generate an autoconfigured IPv6 address for each MAC address in the array. Log the process, displaying the prefix and each corresponding generated IPv6 address in the console. Ensure to include the necessary ns-3 headers and set up logging for the program."}, {"role": "assistant", "content": "#include \"ns3/ipv6-address.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mac48-address.h\"\n#include \"ns3/node.h\"\n#include \"ns3/simulator.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TestIpv6\");\n\nint\nmain(int argc, char* argv[])\n{\n    LogComponentEnable(\"TestIpv6\", LOG_LEVEL_ALL);\n\n    NS_LOG_INFO(\"Test Ipv6\");\n\n    Mac48Address m_addresses[10];\n\n    m_addresses[0] = (\"00:00:00:00:00:01\");\n    m_addresses[1] = (\"00:00:00:00:00:02\");\n    m_addresses[2] = (\"00:00:00:00:00:03\");\n    m_addresses[3] = (\"00:00:00:00:00:04\");\n    m_addresses[4] = (\"00:00:00:00:00:05\");\n    m_addresses[5] = (\"00:00:00:00:00:06\");\n    m_addresses[6] = (\"00:00:00:00:00:07\");\n    m_addresses[7] = (\"00:00:00:00:00:08\");\n    m_addresses[8] = (\"00:00:00:00:00:09\");\n    m_addresses[9] = (\"00:00:00:00:00:10\");\n\n    Ipv6Address prefix1(\"2001:1::\");\n    NS_LOG_INFO(\"prefix = \" << prefix1);\n    for (uint32_t i = 0; i < 10; ++i)\n    {\n        NS_LOG_INFO(\"address = \" << m_addresses[i]);\n        Ipv6Address ipv6address = Ipv6Address::MakeAutoconfiguredAddress(m_addresses[i], prefix1);\n        NS_LOG_INFO(\"address = \" << ipv6address);\n    }\n\n    Ipv6Address prefix2(\"2002:1:1::\");\n\n    NS_LOG_INFO(\"prefix = \" << prefix2);\n    for (uint32_t i = 0; i < 10; ++i)\n    {\n        Ipv6Address ipv6address = Ipv6Address::MakeAutoconfiguredAddress(m_addresses[i], prefix2);\n        NS_LOG_INFO(\"address = \" << ipv6address);\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a simple wireless network with WiFi nodes. The network consists of two nodes, where Node 0 is the TCP client and Node 1 is the TCP server. Use 802.11b WiFi standard and create a simple TCP connection between the nodes. Set the Ssid for WiFi to 'ns-3-ssid' and the TCP port to 9. The server starts at 1 second and stops at 10 seconds, while the client starts at 2 seconds and stops at 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"WifiSimpleExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the network\n    NodeContainer nodes;\n    nodes.Create(2); // Two nodes: Client and Server\n\n    // Set up mobility model (place nodes at fixed positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Set up WiFi helper for wireless communication\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    // Set up WiFi PHY (physical layer)\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(YansWifiChannelHelper::Default().Create());\n\n    // Set up WiFi MAC (media access control)\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(Ssid(\"ns-3-ssid\")));\n\n    // Install WiFi devices on nodes\n    NetDeviceContainer devices;\n    devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up the TCP server application on Node 1 (server)\n    uint16_t port = 9; // TCP port for communication\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1)); // Install on Node 1 (Server)\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the TCP client application on Node 0 (client)\n    BulkSendHelper bulkSendHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    bulkSendHelper.SetAttribute(\"MaxBytes\", UintegerValue(0));             // Unlimited data transfer\n    ApplicationContainer clientApp = bulkSendHelper.Install(nodes.Get(0)); // Install on Node 0 (Client)\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ script using ns-3 that configures two nodes with 802.11b NICs operating in ad-hoc mode. The nodes are set to communicate over a physical layer that uses a fixed received signal strength (RSS), regardless of their positions. The script should allow sending one 1000-byte packet by default between the nodes and provide several command-line options for modifying behavior. Ensure the physical layer stops receiving packets when the RSS drops below a threshold, and implement verbose logging, pcap trace generation, and command-line control for attributes like RSS and packet size."}, {"role": "assistant", "content": "// This script configures two nodes on an 802.11b physical layer, with\n// 802.11b NICs in adhoc mode, and by default, sends one packet of 1000\n// (application) bytes to the other node.  The physical layer is configured\n// to receive at a fixed RSS (regardless of the distance and transmit\n// power); therefore, changing position of the nodes has no effect.\n//\n// There are a number of command-line options available to control\n// the default behavior.  The list of available command-line options\n// can be listed with the following command:\n// ./ns3 run \"wifi-simple-adhoc --help\"\n//\n// For instance, for this configuration, the physical layer will\n// stop successfully receiving packets when rss drops below -97 dBm.\n// To see this effect, try running:\n//\n// ./ns3 run \"wifi-simple-adhoc --rss=-97 --numPackets=20\"\n// ./ns3 run \"wifi-simple-adhoc --rss=-98 --numPackets=20\"\n// ./ns3 run \"wifi-simple-adhoc --rss=-99 --numPackets=20\"\n//\n// Note that all ns-3 attributes (not just the ones exposed in the below\n// script) can be changed at command line; see the documentation.\n//\n// This script can also be helpful to put the Wifi layer into verbose\n// logging mode; this command will turn on all wifi logging:\n//\n// ./ns3 run \"wifi-simple-adhoc --verbose=1\"\n//\n// When you are done, you will notice two pcap trace files in your directory.\n// If you have tcpdump installed, you can try this:\n//\n// tcpdump -r wifi-simple-adhoc-0-0.pcap -nn -tt\n//\n\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/string.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleAdhoc\");\n\n/**\n * Function called when a packet is received.\n *\n * \\param socket The receiving socket.\n */\nvoid\nReceivePacket(Ptr<Socket> socket)\n{\n    while (socket->Recv())\n    {\n        NS_LOG_UNCOND(\"Received one packet!\");\n    }\n}\n\n/**\n * Generate traffic.\n *\n * \\param socket The sending socket.\n * \\param pktSize The packet size.\n * \\param pktCount The packet count.\n * \\param pktInterval The interval between two packets.\n */\nstatic void\nGenerateTraffic(Ptr<Socket> socket, uint32_t pktSize, uint32_t pktCount, Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval,\n                            &GenerateTraffic,\n                            socket,\n                            pktSize,\n                            pktCount - 1,\n                            pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string phyMode(\"DsssRate1Mbps\");\n    dBm_u rss{-80};\n    uint32_t packetSize{1000}; // bytes\n    uint32_t numPackets{1};\n    Time interPacketInterval{\"1s\"};\n    bool verbose{false};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"phyMode\", \"Wifi Phy mode\", phyMode);\n    cmd.AddValue(\"rss\", \"received signal strength\", rss);\n    cmd.AddValue(\"packetSize\", \"size of application packet sent\", packetSize);\n    cmd.AddValue(\"numPackets\", \"number of packets generated\", numPackets);\n    cmd.AddValue(\"interval\", \"interval between packets\", interPacketInterval);\n    cmd.AddValue(\"verbose\", \"turn on all WifiNetDevice log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    // Fix non-unicast data rate to be the same as that of unicast\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(phyMode));\n\n    NodeContainer c;\n    c.Create(2);\n\n    // The below set of helpers will help us to put together the wifi NICs we want\n    WifiHelper wifi;\n    if (verbose)\n    {\n        WifiHelper::EnableLogComponents(); // Turn on all Wifi logging\n    }\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy;\n    // This is one parameter that matters when using FixedRssLossModel\n    // set it to zero; otherwise, gain will be added\n    wifiPhy.Set(\"RxGain\", DoubleValue(0));\n    // ns-3 supports RadioTap and Prism tracing extensions for 802.11b\n    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    // The below FixedRssLossModel will cause the rss to be fixed regardless\n    // of the distance between the two stations, and the transmit power\n    wifiChannel.AddPropagationLoss(\"ns3::FixedRssLossModel\", \"Rss\", DoubleValue(rss));\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Add a mac and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n    // Set it to adhoc mode\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, c);\n\n    // Note that with FixedRssLossModel, the positions below are not\n    // used for received signal strength.\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    Ipv4AddressHelper ipv4;\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(c.Get(0), tid);\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 80);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    Ptr<Socket> source = Socket::CreateSocket(c.Get(1), tid);\n    InetSocketAddress remote = InetSocketAddress(Ipv4Address(\"255.255.255.255\"), 80);\n    source->SetAllowBroadcast(true);\n    source->Connect(remote);\n\n    // Tracing\n    wifiPhy.EnablePcap(\"wifi-simple-adhoc\", devices);\n\n    // Output what we are doing\n    NS_LOG_UNCOND(\"Testing \" << numPackets << \" packets sent with receiver rss \" << rss);\n\n    Simulator::ScheduleWithContext(source->GetNode()->GetId(),\n                                   Seconds(1.0),\n                                   &GenerateTraffic,\n                                   source,\n                                   packetSize,\n                                   numPackets,\n                                   interPacketInterval);\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that demonstrates OSPF (Open Shortest Path First) routing protocol between multiple nodes using NetAnim. Set up a basic network topology where multiple nodes are interconnected using point-to-point links. OSPF will dynamically compute the shortest path between nodes, and packet flows should be visualized using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ospf-helper.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OspfWithNetAnimExample\");\n\nint main(int argc, char *argv[])\n{\n    // Log level\n    LogComponentEnable(\"OspfWithNetAnimExample\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Set up point-to-point link properties\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install links between nodes in a square topology\n    NetDeviceContainer d1d2, d2d3, d3d4, d4d1;\n    d1d2 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));\n    d2d3 = pointToPoint.Install(nodes.Get(1), nodes.Get(2));\n    d3d4 = pointToPoint.Install(nodes.Get(2), nodes.Get(3));\n    d4d1 = pointToPoint.Install(nodes.Get(3), nodes.Get(0));\n\n    // Install internet stack on nodes with OSPF routing\n    OspfHelper ospfRouting;\n    Ipv4ListRoutingHelper listRouting;\n    listRouting.Add(ospfRouting, 10); // OSPF priority 10\n    InternetStackHelper stack;\n    stack.SetRoutingHelper(listRouting);\n    stack.Install(nodes);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfaces;\n    \n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(d1d2));\n    \n    address.SetBase(\"10.2.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(d2d3));\n    \n    address.SetBase(\"10.3.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(d3d4));\n    \n    address.SetBase(\"10.4.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(d4d1));\n\n    // Enable OSPF to populate routing tables\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create TCP traffic from node 1 to node 3\n    uint16_t port = 50000;\n    OnOffHelper onOffHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(2), port));\n    onOffHelper.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    onOffHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = onOffHelper.Install(nodes.Get(0)); // TCP traffic from node 1 to node 3\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Install a sink on node 3\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sinkHelper.Install(nodes.Get(2));\n    sinkApp.Start(Seconds(0.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Set up NetAnim\n    AnimationInterface anim(\"ospf_with_netanim.xml\");\n\n    // Set node positions for better visualization\n    anim.SetConstantPosition(nodes.Get(0), 10, 10);\n    anim.SetConstantPosition(nodes.Get(1), 30, 10);\n    anim.SetConstantPosition(nodes.Get(2), 30, 30);\n    anim.SetConstantPosition(nodes.Get(3), 10, 30);\n\n    // Enable packet metadata for visualization\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(12.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using NS-3 to simulate a basic Wi-Fi network consisting of three nodes: one acting as an access point (AP) and the other two as Wi-Fi stations (STAs). The stations should communicate with each other through the AP. Set up an IPv4 network and assign IP addresses to all nodes. Implement a UDP echo protocol where one station acts as a client and the other as a server. The client should send a 512-byte message to the server. Capture network traffic in a .pcap file. The simulation should run for 20 seconds, with the UDP server starting at 1 second and the client starting at 2 seconds. Ensure the simulation ends after all messages are exchanged."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleAdhocExample\");\n\nint main(int argc, char *argv[]) {\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create three nodes (1 Access Point, 2 Stations)\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Configure Wi-Fi channel and physical layer\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    // Set Wi-Fi standard and install on nodes\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\", \"DataMode\", StringValue(\"HtMcs7\"), \"ControlMode\", StringValue(\"HtMcs0\"));\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n\n    // Configure the stations (STAs)\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure the access point (AP)\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set mobility model for all nodes (random positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \n                                  \"MinX\", DoubleValue(0.0), \n                                  \"MinY\", DoubleValue(0.0), \n                                  \"DeltaX\", DoubleValue(5.0), \n                                  \"DeltaY\", DoubleValue(10.0), \n                                  \"GridWidth\", UintegerValue(3), \n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    \n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Install Internet stack (IP protocol)\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Create a UDP echo server on one of the stations (node 0)\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Create a UDP echo client on the other station (node 1)\n    UdpEchoClientHelper echoClient(staInterfaces.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10)); // Send 10 packets\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp = echoClient.Install(wifiStaNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(20.0));\n\n    // Enable packet capture\n    phy.EnablePcap(\"wifi-simple\", staDevices.Get(0));\n\n    // Enable logging for debugging purposes\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"ArpL3Protocol\", LOG_LEVEL_INFO); // For ARP resolution\n\n    // Run the simulation\n    Simulator::Stop(Seconds(21.0)); // Ensure the simulation stops after 21 seconds\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless LAN network using ns-3 where a single access point (AP) communicates with two wireless stations (STAs). Configure TCP traffic where one station acts as a server and another as a client. The Wi-Fi standard should be 802.11b with a data rate of 11 Mbps. Run the simulation for 10 seconds and use pcap tracing to capture packet transmissions. Measure the throughput at the server side and display packet counts at the end of the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation parameters\n    double simulationTime = 10.0; // seconds\n\n    // Enable logging for BulkSend and PacketSink applications\n    LogComponentEnable(\"BulkSendApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"PacketSink\", LOG_LEVEL_INFO);\n\n    // Create AP and STA nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2); // Two stations (STA)\n\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1); // One access point (AP)\n\n    // Set up Wi-Fi network\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n\n    // Configure STA devices\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure AP device\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set up mobility for stations and AP\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Install TCP/IP stack on both AP and STA nodes\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Create a TCP server (packet sink) on one STA\n    uint16_t port = 9;  // TCP port\n    Address sinkAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(wifiStaNodes.Get(1)); // Server on STA2\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(simulationTime + 1));\n\n    // Create a TCP client (bulk sender) on another STA\n    BulkSendHelper bulkSend(\"ns3::TcpSocketFactory\",\n                            InetSocketAddress(staInterfaces.GetAddress(1), port));\n    bulkSend.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data\n    ApplicationContainer clientApp = bulkSend.Install(wifiStaNodes.Get(0)); // Client on STA1\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime + 1));\n\n    // Enable packet capture tracing\n    phy.EnablePcap(\"wifi-tcp\", apDevice.Get(0));\n\n    // FlowMonitor to monitor traffic\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime + 1));\n    Simulator::Run();\n\n    // Output flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Bytes: \" << i->second.txBytes);\n        NS_LOG_UNCOND(\"  Rx Bytes: \" << i->second.rxBytes);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 / simulationTime / 1000 / 1000 << \" Mbps\");\n    }\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 network simulator to build a simple LAN (CSMA) connecting two nodes, n0 and n1. Implement a UDP flow from n0 to n1, where packets are drawn from a trace file. Provide options for using either IPv4 or IPv6 addressing and for enabling or disabling logging of the simulation events. Configure a CSMA channel between the nodes with a data rate of 5 Mbps, a delay of 2 ms, and an MTU of 1500 bytes. Start the UDP server at 1 second and the client at 2 seconds, running the simulation for a total of 10 seconds."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1\n//       |     |\n//       =======\n//         LAN (CSMA)\n//\n// - UDP flow from n0 to n1 of packets drawn from a trace file\n//  -- option to use IPv4 or IPv6 addressing\n//  -- option to disable logging statements\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpTraceClientServerExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Declare variables used in command-line arguments\n    bool useV6 = false;\n    bool logging = true;\n    Address serverAddress;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"useIpv6\", \"Use Ipv6\", useV6);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.Parse(argc, argv);\n\n    if (logging)\n    {\n        LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n    }\n\n    NS_LOG_INFO(\"Create nodes in above topology.\");\n    NodeContainer n;\n    n.Create(2);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    NS_LOG_INFO(\"Create channel between the two nodes.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1500));\n    NetDeviceContainer d = csma.Install(n);\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    if (!useV6)\n    {\n        Ipv4AddressHelper ipv4;\n        ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer i = ipv4.Assign(d);\n        serverAddress = Address(i.GetAddress(1));\n    }\n    else\n    {\n        Ipv6AddressHelper ipv6;\n        ipv6.SetBase(\"2001:0000:f00d:cafe::\", Ipv6Prefix(64));\n        Ipv6InterfaceContainer i6 = ipv6.Assign(d);\n        serverAddress = Address(i6.GetAddress(1, 1));\n    }\n\n    NS_LOG_INFO(\"Create UdpServer application on node 1.\");\n    uint16_t port = 4000;\n    UdpServerHelper server(port);\n    ApplicationContainer apps = server.Install(n.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Create UdpClient application on node 0 to send to node 1.\");\n    uint32_t MaxPacketSize = 1472; // Back off 20 (IP) + 8 (UDP) bytes from MTU\n    UdpTraceClientHelper client(serverAddress, port, \"\");\n    client.SetAttribute(\"MaxPacketSize\", UintegerValue(MaxPacketSize));\n    apps = client.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a Mobile Ad Hoc Network (MANET) with five nodes using AODV routing. The nodes should move randomly using the RandomWaypointMobilityModel with a speed of 5 m/s and a pause time of 2 seconds. The network should use 802.11b WiFi for communication. Node 0 should be a UDP client sending 512-byte packets every 50ms to Node 4, which acts as a UDP server on port 4000. The simulation should run for 20 seconds, with PCAP tracing enabled."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ManetAodvExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"ManetAodvExample\", LOG_LEVEL_INFO);\n\n    // Create 5 mobile nodes\n    NodeContainer nodes;\n    nodes.Create(5);\n\n    // Configure WiFi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", StringValue(\"ns3::ConstantRandomVariable[Constant=5.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=2.0]\"),\n                              \"PositionAllocator\", StringValue(\"ns3::GridPositionAllocator\"));\n    mobility.Install(nodes);\n\n    // Install Internet stack with AODV routing\n    AodvHelper aodv;\n    Ipv4StaticRoutingHelper staticRouting;\n    Ipv4ListRoutingHelper list;\n    list.Add(staticRouting, 0);\n    list.Add(aodv, 10);\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(list);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a UDP server on Node 4\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(4));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Set up a UDP client on Node 0 sending to Node 4\n    UdpClientHelper udpClient(interfaces.GetAddress(4), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(50)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(20.0));\n\n    // Enable PCAP tracing\n    wifiPhy.EnablePcap(\"manet-aodv\", devices);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to set up a branch topology with four nodes. Node 0 acts as the central node, with point-to-point links connecting it to nodes 1, 2, and 3. Configure UDP traffic so that nodes 1, 2, and 3 send traffic to node 0, and assign unique IP addresses to each network segment. Enable PCAP tracing to capture the traffic, and run the simulation for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BranchTopology4Nodes\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"BranchTopology4Nodes\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes: node 0 as central, nodes 1, 2, and 3 as branches\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Set up point-to-point links\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install point-to-point links between node 0 and the other nodes (1, 2, and 3)\n    NetDeviceContainer device01, device02, device03;\n    device01 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));  // Link between node 0 and node 1\n    device02 = pointToPoint.Install(nodes.Get(0), nodes.Get(2));  // Link between node 0 and node 2\n    device03 = pointToPoint.Install(nodes.Get(0), nodes.Get(3));  // Link between node 0 and node 3\n\n    // Install internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces01 = address.Assign(device01);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces02 = address.Assign(device02);\n\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces03 = address.Assign(device03);\n\n    // Set up a UDP Echo server on node 0\n    UdpEchoServerHelper echoServer(9);  // Port number\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 1 to send packets to node 0\n    UdpEchoClientHelper echoClient1(interfaces01.GetAddress(0), 9);\n    echoClient1.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient1.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient1.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApps1 = echoClient1.Install(nodes.Get(1));\n    clientApps1.Start(Seconds(2.0));\n    clientApps1.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 2 to send packets to node 0\n    UdpEchoClientHelper echoClient2(interfaces02.GetAddress(0), 9);\n    echoClient2.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient2.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient2.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApps2 = echoClient2.Install(nodes.Get(2));\n    clientApps2.Start(Seconds(2.5));\n    clientApps2.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 3 to send packets to node 0\n    UdpEchoClientHelper echoClient3(interfaces03.GetAddress(0), 9);\n    echoClient3.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient3.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient3.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApps3 = echoClient3.Install(nodes.Get(3));\n    clientApps3.Start(Seconds(3.0));\n    clientApps3.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing to capture packet transmissions\n    pointToPoint.EnablePcapAll(\"branch-topology-4-nodes\");\n\n    // Run the simulation\n    Simulator::Run();\n\n    // End the simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 to simulate Distance Vector Routing (DVR) in a small network. Create a simple network topology with three routers and four subnetworks, where Distance Vector Routing is used to dynamically compute the best path between nodes. The topology should include point-to-point links between the routers and allow traffic between subnetworks using the dynamic routing information generated by DVR. Also, include pcap tracing to capture the data flow and routing exchanges."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/rip-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"DVRSimulation\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Command-line options\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Step 1: Create nodes (3 routers)\n    NodeContainer routers;\n    routers.Create(3);\n\n    // Step 2: Create point-to-point links between routers\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer routerLink1 = p2p.Install(routers.Get(0), routers.Get(1)); // Link between router 0 and router 1\n    NetDeviceContainer routerLink2 = p2p.Install(routers.Get(1), routers.Get(2)); // Link between router 1 and router 2\n    NetDeviceContainer routerLink3 = p2p.Install(routers.Get(0), routers.Get(2)); // Link between router 0 and router 2\n\n    // Step 3: Install internet stacks\n    RipHelper ripRouting;\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(ripRouting); // Use RIP as the routing protocol\n    internet.Install(routers);\n\n    // Step 4: Assign IP addresses to the links\n    Ipv4AddressHelper ipv4;\n\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iRouter1 = ipv4.Assign(routerLink1);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iRouter2 = ipv4.Assign(routerLink2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iRouter3 = ipv4.Assign(routerLink3);\n\n    // Step 5: Enable Global Routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Step 6: Add a UDP echo server on router 2\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(routers.Get(2)); // Server on router 2\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Step 7: Add a UDP echo client on router 0\n    UdpEchoClientHelper echoClient(iRouter2.GetAddress(1), 9); // Targeting router 2 IP\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(routers.Get(0)); // Client on router 0\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Step 8: Enable tracing (pcap files)\n    p2p.EnablePcapAll(\"dvr-routing\");\n\n    // Step 9: Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 to simulate a simple network topology with 4 nodes using the AODV (Ad-hoc On-Demand Distance Vector) routing protocol instead of OSPF. Configure the nodes to form an ad-hoc wireless network, assign IP addresses, and set up a UDP Echo server on node 3. Node 0 should send traffic to node 3 via the AODV protocol. Enable PCAP tracing to capture the traffic and run the simulation for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/aodv-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AodvRoutingExample\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"AodvRoutingExample\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes: node 0, node 1, node 2, and node 3\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Configure WiFi channel and physical layer\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up the WiFi MAC and install on nodes\n    WifiHelper wifi;\n    WifiMacHelper mac;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n    mac.SetType(\"ns3::AdhocWifiMac\");  // Ad-hoc network\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set up mobility model to arrange nodes in a random 100x100 area\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the AODV routing protocol using the InternetStackHelper\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);  // Set AODV as the routing protocol\n    internet.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a UDP Echo server on node 3\n    UdpEchoServerHelper echoServer(9);  // Port 9\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(3));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 0 to send traffic to node 3\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(3), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing to capture the traffic\n    phy.EnablePcapAll(\"aodv-routing-4-nodes\");\n\n    // Run the simulation for 10 seconds\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // End the simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ simulation program using the ns-3 network simulator that sets up a simple Wi-Fi network using either `ns3::SpectrumWifiPhy` or `ns3::YansWifiPhy` for the physical layer. This program should include configuration for multiple modulation and coding schemes (MCS), channel widths, and guard intervals, and allow the user to modify the simulation's parameters through the command line, such as simulation time, distance between nodes, and Wi-Fi and error model types. It should create a Wi-Fi station (STA) and access point (AP) node, transmit UDP packets under different conditions, and output throughput statistics like modulation scheme, channel width, and received data throughput for each MCS index."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/propagation-loss-model.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <iomanip>\n\n// This is a simple example of an IEEE 802.11n Wi-Fi network.\n//\n// The main use case is to enable and test SpectrumWifiPhy vs YansWifiPhy\n// under saturation conditions (for max throughput).\n//\n// Network topology:\n//\n//  Wi-Fi 192.168.1.0\n//\n//   STA                  AP\n//    * <-- distance -->  *\n//    |                   |\n//    n1                  n2\n//\n// Users may vary the following command-line arguments in addition to the\n// attributes, global values, and default values typically available:\n//\n//    --simulationTime:  Simulation time [10s]\n//    --distance:        meters separation between nodes [1]\n//    --index:           restrict index to single value between 0 and 31 [256]\n//    --wifiType:        select ns3::SpectrumWifiPhy or ns3::YansWifiPhy [ns3::SpectrumWifiPhy]\n//    --errorModelType:  select ns3::NistErrorRateModel or ns3::YansErrorRateModel\n//    [ns3::NistErrorRateModel]\n//    --enablePcap:      enable pcap output [false]\n//\n// By default, the program will step through 64 index values, corresponding\n// to the following MCS, channel width, and guard interval combinations:\n//   index 0-7:    MCS 0-7, long guard interval, 20 MHz channel\n//   index 8-15:   MCS 0-7, short guard interval, 20 MHz channel\n//   index 16-23:  MCS 0-7, long guard interval, 40 MHz channel\n//   index 24-31:  MCS 0-7, short guard interval, 40 MHz channel\n//   index 32-39:    MCS 8-15, long guard interval, 20 MHz channel\n//   index 40-47:   MCS 8-15, short guard interval, 20 MHz channel\n//   index 48-55:  MCS 8-15, long guard interval, 40 MHz channel\n//   index 56-63:  MCS 8-15, short guard interval, 40 MHz channel\n// and send packets at a high rate using each MCS, using the SpectrumWifiPhy\n// and the NistErrorRateModel, at a distance of 1 meter.  The program outputs\n// results such as:\n//\n// wifiType: ns3::SpectrumWifiPhy distance: 1m\n// index   MCS   width Rate (Mb/s) Tput (Mb/s) Received\n//     0     0      20       6.5     5.96219    5063\n//     1     1      20        13     11.9491   10147\n//     2     2      20      19.5     17.9184   15216\n//     3     3      20        26     23.9253   20317\n//     ...\n//\n// selection of index values 32-63 will result in MCS selection 8-15\n// involving two spatial streams\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSpectrumSaturationExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    meter_u distance{1};\n    Time simulationTime{\"10s\"};\n    uint16_t index{256};\n    uint32_t channelWidth{0};\n    std::string wifiType{\"ns3::SpectrumWifiPhy\"};\n    std::string errorModelType{\"ns3::NistErrorRateModel\"};\n    bool enablePcap{false};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"distance\", \"meters separation between nodes\", distance);\n    cmd.AddValue(\"index\", \"restrict index to single value between 0 and 63\", index);\n    cmd.AddValue(\"wifiType\", \"select ns3::SpectrumWifiPhy or ns3::YansWifiPhy\", wifiType);\n    cmd.AddValue(\"errorModelType\",\n                 \"select ns3::NistErrorRateModel or ns3::YansErrorRateModel\",\n                 errorModelType);\n    cmd.AddValue(\"enablePcap\", \"enable pcap output\", enablePcap);\n    cmd.Parse(argc, argv);\n\n    uint16_t startIndex = 0;\n    uint16_t stopIndex = 63;\n    if (index < 64)\n    {\n        startIndex = index;\n        stopIndex = index;\n    }\n\n    std::cout << \"wifiType: \" << wifiType << \" distance: \" << distance << \"m\" << std::endl;\n    std::cout << std::setw(5) << \"index\" << std::setw(6) << \"MCS\" << std::setw(8) << \"width\"\n              << std::setw(12) << \"Rate (Mb/s)\" << std::setw(12) << \"Tput (Mb/s)\" << std::setw(10)\n              << \"Received \" << std::endl;\n    for (uint16_t i = startIndex; i <= stopIndex; i++)\n    {\n        uint32_t payloadSize;\n        payloadSize = 1472; // 1500 bytes IPv4\n\n        NodeContainer wifiStaNode;\n        wifiStaNode.Create(1);\n        NodeContainer wifiApNode;\n        wifiApNode.Create(1);\n\n        YansWifiPhyHelper yansPhy;\n        SpectrumWifiPhyHelper spectrumPhy;\n        if (wifiType == \"ns3::YansWifiPhy\")\n        {\n            YansWifiChannelHelper channel;\n            channel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n            channel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n            yansPhy.SetChannel(channel.Create());\n            yansPhy.Set(\"TxPowerStart\", DoubleValue(1));\n            yansPhy.Set(\"TxPowerEnd\", DoubleValue(1));\n\n            if (i > 31 && i <= 63)\n            {\n                yansPhy.Set(\"Antennas\", UintegerValue(2));\n                yansPhy.Set(\"MaxSupportedTxSpatialStreams\", UintegerValue(2));\n                yansPhy.Set(\"MaxSupportedRxSpatialStreams\", UintegerValue(2));\n            }\n        }\n        else if (wifiType == \"ns3::SpectrumWifiPhy\")\n        {\n            Ptr<MultiModelSpectrumChannel> spectrumChannel =\n                CreateObject<MultiModelSpectrumChannel>();\n            Ptr<FriisPropagationLossModel> lossModel = CreateObject<FriisPropagationLossModel>();\n            spectrumChannel->AddPropagationLossModel(lossModel);\n\n            Ptr<ConstantSpeedPropagationDelayModel> delayModel =\n                CreateObject<ConstantSpeedPropagationDelayModel>();\n            spectrumChannel->SetPropagationDelayModel(delayModel);\n\n            spectrumPhy.SetChannel(spectrumChannel);\n            spectrumPhy.SetErrorRateModel(errorModelType);\n            spectrumPhy.Set(\"TxPowerStart\", DoubleValue(1));\n            spectrumPhy.Set(\"TxPowerEnd\", DoubleValue(1));\n\n            if (i > 31 && i <= 63)\n            {\n                spectrumPhy.Set(\"Antennas\", UintegerValue(2));\n                spectrumPhy.Set(\"MaxSupportedTxSpatialStreams\", UintegerValue(2));\n                spectrumPhy.Set(\"MaxSupportedRxSpatialStreams\", UintegerValue(2));\n            }\n        }\n        else\n        {\n            NS_FATAL_ERROR(\"Unsupported WiFi type \" << wifiType);\n        }\n\n        WifiHelper wifi;\n        wifi.SetStandard(WIFI_STANDARD_80211n);\n        WifiMacHelper mac;\n\n        Ssid ssid = Ssid(\"ns380211n\");\n\n        double datarate = 0;\n        StringValue DataRate;\n        if (i == 0)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 6.5;\n        }\n        else if (i == 1)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 13;\n        }\n        else if (i == 2)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 19.5;\n        }\n        else if (i == 3)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 26;\n        }\n        else if (i == 4)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 39;\n        }\n        else if (i == 5)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 52;\n        }\n        else if (i == 6)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 58.5;\n        }\n        else if (i == 7)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 65;\n        }\n        else if (i == 8)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 7.2;\n        }\n        else if (i == 9)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 14.4;\n        }\n        else if (i == 10)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 21.7;\n        }\n        else if (i == 11)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 28.9;\n        }\n        else if (i == 12)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 43.3;\n        }\n        else if (i == 13)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 57.8;\n        }\n        else if (i == 14)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 65;\n        }\n        else if (i == 15)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 72.2;\n        }\n        else if (i == 16)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 13.5;\n        }\n        else if (i == 17)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 27;\n        }\n        else if (i == 18)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 40.5;\n        }\n        else if (i == 19)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 54;\n        }\n        else if (i == 20)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 81;\n        }\n        else if (i == 21)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 108;\n        }\n        else if (i == 22)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 121.5;\n        }\n        else if (i == 23)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 135;\n        }\n        else if (i == 24)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 15;\n        }\n        else if (i == 25)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 30;\n        }\n        else if (i == 26)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 45;\n        }\n        else if (i == 27)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 60;\n        }\n        else if (i == 28)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 90;\n        }\n        else if (i == 29)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 120;\n        }\n        else if (i == 30)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 135;\n        }\n        else if (i == 31)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 150;\n        }\n        else if (i == 32)\n        {\n            DataRate = StringValue(\"HtMcs8\");\n            datarate = 13;\n        }\n        else if (i == 33)\n        {\n            DataRate = StringValue(\"HtMcs9\");\n            datarate = 26;\n        }\n        else if (i == 34)\n        {\n            DataRate = StringValue(\"HtMcs10\");\n            datarate = 39;\n        }\n        else if (i == 35)\n        {\n            DataRate = StringValue(\"HtMcs11\");\n            datarate = 52;\n        }\n        else if (i == 36)\n        {\n            DataRate = StringValue(\"HtMcs12\");\n            datarate = 78;\n        }\n        else if (i == 37)\n        {\n            DataRate = StringValue(\"HtMcs13\");\n            datarate = 104;\n        }\n        else if (i == 38)\n        {\n            DataRate = StringValue(\"HtMcs14\");\n            datarate = 117;\n        }\n        else if (i == 39)\n        {\n            DataRate = StringValue(\"HtMcs15\");\n            datarate = 130;\n        }\n        else if (i == 40)\n        {\n            DataRate = StringValue(\"HtMcs8\");\n            datarate = 14.4;\n        }\n        else if (i == 41)\n        {\n            DataRate = StringValue(\"HtMcs9\");\n            datarate = 28.9;\n        }\n        else if (i == 42)\n        {\n            DataRate = StringValue(\"HtMcs10\");\n            datarate = 43.3;\n        }\n        else if (i == 43)\n        {\n            DataRate = StringValue(\"HtMcs11\");\n            datarate = 57.8;\n        }\n        else if (i == 44)\n        {\n            DataRate = StringValue(\"HtMcs12\");\n            datarate = 86.7;\n        }\n        else if (i == 45)\n        {\n            DataRate = StringValue(\"HtMcs13\");\n            datarate = 115.6;\n        }\n        else if (i == 46)\n        {\n            DataRate = StringValue(\"HtMcs14\");\n            datarate = 130.3;\n        }\n        else if (i == 47)\n        {\n            DataRate = StringValue(\"HtMcs15\");\n            datarate = 144.4;\n        }\n        else if (i == 48)\n        {\n            DataRate = StringValue(\"HtMcs8\");\n            datarate = 27;\n        }\n        else if (i == 49)\n        {\n            DataRate = StringValue(\"HtMcs9\");\n            datarate = 54;\n        }\n        else if (i == 50)\n        {\n            DataRate = StringValue(\"HtMcs10\");\n            datarate = 81;\n        }\n        else if (i == 51)\n        {\n            DataRate = StringValue(\"HtMcs11\");\n            datarate = 108;\n        }\n        else if (i == 52)\n        {\n            DataRate = StringValue(\"HtMcs12\");\n            datarate = 162;\n        }\n        else if (i == 53)\n        {\n            DataRate = StringValue(\"HtMcs13\");\n            datarate = 216;\n        }\n        else if (i == 54)\n        {\n            DataRate = StringValue(\"HtMcs14\");\n            datarate = 243;\n        }\n        else if (i == 55)\n        {\n            DataRate = StringValue(\"HtMcs15\");\n            datarate = 270;\n        }\n        else if (i == 56)\n        {\n            DataRate = StringValue(\"HtMcs8\");\n            datarate = 30;\n        }\n        else if (i == 57)\n        {\n            DataRate = StringValue(\"HtMcs9\");\n            datarate = 60;\n        }\n        else if (i == 58)\n        {\n            DataRate = StringValue(\"HtMcs10\");\n            datarate = 90;\n        }\n        else if (i == 59)\n        {\n            DataRate = StringValue(\"HtMcs11\");\n            datarate = 120;\n        }\n        else if (i == 60)\n        {\n            DataRate = StringValue(\"HtMcs12\");\n            datarate = 180;\n        }\n        else if (i == 61)\n        {\n            DataRate = StringValue(\"HtMcs13\");\n            datarate = 240;\n        }\n        else if (i == 62)\n        {\n            DataRate = StringValue(\"HtMcs14\");\n            datarate = 270;\n        }\n        else if (i == 63)\n        {\n            DataRate = StringValue(\"HtMcs15\");\n            datarate = 300;\n        }\n        else\n        {\n            NS_FATAL_ERROR(\"Illegal index i \" << i);\n        }\n\n        wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                     \"DataMode\",\n                                     DataRate,\n                                     \"ControlMode\",\n                                     DataRate);\n\n        NetDeviceContainer staDevice;\n        NetDeviceContainer apDevice;\n\n        channelWidth = (i <= 15 || (i > 31 && i <= 47) ? 20 : 40);\n        std::string channelStr = \"{0, \" + std::to_string(channelWidth) + \", BAND_5GHZ, 0}\";\n\n        if (wifiType == \"ns3::YansWifiPhy\")\n        {\n            mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n            yansPhy.Set(\"ChannelSettings\", StringValue(channelStr));\n\n            staDevice = wifi.Install(yansPhy, mac, wifiStaNode);\n            mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n            yansPhy.Set(\"ChannelSettings\", StringValue(channelStr));\n            apDevice = wifi.Install(yansPhy, mac, wifiApNode);\n        }\n        else if (wifiType == \"ns3::SpectrumWifiPhy\")\n        {\n            mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n            spectrumPhy.Set(\"ChannelSettings\", StringValue(channelStr));\n            staDevice = wifi.Install(spectrumPhy, mac, wifiStaNode);\n            mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n            spectrumPhy.Set(\"ChannelSettings\", StringValue(channelStr));\n            apDevice = wifi.Install(spectrumPhy, mac, wifiApNode);\n        }\n\n        bool shortGuardIntervalSupported =\n            (i > 7 && i <= 15) || (i > 23 && i <= 31) || (i > 39 && i <= 47) || (i > 55);\n        Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/\"\n                    \"ShortGuardIntervalSupported\",\n                    BooleanValue(shortGuardIntervalSupported));\n\n        // mobility.\n        MobilityHelper mobility;\n        Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n        positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n        positionAlloc->Add(Vector(distance, 0.0, 0.0));\n        mobility.SetPositionAllocator(positionAlloc);\n\n        mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n        mobility.Install(wifiApNode);\n        mobility.Install(wifiStaNode);\n\n        /* Internet stack*/\n        InternetStackHelper stack;\n        stack.Install(wifiApNode);\n        stack.Install(wifiStaNode);\n\n        Ipv4AddressHelper address;\n        address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer staNodeInterface;\n        Ipv4InterfaceContainer apNodeInterface;\n\n        staNodeInterface = address.Assign(staDevice);\n        apNodeInterface = address.Assign(apDevice);\n\n        /* Setting applications */\n        uint16_t port = 9;\n        UdpServerHelper server(port);\n        ApplicationContainer serverApp = server.Install(wifiStaNode.Get(0));\n        serverApp.Start(Seconds(0.0));\n        serverApp.Stop(simulationTime + Seconds(1.0));\n        const auto packetInterval = payloadSize * 8.0 / (datarate * 1e6);\n\n        UdpClientHelper client(staNodeInterface.GetAddress(0), port);\n        client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n        client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n        client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n        ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n        clientApp.Start(Seconds(1.0));\n        clientApp.Stop(simulationTime + Seconds(1.0));\n\n        if (enablePcap)\n        {\n            auto& phy =\n                (wifiType == \"ns3::YansWifiPhy\" ? dynamic_cast<WifiPhyHelper&>(yansPhy)\n                                                : dynamic_cast<WifiPhyHelper&>(spectrumPhy));\n            phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n            std::stringstream ss;\n            ss << \"wifi-spectrum-saturation-example-\" << i;\n            phy.EnablePcap(ss.str(), apDevice);\n        }\n\n        Simulator::Stop(simulationTime + Seconds(1.0));\n        Simulator::Run();\n\n        double totalPacketsThrough = DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n        auto throughput =\n            totalPacketsThrough * payloadSize * 8 / simulationTime.GetMicroSeconds(); // Mbit/s\n        std::cout << std::setw(5) << i << std::setw(6) << (i % 8) + 8 * (i / 32) << std::setw(8)\n                  << channelWidth << std::setw(10) << datarate << std::setw(12) << throughput\n                  << std::setw(8) << totalPacketsThrough << std::endl;\n        Simulator::Destroy();\n    }\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and assigns them individual names using an Object Name Service (ONS). The program should then print the assigned names along with their unique node IDs. Keep the example simple and focus on node creation and naming."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/object.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"NodeNamingExample\", LOG_LEVEL_INFO);\n\n    // Create a NodeContainer and generate 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Assign names to each node using Object Name Service (ONS)\n    for (uint32_t i = 0; i < nodes.GetN(); ++i) {\n        std::ostringstream nodeName;\n        nodeName << \"Node-\" << i;\n        Names::Add(nodeName.str(), nodes.Get(i));\n\n        // Print assigned names and node IDs\n        NS_LOG_INFO(nodeName.str() << \" has ID: \" << nodes.Get(i)->GetId());\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a Wi-Fi Mesh Network with four mesh nodes. The last node acts as a UDP server on port 9, and the first three nodes act as UDP clients. The UDP clients send 1,000 UDP packets of 1024 bytes each with an interval of 0.01 seconds. The simulation runs for 10 seconds, with the server starting at 1 second and the clients starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleMeshExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleMeshExample\", LOG_LEVEL_INFO);\n\n    // Create mesh nodes\n    NodeContainer meshNodes;\n    meshNodes.Create(4);\n\n    // Set up Wi-Fi mesh network\n    MeshHelper meshHelper;\n    meshHelper.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n    meshHelper.SetRemoteStationManager(\"ns3::ArfWifiManager\");\n\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns-3-mesh-ssid\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    WifiMacHelper apMac;\n    apMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    // Install Wi-Fi devices (mesh nodes)\n    NetDeviceContainer meshDevices = meshHelper.Install(wifiPhy, wifiMac, meshNodes);\n\n    // Install internet stack (IP, UDP, etc.)\n    InternetStackHelper stack;\n    stack.Install(meshNodes);\n\n    // Assign IP addresses to mesh nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer meshIpIface = ipv4.Assign(meshDevices);\n\n    // Set up UDP server on the last mesh node\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(meshNodes.Get(3));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on each of the other mesh nodes\n    UdpClientHelper udpClient(meshIpIface.GetAddress(3), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp;\n    for (uint32_t i = 0; i < 3; ++i)\n    {\n        clientApp.Add(udpClient.Install(meshNodes.Get(i)));\n    }\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating an LTE network with one eNodeB and three UE nodes. The UE nodes should be mobile within a 100x100 area, while the eNodeB remains stationary. UE 0 should act as a UDP server on port 5000, while UE 1 should be a UDP client sending 512-byte packets every 10ms. The LTE network should assign IP addresses to the UEs, and PCAP tracing should be enabled. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteBasicSimulation\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"LteBasicSimulation\", LOG_LEVEL_INFO);\n\n    // Create LTE eNodeB and UE nodes\n    NodeContainer ueNodes, enbNode;\n    ueNodes.Create(3);\n    enbNode.Create(1);\n\n    // Set up mobility models\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(enbNode);\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-100, 100, -100, 100)));\n    mobility.Install(ueNodes);\n\n    // Install LTE module\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    NetDeviceContainer enbDevice = lteHelper->InstallEnbDevice(enbNode);\n    NetDeviceContainer ueDevices = lteHelper->InstallUeDevice(ueNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n\n    // Assign IP addresses\n    Ipv4InterfaceContainer ueInterfaces = lteHelper->AssignUeIpv4Address(NetDeviceContainer(ueDevices));\n\n    // Attach UE nodes to eNodeB\n    for (uint32_t i = 0; i < ueNodes.GetN(); ++i)\n    {\n        lteHelper->Attach(ueDevices.Get(i), enbDevice.Get(0));\n    }\n\n    // Set up a UDP server on UE 0\n    uint16_t port = 5000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ueNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up a UDP client on UE 1 sending to UE 0\n    UdpClientHelper udpClient(ueInterfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = udpClient.Install(ueNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing\n    lteHelper->EnablePcapAll(\"lte-basic\");\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Wi-Fi communication between two nodes in an ad hoc network using the 802.11b standard. One node should act as a UDP server and the other as a UDP client. The communication should use UDP packets, with the client sending 10 packets of 1024 bytes at a 1-second interval. The server should be installed on Node 0, and the client on Node 1. The simulation should run for 10 seconds, starting the server at 1 second and the client at 2 seconds. Use an SSID named \"wifi-adhoc-network\" and configure the Wi-Fi physical and MAC layers accordingly."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpClientServerExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiUdpClientServerExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Wi-Fi and install Wi-Fi devices on the nodes\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"wifi-adhoc-network\");\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Install the internet stack (IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create and install the UDP server on Node 0\n    uint16_t port = 9; // Port number for UDP connection\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create and install the UDP client on Node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // Send 10 packets\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // Interval between packets\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // Packet size\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Wi-Fi network with one Access Point (AP) and three stations (STAs). The AP should be static, while the STAs should be placed in a grid layout. Use the IEEE 802.11n 5GHz standard for Wi-Fi. Set the IP address for the STAs and the AP. Create a Simplex UDP server on the AP and Simplex UDP clients on the STAs, where each STA sends five 512-byte packets at 1-second intervals to the AP. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Set the number of stations\n    uint32_t numSta = 3;\n\n    // Create nodes: 1 AP and several STAs\n    NodeContainer apNode, staNodes;\n    apNode.Create(1);\n    staNodes.Create(numSta);\n\n    // Set up the Wi-Fi devices\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"wifi-network\");\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"BeaconInterval\", TimeValue(Seconds(2)));\n\n    WifiDeviceHelper wifiDevices;\n    wifiDevices.SetDeviceAttribute(\"WifiPhy\", PointerValue(&phy));\n    NetDeviceContainer apDevice = wifiDevices.Install(apNode);\n    NetDeviceContainer staDevices = wifiDevices.Install(staNodes);\n\n    // Set mobility model (static AP and random STAs)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(apNode);\n    mobility.Install(staNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(apNode);\n    internet.Install(staNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = ipv4.Assign(staDevices);\n    Ipv4InterfaceContainer apInterfaces = ipv4.Assign(apDevice);\n\n    // Create a Simplex UDP server on AP\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(apNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create Simplex UDP clients on STAs\n    UdpClientHelper udpClient(apInterfaces.GetAddress(0), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < numSta; i++)\n    {\n        clientApps.Add(udpClient.Install(staNodes.Get(i)));\n    }\n\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 to simulate a UDP Echo Client and Server for six nodes. Set up five point-to-point links: one between node 0 and node 1, another between node 1 and node 2, one between node 2 and node 3, one between node 3 and node 4, and the last one between node 4 and node 5. All links should have a data rate of 5Mbps and a delay of 2ms. The client on node 0 should send UDP packets to the server on node 5, with nodes 1, 2, 3, and 4 acting as routers. Ensure proper routing and log packet transmission and reception during the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpEchoSixNodesExample\");\n\nint \nmain(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"UdpEchoSixNodesExample\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create six nodes\n    NodeContainer nodes;\n    nodes.Create(6); // Six nodes: n0 -> n1 -> n2 -> n3 -> n4 -> n5\n\n    // Configure point-to-point link between nodes n0 and n1\n    PointToPointHelper pointToPoint1;\n    pointToPoint1.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint1.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Configure point-to-point link between nodes n1 and n2\n    PointToPointHelper pointToPoint2;\n    pointToPoint2.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint2.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Configure point-to-point link between nodes n2 and n3\n    PointToPointHelper pointToPoint3;\n    pointToPoint3.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint3.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Configure point-to-point link between nodes n3 and n4\n    PointToPointHelper pointToPoint4;\n    pointToPoint4.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint4.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Configure point-to-point link between nodes n4 and n5\n    PointToPointHelper pointToPoint5;\n    pointToPoint5.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint5.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on the nodes and the links between them\n    NetDeviceContainer devices1, devices2, devices3, devices4, devices5;\n    devices1 = pointToPoint1.Install(nodes.Get(0), nodes.Get(1)); // Link n0 -> n1\n    devices2 = pointToPoint2.Install(nodes.Get(1), nodes.Get(2)); // Link n1 -> n2\n    devices3 = pointToPoint3.Install(nodes.Get(2), nodes.Get(3)); // Link n2 -> n3\n    devices4 = pointToPoint4.Install(nodes.Get(3), nodes.Get(4)); // Link n3 -> n4\n    devices5 = pointToPoint5.Install(nodes.Get(4), nodes.Get(5)); // Link n4 -> n5\n\n    // Install Internet stack (TCP/IP stack) on the nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes' links\n    Ipv4AddressHelper address;\n\n    // IP address for the link between n0 and n1\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces1 = address.Assign(devices1);\n\n    // IP address for the link between n1 and n2\n    address.SetBase(\"10.2.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces2 = address.Assign(devices2);\n\n    // IP address for the link between n2 and n3\n    address.SetBase(\"10.3.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces3 = address.Assign(devices3);\n\n    // IP address for the link between n3 and n4\n    address.SetBase(\"10.4.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces4 = address.Assign(devices4);\n\n    // IP address for the link between n4 and n5\n    address.SetBase(\"10.5.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces5 = address.Assign(devices5);\n\n    // Enable routing on nodes n1, n2, n3, and n4 (routers)\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create and set up UDP Echo Server on node n5 (server)\n    uint16_t port = 9; // Echo server port number\n    UdpEchoServerHelper echoServer(port);\n\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(5)); // Server is node n5\n    serverApp.Start(Seconds(1.0)); // Start server at time = 1 second\n    serverApp.Stop(Seconds(10.0)); // Stop server at time = 10 seconds\n\n    // Create and set up UDP Echo Client on node n0 (client)\n    uint32_t packetSize = 1024;   // Packet size\n    uint32_t nPackets = 10;       // Number of packets to send\n    double interval = 1.0;        // Interval between packets (1 second)\n\n    UdpEchoClientHelper echoClient(interfaces5.GetAddress(1), port); // Server's IP (n5)\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(nPackets));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(interval)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0)); // Client is node n0\n    clientApp.Start(Seconds(2.0)); // Start client at time = 2 seconds\n    clientApp.Stop(Seconds(10.0)); // Stop client at time = 10 seconds\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulator to demonstrate 802.11n aggregation across four independent Wi-Fi networks, each operating on a different channel (36, 40, 44, and 48) with one access point (AP) and one station (STA) per network. Configure different aggregation settings for each station: station A uses default A-MPDU with a max size of 65kB, station B disables aggregation, station C enables A-MSDU with a max size of 8kB but disables A-MPDU, and station D enables both A-MPDU with a max size of 32kB and A-MSDU with 4kB. Include options for adjusting distance between the AP and STA, enabling/disabling RTS/CTS, and modifying TXOP durations, then output the throughput and maximum TXOP duration for each network. Use the YansWifiPhy, YansWifiChannel, and mobility models to set up the simulation, and trace TXOP durations for each access point using callbacks."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/pointer.h\"\n#include \"ns3/qos-txop.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/wifi-mac.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This is an example that illustrates how 802.11n aggregation is configured.\n// It defines 4 independent Wi-Fi networks (working on different channels).\n// Each network contains one access point and one station. Each station\n// continuously transmits data packets to its respective AP.\n//\n// Network topology (numbers in parentheses are channel numbers):\n//\n//  Network A (36)   Network B (40)   Network C (44)   Network D (48)\n//   *      *          *      *         *      *          *      *\n//   |      |          |      |         |      |          |      |\n//  AP A   STA A      AP B   STA B     AP C   STA C      AP D   STA D\n//\n// The aggregation parameters are configured differently on the 4 stations:\n// - station A uses default aggregation parameter values (A-MSDU disabled, A-MPDU enabled with\n// maximum size of 65 kB);\n// - station B doesn't use aggregation (both A-MPDU and A-MSDU are disabled);\n// - station C enables A-MSDU (with maximum size of 8 kB) but disables A-MPDU;\n// - station D uses two-level aggregation (A-MPDU with maximum size of 32 kB and A-MSDU with maximum\n// size of 4 kB).\n//\n// The user can select the distance between the stations and the APs, can enable/disable the RTS/CTS\n// mechanism and can modify the duration of a TXOP. Example: ./ns3 run \"wifi-txop-aggregation\n// --distance=10 --enableRts=0 --simulationTime=20s\"\n//\n// The output prints the throughput and the maximum TXOP duration measured for the 4 cases/networks\n// described above. When default aggregation parameters are enabled, the\n// maximum A-MPDU size is 65 kB and the throughput is maximal. When aggregation is disabled, the\n// throughput is about the half of the physical bitrate. When only A-MSDU is enabled, the throughput\n// is increased but is not maximal, since the maximum A-MSDU size is limited to 7935 bytes (whereas\n// the maximum A-MPDU size is limited to 65535 bytes). When A-MSDU and A-MPDU are both enabled (=\n// two-level aggregation), the throughput is slightly smaller than the first scenario since we set a\n// smaller maximum A-MPDU size.\n//\n// When the distance is increased, the frame error rate gets higher, and the output shows how it\n// affects the throughput for the 4 networks. Even through A-MSDU has less overheads than A-MPDU,\n// A-MSDU is less robust against transmission errors than A-MPDU. When the distance is augmented,\n// the throughput for the third scenario is more affected than the throughput obtained in other\n// networks.\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TxopMpduAggregation\");\n\n/**\n * Keeps the maximum duration among all TXOPs\n */\nstruct TxopDurationTracer\n{\n    /**\n     * Callback connected to TXOP duration trace source.\n     *\n     * \\param startTime TXOP start time\n     * \\param duration TXOP duration\n     * \\param linkId the ID of the link\n     */\n    void Trace(Time startTime, Time duration, uint8_t linkId);\n    Time m_max{Seconds(0)}; //!< maximum TXOP duration\n};\n\nvoid\nTxopDurationTracer::Trace(Time startTime, Time duration, uint8_t linkId)\n{\n    if (duration > m_max)\n    {\n        m_max = duration;\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t payloadSize{1472}; // bytes\n    Time simulationTime{\"10s\"};\n    double txopLimit{3520}; // microseconds\n    meter_u distance{5};\n    bool enableRts{false};\n    bool enablePcap{false};\n    bool verifyResults{false}; // used for regression\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"payloadSize\", \"Payload size in bytes\", payloadSize);\n    cmd.AddValue(\"enableRts\", \"Enable or disable RTS/CTS\", enableRts);\n    cmd.AddValue(\"txopLimit\", \"TXOP duration in microseconds\", txopLimit);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the station and the access point\",\n                 distance);\n    cmd.AddValue(\"enablePcap\", \"Enable/disable pcap file generation\", enablePcap);\n    cmd.AddValue(\"verifyResults\",\n                 \"Enable/disable results verification at the end of the simulation\",\n                 verifyResults);\n    cmd.Parse(argc, argv);\n\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\",\n                       enableRts ? StringValue(\"0\") : StringValue(\"999999\"));\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(4);\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(4);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"HtMcs7\"),\n                                 \"ControlMode\",\n                                 StringValue(\"HtMcs0\"));\n    WifiMacHelper mac;\n\n    NetDeviceContainer staDeviceA;\n    NetDeviceContainer staDeviceB;\n    NetDeviceContainer staDeviceC;\n    NetDeviceContainer staDeviceD;\n    NetDeviceContainer apDeviceA;\n    NetDeviceContainer apDeviceB;\n    NetDeviceContainer apDeviceC;\n    NetDeviceContainer apDeviceD;\n    Ssid ssid;\n\n    // Network A\n    ssid = Ssid(\"network-A\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{36, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    staDeviceA = wifi.Install(phy, mac, wifiStaNodes.Get(0));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    // Modify EDCA configuration (TXOP limit) for AC_BE\n    mac.SetEdca(AC_BE, \"TxopLimits\", StringValue(std::to_string(txopLimit) + \"us\"));\n    apDeviceA = wifi.Install(phy, mac, wifiApNodes.Get(0));\n\n    // Modify EDCA configuration (TXOP limit) for AC_BE\n    Ptr<NetDevice> dev = wifiApNodes.Get(0)->GetDevice(0);\n    Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    PointerValue ptr;\n    Ptr<QosTxop> edca;\n    wifi_dev->GetMac()->GetAttribute(\"BE_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n\n    // Trace TXOP duration for BE on AP A\n    TxopDurationTracer netA;\n    edca->TraceConnectWithoutContext(\"TxopTrace\", MakeCallback(&TxopDurationTracer::Trace, &netA));\n\n    // Network B\n    ssid = Ssid(\"network-B\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{40, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    staDeviceB = wifi.Install(phy, mac, wifiStaNodes.Get(1));\n\n    // Disable A-MPDU\n    dev = wifiStaNodes.Get(1)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    // Modify EDCA configuration (TXOP limit) for AC_BE\n    mac.SetEdca(AC_BE, \"TxopLimits\", StringValue(std::to_string(txopLimit) + \"us\"));\n    apDeviceB = wifi.Install(phy, mac, wifiApNodes.Get(1));\n\n    // Disable A-MPDU\n    dev = wifiApNodes.Get(1)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n\n    wifi_dev->GetMac()->GetAttribute(\"BE_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n\n    // Trace TXOP duration for BE on AP B\n    TxopDurationTracer netB;\n    edca->TraceConnectWithoutContext(\"TxopTrace\", MakeCallback(&TxopDurationTracer::Trace, &netB));\n\n    // Network C\n    ssid = Ssid(\"network-C\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{44, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    staDeviceC = wifi.Install(phy, mac, wifiStaNodes.Get(2));\n\n    // Disable A-MPDU and enable A-MSDU with the highest maximum size allowed by the standard (7935\n    // bytes)\n    dev = wifiStaNodes.Get(2)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(7935));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    // Modify EDCA configuration (TXOP limit) for AC_BE\n    mac.SetEdca(AC_BE, \"TxopLimits\", StringValue(std::to_string(txopLimit) + \"us\"));\n    apDeviceC = wifi.Install(phy, mac, wifiApNodes.Get(2));\n\n    // Disable A-MPDU and enable A-MSDU with the highest maximum size allowed by the standard (7935\n    // bytes)\n    dev = wifiApNodes.Get(2)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(7935));\n\n    wifi_dev->GetMac()->GetAttribute(\"BE_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n\n    // Trace TXOP duration for BE on AP C\n    TxopDurationTracer netC;\n    edca->TraceConnectWithoutContext(\"TxopTrace\", MakeCallback(&TxopDurationTracer::Trace, &netC));\n\n    // Network D\n    ssid = Ssid(\"network-D\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{48, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    staDeviceD = wifi.Install(phy, mac, wifiStaNodes.Get(3));\n\n    // Enable A-MPDU with a smaller size than the default one and\n    // enable A-MSDU with the smallest maximum size allowed by the standard (3839 bytes)\n    dev = wifiStaNodes.Get(3)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(32768));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(3839));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    // Modify EDCA configuration (TXOP limit) for AC_BE\n    mac.SetEdca(AC_BE, \"TxopLimits\", StringValue(std::to_string(txopLimit) + \"us\"));\n    apDeviceD = wifi.Install(phy, mac, wifiApNodes.Get(3));\n\n    // Enable A-MPDU with a smaller size than the default one and\n    // enable A-MSDU with the smallest maximum size allowed by the standard (3839 bytes)\n    dev = wifiApNodes.Get(3)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(32768));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(3839));\n\n    wifi_dev->GetMac()->GetAttribute(\"BE_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n\n    // Trace TXOP duration for BE on AP D\n    TxopDurationTracer netD;\n    edca->TraceConnectWithoutContext(\"TxopTrace\", MakeCallback(&TxopDurationTracer::Trace, &netD));\n\n    // Setting mobility model\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    // Set position for APs\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(10.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(20.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(30.0, 0.0, 0.0));\n    // Set position for STAs\n    positionAlloc->Add(Vector(distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(10 + distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(20 + distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(30 + distance, 0.0, 0.0));\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(wifiApNodes);\n    mobility.Install(wifiStaNodes);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceA;\n    StaInterfaceA = address.Assign(staDeviceA);\n    Ipv4InterfaceContainer ApInterfaceA;\n    ApInterfaceA = address.Assign(apDeviceA);\n\n    address.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceB;\n    StaInterfaceB = address.Assign(staDeviceB);\n    Ipv4InterfaceContainer ApInterfaceB;\n    ApInterfaceB = address.Assign(apDeviceB);\n\n    address.SetBase(\"192.168.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceC;\n    StaInterfaceC = address.Assign(staDeviceC);\n    Ipv4InterfaceContainer ApInterfaceC;\n    ApInterfaceC = address.Assign(apDeviceC);\n\n    address.SetBase(\"192.168.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceD;\n    StaInterfaceD = address.Assign(staDeviceD);\n    Ipv4InterfaceContainer ApInterfaceD;\n    ApInterfaceD = address.Assign(apDeviceD);\n\n    // Setting applications\n    uint16_t port = 9;\n    UdpServerHelper serverA(port);\n    ApplicationContainer serverAppA = serverA.Install(wifiStaNodes.Get(0));\n    serverAppA.Start(Seconds(0.0));\n    serverAppA.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientA(StaInterfaceA.GetAddress(0), port);\n    clientA.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientA.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientA.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppA = clientA.Install(wifiApNodes.Get(0));\n    clientAppA.Start(Seconds(1.0));\n    clientAppA.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverB(port);\n    ApplicationContainer serverAppB = serverB.Install(wifiStaNodes.Get(1));\n    serverAppB.Start(Seconds(0.0));\n    serverAppB.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientB(StaInterfaceB.GetAddress(0), port);\n    clientB.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientB.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientB.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppB = clientB.Install(wifiApNodes.Get(1));\n    clientAppB.Start(Seconds(1.0));\n    clientAppB.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverC(port);\n    ApplicationContainer serverAppC = serverC.Install(wifiStaNodes.Get(2));\n    serverAppC.Start(Seconds(0.0));\n    serverAppC.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientC(StaInterfaceC.GetAddress(0), port);\n    clientC.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientC.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientC.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppC = clientC.Install(wifiApNodes.Get(2));\n    clientAppC.Start(Seconds(1.0));\n    clientAppC.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverD(port);\n    ApplicationContainer serverAppD = serverD.Install(wifiStaNodes.Get(3));\n    serverAppD.Start(Seconds(0.0));\n    serverAppD.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientD(StaInterfaceD.GetAddress(0), port);\n    clientD.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientD.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientD.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppD = clientD.Install(wifiApNodes.Get(3));\n    clientAppD.Start(Seconds(1.0));\n    clientAppD.Stop(simulationTime + Seconds(1.0));\n\n    if (enablePcap)\n    {\n        phy.EnablePcap(\"AP_A\", apDeviceA.Get(0));\n        phy.EnablePcap(\"STA_A\", staDeviceA.Get(0));\n        phy.EnablePcap(\"AP_B\", apDeviceB.Get(0));\n        phy.EnablePcap(\"STA_B\", staDeviceB.Get(0));\n        phy.EnablePcap(\"AP_C\", apDeviceC.Get(0));\n        phy.EnablePcap(\"STA_C\", staDeviceC.Get(0));\n        phy.EnablePcap(\"AP_D\", apDeviceD.Get(0));\n        phy.EnablePcap(\"STA_D\", staDeviceD.Get(0));\n    }\n\n    Simulator::Stop(simulationTime + Seconds(1.0));\n    Simulator::Run();\n\n    // Show results\n    double totalPacketsThroughA = DynamicCast<UdpServer>(serverAppA.Get(0))->GetReceived();\n    double totalPacketsThroughB = DynamicCast<UdpServer>(serverAppB.Get(0))->GetReceived();\n    double totalPacketsThroughC = DynamicCast<UdpServer>(serverAppC.Get(0))->GetReceived();\n    double totalPacketsThroughD = DynamicCast<UdpServer>(serverAppD.Get(0))->GetReceived();\n\n    Simulator::Destroy();\n\n    auto throughput = totalPacketsThroughA * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Default configuration (A-MPDU aggregation enabled, 65kB): \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 57.5 || throughput > 58.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    if (txopLimit)\n    {\n        std::cout << \"  Maximum TXOP duration (TXOP limit = \" << txopLimit\n                  << \"us): \" << netA.m_max.GetMicroSeconds() << \" us\" << '\\n';\n        if (verifyResults && txopLimit &&\n            (netA.m_max < MicroSeconds(3350) || netA.m_max > MicroSeconds(3520)))\n        {\n            NS_LOG_ERROR(\"Maximum TXOP duration \" << netA.m_max\n                                                  << \" is not in the expected boundaries!\");\n            exit(1);\n        }\n    }\n\n    throughput = totalPacketsThroughB * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Aggregation disabled: \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 38 || throughput > 39))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    if (txopLimit)\n    {\n        std::cout << \"  Maximum TXOP duration (TXOP limit = \" << txopLimit\n                  << \"us): \" << netB.m_max.GetMicroSeconds() << \" us\" << '\\n';\n        if (verifyResults && (netB.m_max < MicroSeconds(3350) || netB.m_max > MicroSeconds(3520)))\n        {\n            NS_LOG_ERROR(\"Maximum TXOP duration \" << netB.m_max\n                                                  << \" is not in the expected boundaries!\");\n            exit(1);\n        }\n    }\n\n    throughput = totalPacketsThroughC * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"A-MPDU disabled and A-MSDU enabled (8kB): \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 52 || throughput > 53))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    if (txopLimit)\n    {\n        std::cout << \"  Maximum TXOP duration (TXOP limit = \" << txopLimit\n                  << \"us): \" << netC.m_max.GetMicroSeconds() << \" us\" << '\\n';\n        if (verifyResults && (netC.m_max < MicroSeconds(3350) || netC.m_max > MicroSeconds(3520)))\n        {\n            NS_LOG_ERROR(\"Maximum TXOP duration \" << netC.m_max\n                                                  << \" is not in the expected boundaries!\");\n            exit(1);\n        }\n    }\n\n    throughput = totalPacketsThroughD * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"A-MPDU enabled (32kB) and A-MSDU enabled (4kB): \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 58 || throughput > 59))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    if (txopLimit)\n    {\n        std::cout << \"  Maximum TXOP duration (TXOP limit = \" << txopLimit\n                  << \"us): \" << netD.m_max.GetMicroSeconds() << \" us\" << '\\n';\n        if (verifyResults && txopLimit &&\n            (netD.m_max < MicroSeconds(3350) || netD.m_max > MicroSeconds(3520)))\n        {\n            NS_LOG_ERROR(\"Maximum TXOP duration \" << netD.m_max\n                                                  << \" is not in the expected boundaries!\");\n            exit(1);\n        }\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using ns-3 to simulate a network with four nodes: a sender, two routers (R1 and R2), and a receiver. Create three point-to-point links: sender to R1 and R2 to receiver with 1000 Mbps bandwidth and 5ms delay, and a bottleneck link between R1 and R2 with 10 Mbps bandwidth and 10ms delay. Set the simulation to run for 100 seconds, and configure the TCP BBR congestion control algorithm on the sender. Enable pcap tracing on all interfaces, save congestion window traces, sender throughput traces, and queue size traces from the bottleneck link to output files. Ensure the BBR algorithm enters the PROBE_RTT phase every 10 seconds, reducing the congestion window to 4 segments."}, {"role": "assistant", "content": "// This program simulates the following topology:\n//\n//           1000 Mbps           10Mbps          1000 Mbps\n//  Sender -------------- R1 -------------- R2 -------------- Receiver\n//              5ms               10ms               5ms\n//\n// The link between R1 and R2 is a bottleneck link with 10 Mbps. All other\n// links are 1000 Mbps.\n//\n// This program runs by default for 100 seconds and creates a new directory\n// called 'bbr-results' in the ns-3 root directory. The program creates one\n// sub-directory called 'pcap' in 'bbr-results' directory (if pcap generation\n// is enabled) and three .dat files.\n//\n// (1) 'pcap' sub-directory contains six PCAP files:\n//     * bbr-0-0.pcap for the interface on Sender\n//     * bbr-1-0.pcap for the interface on Receiver\n//     * bbr-2-0.pcap for the first interface on R1\n//     * bbr-2-1.pcap for the second interface on R1\n//     * bbr-3-0.pcap for the first interface on R2\n//     * bbr-3-1.pcap for the second interface on R2\n// (2) cwnd.dat file contains congestion window trace for the sender node\n// (3) throughput.dat file contains sender side throughput trace (throughput is in Mbit/s)\n// (4) queueSize.dat file contains queue length trace from the bottleneck link\n//\n// BBR algorithm enters PROBE_RTT phase in every 10 seconds. The congestion\n// window is fixed to 4 segments in this phase with a goal to achieve a better\n// estimate of minimum RTT (because queue at the bottleneck link tends to drain\n// when the congestion window is reduced to 4 segments).\n//\n// The congestion window and queue occupancy traces output by this program show\n// periodic drops every 10 seconds when BBR algorithm is in PROBE_RTT phase.\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <filesystem>\n\nusing namespace ns3;\nusing namespace ns3::SystemPath;\n\nstd::string dir;\nstd::ofstream throughput;\nstd::ofstream queueSize;\n\nuint32_t prev = 0;\nTime prevTime = Seconds(0);\n\n// Calculate throughput\nstatic void\nTraceThroughput(Ptr<FlowMonitor> monitor)\n{\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n    if (!stats.empty())\n    {\n        auto itr = stats.begin();\n        Time curTime = Now();\n\n        // Convert (curTime - prevTime) to microseconds so that throughput is in bits per\n        // microsecond (which is equivalent to Mbps)\n        throughput << curTime.GetSeconds() << \"s \"\n                   << 8 * (itr->second.txBytes - prev) / ((curTime - prevTime).ToDouble(Time::US))\n                   << \" Mbps\" << std::endl;\n        prevTime = curTime;\n        prev = itr->second.txBytes;\n    }\n    Simulator::Schedule(Seconds(0.2), &TraceThroughput, monitor);\n}\n\n// Check the queue size\nvoid\nCheckQueueSize(Ptr<QueueDisc> qd)\n{\n    uint32_t qsize = qd->GetCurrentSize().GetValue();\n    Simulator::Schedule(Seconds(0.2), &CheckQueueSize, qd);\n    queueSize << Simulator::Now().GetSeconds() << \" \" << qsize << std::endl;\n}\n\n// Trace congestion window\nstatic void\nCwndTracer(Ptr<OutputStreamWrapper> stream, uint32_t oldval, uint32_t newval)\n{\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << newval / 1448.0 << std::endl;\n}\n\nvoid\nTraceCwnd(uint32_t nodeId, uint32_t socketId)\n{\n    AsciiTraceHelper ascii;\n    Ptr<OutputStreamWrapper> stream = ascii.CreateFileStream(dir + \"/cwnd.dat\");\n    Config::ConnectWithoutContext(\"/NodeList/\" + std::to_string(nodeId) +\n                                      \"/$ns3::TcpL4Protocol/SocketList/\" +\n                                      std::to_string(socketId) + \"/CongestionWindow\",\n                                  MakeBoundCallback(&CwndTracer, stream));\n}\n\nint\nmain(int argc, char* argv[])\n{\n    // Naming the output directory using local system time\n    time_t rawtime;\n    struct tm* timeinfo;\n    char buffer[80];\n    time(&rawtime);\n    timeinfo = localtime(&rawtime);\n    strftime(buffer, sizeof(buffer), \"%d-%m-%Y-%I-%M-%S\", timeinfo);\n    std::string currentTime(buffer);\n\n    std::string tcpTypeId = \"TcpBbr\";\n    std::string queueDisc = \"FifoQueueDisc\";\n    uint32_t delAckCount = 2;\n    bool bql = true;\n    bool enablePcap = false;\n    Time stopTime = Seconds(100);\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"tcpTypeId\", \"Transport protocol to use: TcpNewReno, TcpBbr\", tcpTypeId);\n    cmd.AddValue(\"delAckCount\", \"Delayed ACK count\", delAckCount);\n    cmd.AddValue(\"enablePcap\", \"Enable/Disable pcap file generation\", enablePcap);\n    cmd.AddValue(\"stopTime\",\n                 \"Stop time for applications / simulation time will be stopTime + 1\",\n                 stopTime);\n    cmd.Parse(argc, argv);\n\n    queueDisc = std::string(\"ns3::\") + queueDisc;\n\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\", StringValue(\"ns3::\" + tcpTypeId));\n\n    // The maximum send buffer size is set to 4194304 bytes (4MB) and the\n    // maximum receive buffer size is set to 6291456 bytes (6MB) in the Linux\n    // kernel. The same buffer sizes are used as default in this example.\n    Config::SetDefault(\"ns3::TcpSocket::SndBufSize\", UintegerValue(4194304));\n    Config::SetDefault(\"ns3::TcpSocket::RcvBufSize\", UintegerValue(6291456));\n    Config::SetDefault(\"ns3::TcpSocket::InitialCwnd\", UintegerValue(10));\n    Config::SetDefault(\"ns3::TcpSocket::DelAckCount\", UintegerValue(delAckCount));\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(1448));\n    Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", QueueSizeValue(QueueSize(\"1p\")));\n    Config::SetDefault(queueDisc + \"::MaxSize\", QueueSizeValue(QueueSize(\"100p\")));\n\n    NodeContainer sender;\n    NodeContainer receiver;\n    NodeContainer routers;\n    sender.Create(1);\n    receiver.Create(1);\n    routers.Create(2);\n\n    // Create the point-to-point link helpers\n    PointToPointHelper bottleneckLink;\n    bottleneckLink.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    bottleneckLink.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n\n    PointToPointHelper edgeLink;\n    edgeLink.SetDeviceAttribute(\"DataRate\", StringValue(\"1000Mbps\"));\n    edgeLink.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    // Create NetDevice containers\n    NetDeviceContainer senderEdge = edgeLink.Install(sender.Get(0), routers.Get(0));\n    NetDeviceContainer r1r2 = bottleneckLink.Install(routers.Get(0), routers.Get(1));\n    NetDeviceContainer receiverEdge = edgeLink.Install(routers.Get(1), receiver.Get(0));\n\n    // Install Stack\n    InternetStackHelper internet;\n    internet.Install(sender);\n    internet.Install(receiver);\n    internet.Install(routers);\n\n    // Configure the root queue discipline\n    TrafficControlHelper tch;\n    tch.SetRootQueueDisc(queueDisc);\n\n    if (bql)\n    {\n        tch.SetQueueLimits(\"ns3::DynamicQueueLimits\", \"HoldTime\", StringValue(\"1000ms\"));\n    }\n\n    tch.Install(senderEdge);\n    tch.Install(receiverEdge);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer i1i2 = ipv4.Assign(r1r2);\n\n    ipv4.NewNetwork();\n    Ipv4InterfaceContainer is1 = ipv4.Assign(senderEdge);\n\n    ipv4.NewNetwork();\n    Ipv4InterfaceContainer ir1 = ipv4.Assign(receiverEdge);\n\n    // Populate routing tables\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Select sender side port\n    uint16_t port = 50001;\n\n    // Install application on the sender\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", InetSocketAddress(ir1.GetAddress(1), port));\n    source.SetAttribute(\"MaxBytes\", UintegerValue(0));\n    ApplicationContainer sourceApps = source.Install(sender.Get(0));\n    sourceApps.Start(Seconds(0.1));\n    // Hook trace source after application starts\n    Simulator::Schedule(Seconds(0.1) + MilliSeconds(1), &TraceCwnd, 0, 0);\n    sourceApps.Stop(stopTime);\n\n    // Install application on the receiver\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApps = sink.Install(receiver.Get(0));\n    sinkApps.Start(Seconds(0.0));\n    sinkApps.Stop(stopTime);\n\n    // Create a new directory to store the output of the program\n    dir = \"bbr-results/\" + currentTime + \"/\";\n    MakeDirectories(dir);\n\n    // The plotting scripts are provided in the following repository, if needed:\n    // https://github.com/mohittahiliani/BBR-Validation/\n    //\n    // Download 'PlotScripts' directory (which is inside ns-3 scripts directory)\n    // from the link given above and place it in the ns-3 root directory.\n    // Uncomment the following three lines to copy plot scripts for\n    // Congestion Window, sender side throughput and queue occupancy on the\n    // bottleneck link into the output directory.\n    //\n    // std::filesystem::copy(\"PlotScripts/gnuplotScriptCwnd\", dir);\n    // std::filesystem::copy(\"PlotScripts/gnuplotScriptThroughput\", dir);\n    // std::filesystem::copy(\"PlotScripts/gnuplotScriptQueueSize\", dir);\n\n    // Trace the queue occupancy on the second interface of R1\n    tch.Uninstall(routers.Get(0)->GetDevice(1));\n    QueueDiscContainer qd;\n    qd = tch.Install(routers.Get(0)->GetDevice(1));\n    Simulator::ScheduleNow(&CheckQueueSize, qd.Get(0));\n\n    // Generate PCAP traces if it is enabled\n    if (enablePcap)\n    {\n        MakeDirectories(dir + \"pcap/\");\n        bottleneckLink.EnablePcapAll(dir + \"/pcap/bbr\", true);\n    }\n\n    // Open files for writing throughput traces and queue size\n    throughput.open(dir + \"/throughput.dat\", std::ios::out);\n    queueSize.open(dir + \"/queueSize.dat\", std::ios::out);\n\n    NS_ASSERT_MSG(throughput.is_open(), \"Throughput file was not opened correctly\");\n    NS_ASSERT_MSG(queueSize.is_open(), \"Queue size file was not opened correctly\");\n\n    // Check for dropped packets using Flow Monitor\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n    Simulator::Schedule(Seconds(0 + 0.000001), &TraceThroughput, monitor);\n\n    Simulator::Stop(stopTime + TimeStep(1));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    throughput.close();\n    queueSize.close();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple Wi-Fi network in NS-3 with one Access Point (AP) and one Station (STA). The STA sends UDP packets to the AP. Use 802.11n Wi-Fi and run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer wifiStaNode;\n    NodeContainer wifiApNode;\n    wifiStaNode.Create(1);\n    wifiApNode.Create(1);\n\n    // Set up Wi-Fi\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up the Wi-Fi channel and devices\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer staDevice;\n    staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNode);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterface;\n    staInterface = ipv4.Assign(staDevice);\n\n    // Set up UDP application on Wi-Fi STA (client)\n    UdpClientHelper udpClient(staInterface.GetAddress(0), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiApNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on Wi-Fi AP (server)\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(wifiStaNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Point-to-Point (P2P) Network with three nodes using TCP protocol in ns-3. Node 0 acts as a TCP client, sending data to Node 2 (TCP server), with Node 1 serving as an intermediate router. Monitor the network's performance by collecting data throughput and packet loss statistics. Enable packet capturing (PCAP) for deeper analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"P2PNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(3); // Node 0 -> Client, Node 1 -> Router, Node 2 -> Server\n\n    // Configure Point-to-Point channels\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on node pairs\n    NetDeviceContainer devices01 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));\n    NetDeviceContainer devices12 = pointToPoint.Install(nodes.Get(1), nodes.Get(2));\n\n    // Install the Internet stack on nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces01 = address.Assign(devices01);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces12 = address.Assign(devices12);\n\n    // Set up routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create a TCP server on node 2\n    uint16_t port = 9;\n    Address serverAddress(InetSocketAddress(interfaces12.GetAddress(1), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = packetSinkHelper.Install(nodes.Get(2));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create a TCP client on node 0\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", Address());\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientHelper.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"1Mbps\")));\n    clientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp;\n    clientHelper.SetAttribute(\"Remote\", AddressValue(serverAddress));\n    clientApp = clientHelper.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing\n    pointToPoint.EnablePcapAll(\"p2p-network\");\n\n    // Set up Flow Monitor to collect throughput and packet loss statistics\n    FlowMonitorHelper flowMonitor;\n    Ptr<FlowMonitor> monitor = flowMonitor.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(11.0));\n    Simulator::Run();\n\n    // Collect and print flow monitor statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitor.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"  Lost Packets: \" << i->second.lostPackets);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 /\n                                            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n                                            1024 / 1024 << \" Mbps\");\n    }\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless sensor network (WSN) with six nodes arranged in a circular topology using ns-3. Each node uses the IEEE 802.15.4 standard for low-rate wireless communication and operates in the 2.4 GHz frequency band. Set up one of the nodes as a data collector (sink) that receives sensor data from the other five nodes. Implement a simple UDP-based data transfer, where each node sends a packet to the sink node at regular intervals. Collect performance metrics such as packet delivery ratio, end-to-end delay, and throughput, and visualize the packet flows using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/udp-echo-helper.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/lr-wpan-module.h\"\n#include \"ns3/sixlowpan-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WirelessSensorNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create six sensor nodes\n    NodeContainer sensorNodes;\n    sensorNodes.Create(6);\n\n    // Set up the physical layer with LR-WPAN (IEEE 802.15.4)\n    LrWpanHelper lrWpan;\n    NetDeviceContainer sensorDevices = lrWpan.Install(sensorNodes);\n    lrWpan.AssociateToPan(sensorDevices, 0);\n\n    // Set up the 6LoWPAN layer (optional)\n    SixLowPanHelper sixlowpan;\n    NetDeviceContainer sixlowpanDevices = sixlowpan.Install(sensorDevices);\n\n    // Install the internet stack on all nodes\n    InternetStackHelper internet;\n    internet.Install(sensorNodes);\n\n    // Assign IP addresses\n    Ipv6AddressHelper ipv6;\n    ipv6.SetBase(Ipv6Address(\"2001:db8::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer sensorInterfaces = ipv6.Assign(sixlowpanDevices);\n\n    // Set up mobility: Arrange nodes in a circle\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0)); // Sink node (center)\n    double radius = 20.0;\n    for (int i = 1; i < 6; ++i)\n    {\n        double angle = i * (2 * M_PI / 5); // 5 peripheral nodes\n        positionAlloc->Add(Vector(radius * cos(angle), radius * sin(angle), 0.0));\n    }\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(sensorNodes);\n\n    // Set up UDP echo server on the central (sink) node\n    uint16_t port = 9;\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApp = echoServer.Install(sensorNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Set up UDP echo clients on the peripheral sensor nodes\n    UdpEchoClientHelper echoClient(sensorInterfaces.GetAddress(0, 1), port);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(2.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps;\n    for (int i = 1; i < 6; ++i)\n    {\n        clientApps.Add(echoClient.Install(sensorNodes.Get(i)));\n    }\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(20.0));\n\n    // Enable tracing\n    lrWpan.EnablePcapAll(\"wsn-example\");\n\n    // Set up FlowMonitor to gather performance metrics\n    FlowMonitorHelper flowMonitorHelper;\n    Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n    // Set up NetAnim for visualization\n    AnimationInterface anim(\"wsn-animation.xml\");\n\n    // Run the simulation\n    Simulator::Stop(Seconds(20.0));\n    Simulator::Run();\n\n    // FlowMonitor statistics\n    flowMonitor->CheckForLostPackets();\n    Ptr<Ipv6FlowClassifier> classifier = DynamicCast<Ipv6FlowClassifier>(flowMonitorHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n\n    for (auto it = stats.begin(); it != stats.end(); ++it)\n    {\n        Ipv6FlowClassifier::FiveTuple t = classifier->FindFlow(it->first);\n        std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n        std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n        std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n        std::cout << \"  Throughput: \" << it->second.rxBytes * 8.0 / 20.0 / 1000 / 1000 << \" Mbps\" << std::endl;\n        std::cout << \"  End-to-End Delay: \" << it->second.delaySum.GetSeconds() << \" seconds\" << std::endl;\n    }\n\n    // Clean up\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and assigns them IP addresses using an Internet Stack. The program should install the necessary network stack on each node, configure unique IP addresses, and print the assigned addresses. Keep the example simple, focusing only on node creation and IP configuration."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"NodeIPExample\", LOG_LEVEL_INFO);\n\n    // Create a container for 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n\n    // Assign interfaces and print assigned IPs\n    Ipv4InterfaceContainer interfaces = address.Assign(nodes);\n    \n    for (uint32_t i = 0; i < nodes.GetN(); ++i) {\n        Ptr<Ipv4> ipv4 = nodes.Get(i)->GetObject<Ipv4>();\n        Ipv4Address ip = ipv4->GetAddress(1, 0);\n        NS_LOG_INFO(\"Node \" << i << \" assigned IP: \" << ip);\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a complete NS-3 simulation program that models an IEEE 802.11n Wi-Fi network with a non-Wi-Fi interferer. The code should include appropriate NS-3 libraries, setup for spectrum-based and Yans-based Wi-Fi channels, and the ability to handle both TCP and UDP traffic. Implement command-line argument parsing to control simulation parameters such as simulation time, distance between nodes, index values (for MCS, channel width, and guard interval combinations), waveform power, Wi-Fi type, and error model. Provide detailed output regarding transmission rates, throughput, received signal strength, noise, and SNR during the simulation. Ensure proper configuration of node mobility, internet stack, and the installation of Wi-Fi devices. Include support for packet tracing and allow toggling PCAP generation."}, {"role": "assistant", "content": "#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/non-communicating-net-device.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/propagation-loss-model.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/waveform-generator-helper.h\"\n#include \"ns3/waveform-generator.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <iomanip>\n\n// This is a simple example of an IEEE 802.11n Wi-Fi network with a\n// non-Wi-Fi interferer.  It is an adaptation of the wifi-spectrum-per-example\n//\n// Unless the --waveformPower argument is passed, it will operate similarly to\n// wifi-spectrum-per-example.  Adding --waveformPower=value for values\n// greater than 0.0001 will result in frame losses beyond those that\n// result from the normal SNR based on distance path loss.\n//\n// If YansWifiPhy is selected as the wifiType, --waveformPower will have\n// no effect.\n//\n// Network topology:\n//\n//  Wi-Fi 192.168.1.0\n//\n//   STA                  AP\n//    * <-- distance -->  *\n//    |                   |\n//    n1                  n2\n//\n// Users may vary the following command-line arguments in addition to the\n// attributes, global values, and default values typically available:\n//\n//    --simulationTime:  Simulation time [10s]\n//    --udp:             UDP if set to 1, TCP otherwise [true]\n//    --distance:        meters separation between nodes [50]\n//    --index:           restrict index to single value between 0 and 31 [256]\n//    --wifiType:        select ns3::SpectrumWifiPhy or ns3::YansWifiPhy [ns3::SpectrumWifiPhy]\n//    --errorModelType:  select ns3::NistErrorRateModel or ns3::YansErrorRateModel\n//    [ns3::NistErrorRateModel]\n//    --enablePcap:      enable pcap output [false]\n//    --waveformPower:   Waveform power (linear W) [0]\n//\n// By default, the program will step through 32 index values, corresponding\n// to the following MCS, channel width, and guard interval combinations:\n//   index 0-7:    MCS 0-7, long guard interval, 20 MHz channel\n//   index 8-15:   MCS 0-7, short guard interval, 20 MHz channel\n//   index 16-23:  MCS 0-7, long guard interval, 40 MHz channel\n//   index 24-31:  MCS 0-7, short guard interval, 40 MHz channel\n// and send UDP for 10 seconds using each MCS, using the SpectrumWifiPhy and the\n// NistErrorRateModel, at a distance of 50 meters.  The program outputs\n// results such as:\n//\n// wifiType: ns3::SpectrumWifiPhy distance: 50m; time: 10; TxPower: 16 dBm (40 mW)\n// index   MCS  Rate (Mb/s) Tput (Mb/s) Received Signal (dBm)Noi+Inf(dBm) SNR (dB)\n//     0     0      6.50        5.77    7414      -64.69      -93.97       29.27\n//     1     1     13.00       11.58   14892      -64.69      -93.97       29.27\n//     2     2     19.50       17.39   22358      -64.69      -93.97       29.27\n//     3     3     26.00       23.23   29875      -64.69      -93.97       29.27\n//   ...\n//\n\nusing namespace ns3;\n\n// Global variables for use in callbacks.\ndouble g_signalDbmAvg; //!< Average signal power [dBm]\ndouble g_noiseDbmAvg;  //!< Average noise power [dBm]\nuint32_t g_samples;    //!< Number of samples\n\n/**\n * Monitor sniffer Rx trace\n *\n * \\param packet The sensed packet.\n * \\param channelFreqMhz The channel frequency [MHz].\n * \\param txVector The Tx vector.\n * \\param aMpdu The aMPDU.\n * \\param signalNoise The signal and noise dBm.\n * \\param staId The STA ID.\n */\nvoid\nMonitorSniffRx(Ptr<const Packet> packet,\n               uint16_t channelFreqMhz,\n               WifiTxVector txVector,\n               MpduInfo aMpdu,\n               SignalNoiseDbm signalNoise,\n               uint16_t staId)\n\n{\n    g_samples++;\n    g_signalDbmAvg += ((signalNoise.signal - g_signalDbmAvg) / g_samples);\n    g_noiseDbmAvg += ((signalNoise.noise - g_noiseDbmAvg) / g_samples);\n}\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSpectrumPerInterference\");\n\nPtr<SpectrumModel> SpectrumModelWifi5180MHz; //!< Spectrum model at 5180 MHz.\nPtr<SpectrumModel> SpectrumModelWifi5190MHz; //!< Spectrum model at 5190 MHz.\n\n/** Initializer for a static spectrum model centered around 5180 MHz */\nclass static_SpectrumModelWifi5180MHz_initializer\n{\n  public:\n    static_SpectrumModelWifi5180MHz_initializer()\n    {\n        BandInfo bandInfo;\n        bandInfo.fc = 5180e6;\n        bandInfo.fl = 5180e6 - 10e6;\n        bandInfo.fh = 5180e6 + 10e6;\n\n        Bands bands;\n        bands.push_back(bandInfo);\n\n        SpectrumModelWifi5180MHz = Create<SpectrumModel>(bands);\n    }\n};\n\n/// Static instance to initizlize the spectrum model around 5180 MHz.\nstatic_SpectrumModelWifi5180MHz_initializer static_SpectrumModelWifi5180MHz_initializer_instance;\n\n/** Initializer for a static spectrum model centered around 5190 MHz */\nclass static_SpectrumModelWifi5190MHz_initializer\n{\n  public:\n    static_SpectrumModelWifi5190MHz_initializer()\n    {\n        BandInfo bandInfo;\n        bandInfo.fc = 5190e6;\n        bandInfo.fl = 5190e6 - 10e6;\n        bandInfo.fh = 5190e6 + 10e6;\n\n        Bands bands;\n        bands.push_back(bandInfo);\n\n        SpectrumModelWifi5190MHz = Create<SpectrumModel>(bands);\n    }\n};\n\n/// Static instance to initizlize the spectrum model around 5190 MHz.\nstatic_SpectrumModelWifi5190MHz_initializer static_SpectrumModelWifi5190MHz_initializer_instance;\n\nint\nmain(int argc, char* argv[])\n{\n    bool udp{true};\n    meter_u distance{50};\n    Time simulationTime{\"10s\"};\n    uint16_t index{256};\n    std::string wifiType{\"ns3::SpectrumWifiPhy\"};\n    std::string errorModelType{\"ns3::NistErrorRateModel\"};\n    bool enablePcap{false};\n    const uint32_t tcpPacketSize{1448};\n    Watt_u waveformPower{0};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"udp\", \"UDP if set to 1, TCP otherwise\", udp);\n    cmd.AddValue(\"distance\", \"meters separation between nodes\", distance);\n    cmd.AddValue(\"index\", \"restrict index to single value between 0 and 31\", index);\n    cmd.AddValue(\"wifiType\", \"select ns3::SpectrumWifiPhy or ns3::YansWifiPhy\", wifiType);\n    cmd.AddValue(\"errorModelType\",\n                 \"select ns3::NistErrorRateModel or ns3::YansErrorRateModel\",\n                 errorModelType);\n    cmd.AddValue(\"enablePcap\", \"enable pcap output\", enablePcap);\n    cmd.AddValue(\"waveformPower\", \"Waveform power (linear W)\", waveformPower);\n    cmd.Parse(argc, argv);\n\n    uint16_t startIndex = 0;\n    uint16_t stopIndex = 31;\n    if (index < 32)\n    {\n        startIndex = index;\n        stopIndex = index;\n    }\n\n    std::cout << \"wifiType: \" << wifiType << \" distance: \" << distance\n              << \"m; time: \" << simulationTime << \"; TxPower: 16 dBm (40 mW)\" << std::endl;\n    std::cout << std::setw(5) << \"index\" << std::setw(6) << \"MCS\" << std::setw(13) << \"Rate (Mb/s)\"\n              << std::setw(12) << \"Tput (Mb/s)\" << std::setw(10) << \"Received \" << std::setw(12)\n              << \"Signal (dBm)\" << std::setw(12) << \"Noi+Inf(dBm)\" << std::setw(9) << \"SNR (dB)\"\n              << std::endl;\n    for (uint16_t i = startIndex; i <= stopIndex; i++)\n    {\n        uint32_t payloadSize;\n        if (udp)\n        {\n            payloadSize = 972; // 1000 bytes IPv4\n        }\n        else\n        {\n            payloadSize = 1448; // 1500 bytes IPv6\n            Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n        }\n\n        NodeContainer wifiStaNode;\n        wifiStaNode.Create(1);\n        NodeContainer wifiApNode;\n        wifiApNode.Create(1);\n        NodeContainer interferingNode;\n        interferingNode.Create(1);\n\n        YansWifiPhyHelper phy;\n        SpectrumWifiPhyHelper spectrumPhy;\n        Ptr<MultiModelSpectrumChannel> spectrumChannel;\n        uint16_t frequency = (i <= 15 ? 5180 : 5190);\n        if (wifiType == \"ns3::YansWifiPhy\")\n        {\n            YansWifiChannelHelper channel;\n            channel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\",\n                                       \"Frequency\",\n                                       DoubleValue(frequency * 1e6));\n            channel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n            phy.SetChannel(channel.Create());\n            phy.Set(\"ChannelSettings\",\n                    StringValue(std::string(\"{\") + (frequency == 5180 ? \"36\" : \"38\") +\n                                \", 0, BAND_5GHZ, 0}\"));\n        }\n        else if (wifiType == \"ns3::SpectrumWifiPhy\")\n        {\n            spectrumChannel = CreateObject<MultiModelSpectrumChannel>();\n            Ptr<FriisPropagationLossModel> lossModel = CreateObject<FriisPropagationLossModel>();\n            lossModel->SetFrequency(frequency * 1e6);\n            spectrumChannel->AddPropagationLossModel(lossModel);\n\n            Ptr<ConstantSpeedPropagationDelayModel> delayModel =\n                CreateObject<ConstantSpeedPropagationDelayModel>();\n            spectrumChannel->SetPropagationDelayModel(delayModel);\n\n            spectrumPhy.SetChannel(spectrumChannel);\n            spectrumPhy.SetErrorRateModel(errorModelType);\n            // channel 36 at 20 MHz, 38 at 40 MHz\n            spectrumPhy.Set(\"ChannelSettings\",\n                            StringValue(std::string(\"{\") + (frequency == 5180 ? \"36\" : \"38\") +\n                                        \", 0, BAND_5GHZ, 0}\"));\n        }\n        else\n        {\n            NS_FATAL_ERROR(\"Unsupported WiFi type \" << wifiType);\n        }\n\n        WifiHelper wifi;\n        wifi.SetStandard(WIFI_STANDARD_80211n);\n        WifiMacHelper mac;\n\n        Ssid ssid = Ssid(\"ns380211n\");\n\n        double datarate = 0;\n        StringValue DataRate;\n        if (i == 0)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 6.5;\n        }\n        else if (i == 1)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 13;\n        }\n        else if (i == 2)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 19.5;\n        }\n        else if (i == 3)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 26;\n        }\n        else if (i == 4)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 39;\n        }\n        else if (i == 5)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 52;\n        }\n        else if (i == 6)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 58.5;\n        }\n        else if (i == 7)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 65;\n        }\n        else if (i == 8)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 7.2;\n        }\n        else if (i == 9)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 14.4;\n        }\n        else if (i == 10)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 21.7;\n        }\n        else if (i == 11)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 28.9;\n        }\n        else if (i == 12)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 43.3;\n        }\n        else if (i == 13)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 57.8;\n        }\n        else if (i == 14)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 65;\n        }\n        else if (i == 15)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 72.2;\n        }\n        else if (i == 16)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 13.5;\n        }\n        else if (i == 17)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 27;\n        }\n        else if (i == 18)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 40.5;\n        }\n        else if (i == 19)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 54;\n        }\n        else if (i == 20)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 81;\n        }\n        else if (i == 21)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 108;\n        }\n        else if (i == 22)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 121.5;\n        }\n        else if (i == 23)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 135;\n        }\n        else if (i == 24)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 15;\n        }\n        else if (i == 25)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 30;\n        }\n        else if (i == 26)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 45;\n        }\n        else if (i == 27)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 60;\n        }\n        else if (i == 28)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 90;\n        }\n        else if (i == 29)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 120;\n        }\n        else if (i == 30)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 135;\n        }\n        else\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 150;\n        }\n\n        wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                     \"DataMode\",\n                                     DataRate,\n                                     \"ControlMode\",\n                                     DataRate);\n\n        NetDeviceContainer staDevice;\n        NetDeviceContainer apDevice;\n\n        if (wifiType == \"ns3::YansWifiPhy\")\n        {\n            mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n            staDevice = wifi.Install(phy, mac, wifiStaNode);\n            mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n            apDevice = wifi.Install(phy, mac, wifiApNode);\n        }\n        else if (wifiType == \"ns3::SpectrumWifiPhy\")\n        {\n            mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n            staDevice = wifi.Install(spectrumPhy, mac, wifiStaNode);\n            mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n            apDevice = wifi.Install(spectrumPhy, mac, wifiApNode);\n        }\n\n        bool shortGuardIntervalSupported = (i > 7 && i <= 15) || (i > 23);\n        Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/\"\n                    \"ShortGuardIntervalSupported\",\n                    BooleanValue(shortGuardIntervalSupported));\n\n        // mobility.\n        MobilityHelper mobility;\n        Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n        positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n        positionAlloc->Add(Vector(distance, 0.0, 0.0));\n        positionAlloc->Add(Vector(distance, distance, 0.0));\n        mobility.SetPositionAllocator(positionAlloc);\n\n        mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n        mobility.Install(wifiApNode);\n        mobility.Install(wifiStaNode);\n        mobility.Install(interferingNode);\n\n        /* Internet stack*/\n        InternetStackHelper stack;\n        stack.Install(wifiApNode);\n        stack.Install(wifiStaNode);\n\n        Ipv4AddressHelper address;\n        address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer staNodeInterface;\n        Ipv4InterfaceContainer apNodeInterface;\n\n        staNodeInterface = address.Assign(staDevice);\n        apNodeInterface = address.Assign(apDevice);\n\n        /* Setting applications */\n        ApplicationContainer serverApp;\n        if (udp)\n        {\n            // UDP flow\n            uint16_t port = 9;\n            UdpServerHelper server(port);\n            serverApp = server.Install(wifiStaNode.Get(0));\n            serverApp.Start(Seconds(0.0));\n            serverApp.Stop(simulationTime + Seconds(1.0));\n            const auto packetInterval = payloadSize * 8.0 / (datarate * 1e6);\n\n            UdpClientHelper client(staNodeInterface.GetAddress(0), port);\n            client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n            client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n            client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n            ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n            clientApp.Start(Seconds(1.0));\n            clientApp.Stop(simulationTime + Seconds(1.0));\n        }\n        else\n        {\n            // TCP flow\n            uint16_t port = 50000;\n            Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n            PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n            serverApp = packetSinkHelper.Install(wifiStaNode.Get(0));\n            serverApp.Start(Seconds(0.0));\n            serverApp.Stop(simulationTime + Seconds(1.0));\n\n            OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n            onoff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n            onoff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n            onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n            onoff.SetAttribute(\"DataRate\", DataRateValue(datarate * 1e6));\n            AddressValue remoteAddress(InetSocketAddress(staNodeInterface.GetAddress(0), port));\n            onoff.SetAttribute(\"Remote\", remoteAddress);\n            ApplicationContainer clientApp = onoff.Install(wifiApNode.Get(0));\n            clientApp.Start(Seconds(1.0));\n            clientApp.Stop(simulationTime + Seconds(1.0));\n        }\n\n        // Configure waveform generator\n        Ptr<SpectrumValue> wgPsd =\n            Create<SpectrumValue>(i <= 15 ? SpectrumModelWifi5180MHz : SpectrumModelWifi5190MHz);\n        *wgPsd = waveformPower / 20e6; // PSD spread across 20 MHz\n        NS_LOG_INFO(\"wgPsd : \" << *wgPsd\n                               << \" integrated power: \" << Integral(*(GetPointer(wgPsd))));\n\n        if (wifiType == \"ns3::SpectrumWifiPhy\")\n        {\n            WaveformGeneratorHelper waveformGeneratorHelper;\n            waveformGeneratorHelper.SetChannel(spectrumChannel);\n            waveformGeneratorHelper.SetTxPowerSpectralDensity(wgPsd);\n\n            waveformGeneratorHelper.SetPhyAttribute(\"Period\", TimeValue(Seconds(0.0007)));\n            waveformGeneratorHelper.SetPhyAttribute(\"DutyCycle\", DoubleValue(1));\n            NetDeviceContainer waveformGeneratorDevices =\n                waveformGeneratorHelper.Install(interferingNode);\n\n            Simulator::Schedule(Seconds(0.002),\n                                &WaveformGenerator::Start,\n                                waveformGeneratorDevices.Get(0)\n                                    ->GetObject<NonCommunicatingNetDevice>()\n                                    ->GetPhy()\n                                    ->GetObject<WaveformGenerator>());\n        }\n\n        Config::ConnectWithoutContext(\"/NodeList/0/DeviceList/*/Phy/MonitorSnifferRx\",\n                                      MakeCallback(&MonitorSniffRx));\n\n        if (enablePcap)\n        {\n            phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n            std::stringstream ss;\n            ss << \"wifi-spectrum-per-example-\" << i;\n            phy.EnablePcap(ss.str(), apDevice);\n        }\n        g_signalDbmAvg = 0;\n        g_noiseDbmAvg = 0;\n        g_samples = 0;\n\n        // Make sure we are tuned to 5180 MHz; if not, the example will\n        // not work properly\n        Ptr<NetDevice> staDevicePtr = staDevice.Get(0);\n        Ptr<WifiPhy> wifiPhyPtr = staDevicePtr->GetObject<WifiNetDevice>()->GetPhy();\n        if (i <= 15)\n        {\n            NS_ABORT_MSG_IF(wifiPhyPtr->GetChannelWidth() != 20,\n                            \"Error: Channel width must be 20 MHz if MCS index <= 15\");\n            NS_ABORT_MSG_IF(\n                wifiPhyPtr->GetFrequency() != 5180,\n                \"Error:  Wi-Fi nodes must be tuned to 5180 MHz to match the waveform generator\");\n        }\n        else\n        {\n            NS_ABORT_MSG_IF(wifiPhyPtr->GetChannelWidth() != 40,\n                            \"Error: Channel width must be 40 MHz if MCS index > 15\");\n            NS_ABORT_MSG_IF(\n                wifiPhyPtr->GetFrequency() != 5190,\n                \"Error:  Wi-Fi nodes must be tuned to 5190 MHz to match the waveform generator\");\n        }\n\n        Simulator::Stop(simulationTime + Seconds(1.0));\n        Simulator::Run();\n\n        auto throughput = 0.0;\n        auto totalPacketsThrough = 0.0;\n        if (udp)\n        {\n            // UDP\n            totalPacketsThrough = DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n            throughput =\n                totalPacketsThrough * payloadSize * 8 / simulationTime.GetMicroSeconds(); // Mbit/s\n        }\n        else\n        {\n            // TCP\n            auto totalBytesRx = DynamicCast<PacketSink>(serverApp.Get(0))->GetTotalRx();\n            totalPacketsThrough = totalBytesRx / tcpPacketSize;\n            throughput = totalBytesRx * 8 / simulationTime.GetMicroSeconds(); // Mbit/s\n        }\n        std::cout << std::setw(5) << i << std::setw(6) << (i % 8) << std::setprecision(2)\n                  << std::fixed << std::setw(10) << datarate << std::setw(12) << throughput\n                  << std::setw(8) << totalPacketsThrough;\n        if (totalPacketsThrough > 0)\n        {\n            std::cout << std::setw(12) << g_signalDbmAvg << std::setw(12) << g_noiseDbmAvg\n                      << std::setw(12) << (g_signalDbmAvg - g_noiseDbmAvg) << std::endl;\n        }\n        else\n        {\n            std::cout << std::setw(12) << \"N/A\" << std::setw(12) << \"N/A\" << std::setw(12) << \"N/A\"\n                      << std::endl;\n        }\n        Simulator::Destroy();\n    }\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation with a CSMA network of four nodes. The last node is a UDP echo server, and the others are clients sending packets to it. Use a 100Mbps data rate, assign IPs in the 10.1.1.0/24 range, and ensure proper network stack installation. Clients should send 512-byte packets at 1s intervals. The simulation should start at 1s, run until 10s, and terminate correctly."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleCsmaExample\");\n\nint main(int argc, char *argv[])\n{\n    uint32_t nCsmaNodes = 4; // 3 clients + 1 server\n\n    // Create CSMA nodes\n    NodeContainer csmaNodes;\n    csmaNodes.Create(nCsmaNodes);\n\n    // Set up CSMA network\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install CSMA devices\n    NetDeviceContainer csmaDevices;\n    csmaDevices = csma.Install(csmaNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(csmaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer csmaInterfaces = address.Assign(csmaDevices);\n\n    // Set up UDP server on the last node\n    uint16_t port = 9;\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApp = echoServer.Install(csmaNodes.Get(nCsmaNodes - 1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP clients on the first three nodes\n    for (uint32_t i = 0; i < nCsmaNodes - 1; ++i)\n    {\n        UdpEchoClientHelper echoClient(csmaInterfaces.GetAddress(nCsmaNodes - 1), port);\n        echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n        echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n        echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n        ApplicationContainer clientApp = echoClient.Install(csmaNodes.Get(i));\n        clientApp.Start(Seconds(2.0));\n        clientApp.Stop(Seconds(9.0));\n    }\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an NS-3 simulation in C++ that models a basic network with two nodes. Connect these nodes using a point-to-point link with a data transmission rate of 5 Mbps and a propagation delay of 2 milliseconds. Do not configure any IP addresses or communication protocols for the nodes; the focus is only on setting up the link between them. Once the point-to-point link has been established between the two nodes, the simulation should verify the setup and conclude."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BasicNodeAndLinkSetup\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link between the two nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library to simulate a multi-interface host with static routing. The network topology should include a source node connected to two routers (Rtr1 and Rtr2) through point-to-point links, and both routers connected to a destination router, which is further connected to a destination node. Assign unique subnets for each link, and use static routing to control the path traffic takes through the network. The simulation should use TCP sockets to send traffic from the source to the destination, specifying different paths explicitly for each transmission."}, {"role": "assistant", "content": "/* Test program for multi-interface host, static routing\n\n         Destination host (10.20.1.2)\n                 |\n                 | 10.20.1.0/24\n              DSTRTR\n  10.10.1.0/24 /   \\  10.10.2.0/24\n              / \\\n           Rtr1    Rtr2\n 10.1.1.0/24 |      | 10.1.2.0/24\n             |      /\n              \\    /\n             Source\n*/\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SocketBoundTcpRoutingExample\");\n\nstatic const uint32_t totalTxBytes = 20000;\nstatic uint32_t currentTxBytes = 0;\nstatic const uint32_t writeSize = 1040;\nuint8_t data[writeSize];\n\nvoid StartFlow(Ptr<Socket>, Ipv4Address, uint16_t);\nvoid WriteUntilBufferFull(Ptr<Socket>, uint32_t);\n\nvoid SendStuff(Ptr<Socket> sock, Ipv4Address dstaddr, uint16_t port);\nvoid BindSock(Ptr<Socket> sock, Ptr<NetDevice> netdev);\nvoid srcSocketRecv(Ptr<Socket> socket);\nvoid dstSocketRecv(Ptr<Socket> socket);\n\nint\nmain(int argc, char* argv[])\n{\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Ptr<Node> nSrc = CreateObject<Node>();\n    Ptr<Node> nDst = CreateObject<Node>();\n    Ptr<Node> nRtr1 = CreateObject<Node>();\n    Ptr<Node> nRtr2 = CreateObject<Node>();\n    Ptr<Node> nDstRtr = CreateObject<Node>();\n\n    NodeContainer c = NodeContainer(nSrc, nDst, nRtr1, nRtr2, nDstRtr);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // Point-to-point links\n    NodeContainer nSrcnRtr1 = NodeContainer(nSrc, nRtr1);\n    NodeContainer nSrcnRtr2 = NodeContainer(nSrc, nRtr2);\n    NodeContainer nRtr1nDstRtr = NodeContainer(nRtr1, nDstRtr);\n    NodeContainer nRtr2nDstRtr = NodeContainer(nRtr2, nDstRtr);\n    NodeContainer nDstRtrnDst = NodeContainer(nDstRtr, nDst);\n\n    // We create the channels first without any IP addressing information\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer dSrcdRtr1 = p2p.Install(nSrcnRtr1);\n    NetDeviceContainer dSrcdRtr2 = p2p.Install(nSrcnRtr2);\n    NetDeviceContainer dRtr1dDstRtr = p2p.Install(nRtr1nDstRtr);\n    NetDeviceContainer dRtr2dDstRtr = p2p.Install(nRtr2nDstRtr);\n    NetDeviceContainer dDstRtrdDst = p2p.Install(nDstRtrnDst);\n\n    Ptr<NetDevice> SrcToRtr1 = dSrcdRtr1.Get(0);\n    Ptr<NetDevice> SrcToRtr2 = dSrcdRtr2.Get(0);\n\n    // Later, we add IP addresses.\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iSrciRtr1 = ipv4.Assign(dSrcdRtr1);\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iSrciRtr2 = ipv4.Assign(dSrcdRtr2);\n    ipv4.SetBase(\"10.10.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iRtr1iDstRtr = ipv4.Assign(dRtr1dDstRtr);\n    ipv4.SetBase(\"10.10.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iRtr2iDstRtr = ipv4.Assign(dRtr2dDstRtr);\n    ipv4.SetBase(\"10.20.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iDstRtrDst = ipv4.Assign(dDstRtrdDst);\n\n    Ptr<Ipv4> ipv4Src = nSrc->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4Rtr1 = nRtr1->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4Rtr2 = nRtr2->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4DstRtr = nDstRtr->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4Dst = nDst->GetObject<Ipv4>();\n\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> staticRoutingSrc = ipv4RoutingHelper.GetStaticRouting(ipv4Src);\n    Ptr<Ipv4StaticRouting> staticRoutingRtr1 = ipv4RoutingHelper.GetStaticRouting(ipv4Rtr1);\n    Ptr<Ipv4StaticRouting> staticRoutingRtr2 = ipv4RoutingHelper.GetStaticRouting(ipv4Rtr2);\n    Ptr<Ipv4StaticRouting> staticRoutingDstRtr = ipv4RoutingHelper.GetStaticRouting(ipv4DstRtr);\n    Ptr<Ipv4StaticRouting> staticRoutingDst = ipv4RoutingHelper.GetStaticRouting(ipv4Dst);\n\n    // Create static routes from Src to Dst\n    staticRoutingRtr1->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.10.1.2\"), 2);\n    staticRoutingRtr2->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.10.2.2\"), 2);\n\n    // Two routes to same destination - setting separate metrics.\n    // You can switch these to see how traffic gets diverted via different routes\n    staticRoutingSrc->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.1.1.2\"), 1, 5);\n    staticRoutingSrc->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.1.2.2\"), 2, 10);\n\n    // Creating static routes from DST to Source pointing to Rtr1 VIA Rtr2(!)\n    staticRoutingDst->AddHostRouteTo(Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.20.1.1\"), 1);\n    staticRoutingDstRtr->AddHostRouteTo(Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.10.2.1\"), 2);\n    staticRoutingRtr2->AddHostRouteTo(Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.1.2.1\"), 1);\n\n    staticRoutingDst->AddHostRouteTo(Ipv4Address(\"10.1.2.1\"), Ipv4Address(\"10.20.1.1\"), 1);\n    staticRoutingDstRtr->AddHostRouteTo(Ipv4Address(\"10.1.2.1\"), Ipv4Address(\"10.10.2.1\"), 2);\n    staticRoutingRtr2->AddHostRouteTo(Ipv4Address(\"10.1.2.1\"), Ipv4Address(\"10.1.2.1\"), 1);\n\n    // There are no apps that can utilize the Socket Option so doing the work directly..\n    // Taken from tcp-large-transfer example\n\n    Ptr<Socket> srcSocket1 =\n        Socket::CreateSocket(nSrc, TypeId::LookupByName(\"ns3::TcpSocketFactory\"));\n    Ptr<Socket> srcSocket2 =\n        Socket::CreateSocket(nSrc, TypeId::LookupByName(\"ns3::TcpSocketFactory\"));\n    Ptr<Socket> srcSocket3 =\n        Socket::CreateSocket(nSrc, TypeId::LookupByName(\"ns3::TcpSocketFactory\"));\n    Ptr<Socket> srcSocket4 =\n        Socket::CreateSocket(nSrc, TypeId::LookupByName(\"ns3::TcpSocketFactory\"));\n\n    uint16_t dstport = 12345;\n    Ipv4Address dstaddr(\"10.20.1.2\");\n\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(Ipv4Address::GetAny(), dstport));\n    ApplicationContainer apps = sink.Install(nDst);\n    apps.Start(Seconds(0.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"socket-bound-tcp-static-routing.tr\"));\n    p2p.EnablePcapAll(\"socket-bound-tcp-static-routing\");\n\n    LogComponentEnableAll(LOG_PREFIX_TIME);\n    LogComponentEnable(\"SocketBoundTcpRoutingExample\", LOG_LEVEL_INFO);\n\n    // First packet as normal (goes via Rtr1)\n    Simulator::Schedule(Seconds(0.1), &StartFlow, srcSocket1, dstaddr, dstport);\n    // Second via Rtr1 explicitly\n    Simulator::Schedule(Seconds(1.0), &BindSock, srcSocket2, SrcToRtr1);\n    Simulator::Schedule(Seconds(1.1), &StartFlow, srcSocket2, dstaddr, dstport);\n    // Third via Rtr2 explicitly\n    Simulator::Schedule(Seconds(2.0), &BindSock, srcSocket3, SrcToRtr2);\n    Simulator::Schedule(Seconds(2.1), &StartFlow, srcSocket3, dstaddr, dstport);\n    // Fourth again as normal (goes via Rtr1)\n    Simulator::Schedule(Seconds(3.0), &BindSock, srcSocket4, Ptr<NetDevice>(nullptr));\n    Simulator::Schedule(Seconds(3.1), &StartFlow, srcSocket4, dstaddr, dstport);\n    // If you uncomment what's below, it results in ASSERT failing since you can't\n    // bind to a socket not existing on a node\n    // Simulator::Schedule(Seconds(4.0),&BindSock, srcSocket, dDstRtrdDst.Get(0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}\n\nvoid\nBindSock(Ptr<Socket> sock, Ptr<NetDevice> netdev)\n{\n    sock->BindToNetDevice(netdev);\n}\n\nvoid\nStartFlow(Ptr<Socket> localSocket, Ipv4Address servAddress, uint16_t servPort)\n{\n    NS_LOG_INFO(\"Starting flow at time \" << Simulator::Now().GetSeconds());\n    currentTxBytes = 0;\n    localSocket->Bind();\n    localSocket->Connect(InetSocketAddress(servAddress, servPort)); // connect\n\n    // tell the tcp implementation to call WriteUntilBufferFull again\n    // if we blocked and new tx buffer space becomes available\n    localSocket->SetSendCallback(MakeCallback(&WriteUntilBufferFull));\n    WriteUntilBufferFull(localSocket, localSocket->GetTxAvailable());\n}\n\nvoid\nWriteUntilBufferFull(Ptr<Socket> localSocket, uint32_t txSpace)\n{\n    while (currentTxBytes < totalTxBytes && localSocket->GetTxAvailable() > 0)\n    {\n        uint32_t left = totalTxBytes - currentTxBytes;\n        uint32_t dataOffset = currentTxBytes % writeSize;\n        uint32_t toWrite = writeSize - dataOffset;\n        toWrite = std::min(toWrite, left);\n        toWrite = std::min(toWrite, localSocket->GetTxAvailable());\n        int amountSent = localSocket->Send(&data[dataOffset], toWrite, 0);\n        if (amountSent < 0)\n        {\n            // we will be called again when new tx space becomes available.\n            return;\n        }\n        currentTxBytes += amountSent;\n    }\n    localSocket->Close();\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple LTE cellular network with a single cell. The network should consist of one eNodeB (base station) and one User Equipment (UE). The eNodeB and UE should have unique IPv4 addresses in the 10.1.1.0/24 subnet. The UE should move using the RandomWalk2dMobilityModel within a bounded area (-50, 50, -50, 50). A UDP echo server should run on the UE node on port 9, while the eNodeB node acts as the client sending ten packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create the nodes (eNodeB and UE)\n    NodeContainer enbNode;\n    enbNode.Create(1); // Create 1 eNodeB\n    NodeContainer ueNodes;\n    ueNodes.Create(1); // Create 1 UE\n\n    // Set up LTE helper and Internet stack\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    internet.Install(enbNode);\n\n    // Set up mobility for eNodeB and UE\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(enbNode);\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(ueNodes);\n\n    // Install LTE devices (eNodeB and UE)\n    NetDeviceContainer enbDevs = lteHelper->InstallEnbDevice(enbNode);\n    NetDeviceContainer ueDevs = lteHelper->InstallUeDevice(ueNodes);\n\n    // Attach UE to the eNodeB\n    lteHelper->Attach(ueDevs.Get(0), enbDevs.Get(0));\n\n    // Set up IP addressing\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface = address.Assign(ueDevs);\n\n    // Set up a simple UDP echo server and client\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(ueNodes.Get(0)); // Install on the UE node\n    serverApps.Start(Seconds(2.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(ueIpIface.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(enbNode.Get(0)); // Install on the eNodeB node\n    clientApps.Start(Seconds(3.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an NS-3 simulation in C++ that models a simple point-to-point network consisting of two nodes connected directly to each other. The link between the nodes should have a data transmission rate of 5 Mbps and a propagation delay of 2 milliseconds. The nodes should use standard Internet protocols for communication. Assign IP addresses to both nodes, and configure one node to act as a UDP echo server listening on port 9, while the other node should act as a UDP echo client. The server should start at 1 second and stop at 10 seconds, while the client should start at 2 seconds, sending a single 1024-byte message to the server. After receiving the message, the server should send the message back to the client. Additionally, capture the network traffic in a `.pcap` file for analysis. The simulation should run for 10 seconds, concluding after all messages are exchanged."}, {"role": "assistant", "content": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"FirstScriptExample\");\n\nint main(int argc, char *argv[])\n{\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  // Create two nodes\n  NodeContainer nodes;\n  nodes.Create(2);\n\n  // Set up the point-to-point link between the two nodes\n  PointToPointHelper pointToPoint;\n  pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5 Mbps\"));\n  pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2 ms\"));\n\n  // Install network devices on the nodes\n  NetDeviceContainer devices;\n  devices = pointToPoint.Install(nodes);\n\n  // Install the Internet stack (IP protocol)\n  InternetStackHelper stack;\n  stack.Install(nodes);\n\n  // Assign IP addresses to the devices\n  Ipv4AddressHelper address;\n  address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n  // Create a UDP echo server on node 1\n  UdpEchoServerHelper echoServer(9);\n  ApplicationContainer serverApps = echoServer.Install(nodes.Get(1));\n  serverApps.Start(Seconds(1.0));\n  serverApps.Stop(Seconds(10.0));\n\n  // Create a UDP echo client on node 0\n  UdpEchoClientHelper echoClient(interfaces.GetAddress(1), 9);\n  echoClient.SetAttribute(\"MaxPackets\", UintegerValue(1));\n  echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n  echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n  ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));\n  clientApps.Start(Seconds(2.0));\n  clientApps.Stop(Seconds(10.0));\n\n  // Enable packet capture\n  pointToPoint.EnablePcapAll(\"simple-point-to-point\");\n\n  // Run the simulation\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and organizes them in a star topology. The program should assign a central node as the hub and connect peripheral nodes to it using Point-to-Point links. The program should then print confirmation of the established connections. Keep the example simple, focusing only on node creation and topology setup."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"StarTopologyExample\", LOG_LEVEL_INFO);\n\n    // Define the number of peripheral nodes\n    uint32_t numPeripheralNodes = 4;\n\n    // Create nodes: 1 central node + peripheral nodes\n    NodeContainer centralNode;\n    centralNode.Create(1);\n\n    NodeContainer peripheralNodes;\n    peripheralNodes.Create(numPeripheralNodes);\n\n    // Point-to-Point Helper\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create links from each peripheral node to the central node\n    for (uint32_t i = 0; i < numPeripheralNodes; ++i) {\n        NodeContainer link(centralNode.Get(0), peripheralNodes.Get(i));\n        NetDeviceContainer devices = p2p.Install(link);\n        NS_LOG_INFO(\"Connected Peripheral Node \" << i << \" to Central Node 0\");\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a program in C++ using the ns-3 network simulator that configures an IEEE 802.11ac Wi-Fi network with options for UDP or TCP traffic, RTS/CTS, 80+80 MHz channel width, different modulation and coding schemes (MCS 0-9), various channel widths (20, 40, 80, 160 MHz), and guard intervals (short or long). The program should simulate a simple network with one station and one access point (STA-AP), allow customization of distance between the nodes, and output the goodput (throughput) for every combination of the parameters. Include necessary ns-3 headers and use appropriate helper classes such as `SpectrumWifiPhy`, `YansWifiPhy`, `UdpClientHelper`, `UdpServerHelper`, `OnOffHelper`, `PacketSinkHelper`, and others to simulate the network and applications."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/vht-phy.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This is a simple example in order to show how to configure an IEEE 802.11ac Wi-Fi network.\n//\n// It outputs the UDP or TCP goodput for every VHT MCS value, which depends on the MCS value (0 to\n// 9, where 9 is forbidden when the channel width is 20 MHz), the channel width (20, 40, 80 or 160\n// MHz) and the guard interval (long or short). The PHY bitrate is constant over all the simulation\n// run. The user can also specify the distance between the access point and the station: the larger\n// the distance the smaller the goodput.\n//\n// The simulation assumes a single station in an infrastructure network:\n//\n//  STA     AP\n//    *     *\n//    |     |\n//   n1     n2\n//\n// Packets in this simulation belong to BestEffort Access Class (AC_BE).\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"vht-wifi-network\");\n\nint\nmain(int argc, char* argv[])\n{\n    bool udp{true};\n    bool useRts{false};\n    bool use80Plus80{false};\n    Time simulationTime{\"10s\"};\n    meter_u distance{1.0};\n    int mcs{-1}; // -1 indicates an unset value\n    std::string phyModel{\"Yans\"};\n    double minExpectedThroughput{0.0};\n    double maxExpectedThroughput{0.0};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the station and the access point\",\n                 distance);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"udp\", \"UDP if set to 1, TCP otherwise\", udp);\n    cmd.AddValue(\"useRts\", \"Enable/disable RTS/CTS\", useRts);\n    cmd.AddValue(\"use80Plus80\", \"Enable/disable use of 80+80 MHz\", use80Plus80);\n    cmd.AddValue(\"mcs\", \"if set, limit testing to a specific MCS (0-9)\", mcs);\n    cmd.AddValue(\"phyModel\",\n                 \"PHY model to use (Yans or Spectrum). If 80+80 MHz is enabled, then Spectrum is \"\n                 \"automatically selected\",\n                 phyModel);\n    cmd.AddValue(\"minExpectedThroughput\",\n                 \"if set, simulation fails if the lowest throughput is below this value\",\n                 minExpectedThroughput);\n    cmd.AddValue(\"maxExpectedThroughput\",\n                 \"if set, simulation fails if the highest throughput is above this value\",\n                 maxExpectedThroughput);\n    cmd.Parse(argc, argv);\n\n    if (phyModel != \"Yans\" && phyModel != \"Spectrum\")\n    {\n        NS_ABORT_MSG(\"Invalid PHY model (must be Yans or Spectrum)\");\n    }\n    if (use80Plus80)\n    {\n        // SpectrumWifiPhy is required for 80+80 MHz\n        phyModel = \"Spectrum\";\n    }\n\n    if (useRts)\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"0\"));\n    }\n\n    double prevThroughput[8] = {0};\n\n    std::cout << \"MCS value\"\n              << \"\\t\\t\"\n              << \"Channel width\"\n              << \"\\t\\t\"\n              << \"short GI\"\n              << \"\\t\\t\"\n              << \"Throughput\" << '\\n';\n    int minMcs = 0;\n    int maxMcs = 9;\n    if (mcs >= 0 && mcs <= 9)\n    {\n        minMcs = mcs;\n        maxMcs = mcs;\n    }\n    for (int mcs = minMcs; mcs <= maxMcs; mcs++)\n    {\n        uint8_t index = 0;\n        double previous = 0;\n        for (int channelWidth = 20; channelWidth <= 160;)\n        {\n            if (mcs == 9 && channelWidth == 20)\n            {\n                channelWidth *= 2;\n                continue;\n            }\n            const auto is80Plus80 = (use80Plus80 && (channelWidth == 160));\n            const std::string widthStr = is80Plus80 ? \"80+80\" : std::to_string(channelWidth);\n            const auto segmentWidthStr = is80Plus80 ? \"80\" : widthStr;\n            for (auto sgi : {false, true})\n            {\n                uint32_t payloadSize; // 1500 byte IP packet\n                if (udp)\n                {\n                    payloadSize = 1472; // bytes\n                }\n                else\n                {\n                    payloadSize = 1448; // bytes\n                    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n                }\n\n                NodeContainer wifiStaNode;\n                wifiStaNode.Create(1);\n                NodeContainer wifiApNode;\n                wifiApNode.Create(1);\n\n                NetDeviceContainer apDevice;\n                NetDeviceContainer staDevice;\n                WifiMacHelper mac;\n                WifiHelper wifi;\n                std::string channelStr{\"{0, \" + segmentWidthStr + \", BAND_5GHZ, 0}\"};\n\n                std::ostringstream ossControlMode;\n                auto nonHtRefRateMbps = VhtPhy::GetNonHtReferenceRate(mcs) / 1e6;\n                ossControlMode << \"OfdmRate\" << nonHtRefRateMbps << \"Mbps\";\n\n                std::ostringstream ossDataMode;\n                ossDataMode << \"VhtMcs\" << mcs;\n\n                if (is80Plus80)\n                {\n                    channelStr += std::string(\";\") + channelStr;\n                }\n\n                wifi.SetStandard(WIFI_STANDARD_80211ac);\n                wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                             \"DataMode\",\n                                             StringValue(ossDataMode.str()),\n                                             \"ControlMode\",\n                                             StringValue(ossControlMode.str()));\n\n                // Set guard interval\n                wifi.ConfigHtOptions(\"ShortGuardIntervalSupported\", BooleanValue(sgi));\n\n                Ssid ssid = Ssid(\"ns3-80211ac\");\n\n                if (phyModel == \"Spectrum\")\n                {\n                    auto spectrumChannel = CreateObject<MultiModelSpectrumChannel>();\n                    auto lossModel = CreateObject<LogDistancePropagationLossModel>();\n                    spectrumChannel->AddPropagationLossModel(lossModel);\n\n                    SpectrumWifiPhyHelper phy;\n                    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n                    phy.SetChannel(spectrumChannel);\n\n                    phy.Set(\"ChannelSettings\",\n                            StringValue(\"{0, \" + std::to_string(channelWidth) + \", BAND_5GHZ, 0}\"));\n\n                    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n                    staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n                    mac.SetType(\"ns3::ApWifiMac\",\n                                \"EnableBeaconJitter\",\n                                BooleanValue(false),\n                                \"Ssid\",\n                                SsidValue(ssid));\n                    apDevice = wifi.Install(phy, mac, wifiApNode);\n                }\n                else\n                {\n                    auto channel = YansWifiChannelHelper::Default();\n                    YansWifiPhyHelper phy;\n                    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n                    phy.SetChannel(channel.Create());\n\n                    phy.Set(\"ChannelSettings\",\n                            StringValue(\"{0, \" + std::to_string(channelWidth) + \", BAND_5GHZ, 0}\"));\n\n                    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n                    staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n                    mac.SetType(\"ns3::ApWifiMac\",\n                                \"EnableBeaconJitter\",\n                                BooleanValue(false),\n                                \"Ssid\",\n                                SsidValue(ssid));\n                    apDevice = wifi.Install(phy, mac, wifiApNode);\n                }\n\n                int64_t streamNumber = 150;\n                streamNumber += WifiHelper::AssignStreams(apDevice, streamNumber);\n                streamNumber += WifiHelper::AssignStreams(staDevice, streamNumber);\n\n                // mobility.\n                MobilityHelper mobility;\n                Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n                positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n                positionAlloc->Add(Vector(distance, 0.0, 0.0));\n                mobility.SetPositionAllocator(positionAlloc);\n\n                mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n                mobility.Install(wifiApNode);\n                mobility.Install(wifiStaNode);\n\n                /* Internet stack*/\n                InternetStackHelper stack;\n                stack.Install(wifiApNode);\n                stack.Install(wifiStaNode);\n                streamNumber += stack.AssignStreams(wifiApNode, streamNumber);\n                streamNumber += stack.AssignStreams(wifiStaNode, streamNumber);\n\n                Ipv4AddressHelper address;\n                address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n                Ipv4InterfaceContainer staNodeInterface;\n                Ipv4InterfaceContainer apNodeInterface;\n\n                staNodeInterface = address.Assign(staDevice);\n                apNodeInterface = address.Assign(apDevice);\n\n                /* Setting applications */\n                const auto maxLoad =\n                    VhtPhy::GetDataRate(mcs, channelWidth, NanoSeconds(sgi ? 400 : 800), 1);\n                ApplicationContainer serverApp;\n                if (udp)\n                {\n                    // UDP flow\n                    uint16_t port = 9;\n                    UdpServerHelper server(port);\n                    serverApp = server.Install(wifiStaNode.Get(0));\n                    streamNumber += server.AssignStreams(wifiStaNode.Get(0), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n                    const auto packetInterval = payloadSize * 8.0 / maxLoad;\n\n                    UdpClientHelper client(staNodeInterface.GetAddress(0), port);\n                    client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n                    client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n                    client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                    ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n                    streamNumber += client.AssignStreams(wifiApNode.Get(0), streamNumber);\n\n                    clientApp.Start(Seconds(1.0));\n                    clientApp.Stop(simulationTime + Seconds(1.0));\n                }\n                else\n                {\n                    // TCP flow\n                    uint16_t port = 50000;\n                    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n                    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n                    serverApp = packetSinkHelper.Install(wifiStaNode.Get(0));\n                    streamNumber +=\n                        packetSinkHelper.AssignStreams(wifiStaNode.Get(0), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n\n                    OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n                    onoff.SetAttribute(\"OnTime\",\n                                       StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n                    onoff.SetAttribute(\"OffTime\",\n                                       StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n                    onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                    onoff.SetAttribute(\"DataRate\", DataRateValue(maxLoad));\n                    AddressValue remoteAddress(\n                        InetSocketAddress(staNodeInterface.GetAddress(0), port));\n                    onoff.SetAttribute(\"Remote\", remoteAddress);\n                    ApplicationContainer clientApp = onoff.Install(wifiApNode.Get(0));\n                    streamNumber += onoff.AssignStreams(wifiApNode.Get(0), streamNumber);\n\n                    clientApp.Start(Seconds(1.0));\n                    clientApp.Stop(simulationTime + Seconds(1.0));\n                }\n\n                Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n                Simulator::Stop(simulationTime + Seconds(1.0));\n                Simulator::Run();\n\n                auto rxBytes = 0.0;\n                if (udp)\n                {\n                    rxBytes = payloadSize * DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n                }\n                else\n                {\n                    rxBytes = DynamicCast<PacketSink>(serverApp.Get(0))->GetTotalRx();\n                }\n                auto throughput = (rxBytes * 8) / simulationTime.GetMicroSeconds(); // Mbit/s\n\n                Simulator::Destroy();\n\n                std::cout << +mcs << \"\\t\\t\\t\" << widthStr << \" MHz\\t\\t\"\n                          << (widthStr.size() > 3 ? \"\" : \"\\t\") << (sgi ? \"400 ns\" : \"800 ns\")\n                          << \"\\t\\t\\t\" << throughput << \" Mbit/s\" << std::endl;\n\n                // test first element\n                if (mcs == minMcs && channelWidth == 20 && !sgi)\n                {\n                    if (throughput < minExpectedThroughput)\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                }\n                // test last element\n                if (mcs == maxMcs && channelWidth == 160 && sgi)\n                {\n                    if (maxExpectedThroughput > 0 && throughput > maxExpectedThroughput)\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                }\n                // test previous throughput is smaller (for the same mcs)\n                if (throughput > previous)\n                {\n                    previous = throughput;\n                }\n                else\n                {\n                    NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                    exit(1);\n                }\n                // test previous throughput is smaller (for the same channel width and GI)\n                if (throughput > prevThroughput[index])\n                {\n                    prevThroughput[index] = throughput;\n                }\n                else\n                {\n                    NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                    exit(1);\n                }\n                index++;\n            }\n            channelWidth *= 2;\n        }\n    }\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an ns-3 simulation that sets up a simple network with two nodes connected via a point-to-point link. Install the TCP/IP stack on both nodes, and assign IP addresses to the devices. On one node, configure a TCP server that listens on port 8080. On the other node, configure a TCP client that sends packets to the server using the OnOffApplication with a constant data rate of 5Mbps and a packet size of 1024 bytes. Set the client to start transmitting after 2 seconds and stop at 10 seconds. Enable the FlowMonitor to collect network performance statistics like transmitted and received packets, and throughput. Run the simulation for 10 seconds and print out the flow statistics at the end."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"TcpExample\");\n\nint main (int argc, char *argv[])\n{\n    // Set up default simulation parameters\n    CommandLine cmd;\n    cmd.Parse (argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create (2);\n\n    // Set up a point-to-point link between the nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute (\"DataRate\", StringValue (\"5Mbps\"));\n    pointToPoint.SetChannelAttribute (\"Delay\", StringValue (\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install (nodes);\n\n    // Install the Internet stack (TCP/IP) on both nodes\n    InternetStackHelper stack;\n    stack.Install (nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n    // Set up a TCP server on node 1\n    uint16_t port = 8080; // Port number\n    Address serverAddress (InetSocketAddress (interfaces.GetAddress (1), port));\n    PacketSinkHelper tcpServerHelper (\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = tcpServerHelper.Install (nodes.Get (1));\n    serverApp.Start (Seconds (1.0));\n    serverApp.Stop (Seconds (10.0));\n\n    // Set up a TCP client on node 0 to send data to node 1\n    OnOffHelper tcpClientHelper (\"ns3::TcpSocketFactory\", serverAddress);\n    tcpClientHelper.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=1]\"));\n    tcpClientHelper.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0]\"));\n    tcpClientHelper.SetAttribute (\"DataRate\", DataRateValue (DataRate (\"5Mbps\")));\n    tcpClientHelper.SetAttribute (\"PacketSize\", UintegerValue (1024)); // Packet size: 1024 bytes\n\n    ApplicationContainer clientApp = tcpClientHelper.Install (nodes.Get (0));\n    clientApp.Start (Seconds (2.0)); // Start client after 2 seconds\n    clientApp.Stop (Seconds (10.0)); // Stop after 10 seconds\n\n    // Enable flow monitor to track performance statistics\n    FlowMonitorHelper flowMonitor;\n    Ptr<FlowMonitor> monitor = flowMonitor.InstallAll ();\n\n    // Run the simulation\n    Simulator::Stop (Seconds (10.0));\n    Simulator::Run ();\n\n    // Print flow statistics (e.g., throughput, delay)\n    monitor->CheckForLostPackets ();\n    monitor->SerializeToXmlFile (\"tcp-flow-monitor.xml\", true, true);\n\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats ();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n    {\n        NS_LOG_UNCOND (\"Flow \" << i->first << \" (\" << serverAddress << \"):\");\n        NS_LOG_UNCOND (\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND (\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND (\"  Throughput: \" << i->second.rxBytes * 8.0 / 9.0 / 1024 / 1024 << \" Mbps\");\n    }\n\n    // Cleanup and exit\n    Simulator::Destroy ();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a mobile ad hoc network (MANET) with two nodes. Configure random movement for both nodes using a random walk mobility model with speeds between 1 and 5 m/s and a time interval of 2 seconds. The nodes should send UDP packets from the client (node 0) to the server (node 1) over a 1 Mbps link with a 10 ms delay. Use port 9 for communication, and set the client to send 100 packets of 512 bytes with an interval of 0.1 seconds. The simulation should run for 20 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/udp-client-server-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ManetUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"ManetUdpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes: one for the server and one for the client\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up mobility model for the nodes (to simulate movement)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=100]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=100]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Time\", TimeValue(Seconds(2.0)),\n                              \"Speed\", StringValue(\"ns3::UniformRandomVariable[Min=1|Max=5]\"));\n    mobility.Install(nodes);\n\n    // Install the Internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Set up the point-to-point link (no physical link here, just logical for communication)\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Install UDP server on node 1 (server side)\n    UdpServerHelper udpServer(9); // Port 9\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Install UDP client on node 0 (client side)\n    UdpClientHelper udpClient(interfaces.GetAddress(1), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));    // Send 100 packets\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1))); // Send packets every 0.1 seconds\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));    // 512 bytes packets\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(20.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 that simulates global routing in a mixed point-to-point and CSMA/CD network. Set up a network with seven nodes, including both point-to-point and CSMA links. Implement two separate CBR/UDP traffic flows from node 1 to node 6, with the first starting on the point-to-point link at 1 second and the second at 11 seconds using the alternative point-to-point link. Simulate interface down and up events at various times, causing rerouting of traffic via alternative paths. Enable automatic response to interface events for global route recomputation, and trace packet receptions and queue activity to output files."}, {"role": "assistant", "content": "// This script exercises global routing code in a mixed point-to-point\n// and csma/cd environment.  We bring up and down interfaces and observe\n// the effect on global routing.  We explicitly enable the attribute\n// to respond to interface events, so that routes are recomputed\n// automatically.\n//\n// Network topology\n//\n//  n0\n//     \\ p-p\n//      \\          (shared csma/cd)\n//       n2 -------------------------n3\n//      /            |        |\n//     / p-p        n4        n5 ---------- n6\n//   n1                             p-p\n//   |                                      |\n//   ----------------------------------------\n//                p-p\n//\n// - at time 1 CBR/UDP flow from n1 to n6's IP address on the n5/n6 link\n// - at time 10, start similar flow from n1 to n6's address on the n1/n6 link\n//\n//  Order of events\n//  At pre-simulation time, configure global routes.  Shortest path from\n//  n1 to n6 is via the direct point-to-point link\n//  At time 1s, start CBR traffic flow from n1 to n6\n//  At time 2s, set the n1 point-to-point interface to down.  Packets\n//    will be diverted to the n1-n2-n5-n6 path\n//  At time 4s, re-enable the n1/n6 interface to up.  n1-n6 route restored.\n//  At time 6s, set the n6-n1 point-to-point Ipv4 interface to down (note, this\n//    keeps the point-to-point link \"up\" from n1's perspective).  Traffic will\n//    flow through the path n1-n2-n5-n6\n//  At time 8s, bring the interface back up.  Path n1-n6 is restored\n//  At time 10s, stop the first flow.\n//  At time 11s, start a new flow, but to n6's other IP address (the one\n//    on the n1/n6 p2p link)\n//  At time 12s, bring the n1 interface down between n1 and n6.  Packets\n//    will be diverted to the alternate path\n//  At time 14s, re-enable the n1/n6 interface to up.  This will change\n//    routing back to n1-n6 since the interface up notification will cause\n//    a new local interface route, at higher priority than global routing\n//  At time 16s, stop the second flow.\n\n// - Tracing of queues and packet receptions to file \"dynamic-global-routing.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"DynamicGlobalRoutingExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // The below value configures the default behavior of global routing.\n    // By default, it is disabled.  To respond to interface events, set to true\n    Config::SetDefault(\"ns3::Ipv4GlobalRouting::RespondToInterfaceEvents\", BooleanValue(true));\n\n    // Allow the user to override any of the defaults and the above\n    // Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer c;\n    c.Create(7);\n    NodeContainer n0n2 = NodeContainer(c.Get(0), c.Get(2));\n    NodeContainer n1n2 = NodeContainer(c.Get(1), c.Get(2));\n    NodeContainer n5n6 = NodeContainer(c.Get(5), c.Get(6));\n    NodeContainer n1n6 = NodeContainer(c.Get(1), c.Get(6));\n    NodeContainer n2345 = NodeContainer(c.Get(2), c.Get(3), c.Get(4), c.Get(5));\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // We create the channels first without any IP addressing information\n    NS_LOG_INFO(\"Create channels.\");\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d0d2 = p2p.Install(n0n2);\n    NetDeviceContainer d1d6 = p2p.Install(n1n6);\n\n    NetDeviceContainer d1d2 = p2p.Install(n1n2);\n\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1500kbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    NetDeviceContainer d5d6 = p2p.Install(n5n6);\n\n    // We create the channels first without any IP addressing information\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d2345 = csma.Install(n2345);\n\n    // Later, we add IP addresses.\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(d0d2);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    ipv4.Assign(d1d2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i5i6 = ipv4.Assign(d5d6);\n\n    ipv4.SetBase(\"10.250.1.0\", \"255.255.255.0\");\n    ipv4.Assign(d2345);\n\n    ipv4.SetBase(\"172.16.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1i6 = ipv4.Assign(d1d6);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    NS_LOG_INFO(\"Create Applications.\");\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(i5i6.GetAddress(1), port));\n    onoff.SetConstantRate(DataRate(\"2kbps\"));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(50));\n\n    ApplicationContainer apps = onoff.Install(c.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a second OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    OnOffHelper onoff2(\"ns3::UdpSocketFactory\", InetSocketAddress(i1i6.GetAddress(1), port));\n    onoff2.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onoff2.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    onoff2.SetAttribute(\"DataRate\", StringValue(\"2kbps\"));\n    onoff2.SetAttribute(\"PacketSize\", UintegerValue(50));\n\n    ApplicationContainer apps2 = onoff2.Install(c.Get(1));\n    apps2.Start(Seconds(11.0));\n    apps2.Stop(Seconds(16.0));\n\n    // Create an optional packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(c.Get(6));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    PacketSinkHelper sink2(\"ns3::UdpSocketFactory\",\n                           Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps2 = sink2.Install(c.Get(6));\n    apps2.Start(Seconds(11.0));\n    apps2.Stop(Seconds(16.0));\n\n    AsciiTraceHelper ascii;\n    Ptr<OutputStreamWrapper> stream = ascii.CreateFileStream(\"dynamic-global-routing.tr\");\n    p2p.EnableAsciiAll(stream);\n    csma.EnableAsciiAll(stream);\n    internet.EnableAsciiIpv4All(stream);\n\n    p2p.EnablePcapAll(\"dynamic-global-routing\");\n    csma.EnablePcapAll(\"dynamic-global-routing\", false);\n\n    Ptr<Node> n1 = c.Get(1);\n    Ptr<Ipv4> ipv41 = n1->GetObject<Ipv4>();\n    // The first ifIndex is 0 for loopback, then the first p2p is numbered 1,\n    // then the next p2p is numbered 2\n    uint32_t ipv4ifIndex1 = 2;\n\n    Simulator::Schedule(Seconds(2), &Ipv4::SetDown, ipv41, ipv4ifIndex1);\n    Simulator::Schedule(Seconds(4), &Ipv4::SetUp, ipv41, ipv4ifIndex1);\n\n    Ptr<Node> n6 = c.Get(6);\n    Ptr<Ipv4> ipv46 = n6->GetObject<Ipv4>();\n    // The first ifIndex is 0 for loopback, then the first p2p is numbered 1,\n    // then the next p2p is numbered 2\n    uint32_t ipv4ifIndex6 = 2;\n    Simulator::Schedule(Seconds(6), &Ipv4::SetDown, ipv46, ipv4ifIndex6);\n    Simulator::Schedule(Seconds(8), &Ipv4::SetUp, ipv46, ipv4ifIndex6);\n\n    Simulator::Schedule(Seconds(12), &Ipv4::SetDown, ipv41, ipv4ifIndex1);\n    Simulator::Schedule(Seconds(14), &Ipv4::SetUp, ipv41, ipv4ifIndex1);\n\n    // Trace routing tables\n    Ptr<OutputStreamWrapper> routingStream =\n        Create<OutputStreamWrapper>(\"dynamic-global-routing.routes\", std::ios::out);\n    Ipv4RoutingHelper::PrintRoutingTableAllAt(Seconds(12), routingStream);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple vehicle-to-vehicle (V2V) communication scenario using the ns-3 Wave module. There are two vehicles communicating via the Wave protocol (802.11p), and a UDP application is used to send messages from one vehicle to another. The simulation should track packet transmissions and receptions and provide statistics on the messages sent and received."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wave-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"V2VCommunicationExample\");\n\nint main (int argc, char *argv[])\n{\n    // Set simulation parameters\n    double simTime = 10.0; // seconds\n    double distance = 50.0; // meters between vehicles\n\n    // Enable logging\n    LogComponentEnable (\"UdpClient\", LOG_LEVEL_INFO);\n    LogComponentEnable (\"UdpServer\", LOG_LEVEL_INFO);\n\n    // Create two vehicle nodes\n    NodeContainer vehicles;\n    vehicles.Create (2);\n\n    // Set up Wi-Fi for vehicular communication using Wave (802.11p)\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default ();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default ();\n    wifiPhy.SetChannel (wifiChannel.Create ());\n\n    QosWaveMacHelper wifiMac = QosWaveMacHelper::Default ();\n    WaveHelper waveHelper = WaveHelper::Default ();\n    NetDeviceContainer devices = waveHelper.Install (wifiPhy, wifiMac, vehicles);\n\n    // Set up mobility model for the vehicles\n    MobilityHelper mobility;\n    mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();\n    positionAlloc->Add (Vector (0.0, 0.0, 0.0));  // Position for vehicle 1\n    positionAlloc->Add (Vector (distance, 0.0, 0.0));  // Position for vehicle 2\n    mobility.SetPositionAllocator (positionAlloc);\n    mobility.Install (vehicles);\n\n    // Install the internet stack on the vehicles\n    InternetStackHelper internet;\n    internet.Install (vehicles);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);\n\n    // Set up UDP server on vehicle 2 (Node 1)\n    uint16_t port = 4000;\n    UdpServerHelper udpServer (port);\n    ApplicationContainer serverApp = udpServer.Install (vehicles.Get (1));\n    serverApp.Start (Seconds (1.0));\n    serverApp.Stop (Seconds (simTime));\n\n    // Set up UDP client on vehicle 1 (Node 0)\n    UdpClientHelper udpClient (interfaces.GetAddress (1), port);\n    udpClient.SetAttribute (\"MaxPackets\", UintegerValue (100));\n    udpClient.SetAttribute (\"Interval\", TimeValue (Seconds (1.0))); // 1 packet per second\n    udpClient.SetAttribute (\"PacketSize\", UintegerValue (1024));\n\n    ApplicationContainer clientApp = udpClient.Install (vehicles.Get (0));\n    clientApp.Start (Seconds (2.0));\n    clientApp.Stop (Seconds (simTime));\n\n    // Set up Flow Monitor to track statistics\n    FlowMonitorHelper flowHelper;\n    Ptr<FlowMonitor> monitor = flowHelper.InstallAll ();\n\n    // Run the simulation\n    Simulator::Stop (Seconds (simTime));\n    Simulator::Run ();\n\n    // Print Flow Monitor statistics\n    monitor->CheckForLostPackets ();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowHelper.GetClassifier ());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats ();\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);\n        NS_LOG_UNCOND (\"Flow ID: \" << i->first << \" Src Addr \" << t.sourceAddress << \" Dst Addr \" << t.destinationAddress);\n        NS_LOG_UNCOND (\"Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND (\"Rx Packets: \" << i->second.rxPackets);\n    }\n\n    // Clean up\n    Simulator::Destroy ();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a simulation in ns-3 that demonstrates a wireless sensor network (WSN) with energy constraints. The network should consist of sensor nodes arranged in a grid. Each sensor node generates data packets that are sent to a central sink node. Energy depletion should be simulated, and the network should stop once all nodes run out of energy."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/energy-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"WirelessSensorNetwork\");\n\nvoid RemainingEnergy(Ptr<BasicEnergySource> source)\n{\n    NS_LOG_UNCOND(\"Remaining energy: \" << source->GetRemainingEnergy() << \" J\");\n    if (source->GetRemainingEnergy() <= 0)\n    {\n        NS_LOG_UNCOND(\"Node has run out of energy\");\n    }\n}\n\nint main (int argc, char *argv[])\n{\n    uint32_t gridSize = 3; // 3x3 grid of nodes\n    double totalEnergy = 100.0; // Initial energy in Joules\n    double simulationTime = 50.0; // seconds\n    double dataRate = 1.0; // packets per second\n\n    // 1. Create nodes\n    NodeContainer sensorNodes;\n    sensorNodes.Create (gridSize * gridSize);\n\n    // 2. Configure Wifi PHY and MAC\n    WifiHelper wifi;\n    wifi.SetStandard (WIFI_PHY_STANDARD_80211b);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();\n    phy.SetChannel (channel.Create ());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid (\"wsn-grid\");\n    mac.SetType (\"ns3::AdhocWifiMac\", \"Ssid\", SsidValue (ssid));\n\n    NetDeviceContainer devices = wifi.Install (phy, mac, sensorNodes);\n\n    // 3. Set up mobility model (grid)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                    \"MinX\", DoubleValue (0.0),\n                                    \"MinY\", DoubleValue (0.0),\n                                    \"DeltaX\", DoubleValue (50.0),\n                                    \"DeltaY\", DoubleValue (50.0),\n                                    \"GridWidth\", UintegerValue (gridSize),\n                                    \"LayoutType\", StringValue (\"RowFirst\"));\n    mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install (sensorNodes);\n\n    // 4. Install energy model\n    BasicEnergySourceHelper energySourceHelper;\n    energySourceHelper.Set (\"BasicEnergySourceInitialEnergyJ\", DoubleValue (totalEnergy));\n    EnergySourceContainer sources = energySourceHelper.Install (sensorNodes);\n\n    WifiRadioEnergyModelHelper radioEnergyHelper;\n    DeviceEnergyModelContainer deviceModels = radioEnergyHelper.Install (devices, sources);\n\n    // 5. Set up the Internet stack\n    InternetStackHelper internet;\n    internet.Install (sensorNodes);\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);\n\n    // 6. Install applications\n    uint16_t sinkPort = 9;\n    Address sinkAddress (InetSocketAddress (interfaces.GetAddress (0), sinkPort)); // First node is the sink\n\n    PacketSinkHelper sinkHelper (\"ns3::UdpSocketFactory\", sinkAddress);\n    ApplicationContainer sinkApp = sinkHelper.Install (sensorNodes.Get (0)); // Sink installed on node 0\n    sinkApp.Start (Seconds (0.0));\n    sinkApp.Stop (Seconds (simulationTime));\n\n    OnOffHelper clientHelper (\"ns3::UdpSocketFactory\", sinkAddress);\n    clientHelper.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientHelper.SetAttribute (\"DataRate\", DataRateValue (DataRate (\"1kbps\")));\n    clientHelper.SetAttribute (\"PacketSize\", UintegerValue (50));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 1; i < sensorNodes.GetN (); ++i) // All nodes except the sink send data\n    {\n        clientApps.Add (clientHelper.Install (sensorNodes.Get (i)));\n    }\n    clientApps.Start (Seconds (1.0));\n    clientApps.Stop (Seconds (simulationTime));\n\n    // 7. Trace remaining energy\n    for (uint32_t i = 0; i < sources.GetN (); ++i)\n    {\n        Ptr<BasicEnergySource> basicSource = DynamicCast<BasicEnergySource> (sources.Get (i));\n        basicSource->TraceConnectWithoutContext (\"RemainingEnergy\", MakeCallback (&RemainingEnergy));\n    }\n\n    // 8. Enable pcap tracing\n    phy.EnablePcapAll (\"wsn-grid\");\n\n    // 9. Run simulation\n    Simulator::Stop (Seconds (simulationTime));\n    Simulator::Run ();\n    Simulator::Destroy ();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ script using the ns-3 simulation library to simulate a point-to-point network topology with four nodes. The topology should include three point-to-point links: n0 to n2 and n1 to n2 with a bandwidth of 5 Mbps and delay of 2 ms, and n2 to n3 with a bandwidth of 1.5 Mbps and delay of 10 ms. Set up CBR/UDP traffic from n0 to n3 and n3 to n1, using a packet size of 210 bytes and a data rate of 448 kbps. Additionally, set up an FTP/TCP flow from n0 to n3 starting at 1.2 seconds and ending at 1.35 seconds. Use DropTail queues and enable tracing to a file called 'simple-global-routing.tr'."}, {"role": "assistant", "content": "// Network topology\n//\n//  n0\n//     \\ 5 Mb/s, 2ms\n//      \\          1.5Mb/s, 10ms\n//       n2 -------------------------n3\n//      /\n//     / 5 Mb/s, 2ms\n//   n1\n//\n// - all links are point-to-point links with indicated one-way BW/delay\n// - CBR/UDP flows from n0 to n3, and from n3 to n1\n// - FTP/TCP flow from n0 to n3, starting at time 1.2 to time 1.35 sec.\n// - UDP packet size of 210 bytes, with per-packet interval 0.00375 sec.\n//   (i.e., DataRate of 448,000 bps)\n// - DropTail queues\n// - Tracing of queues and packet receptions to file \"simple-global-routing.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleGlobalRoutingExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Users may find it convenient to turn on explicit debugging\n    // for selected modules; the below lines suggest how to do this\n#if 0\n  LogComponentEnable (\"SimpleGlobalRoutingExample\", LOG_LEVEL_INFO);\n#endif\n\n    // Set up some default values for the simulation.  Use the\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(210));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(\"448kb/s\"));\n\n    // DefaultValue::Bind (\"DropTailQueue::m_maxPackets\", 30);\n\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    bool enableFlowMonitor = false;\n    cmd.AddValue(\"EnableMonitor\", \"Enable Flow Monitor\", enableFlowMonitor);\n    cmd.Parse(argc, argv);\n\n    // Here, we will explicitly create four nodes.  In more sophisticated\n    // topologies, we could configure a node factory.\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer c;\n    c.Create(4);\n    NodeContainer n0n2 = NodeContainer(c.Get(0), c.Get(2));\n    NodeContainer n1n2 = NodeContainer(c.Get(1), c.Get(2));\n    NodeContainer n3n2 = NodeContainer(c.Get(3), c.Get(2));\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // We create the channels first without any IP addressing information\n    NS_LOG_INFO(\"Create channels.\");\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d0d2 = p2p.Install(n0n2);\n\n    NetDeviceContainer d1d2 = p2p.Install(n1n2);\n\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1500kbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    NetDeviceContainer d3d2 = p2p.Install(n3n2);\n\n    // Later, we add IP addresses.\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i0i2 = ipv4.Assign(d0d2);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1i2 = ipv4.Assign(d1d2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i3i2 = ipv4.Assign(d3d2);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    NS_LOG_INFO(\"Create Applications.\");\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(i3i2.GetAddress(0), port)));\n    onoff.SetConstantRate(DataRate(\"448kb/s\"));\n    ApplicationContainer apps = onoff.Install(c.Get(0));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(c.Get(3));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a similar flow from n3 to n1, starting at time 1.1 seconds\n    onoff.SetAttribute(\"Remote\", AddressValue(InetSocketAddress(i1i2.GetAddress(0), port)));\n    apps = onoff.Install(c.Get(3));\n    apps.Start(Seconds(1.1));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    apps = sink.Install(c.Get(1));\n    apps.Start(Seconds(1.1));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"simple-global-routing.tr\"));\n    p2p.EnablePcapAll(\"simple-global-routing\");\n\n    // Flow Monitor\n    FlowMonitorHelper flowmonHelper;\n    if (enableFlowMonitor)\n    {\n        flowmonHelper.InstallAll();\n    }\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Stop(Seconds(11));\n    Simulator::Run();\n    NS_LOG_INFO(\"Done.\");\n\n    if (enableFlowMonitor)\n    {\n        flowmonHelper.SerializeToXmlFile(\"simple-global-routing.flowmon\", false, false);\n    }\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulator to create a mixed point-to-point and CSMA/CD network. The topology should include seven nodes, where two point-to-point links connect nodes n0 to n2 and n1 to n2, while nodes n2, n3, n4, and n5 form a shared CSMA/CD segment. Another point-to-point link connects n5 and n6. Implement a CBR/UDP flow from n0 to n6, and configure the OnOff application to send UDP packets of 50 bytes at a rate of 300 bps. Trace the network queues and packet receptions to a file, and enable pcap tracing for all channels."}, {"role": "assistant", "content": "// This script exercises global routing code in a mixed point-to-point\n// and csma/cd environment\n//\n// Network topology\n//\n//  n0\n//     \\ p-p\n//      \\          (shared csma/cd)\n//       n2 -------------------------n3\n//      /            |        |\n//     / p-p        n4        n5 ---------- n6\n//   n1                             p-p\n//\n// - CBR/UDP flows from n0 to n6\n// - Tracing of queues and packet receptions to file \"mixed-global-routing.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MixedGlobalRoutingExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(210));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(\"448kb/s\"));\n\n    // Allow the user to override any of the defaults and the above\n    // Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer c;\n    c.Create(7);\n    NodeContainer n0n2 = NodeContainer(c.Get(0), c.Get(2));\n    NodeContainer n1n2 = NodeContainer(c.Get(1), c.Get(2));\n    NodeContainer n5n6 = NodeContainer(c.Get(5), c.Get(6));\n    NodeContainer n2345 = NodeContainer(c.Get(2), c.Get(3), c.Get(4), c.Get(5));\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // We create the channels first without any IP addressing information\n    NS_LOG_INFO(\"Create channels.\");\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d0d2 = p2p.Install(n0n2);\n\n    NetDeviceContainer d1d2 = p2p.Install(n1n2);\n\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1500kbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    NetDeviceContainer d5d6 = p2p.Install(n5n6);\n\n    // We create the channels first without any IP addressing information\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d2345 = csma.Install(n2345);\n\n    // Later, we add IP addresses.\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(d0d2);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    ipv4.Assign(d1d2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i5i6 = ipv4.Assign(d5d6);\n\n    ipv4.SetBase(\"10.250.1.0\", \"255.255.255.0\");\n    ipv4.Assign(d2345);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    NS_LOG_INFO(\"Create Applications.\");\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(i5i6.GetAddress(1), port));\n    onoff.SetConstantRate(DataRate(\"300bps\"));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(50));\n\n    ApplicationContainer apps = onoff.Install(c.Get(0));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    Ptr<OutputStreamWrapper> stream = ascii.CreateFileStream(\"mixed-global-routing.tr\");\n    p2p.EnableAsciiAll(stream);\n    csma.EnableAsciiAll(stream);\n\n    p2p.EnablePcapAll(\"mixed-global-routing\");\n    csma.EnablePcapAll(\"mixed-global-routing\", false);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a network using OSPF as the routing protocol in NS-3. The network consists of four nodes arranged in a square topology. OSPF should be used to dynamically generate routing tables at each node. Monitor the routing tables to verify that the correct routes are chosen based on the shortest path."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ospf-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OspfRoutingExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for OSPF and other components\n    LogComponentEnable(\"OspfRoutingExample\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Create Point-to-Point links between the nodes to form a square topology\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install links: Node 0-1, Node 1-2, Node 2-3, Node 3-0 (square)\n    NetDeviceContainer devices01 = p2p.Install(nodes.Get(0), nodes.Get(1));\n    NetDeviceContainer devices12 = p2p.Install(nodes.Get(1), nodes.Get(2));\n    NetDeviceContainer devices23 = p2p.Install(nodes.Get(2), nodes.Get(3));\n    NetDeviceContainer devices30 = p2p.Install(nodes.Get(3), nodes.Get(0));\n\n    // Install Internet stack with OSPF routing on all nodes\n    InternetStackHelper internet;\n    \n    // Enable OSPF routing\n    Ipv4ListRoutingHelper listRouting;\n    OspfHelper ospfRouting;\n    listRouting.Add(ospfRouting, 0);\n    internet.SetRoutingHelper(listRouting);  // Use OSPF as the routing protocol\n    internet.Install(nodes);\n\n    // Assign IP addresses to the network interfaces\n    Ipv4AddressHelper ipv4;\n    \n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ifaces01 = ipv4.Assign(devices01);  // Link 0-1\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ifaces12 = ipv4.Assign(devices12);  // Link 1-2\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ifaces23 = ipv4.Assign(devices23);  // Link 2-3\n\n    ipv4.SetBase(\"10.1.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ifaces30 = ipv4.Assign(devices30);  // Link 3-0\n\n    // Set up a simple application: Echo server on node 3\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(3));  // Server on node 3\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a client on node 0 to send packets to node 3\n    UdpEchoClientHelper echoClient(ifaces23.GetAddress(1), 9);  // Node 0 sends to node 3\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));  // Client on node 0\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable routing table printing on all nodes for OSPF\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n    Simulator::Schedule(Seconds(2.0), &Ipv4GlobalRoutingHelper::PrintRoutingTableAllAt, Seconds(2.0), Create<OutputStreamWrapper>(&std::cout));\n\n    // Enable pcap tracing to observe packet transmission\n    p2p.EnablePcapAll(\"ospf-routing\");\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a point-to-point (P2P) wired network with two nodes communicating over a 5 Mbps link with a 2 ms delay. Node 1 should run a TCP server listening on port 50000, while Node 0 should run a TCP client using the BulkSendHelper to send unlimited data to the server. The server should start at 1 second, and the client should start at 2 seconds, both running until 10 seconds. The network should use the 10.1.1.0/24 subnet."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleP2PExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"SimpleP2PExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure the point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install the point-to-point devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP server on node 1\n    uint16_t port = 50000;\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\",\n                                InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = sinkHelper.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create a TCP client on node 0\n    BulkSendHelper sourceHelper(\"ns3::TcpSocketFactory\",\n                                InetSocketAddress(interfaces.GetAddress(1), port));\n    sourceHelper.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n    ApplicationContainer clientApp = sourceHelper.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a CSMA-based local area network with four nodes connected via a shared medium. The CSMA link should have a data rate of 100 Mbps and a delay of 1 millisecond. The third node should act as a UDP echo server on port 9, while the first node should be a UDP echo client sending five packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create 4 nodes\n    NodeContainer csmaNodes;\n    csmaNodes.Create(4);\n\n    // Set up a CSMA channel\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    // Install CSMA devices on nodes\n    NetDeviceContainer csmaDevices;\n    csmaDevices = csma.Install(csmaNodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(csmaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer csmaInterfaces = address.Assign(csmaDevices);\n\n    // Set up a UDP echo server on Node 3\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(csmaNodes.Get(3));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP echo client on Node 0\n    UdpEchoClientHelper echoClient(csmaInterfaces.GetAddress(3), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(csmaNodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 to simulate a basic TCP Socket communication between two nodes. Set up a point-to-point link between the nodes with a data rate of 5Mbps and a delay of 2ms. Use a custom TCP socket on one node to send data to another node, acting as a server, using the socket API. Log the data transmission and reception events during the simulation"}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/socket.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpSocketExample\");\n\n// Callback function to log when a packet is received at the server\nvoid ReceivePacket(Ptr<Socket> socket)\n{\n    Ptr<Packet> packet;\n    while ((packet = socket->Recv()))\n    {\n        NS_LOG_INFO(\"Received packet of size \" << packet->GetSize());\n    }\n}\n\n// Function to simulate a client sending data via a TCP socket\nvoid SendPacket(Ptr<Socket> socket, uint32_t size, Time sendInterval)\n{\n    Ptr<Packet> packet = Create<Packet>(size); // Create a packet of given size\n    socket->Send(packet); // Send the packet\n    NS_LOG_INFO(\"Sent packet of size \" << size);\n    Simulator::Schedule(sendInterval, &SendPacket, socket, size, sendInterval); // Schedule the next send\n}\n\nint \nmain(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"TcpSocketExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2); // Two nodes: n0 (client) -> n1 (server)\n\n    // Set up a point-to-point link between the two nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install the devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack (TCP/IP) on both nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP socket on the server (node 1)\n    Ptr<Socket> serverSocket = Socket::CreateSocket(nodes.Get(1), TcpSocketFactory::GetTypeId());\n    InetSocketAddress localAddress = InetSocketAddress(Ipv4Address::GetAny(), 8080); // Listening on port 8080\n    serverSocket->Bind(localAddress); // Bind the socket to the address\n    serverSocket->Listen(); // Set the socket to listen mode\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket)); // Set callback to handle received packets\n\n    // Create a TCP socket on the client (node 0)\n    Ptr<Socket> clientSocket = Socket::CreateSocket(nodes.Get(0), TcpSocketFactory::GetTypeId());\n    InetSocketAddress remoteAddress = InetSocketAddress(interfaces.GetAddress(1), 8080); // Server address (node 1)\n    clientSocket->Connect(remoteAddress); // Connect the client socket to the server\n\n    // Schedule the first packet transmission at 2 seconds\n    Simulator::Schedule(Seconds(2.0), &SendPacket, clientSocket, 1024, Seconds(1.0)); // 1024 bytes, every 1 second\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to create an ad hoc wireless network with four nodes. Configure the nodes to use IEEE 802.11 in ad hoc mode and set up a grid mobility model that positions them initially in a grid layout, allowing for random movement within a specified rectangular area. Install the Internet stack and assign IPv4 addresses from the subnet 192.9.39.0/24. Establish UDP echo server applications on each node, enabling them to communicate in a ring topology where each node sends echo requests to the next. Set the maximum number of packets for each client to 20, with an interval of half a second. Integrate a flow monitor to capture statistics such as packet delivery ratios, end-to-end delays, and throughput for all communications. Generate an animation file to visualize the network activity during the simulation. Finally, output the collected flow statistics and performance metrics after running the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/propagation-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"AdhocNetworkExample\");\n\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable (\"AdhocNetworkExample\", LOG_LEVEL_INFO);\n\n  // Create two wireless nodes\n  NodeContainer nodes;\n  nodes.Create (4);\n\n  // Configure wireless parameters\n  WifiHelper wifi;\n\n  WifiMacHelper mac;\n  mac.SetType (\"ns3::AdhocWifiMac\");\n  \n\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default(); //define channel default configuration\n  YansWifiPhyHelper phy; //configure wifiPHY\n  phy.SetChannel(channel.Create());\n\n  \n\n  NetDeviceContainer devices = wifi.Install (phy, mac, nodes); //create wifiNetDevice\n  \n\n  // Set up mobility model\n  MobilityHelper mobility; //to set position of nodes\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0), //starting node x axis\n                                 \"MinY\", DoubleValue (0.0), //starting node y axis\n                                 \"DeltaX\", DoubleValue (2.0), //gap before next node in row\n                                 \"DeltaY\", DoubleValue (2.0), //gap before next node in column\n                                 \"GridWidth\", UintegerValue (5), // max number of nodes based on the layout type\n                                 \"LayoutType\", StringValue (\"RowFirst\")); //nodes will first fill up the rows then columns\n                                 \n                                \n  mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue(Rectangle(-100, 100, -100,100))); //nodes over randomly in 2D\n                                                                                          //nodes movement bound in rectangle   (Xmin,Xmax,Ymin,Ymax)        \n  mobility.Install (nodes); //install the nodes\n  \n  // Set up network stack\n  InternetStackHelper stack;\n  stack.Install (nodes);\n\n  // Assign IPv4 addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"192.9.39.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  UdpEchoServerHelper server01(10);\n  ApplicationContainer serverApps01 = server01.Install (nodes.Get (0));\n  serverApps01.Start (Seconds (1.0));\n  serverApps01.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client01 (interfaces.GetAddress (0), 10);\n  client01.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client01.SetAttribute (\"Interval\", TimeValue (Seconds(0.5)));\n  client01.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps01 = client01.Install (nodes.Get (1));\n  clientApps01.Start (Seconds (2.0));\n  clientApps01.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server12(15);\n\n  ApplicationContainer serverApps12 = server12.Install (nodes.Get (1));\n  serverApps12.Start (Seconds (1.0));\n  serverApps12.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client12 (interfaces.GetAddress (1), 15);\n  client12.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client12.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client12.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps12 = client12.Install (nodes.Get (2));\n  clientApps12.Start (Seconds (2.0));\n  clientApps12.Stop (Seconds (100.0));\n\n   UdpEchoServerHelper server23(17);\n\n  ApplicationContainer serverApps23 = server23.Install (nodes.Get (2));\n  serverApps23.Start (Seconds (1.0));\n  serverApps23.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client23 (interfaces.GetAddress (2), 17);\n  client23.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client23.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client23.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps23 = client23.Install (nodes.Get (3));\n  clientApps23.Start (Seconds (2.0));\n  clientApps23.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server30(22);\n\n  ApplicationContainer serverApps30 = server30.Install (nodes.Get (3));\n  serverApps30.Start (Seconds (1.0));\n  serverApps30.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client30 (interfaces.GetAddress (3), 22);\n  client30.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client30.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client30.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps30 = client30.Install (nodes.Get (0));\n  clientApps30.Start (Seconds (2.0));\n  clientApps30.Stop (Seconds (100.0));\n  \n  // Define a flow monitor object\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();\n  Simulator::Stop(Seconds(100.0));\n  \n  \n  // Animation\n  AnimationInterface anim(\"239_task4_4nodes.xml\");\n  \n\n  // Run simulation\n  Simulator::Run ();\n  \n \n  \n Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());\n std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats ();\nfor (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n{\n // Calculate packet delivery ratio and end to end delay and throughput\n  uint32_t packetsDelivered = 0;\n  uint32_t totalPackets = 0;\n  double totalDelay = 0;\n Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);\nstd::cout << \"FlowId: \" << i->first << \"\\n\";\nstd::cout << \"Sender: \"<< t.sourceAddress << \"\\n\"; \nstd::cout << \"Receiver: \"<< t.destinationAddress << \"\\n\"; \nstd::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\nstd::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n\nstd::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\nstd::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\nif(i->second.rxPackets > 0)\n  \t{\n  \t\tpacketsDelivered += i->second.rxPackets;\n  \t\ttotalPackets += i->second.txPackets;\n  \t\ttotalDelay += (i->second.delaySum.ToDouble(ns3::Time::S) / i->second.rxPackets);\n  \t}\n       \n  double packetDeliveryRatio = (double) packetsDelivered / totalPackets;\n  double averageEndToEndDelay = totalDelay / packetsDelivered;\n  double throughput = (double) packetsDelivered * 1024 * 8 / (100.0 - 0.0) / 1000000;\n  \n  // Printing the results\n  std::cout << \"Packets Delivered Ratio: \" << packetDeliveryRatio << std::endl;\n  std::cout << \"Average End-to-End Delay: \" << averageEndToEndDelay << std::endl;\n  std::cout << \"Throughput: \" << throughput << std::endl;\n   }\n  \n \n  \n  Simulator::Destroy ();\n\n  return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a 5G NR (New Radio) network with one gNB (base station) and one UE (user equipment). The gNB serves as the base station and the UE sends 512-byte UDP packets to the gNB every 500ms. The simulation should run for 10 seconds. The 5G NR module should be used for the radio access network, and the Evolved Packet Core (EPC) should be implemented for packet forwarding. Set up mobility so the gNB is stationary, and the UE sends data while moving."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/epc-helper.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/nr-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Nr5GExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"Nr5GExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: gNB (Base Station) and UE (User Equipment)\n    NodeContainer gNbNode, ueNode;\n    gNbNode.Create(1);\n    ueNode.Create(1);\n\n    // Create EPC (Evolved Packet Core) helper and install it\n    Ptr<EpcHelper> epcHelper = CreateObject<EpcHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    // Install NR stack\n    nrHelper->Install(gNbNode);\n    nrHelper->Install(ueNode);\n\n    // Setup mobility for gNB and UE\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(gNbNode);\n    mobility.Install(ueNode);\n\n    // Install Internet Stack (IP) on UE\n    InternetStackHelper internet;\n    internet.Install(ueNode);\n\n    // Setup UE and gNB network interface\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpInterface = ipv4.Assign(ueNode);\n\n    // Configure and install applications\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(gNbNode);\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup UDP client on UE to send data to gNB\n    UdpClientHelper udpClient(ueIpInterface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(500)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp = udpClient.Install(ueNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple point-to-point network with two nodes using ns-3. Configure the first node to act as a sender and the second node as a receiver. Use TCP as the transport protocol, and set up a bulk data transfer application on the sender to continuously send data to the receiver. Enable packet tracing to generate pcap files for traffic analysis, and log the total amount of data received at the end of the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"PointToPointTcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link with specific data rate and delay\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the internet stack on both nodes\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up a BulkSendApplication on the sender (node 0)\n    uint16_t port = 9; // TCP well-known port number\n    BulkSendHelper bulkSend(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    bulkSend.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n    ApplicationContainer senderApp = bulkSend.Install(nodes.Get(0));\n    senderApp.Start(Seconds(1.0));\n    senderApp.Stop(Seconds(10.0));\n\n    // Set up a PacketSinkApplication on the receiver (node 1)\n    PacketSinkHelper packetSink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer receiverApp = packetSink.Install(nodes.Get(1));\n    receiverApp.Start(Seconds(1.0));\n    receiverApp.Stop(Seconds(10.0));\n\n    // Enable packet tracing (pcap file generation)\n    pointToPoint.EnablePcapAll(\"tcp-p2p-example\");\n\n    // Run the simulation\n    Simulator::Run();\n\n    // Log the total bytes received by the receiver node\n    Ptr<PacketSink> sink = DynamicCast<PacketSink>(receiverApp.Get(0));\n    NS_LOG_INFO(\"Total Bytes Received: \" << sink->GetTotalRx());\n\n    // Destroy the simulation\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Mobile Ad-Hoc Network (MANET) using the AODV routing protocol. The network should consist of five nodes, each assigned a unique IPv4 address in the 192.168.1.0/24 subnet. Nodes should move using a RandomWalk2dMobilityModel within a bounded area (-50,50,-50,50). The last node should act as a UDP echo server on port 9, while the first node should be a client sending three packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/aodv-helper.h\"\n#include \"ns3/olsr-helper.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    NodeContainer nodes;\n    nodes.Create(5); // Create 5 MANET nodes\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(nodes);\n\n    AodvHelper aodv;\n    Ipv4ListRoutingHelper list;\n    list.Add(aodv, 100);\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(list);\n    internet.Install(nodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(4)); // Last node as server\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(4), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(3));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0)); // First node as client\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns3 library to simulate a ring topology network. The network should consist of four nodes, where each node is connected to two other nodes, forming a ring. Use the UDP echo client-server application to simulate communication between the nodes. Each node should act as both a client and a server at least once, with only one pair of client-server applications running at a time. The clients should send a maximum of 4 packets with a defined transmission interval, and all packets should be successfully received by the respective server. Set the network address to 192.9.39.0/24, and use point-to-point links with a 5Mbps data rate and 2ms delay for the connections. Include necessary logging and NetAnim visualization for the simulation"}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TREE_TOPOLOGY_EXAMPLE\");\n\nint main(int argc, char* argv[]) {\n    // Parse command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    // Set time resolution and enable logging for client-server applications\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create a node container with 4 nodes, representing a simple network\n    NodeContainer tree;\n    tree.Create(4);\n\n    // Define point-to-point link characteristics (5 Mbps data rate, 2 ms delay)\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create NetDevice containers to store the devices for each link\n    NetDeviceContainer device1, device2, device3;\n\n    // Install the point-to-point links between nodes (representing the tree structure)\n    device1.Add(pointToPoint.Install(tree.Get(0), tree.Get(1))); // Link between node 0 and node 1\n    device2.Add(pointToPoint.Install(tree.Get(0), tree.Get(2))); // Link between node 0 and node 2\n    device3.Add(pointToPoint.Install(tree.Get(1), tree.Get(3))); // Link between node 1 and node 3\n\n    // Install the internet stack on the nodes\n    InternetStackHelper stack;\n    stack.Install(tree);\n\n    // Set up IP address helpers for each interface\n    Ipv4AddressHelper address1, address2, address3;\n    address1.SetBase(\"192.9.39.0\", \"255.255.255.252\");\n    address2.SetBase(\"192.9.39.4\", \"255.255.255.252\");\n    address3.SetBase(\"192.9.39.8\", \"255.255.255.252\");\n\n    // Create interface containers and assign IP addresses to each link\n    Ipv4InterfaceContainer interface1, interface2, interface3;\n    interface1 = address1.Assign(device1);\n    interface2 = address2.Assign(device2);\n    interface3 = address3.Assign(device3);\n\n    // Setup UDP echo server on node 0\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps01;\n    serverApps01 = echoServer.Install(tree.Get(0)); // Install on node 0\n    serverApps01.Start(Seconds(1.0));\n    serverApps01.Stop(Seconds(10.0));\n\n    // Setup UDP echo client on node 1 to communicate with server on node 0\n    UdpEchoClientHelper echoClient01(interface1.GetAddress(0), 9); // Use address of node 0 as the server\n    echoClient01.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient01.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient01.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp01 = echoClient01.Install(tree.Get(1)); // Install client on node 1\n    clientApp01.Start(Seconds(2.0));\n    clientApp01.Stop(Seconds(10.0));\n\n    // Repeat the same for other client-server pairs\n\n    // Server on node 1 and client on node 0\n    ApplicationContainer serverApps10 = echoServer.Install(tree.Get(1)); // Server on node 1\n    serverApps10.Start(Seconds(11.0));\n    serverApps10.Stop(Seconds(20.0));\n\n    UdpEchoClientHelper echoClient10(interface1.GetAddress(1), 9); // Use address of node 1 as the server\n    echoClient10.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient10.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient10.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp10 = echoClient10.Install(tree.Get(0)); // Install client on node 0\n    clientApp10.Start(Seconds(12.0));\n    clientApp10.Stop(Seconds(20.0));\n\n    // Server on node 0 and client on node 2\n    ApplicationContainer serverApps02 = echoServer.Install(tree.Get(0)); // Server on node 0\n    serverApps02.Start(Seconds(21.0));\n    serverApps02.Stop(Seconds(30.0));\n\n    UdpEchoClientHelper echoClient02(interface2.GetAddress(0), 9); // Use address of node 0 as the server\n    echoClient02.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient02.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient02.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp02 = echoClient02.Install(tree.Get(2)); // Install client on node 2\n    clientApp02.Start(Seconds(22.0));\n    clientApp02.Stop(Seconds(30.0));\n\n    // Server on node 2 and client on node 0\n    ApplicationContainer serverApps20 = echoServer.Install(tree.Get(2)); // Server on node 2\n    serverApps20.Start(Seconds(31.0));\n    serverApps20.Stop(Seconds(40.0));\n\n    UdpEchoClientHelper echoClient20(interface2.GetAddress(1), 9); // Use address of node 2 as the server\n    echoClient20.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient20.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient20.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp20 = echoClient20.Install(tree.Get(0)); // Install client on node 0\n    clientApp20.Start(Seconds(32.0));\n    clientApp20.Stop(Seconds(40.0));\n\n    // Server on node 1 and client on node 3\n    ApplicationContainer serverApps13 = echoServer.Install(tree.Get(1)); // Server on node 1\n    serverApps13.Start(Seconds(41.0));\n    serverApps13.Stop(Seconds(50.0));\n\n    UdpEchoClientHelper echoClient13(interface3.GetAddress(0), 9); // Use address of node 1 as the server\n    echoClient13.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient13.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient13.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp13 = echoClient13.Install(tree.Get(3)); // Install client on node 3\n    clientApp13.Start(Seconds(42.0));\n    clientApp13.Stop(Seconds(50.0));\n\n    // Server on node 3 and client on node 1\n    ApplicationContainer serverApps31 = echoServer.Install(tree.Get(3)); // Server on node 3\n    serverApps31.Start(Seconds(51.0));\n    serverApps31.Stop(Seconds(60.0));\n\n    UdpEchoClientHelper echoClient31(interface3.GetAddress(1), 9); // Use address of node 3 as the server\n    echoClient31.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient31.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient31.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp31 = echoClient31.Install(tree.Get(1)); // Install client on node 1\n    clientApp31.Start(Seconds(52.0));\n    clientApp31.Stop(Seconds(60.0));\n\n    // Enable animation output to view the topology\n    AnimationInterface anim(\"Tree_Topology.xml\");\n\n    // Run the simulation and destroy after completion\n    Simulator::Run();\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a network simulation code in ns-3 that models two Local Area Networks (LANs) connected by a Wide Area Network (WAN), illustrating how global-router-interface source code supports bridging multiple Layer 2 (L2) switches between Layer 3 (L3) routers. Configure one LAN at the top with subnet 192.168.1/24 and another at the bottom with subnet 192.168.2/24, each connected through a router to a 5Mbit/s, 50ms WAN link (76.1.1.*). On each LAN, implement UDP echo clients and servers for testing connectivity. The \"top\" LAN uses four switches (ts1, ts2, ts3, ts4) and two UDP endpoints (t2 and t3), while the \"bottom\" LAN employs five switches (bs1 to bs5) and two endpoints (b2 and b3). Ensure that t2 communicates with b2 across multiple switches, and t3 with b3 through a single switch, both LANs interconnected via routers (tr and br). Allow for adjustable CSMA link speeds (100Mbit or 10Mbit) using command-line options, and include PCAP trace points at key network locations."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/bridge-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <fstream>\n#include <iostream>\n\nusing namespace ns3;\n\n// ########################################################################\n// Main routine\n// ########################################################################\nNS_LOG_COMPONENT_DEFINE(\"GlobalRoutingMultiSwitchPlusRouter\");\n\n#define vssearch(loc, vec) std::find((vec).begin(), (vec).end(), (loc)) != (vec).end()\n\nint\nmain(int argc, char* argv[])\n{\n    // ----------------------------------------------------------------------\n    // Default values for command line arguments\n    // ----------------------------------------------------------------------\n    bool verbose = true;\n\n    int simDurationSeconds = 60;\n\n    bool enableUdpMultiSW = true;\n    bool enableUdpSingleSW = true;\n\n    std::string pcapLocations = \"\";\n    uint32_t snapLen = PcapFile::SNAPLEN_DEFAULT;\n\n    std::string csmaXLinkDataRate = \"100Mbps\";\n    std::string csmaXLinkDelay = \"500ns\";\n\n    std::string csmaYLinkDataRate = \"10Mbps\";\n    std::string csmaYLinkDelay = \"500ns\";\n\n    std::string p2pLinkDataRate = \"5Mbps\";\n    std::string p2pLinkDelay = \"50ms\";\n\n    uint16_t udpEchoPort = 9; // The well-known UDP echo port\n\n    // ----------------------------------------------------------------------\n    // Create command line options and get them\n    // ----------------------------------------------------------------------\n    CommandLine cmd(__FILE__);\n\n    cmd.Usage(\"NOTE: valid --pcap arguments are: 't2,t3,b2,b3,trlan,trwan,brlan,brwan'\");\n\n    cmd.AddValue(\"verbose\", \"Enable printing informational messages\", verbose);\n\n    cmd.AddValue(\"duration\", \"Duration of simulation.\", simDurationSeconds);\n\n    cmd.AddValue(\"udpMultiSW\", \"Enable udp over multi-switch links\", enableUdpMultiSW);\n    cmd.AddValue(\"udpSingleSW\", \"Enable udp over single-switch links\", enableUdpSingleSW);\n\n    cmd.AddValue(\"pcap\", \"Comma separated list of PCAP Locations to tap\", pcapLocations);\n    cmd.AddValue(\"snapLen\", \"PCAP packet capture length\", snapLen);\n\n    cmd.AddValue(\"csmaXRate\", \"CSMA X Link data rate\", csmaXLinkDataRate);\n    cmd.AddValue(\"csmaXDelay\", \"CSMA X Link delay\", csmaXLinkDelay);\n\n    cmd.AddValue(\"csmaYRate\", \"CSMA Y Link data rate\", csmaYLinkDataRate);\n    cmd.AddValue(\"csmaYDelay\", \"CSMA Y Link delay\", csmaYLinkDelay);\n\n    cmd.AddValue(\"p2pRate\", \"P2P Link data rate\", p2pLinkDataRate);\n    cmd.AddValue(\"p2pDelay\", \"P2P Link delay\", p2pLinkDelay);\n\n    cmd.Parse(argc, argv);\n\n    // --------------------------------------------------------------------\n    // Users may find it convenient to turn on explicit debugging\n    // for selected modules; the below lines suggest how to do this\n    // --------------------------------------------------------------------\n    if (verbose)\n    {\n        LogComponentEnable(\"GlobalRoutingMultiSwitchPlusRouter\", LOG_LEVEL_INFO);\n    }\n\n    // ======================================================================\n    // Define the list of valid PCAP taps\n    // ----------------------------------------------------------------------\n    const std::vector<std::string> pcapTaps{\n        \"t2\",    // multi-switch  UDP echo client\n        \"t3\",    // single-switch UDP echo server\n        \"b2\",    // multi-switch  UDP echo server\n        \"b3\",    // single-switch UDP echo client\n        \"trlan\", // top router    LAN side\n        \"trwan\", // top router    WAN side\n        \"brlan\", // bottom router LAN side\n        \"brwan\", // bottom router WAN side\n    };\n\n    // ----------------------------------------------------------------------\n    // Parse the pcapLocations string into pcapLocationVec\n    // ----------------------------------------------------------------------\n    std::vector<std::string> pcapLocationVec;\n    if (!pcapLocations.empty())\n    {\n        std::stringstream sStream(pcapLocations);\n\n        while (sStream.good())\n        {\n            std::string substr;\n            getline(sStream, substr, ',');\n            if (vssearch(substr, pcapTaps))\n            {\n                pcapLocationVec.push_back(substr);\n            }\n            else\n            {\n                NS_LOG_ERROR(\"WARNING: Unrecognized PCAP location: <\" + substr + \">\");\n            }\n        }\n\n        for (auto ploc = pcapLocationVec.begin(); ploc != pcapLocationVec.end(); ++ploc)\n        {\n            NS_LOG_INFO(\"PCAP capture at: <\" + *ploc + \">\");\n        }\n    }\n\n    // ======================================================================\n    // Set some simulator-wide values\n    // ======================================================================\n\n    // ----------------------------------------------------------------------\n    // Set PCAP packet capture maximum packet length\n    // ----------------------------------------------------------------------\n    if (snapLen != PcapFile::SNAPLEN_DEFAULT)\n    {\n        Config::SetDefault(\"ns3::PcapFileWrapper::CaptureSize\", UintegerValue(snapLen));\n    }\n\n    // ======================================================================\n    // Create the nodes & links required for the topology shown in comments above.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"INFO: Create nodes.\");   // - - - - - - - - - - - - - - - -\n                                          // Node IP     : Description\n                                          // - - - - - - - - - - - - - - - -\n    Ptr<Node> t2 = CreateObject<Node>();  // 192.168.1.2 : Top multi-switch udp echo client\n    Ptr<Node> t3 = CreateObject<Node>();  // 192.168.1.3 : Top single-switch   udp echo server\n                                          //             :\n    Ptr<Node> ts1 = CreateObject<Node>(); // <no IP>     : Top switch #1 (bridge)\n    Ptr<Node> ts2 = CreateObject<Node>(); // <no IP>     : Top switch #2 (bridge)\n    Ptr<Node> ts3 = CreateObject<Node>(); // <no IP>     : Top switch #3 (bridge)\n    Ptr<Node> ts4 = CreateObject<Node>(); // <no IP>     : Top switch #4 (bridge)\n                                          //             :\n    Ptr<Node> tr = CreateObject<Node>();  // 192.168.1.1 : Router connecting top LAN & WAN\n                                          // 76.1.1.1    :\n                                          //             :\n    Ptr<Node> br = CreateObject<Node>();  // 76.1.1.2    : Router connecting WAN & bottom LANs\n                                          // 192.168.2.1 :\n                                          //             :\n    Ptr<Node> bs1 = CreateObject<Node>(); // <no IP>     : Bottom switch #1 (bridge)\n    Ptr<Node> bs2 = CreateObject<Node>(); // <no IP>     : Bottom switch #2 (bridge)\n    Ptr<Node> bs3 = CreateObject<Node>(); // <no IP>     : Bottom switch #3 (bridge)\n    Ptr<Node> bs4 = CreateObject<Node>(); // <no IP>     : Bottom switch #4 (bridge)\n    Ptr<Node> bs5 = CreateObject<Node>(); // <no IP>     : Bottom switch #5 (bridge)\n                                          //             :\n    Ptr<Node> b2 = CreateObject<Node>();  // 192.168.2.2 : Bottom multi-switch udp echo server\n\n    Ptr<Node> b3 = CreateObject<Node>(); // 192.168.2.3 : Bottom single-switch   udp echo client\n                                         // - - - - - - - - - - - - - - - -\n\n    // ----------------------------------------------------------------------\n    // Give the nodes names\n    // ----------------------------------------------------------------------\n    Names::Add(\"t2\", t2);\n    Names::Add(\"t3\", t3);\n    Names::Add(\"ts1\", ts1);\n    Names::Add(\"ts2\", ts2);\n    Names::Add(\"ts3\", ts3);\n    Names::Add(\"ts4\", ts4);\n    Names::Add(\"tr\", tr);\n    Names::Add(\"br\", br);\n    Names::Add(\"bs1\", bs1);\n    Names::Add(\"bs2\", bs2);\n    Names::Add(\"bs3\", bs3);\n    Names::Add(\"bs4\", bs4);\n    Names::Add(\"bs5\", bs5);\n    Names::Add(\"b2\", b2);\n    Names::Add(\"b3\", b3);\n\n    // ======================================================================\n    // Create CSMA links to use for connecting LAN nodes together\n    // ----------------------------------------------------------------------\n\n    // ----------------------------------------\n    // CSMA [X]\n    // ----------------------------------------\n    NS_LOG_INFO(\"L2: Create a \" << csmaXLinkDataRate << \" \" << csmaXLinkDelay\n                                << \" CSMA link for csmaX for LANs.\");\n    CsmaHelper csmaX;\n    csmaX.SetChannelAttribute(\"DataRate\", StringValue(csmaXLinkDataRate));\n    csmaX.SetChannelAttribute(\"Delay\", StringValue(csmaXLinkDelay));\n\n    // ----------------------------------------\n    // CSMA [Y]\n    // ----------------------------------------\n    NS_LOG_INFO(\"L2: Create a \" << csmaYLinkDataRate << \" \" << csmaYLinkDelay\n                                << \" CSMA link for csmaY for LANs.\");\n    CsmaHelper csmaY;\n    csmaY.SetChannelAttribute(\"DataRate\", StringValue(csmaYLinkDataRate));\n    csmaY.SetChannelAttribute(\"Delay\", StringValue(csmaYLinkDelay));\n\n    // ----------------------------------------------------------------------\n    // Now, connect the top LAN nodes together with csma links.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Connect nodes on top LAN together with half-duplex CSMA links.\");\n\n    // Multi-switch top LAN chain: t2-ts4-ts3-ts2-ts1-tr\n    NetDeviceContainer link_t2_ts4 = csmaX.Install(NodeContainer(t2, ts4));\n    NetDeviceContainer link_ts4_ts3 = csmaY.Install(NodeContainer(ts4, ts3));\n    NetDeviceContainer link_ts3_ts2 = csmaX.Install(NodeContainer(ts3, ts2));\n    NetDeviceContainer link_ts2_ts1 = csmaY.Install(NodeContainer(ts2, ts1));\n\n    // Single-switch top LAN link: t3-ts1-tr\n    NetDeviceContainer link_t3_ts1 = csmaX.Install(NodeContainer(t3, ts1));\n\n    // Common link for top LAN between ts1 and tr (for t2 and t3 to get to tr)\n    NetDeviceContainer link_tr_ts1 = csmaY.Install(NodeContainer(tr, ts1));\n\n    // ----------------------------------------------------------------------\n    // And repeat above steps to connect the bottom LAN nodes together\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Connect nodes on bottom LAN together with half-duplex CSMA links.\");\n\n    // Multi-switch bottom LAN chain: b2-bs5-bs4-bs3-bs2-bs1-br\n    NetDeviceContainer link_b2_bs5 = csmaY.Install(NodeContainer(b2, bs5));\n    NetDeviceContainer link_bs5_bs4 = csmaX.Install(NodeContainer(bs5, bs4));\n    NetDeviceContainer link_bs4_bs3 = csmaY.Install(NodeContainer(bs4, bs3));\n    NetDeviceContainer link_bs3_bs2 = csmaX.Install(NodeContainer(bs3, bs2));\n    NetDeviceContainer link_bs2_bs1 = csmaY.Install(NodeContainer(bs2, bs1));\n\n    // Single-switch bottom LAN link: b3-bs1-br\n    NetDeviceContainer link_b3_bs1 = csmaY.Install(NodeContainer(b3, bs1));\n\n    // Common link for bottom LAN between bs1 and br (for b2 and b3 to get to br)\n    NetDeviceContainer link_br_bs1 = csmaX.Install(NodeContainer(br, bs1));\n\n    // ======================================================================\n    // Create a point-to-point link for connecting WAN nodes together\n    // (this type of link is full-duplex)\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Create a \" << p2pLinkDataRate << \" \" << p2pLinkDelay\n                                << \" Point-to-Point link for the WAN.\");\n\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(p2pLinkDataRate));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(p2pLinkDelay));\n\n    // ----------------------------------------------------------------------\n    // Now, connect top router to bottom router with a p2p WAN link\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Connect the routers together with the Point-to-Point WAN link.\");\n\n    NetDeviceContainer link_tr_br;\n    link_tr_br = p2p.Install(NodeContainer(tr, br));\n\n    // ======================================================================\n    // Manually create the list of NetDevices for each switch\n    // ----------------------------------------------------------------------\n\n    // Top Switch 4 NetDevices\n    NetDeviceContainer ts4nd;\n    ts4nd.Add(link_t2_ts4.Get(1));\n    ts4nd.Add(link_ts4_ts3.Get(0));\n\n    // Top Switch 3 NetDevices\n    NetDeviceContainer ts3nd;\n    ts3nd.Add(link_ts4_ts3.Get(1));\n    ts3nd.Add(link_ts3_ts2.Get(0));\n\n    // Top Switch 2 NetDevices\n    NetDeviceContainer ts2nd;\n    ts2nd.Add(link_ts3_ts2.Get(1));\n    ts2nd.Add(link_ts2_ts1.Get(0));\n\n    // Top Switch 1 NetDevices\n    NetDeviceContainer ts1nd;\n    ts1nd.Add(link_ts2_ts1.Get(1));\n    ts1nd.Add(link_t3_ts1.Get(1));\n    ts1nd.Add(link_tr_ts1.Get(1));\n\n    // Bottom Switch 1 NetDevices\n    NetDeviceContainer bs1nd;\n    bs1nd.Add(link_br_bs1.Get(1));\n    bs1nd.Add(link_bs2_bs1.Get(1));\n    bs1nd.Add(link_b3_bs1.Get(1));\n\n    // Bottom Switch 2 NetDevices\n    NetDeviceContainer bs2nd;\n    bs2nd.Add(link_bs2_bs1.Get(0));\n    bs2nd.Add(link_bs3_bs2.Get(1));\n\n    // Bottom Switch 3 NetDevices\n    NetDeviceContainer bs3nd;\n    bs3nd.Add(link_bs3_bs2.Get(0));\n    bs3nd.Add(link_bs4_bs3.Get(1));\n\n    // Bottom Switch 4 NetDevices\n    NetDeviceContainer bs4nd;\n    bs4nd.Add(link_bs4_bs3.Get(0));\n    bs4nd.Add(link_bs5_bs4.Get(1));\n\n    // Bottom Switch 5 NetDevices\n    NetDeviceContainer bs5nd;\n    bs5nd.Add(link_bs5_bs4.Get(0));\n    bs5nd.Add(link_b2_bs5.Get(1));\n\n    // ======================================================================\n    // Install bridging code on each switch\n    // ----------------------------------------------------------------------\n    BridgeHelper bridge;\n\n    bridge.Install(ts1, ts1nd);\n    bridge.Install(ts2, ts2nd);\n    bridge.Install(ts3, ts3nd);\n    bridge.Install(ts4, ts4nd);\n\n    bridge.Install(bs1, bs1nd);\n    bridge.Install(bs2, bs2nd);\n    bridge.Install(bs3, bs3nd);\n    bridge.Install(bs4, bs4nd);\n    bridge.Install(bs5, bs5nd);\n\n    // ======================================================================\n    // Install the L3 internet stack  (TCP/IP)\n    // ----------------------------------------------------------------------\n    InternetStackHelper ns3IpStack;\n\n    // ----------------------------------------------------------------------\n    // Install the L3 internet stack on UDP endpoints\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Install the ns3 IP stack on udp client and server nodes.\");\n    NodeContainer endpointNodes(t2, t3, b2, b3);\n    ns3IpStack.Install(endpointNodes);\n\n    // ----------------------------------------------------------------------\n    // Install the L3 internet stack on routers.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Install the ns3 IP stack on routers.\");\n    NodeContainer routerNodes(tr, br);\n    ns3IpStack.Install(routerNodes);\n\n    // ======================================================================\n    // Assign top LAN IP addresses\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Assign top LAN IP Addresses.\");\n\n    NetDeviceContainer topLanIpDevices;      // - - - - - -- - - - - - -\n    topLanIpDevices.Add(link_tr_ts1.Get(0)); // NOTE: order matters here\n    topLanIpDevices.Add(link_t2_ts4.Get(0)); //       for IP address\n    topLanIpDevices.Add(link_t3_ts1.Get(0)); //       assignment\n                                             // - - - - - -- - - - - - -\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    ipv4.Assign(topLanIpDevices);\n\n    // ----------------------------------------------------------------------\n    // Assign bottom LAN IP addresses\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Assign bottom LAN IP Addresses.\");\n\n    NetDeviceContainer botLanIpDevices;      // - - - - - -- - - - - - -\n    botLanIpDevices.Add(link_br_bs1.Get(0)); // NOTE: order matters here\n    botLanIpDevices.Add(link_b2_bs5.Get(0)); //       for IP address\n    botLanIpDevices.Add(link_b3_bs1.Get(0)); //       assignment\n                                             // - - - - - -- - - - - - -\n\n    ipv4.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    ipv4.Assign(botLanIpDevices);\n\n    // ----------------------------------------------------------------------\n    // Assign WAN IP addresses\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Assign WAN IP Addresses.\");\n\n    ipv4.SetBase(\"76.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(link_tr_br);\n\n    // ======================================================================\n    // Calculate and populate routing tables\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Populate routing tables.\");\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // ======================================================================\n    // Multi-Switch UDP traffic generation\n    // ----------------------------------------------------------------------\n    ApplicationContainer apps;\n\n    if (enableUdpMultiSW)\n    {\n        // ------------------------------------------------------------------\n        // Install multi-switch UDP echo server on b2\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Multi-Switch UDP server (on node b2 of bottom LAN)\");\n\n        UdpEchoServerHelper server(udpEchoPort);\n\n        ApplicationContainer serverApp = server.Install(b2);\n        serverApp.Start(Seconds(0.5));\n        serverApp.Stop(Seconds(simDurationSeconds));\n\n        // ------------------------------------------------------------------\n        // Install multi-switch UDP echo client on t2\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Multi-Switch UDP client (on node t2 of top LAN)\");\n\n        Time interPacketInterval = Seconds(0.005);\n        uint32_t packetSize = 1000;\n        uint32_t maxPacketCount = (simDurationSeconds - 2.0) / 0.005;\n\n        UdpEchoClientHelper client(Ipv4Address(\"192.168.2.2\"), udpEchoPort);\n\n        client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n        client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n        client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n        ApplicationContainer clientApp = client.Install(t2);\n        clientApp.Start(Seconds(0.5));\n        clientApp.Stop(Seconds(simDurationSeconds));\n    }\n\n    // ======================================================================\n    // Single-Switch UDP traffic generation\n    // ----------------------------------------------------------------------\n    if (enableUdpSingleSW)\n    {\n        // ------------------------------------------------------------------\n        // Install single-switch UDP echo server on t3\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Single-Switch UDP server (on node t3 of top LAN)\");\n\n        UdpEchoServerHelper server(udpEchoPort);\n\n        ApplicationContainer serverApp = server.Install(t3);\n        serverApp.Start(Seconds(0.5));\n        serverApp.Stop(Seconds(simDurationSeconds));\n\n        // ------------------------------------------------------------------\n        // Install single-switch UDP echo client on b3\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Single-Switch UDP client (on node b3 bottom LAN)\");\n\n        Time interPacketInterval = Seconds(0.005);\n        uint32_t packetSize = 1000;\n        uint32_t maxPacketCount = (simDurationSeconds - 2.0) / 0.005;\n\n        UdpEchoClientHelper client(Ipv4Address(\"192.168.1.3\"), udpEchoPort);\n\n        client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n        client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n        client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n        ApplicationContainer clientApp = client.Install(b3);\n        clientApp.Start(Seconds(0.5));\n        clientApp.Stop(Seconds(simDurationSeconds));\n    }\n\n    // ======================================================================\n    // Print routing tables at T=0.1\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    // NOTE: Node 0 and Node 13 must have non-empty tables (except for local\n    //       loopback and local LAN) if routing is operating correctly.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"Set up to print routing tables at T=0.1s\");\n\n    Ptr<OutputStreamWrapper> routingStream =\n        Create<OutputStreamWrapper>(\"global-routing-multi-switch-plus-router.routes\",\n                                    std::ios::out);\n\n    Ipv4RoutingHelper::PrintRoutingTableAllAt(Seconds(0.1), routingStream);\n\n    // ======================================================================\n    // Configure PCAP traces\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"Configure PCAP Tracing (if any configured).\");\n\n    // - - - - - - - - - - - - - -\n    // multi-switch UDP echo client\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"t2\", pcapLocationVec))\n    {\n        csmaX.EnablePcap(\"t2.pcap\", topLanIpDevices.Get(1), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // multi-switch UDP echo server\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"b2\", pcapLocationVec))\n    {\n        csmaY.EnablePcap(\"b2.pcap\", botLanIpDevices.Get(1), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // single-switch UDP echo client\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"b3\", pcapLocationVec))\n    {\n        csmaY.EnablePcap(\"b3.pcap\", botLanIpDevices.Get(2), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // single-switch UDP echo server\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"t3\", pcapLocationVec))\n    {\n        csmaX.EnablePcap(\"t3.pcap\", topLanIpDevices.Get(2), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // top router, LAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"trlan\", pcapLocationVec))\n    {\n        csmaY.EnablePcap(\"trlan.pcap\", topLanIpDevices.Get(0), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // bottom router, LAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"brlan\", pcapLocationVec))\n    {\n        csmaX.EnablePcap(\"brlan.pcap\", botLanIpDevices.Get(0), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // top router, WAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"trwan\", pcapLocationVec))\n    {\n        p2p.EnablePcap(\"trwan.pcap\", link_tr_br.Get(0), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // bottom router, WAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"brwan\", pcapLocationVec))\n    {\n        p2p.EnablePcap(\"brwan.pcap\", link_tr_br.Get(1), true, true);\n    }\n\n    // ======================================================================\n    // Now, do the actual simulation.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"Run Simulation for \" << simDurationSeconds << \" seconds.\");\n\n    Simulator::Stop(Seconds(simDurationSeconds));\n    Simulator::Run();\n\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate the \"count to infinity\" problem in a small network using Distance Vector (DV) routing in NS-3. The network consists of three routers (A, B, and C) connected in a triangle. Router A connects to router B, and router B connects to router C. Initially, all routers exchange routing information and establish routes. After a few seconds, the link between router B and router C is intentionally broken. Observe how routers A and C incorrectly continue to believe they can reach each other through the failed link and increment their hop counts until they reach the maximum hop count, simulating the \"count to infinity\" problem."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/distance-vector-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CountToInfinityDVExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create nodes: A, B, C\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Create point-to-point links\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create links between A-B, B-C, and A-C (triangle)\n    NetDeviceContainer ab = p2p.Install(NodeContainer(nodes.Get(0), nodes.Get(1))); // A-B\n    NetDeviceContainer bc = p2p.Install(NodeContainer(nodes.Get(1), nodes.Get(2))); // B-C\n    NetDeviceContainer ac = p2p.Install(NodeContainer(nodes.Get(0), nodes.Get(2))); // A-C\n\n    // Install the Internet stack on nodes\n    InternetStackHelper internet;\n    DistanceVectorHelper dvRouting;  // Use DV routing (simulating RIP)\n    internet.SetRoutingHelper(dvRouting);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer abIf = ipv4.Assign(ab);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer bcIf = ipv4.Assign(bc);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer acIf = ipv4.Assign(ac);\n\n    // Create UDP echo server on node C (destination)\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(2)); // C as server\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Create UDP echo client on node A (source)\n    UdpEchoClientHelper echoClient(bcIf.GetAddress(1), 9);  // Sending to C via B\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0)); // A as client\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Simulate link failure between B and C at t = 5s\n    Simulator::Schedule(Seconds(5.0), &NetDevice::SetLinkDown, bc.Get(1));\n    Simulator::Schedule(Seconds(5.0), &NetDevice::SetLinkDown, bc.Get(0));\n\n    // Enable pcap tracing\n    p2p.EnablePcapAll(\"count-to-infinity\");\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script for a three-node ad-hoc wireless network using the AODV routing protocol. The network should operate on 802.11g Wi-Fi. The nodes should be positioned in a straight line, 100 meters apart. The first node should send UDP packets to the third node, while the second node acts as a router. A UDP Echo server should run on Node 2 (port 9) starting at 1 second. The client on Node 0 should send 5 packets of 512 bytes at 2-second intervals, starting at 2 seconds. The simulation should run for 20 seconds. The IP network should be 10.1.1.x."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/aodv-helper.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocAodvExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create three nodes\n    NodeContainer adhocNodes;\n    adhocNodes.Create(3);\n\n    // Set up Wi-Fi for ad-hoc mode\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, adhocNodes);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(100.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(adhocNodes);\n\n    // Install AODV routing\n    AodvHelper aodv;\n    InternetStackHelper stack;\n    stack.SetRoutingHelper(aodv);\n    stack.Install(adhocNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a UDP Echo server on Node 2\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(adhocNodes.Get(2));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Set up a UDP Echo client on Node 0\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(2), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(2.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = echoClient.Install(adhocNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(20.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a hybrid network topology in ns-3 with 4 wired nodes and 3 wireless nodes. The wired nodes will be connected in a chain using point-to-point links. The wireless nodes will be connected via Wi-Fi, and one of the wired nodes will act as a gateway for the wireless network. Generate TCP traffic from the wireless nodes to the wired nodes, and enable pcap tracing to capture packet transmissions. At the end of the simulation, output the average throughput of the TCP flow."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"HybridNetworkTopology\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation parameters\n    double simulationTime = 10.0; // seconds\n\n    // Create wired nodes\n    NodeContainer wiredNodes;\n    wiredNodes.Create(4); // 4 wired nodes\n\n    // Create wireless nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(3); // 3 wireless nodes\n\n    NodeContainer wifiApNode = wiredNodes.Get(3); // Use one wired node as AP\n\n    // Create point-to-point connections between wired nodes\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer p2pDevices;\n    for (uint32_t i = 0; i < wiredNodes.GetN() - 1; ++i)\n    {\n        NetDeviceContainer link = p2p.Install(wiredNodes.Get(i), wiredNodes.Get(i + 1));\n        p2pDevices.Add(link);\n    }\n\n    // Set up Wi-Fi for wireless nodes\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    phy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(wiredNodes);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses to the wired network\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer wiredInterfaces = address.Assign(p2pDevices);\n\n    // Assign IP addresses to the wireless network\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer wifiInterfaces = address.Assign(staDevices);\n    address.Assign(apDevice);\n\n    // Set up mobility for wireless nodes\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Enable global routing to route between wired and wireless sections\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create TCP traffic from wireless nodes to wired nodes\n    uint16_t port = 9;\n    OnOffHelper onOffHelper(\"ns3::TcpSocketFactory\", Address());\n    onOffHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    onOffHelper.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"1Mbps\")));\n    onOffHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < wifiStaNodes.GetN(); ++i)\n    {\n        AddressValue remoteAddress(InetSocketAddress(wiredInterfaces.GetAddress(3), port));\n        onOffHelper.SetAttribute(\"Remote\", remoteAddress);\n        clientApps.Add(onOffHelper.Install(wifiStaNodes.Get(i)));\n    }\n\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(simulationTime));\n\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = packetSinkHelper.Install(wiredNodes.Get(3)); // Sink on last wired node\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Enable pcap tracing\n    p2p.EnablePcapAll(\"hybrid-topology\");\n    phy.EnablePcap(\"wifi-ap\", apDevice.Get(0));\n    phy.EnablePcap(\"wifi-sta\", staDevices.Get(0));\n\n    // Flow monitor to calculate throughput\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n\n    // Output the throughput\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    double totalThroughput = 0;\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        totalThroughput += i->second.rxBytes * 8.0 / simulationTime / 1000 / 1000; // in Mbps\n    }\n\n    NS_LOG_UNCOND(\"Average Throughput: \" << totalThroughput << \" Mbps\");\n\n    // Clean up\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a simple wired network using a point-to-point link with two nodes. The nodes should be connected with a 5 Mbps data rate and a 2 ms delay. Node 1 should act as a TCP server listening on port 9. Node 0 should act as a TCP client, sending 10 packets of 512 bytes to the server at intervals of 0.1 seconds. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpServerClientExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"TcpServerClientExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack (IP/TCP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Install a TCP server on node 1 (server side)\n    uint16_t port = 9;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Install a TCP client on node 0 (client side)\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Wi-Fi network where a Client (STA) and an Access Point (AP) communicate using TCP. The Client sends 10 TCP packets (of 1024 bytes) to the Access Point at a 1-second interval. The Access Point listens on port 9. The Client follows a random walk mobility model within a 100x100 m² area, while the Access Point remains stationary. Use IPv4 addressing within the 10.1.1.0/24 subnet."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiTcpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for Client and Server\n    NodeContainer wifiStaNode, wifiApNode;\n    wifiStaNode.Create(1); // Client (STA)\n    wifiApNode.Create(1);  // Access Point (AP)\n\n    // Install Wi-Fi devices on both the Client and AP\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ); // 802.11n standard\n\n    WifiMacHelper mac;\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-ssid\")));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNode);\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-ssid\")));\n    NetDeviceContainer apDevices = wifi.Install(phy, mac, wifiApNode);\n\n    // Set up the mobility model for the STA\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(wifiStaNode); // Install mobility on the STA node\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode); // Install stationary AP\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(wifiStaNode);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterfaces = address.Assign(apDevices);\n\n    // Set up TCP server on AP\n    TcpServerHelper tcpServer(9); // Listening on port 9\n    ApplicationContainer serverApp = tcpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on STA\n    TcpClientHelper tcpClient(apInterfaces.GetAddress(0), 9);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // 10 packets to send\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // 1 second interval\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // 1024 byte packets\n    ApplicationContainer clientApp = tcpClient.Install(wifiStaNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple sensor network in ns-3, where five sensor nodes are deployed in a star topology around a central sink node. The nodes communicate using a low-power wireless communication protocol such as 802.15.4. The sensor nodes periodically send data to the sink node via UDP. Measure packet delivery, latency, and throughput. Visualize the network using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"SimpleSensorNetwork\");\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable (\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n  LogComponentEnable (\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n  // Create 6 nodes (5 sensors + 1 sink)\n  NodeContainer sensorNodes;\n  sensorNodes.Create (5);\n  \n  NodeContainer sinkNode;\n  sinkNode.Create (1);\n\n  NodeContainer allNodes = NodeContainer (sensorNodes, sinkNode);\n\n  // Set up WiFi 802.15.4\n  WifiHelper wifi;\n  wifi.SetStandard (WIFI_PHY_STANDARD_80211_15_4);\n  \n  YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default ();\n  YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default ();\n  wifiPhy.SetChannel (wifiChannel.Create ());\n  \n  WifiMacHelper wifiMac;\n  wifiMac.SetType (\"ns3::AdhocWifiMac\");\n  \n  NetDeviceContainer devices = wifi.Install (wifiPhy, wifiMac, allNodes);\n\n  // Install Internet stack\n  InternetStackHelper stack;\n  stack.Install (allNodes);\n\n  // Assign IP addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  // Set up mobility model for sensor nodes (fixed positions)\n  MobilityHelper mobility;\n  Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();\n\n  // Position the sink node at the center\n  positionAlloc->Add (Vector (50.0, 50.0, 0.0));\n\n  // Position the sensor nodes around the sink in a star topology\n  positionAlloc->Add (Vector (100.0, 50.0, 0.0));  // Sensor 1\n  positionAlloc->Add (Vector (50.0, 100.0, 0.0));  // Sensor 2\n  positionAlloc->Add (Vector (0.0, 50.0, 0.0));    // Sensor 3\n  positionAlloc->Add (Vector (50.0, 0.0, 0.0));    // Sensor 4\n  positionAlloc->Add (Vector (75.0, 75.0, 0.0));   // Sensor 5\n\n  mobility.SetPositionAllocator (positionAlloc);\n  mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install (allNodes);\n\n  // Set up UDP communication between sensors and sink\n  UdpEchoServerHelper echoServer (9);  // Port 9 for sink node\n  ApplicationContainer serverApps = echoServer.Install (sinkNode.Get (0));\n  serverApps.Start (Seconds (1.0));\n  serverApps.Stop (Seconds (10.0));\n\n  UdpEchoClientHelper echoClient (interfaces.GetAddress (5), 9); // Sink address\n  echoClient.SetAttribute (\"MaxPackets\", UintegerValue (1));\n  echoClient.SetAttribute (\"Interval\", TimeValue (Seconds (1.0))); // Periodic data\n  echoClient.SetAttribute (\"PacketSize\", UintegerValue (1024)); // 1 KB data\n\n  // Install client applications on sensor nodes\n  ApplicationContainer clientApps;\n  for (uint32_t i = 0; i < sensorNodes.GetN (); ++i)\n    {\n      clientApps.Add (echoClient.Install (sensorNodes.Get (i)));\n    }\n  clientApps.Start (Seconds (2.0));\n  clientApps.Stop (Seconds (10.0));\n\n  // Set up FlowMonitor for measuring performance\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();\n\n  // Set up NetAnim for visualization\n  AnimationInterface anim (\"sensor-network.xml\");\n  anim.SetConstantPosition (sinkNode.Get (0), 50.0, 50.0);  // Sink at center\n  for (uint32_t i = 0; i < sensorNodes.GetN (); ++i)\n    {\n      anim.SetConstantPosition (sensorNodes.Get (i), positionAlloc->GetNext ());\n    }\n\n  Simulator::Stop (Seconds (10.0));\n  Simulator::Run ();\n\n  // FlowMonitor analysis\n  monitor->SerializeToXmlFile (\"sensor-network-flowmon.xml\", true, true);\n\n  Simulator::Destroy ();\n  return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a simple LTE network with one User Equipment (UE) and one evolved NodeB (eNB). The UE runs a UDP client on port 9, and the eNB runs a UDP server. The UE sends 1,000 UDP packets of 1024 bytes each, with a packet interval of 0.01 seconds. The simulation should run for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleLteExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleLteExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: UE (User Equipment) and eNB (evolved NodeB)\n    NodeContainer ueNodes, enbNodes;\n    ueNodes.Create(1);\n    enbNodes.Create(1);\n\n    // Set up LTE helper\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n\n    // Set up EPC helper (Evolved Packet Core)\n    Ptr<EpcHelper> epcHelper = CreateObject<EpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    // Set up the LTE network\n    NetDeviceContainer ueDevices, enbDevices;\n    ueDevices = lteHelper->InstallUeDevice(ueNodes);\n    enbDevices = lteHelper->InstallEnbDevice(enbNodes);\n\n    // Install the internet stack (IP, TCP, UDP)\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    internet.Install(enbNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface = ipv4.Assign(ueDevices);\n    Ipv4InterfaceContainer enbIpIface = ipv4.Assign(enbDevices);\n\n    // Attach the UE to the eNB\n    lteHelper->Attach(ueDevices.Get(0), enbDevices.Get(0));\n\n    // Set up UDP server on the eNB node (evolved NodeB)\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(enbNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the UE node (User Equipment)\n    UdpClientHelper udpClient(enbIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(ueNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ script using the ns-3 network simulator that configures two nodes with 802.11b physical layer in adhoc mode. One node generates on-off traffic destined for the other node. The script should allow for testing energy depletion of nodes, and trigger a callback when the node enters a sleep state due to energy depletion. The script should also include the ability to adjust transmission power and log remaining energy and state transitions to trace files. Include command-line options for configuring data rate, packet size, transmission power levels, and energy model parameters."}, {"role": "assistant", "content": "// This script configures two nodes on an 802.11b physical layer, with\n// 802.11b NICs in adhoc mode. One of the nodes generates on-off traffic\n// destined to the other node.\n//\n// The purpose is to test the energy depletion on the nodes and the\n// activation of the callback that puts a node in the sleep state when\n// its energy is depleted. Furthermore, this script can be used to test\n// the available policies for updating the transmit current based on\n// the nominal tx power used to transmit each frame.\n//\n// There are a number of command-line options available to control\n// the default behavior.  The list of available command-line options\n// can be listed with the following command:\n// ./ns3 run \"wifi-sleep --help\"\n//\n// Note that all ns-3 attributes (not just the ones exposed in the below\n// script) can be changed at command line; see the documentation.\n//\n// This script can also be helpful to put the Wifi layer into verbose\n// logging mode; this command will turn on all wifi logging:\n//\n// ./ns3 run \"wifi-sleep --verbose=1\"\n//\n// When you are done, you will notice four trace files in your directory:\n// two for the remaining energy on each node and two for the state transitions\n// of each node.\n\n#include \"ns3/basic-energy-source-helper.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/string.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/wifi-radio-energy-model-helper.h\"\n#include \"ns3/wifi-utils.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\nusing namespace ns3::energy;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSleep\");\n\n/**\n * Remaining energy trace sink\n *\n * \\tparam node The node ID this trace belongs to.\n * \\param oldValue Old value.\n * \\param newValue New value.\n */\ntemplate <int node>\nvoid\nRemainingEnergyTrace(double oldValue, double newValue)\n{\n    std::stringstream ss;\n    ss << \"energy_\" << node << \".log\";\n\n    static std::fstream f(ss.str(), std::ios::out);\n\n    f << Simulator::Now().GetSeconds() << \"    remaining energy=\" << newValue << std::endl;\n}\n\n/**\n * PHY state trace sink\n *\n * \\tparam node The node ID this trace belongs to.\n * \\param context The context\n * \\param start Start time for the current state\n * \\param duration Duratio of the current state\n * \\param state State\n */\ntemplate <int node>\nvoid\nPhyStateTrace(std::string context, Time start, Time duration, WifiPhyState state)\n{\n    std::stringstream ss;\n    ss << \"state_\" << node << \".log\";\n\n    static std::fstream f(ss.str(), std::ios::out);\n\n    f << Simulator::Now().GetSeconds() << \"    state=\" << state << \" start=\" << start\n      << \" duration=\" << duration << std::endl;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    DataRate dataRate{\"1Mb/s\"};\n    uint32_t packetSize{1000}; // bytes\n    Time duration{\"10s\"};\n    joule_u initialEnergy{7.5};\n    volt_u voltage{3.0};\n    dBm_u txPowerStart{0.0};\n    dBm_u txPowerEnd{15.0};\n    uint32_t nTxPowerLevels{16};\n    uint32_t txPowerLevel{0};\n    ampere_u idleCurrent{0.273};\n    ampere_u txCurrent{0.380};\n    bool verbose{false};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"dataRate\", \"Data rate\", dataRate);\n    cmd.AddValue(\"packetSize\", \"size of application packet sent\", packetSize);\n    cmd.AddValue(\"duration\", \"duration of the experiment\", duration);\n    cmd.AddValue(\"initialEnergy\", \"Initial Energy (Joule) of each node\", initialEnergy);\n    cmd.AddValue(\"voltage\", \"Supply voltage (Joule)\", voltage);\n    cmd.AddValue(\"txPowerStart\", \"Minimum available transmission level (dbm)\", txPowerStart);\n    cmd.AddValue(\"txPowerEnd\", \"Maximum available transmission level (dbm)\", txPowerEnd);\n    cmd.AddValue(\"nTxPowerLevels\",\n                 \"Number of transmission power levels available between txPowerStart and \"\n                 \"txPowerEnd included\",\n                 nTxPowerLevels);\n    cmd.AddValue(\"txPowerLevel\", \"Transmission power level\", txPowerLevel);\n    cmd.AddValue(\"idleCurrent\", \"The radio Idle current in Ampere\", idleCurrent);\n    cmd.AddValue(\"txCurrent\", \"The radio Tx current in Ampere\", txCurrent);\n    cmd.AddValue(\"verbose\", \"turn on all WifiNetDevice log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    NodeContainer c;\n    c.Create(2);\n\n    // The below set of helpers will help us to put together the wifi NICs we want\n    WifiHelper wifi;\n    if (verbose)\n    {\n        WifiHelper::EnableLogComponents(); // Turn on all Wifi logging\n    }\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.Set(\"TxPowerStart\", DoubleValue(txPowerStart));\n    wifiPhy.Set(\"TxPowerEnd\", DoubleValue(txPowerEnd));\n    wifiPhy.Set(\"TxPowerLevels\", UintegerValue(nTxPowerLevels));\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Add a mac and set the selected tx power level\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ArfWifiManager\",\n                                 \"DefaultTxPowerLevel\",\n                                 UintegerValue(txPowerLevel));\n    // Set it to adhoc mode\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, c);\n\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(10.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    Ipv4AddressHelper ipv4;\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    ApplicationContainer apps;\n\n    std::string transportProto = std::string(\"ns3::UdpSocketFactory\");\n    OnOffHelper onOff(transportProto, InetSocketAddress(Ipv4Address(\"10.1.1.2\"), 9000));\n\n    onOff.SetAttribute(\"DataRate\", DataRateValue(DataRate(dataRate)));\n    onOff.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n    onOff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0.001]\"));\n\n    apps = onOff.Install(c.Get(0));\n\n    apps.Start(Seconds(0.01));\n    apps.Stop(duration);\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(transportProto, InetSocketAddress(Ipv4Address::GetAny(), 9001));\n    apps = sink.Install(c.Get(1));\n    apps.Start(Seconds(0.01));\n    apps.Stop(duration);\n\n    // Energy sources\n    EnergySourceContainer eSources;\n    BasicEnergySourceHelper basicSourceHelper;\n    WifiRadioEnergyModelHelper radioEnergyHelper;\n\n    basicSourceHelper.Set(\"BasicEnergySourceInitialEnergyJ\", DoubleValue(initialEnergy));\n    basicSourceHelper.Set(\"BasicEnergySupplyVoltageV\", DoubleValue(voltage));\n\n    radioEnergyHelper.Set(\"IdleCurrentA\", DoubleValue(idleCurrent));\n    radioEnergyHelper.Set(\"TxCurrentA\", DoubleValue(txCurrent));\n\n    // compute the efficiency of the power amplifier (eta) assuming that the provided value for tx\n    // current corresponds to the minimum tx power level\n    double eta = DbmToW(txPowerStart) / ((txCurrent - idleCurrent) * voltage);\n\n    radioEnergyHelper.SetTxCurrentModel(\"ns3::LinearWifiTxCurrentModel\",\n                                        \"Voltage\",\n                                        DoubleValue(voltage),\n                                        \"IdleCurrent\",\n                                        DoubleValue(idleCurrent),\n                                        \"Eta\",\n                                        DoubleValue(eta));\n\n    // install an energy source on each node\n    for (auto n = c.Begin(); n != c.End(); n++)\n    {\n        eSources.Add(basicSourceHelper.Install(*n));\n\n        Ptr<WifiNetDevice> wnd;\n\n        for (uint32_t i = 0; i < (*n)->GetNDevices(); ++i)\n        {\n            wnd = (*n)->GetDevice(i)->GetObject<WifiNetDevice>();\n            // if it is a WifiNetDevice\n            if (wnd)\n            {\n                // this device draws power from the last created energy source\n                radioEnergyHelper.Install(wnd, eSources.Get(eSources.GetN() - 1));\n            }\n        }\n    }\n\n    // Tracing\n    eSources.Get(0)->TraceConnectWithoutContext(\"RemainingEnergy\",\n                                                MakeCallback(&RemainingEnergyTrace<0>));\n    eSources.Get(1)->TraceConnectWithoutContext(\"RemainingEnergy\",\n                                                MakeCallback(&RemainingEnergyTrace<1>));\n\n    Config::Connect(\"/NodeList/0/DeviceList/*/Phy/State/State\", MakeCallback(&PhyStateTrace<0>));\n    Config::Connect(\"/NodeList/1/DeviceList/*/Phy/State/State\", MakeCallback(&PhyStateTrace<1>));\n\n    Simulator::Stop(duration + Seconds(1.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate the two-node loop problem in a network using Distance Vector (DV) routing in NS-3. The network consists of two nodes (A and B) connected to each other. Initially, the routing tables converge, and A and B can forward traffic to a common destination. After a few seconds, the network is altered to simulate a failure, and A and B begin to incorrectly forward packets to each other, creating a loop. Observe how packets circulate between A and B, demonstrating the two-node loop problem in Distance Vector routing."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/distance-vector-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TwoNodeLoopDVExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create nodes: A, B\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Create point-to-point link between A and B\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer ab = p2p.Install(nodes);\n\n    // Install the Internet stack on nodes\n    InternetStackHelper internet;\n    DistanceVectorHelper dvRouting;  // Use DV routing (simulating RIP)\n    internet.SetRoutingHelper(dvRouting);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer abIf = ipv4.Assign(ab);\n\n    // Create UDP echo server on node B\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(1)); // B as server\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Create UDP echo client on node A\n    UdpEchoClientHelper echoClient(abIf.GetAddress(1), 9);  // Sending to B\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0)); // A as client\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Simulate link failure between A and B at t = 5s\n    Simulator::Schedule(Seconds(5.0), &NetDevice::SetLinkDown, ab.Get(1));\n    Simulator::Schedule(Seconds(5.0), &NetDevice::SetLinkDown, ab.Get(0));\n\n    // Re-enable link after 8s to simulate routing loop\n    Simulator::Schedule(Seconds(8.0), &NetDevice::SetLinkUp, ab.Get(1));\n    Simulator::Schedule(Seconds(8.0), &NetDevice::SetLinkUp, ab.Get(0));\n\n    // Enable pcap tracing\n    p2p.EnablePcapAll(\"two-node-loop\");\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and organizes them in a ring topology. The program should connect each node sequentially using Point-to-Point links and ensure that the last node connects back to the first node, forming a closed-loop structure. The program should then print confirmation of the established connections. Keep the example simple, focusing only on node creation and topology setup."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"RingTopologyExample\", LOG_LEVEL_INFO);\n\n    // Define the number of nodes in the ring\n    uint32_t numNodes = 4;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(numNodes);\n\n    // Point-to-Point Helper\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create links between consecutive nodes\n    for (uint32_t i = 0; i < numNodes; ++i) {\n        uint32_t nextNode = (i + 1) % numNodes; // Connect last node to first\n        NodeContainer link(nodes.Get(i), nodes.Get(nextNode));\n        NetDeviceContainer devices = p2p.Install(link);\n        NS_LOG_INFO(\"Connected Node \" << i << \" to Node \" << nextNode);\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 simulation library to model a network topology featuring two nodes (n0 and n1) connected via a router (R) over a CSMA channel. Configure the router to send Router Advertisements (RAs) to n0's subnet with two prefixes: 2001:1::/64 and 2001:ABCD::/64, ensuring that the R interface to n0 has both addresses assigned. Additionally, configure the router to send RAs to n1's subnet (2001:2::/64). Implement a Ping application where n0 sends ICMPv6 echo requests to n1. Incorporate tracing of queues and packet receptions, saving the output to a file named 'radvd-two-prefix.tr'. Include appropriate logging and IP address printing functionality within the simulation."}, {"role": "assistant", "content": "// Network topology\n// //\n// //             n0   R    n1\n// //             |    _    |\n// //             ====|_|====\n// //                router\n// // - R sends RA to n0's subnet (2001:1::/64 and 2001:ABCD::/64);\n// // - R interface to n0 has two addresses with following prefixes 2001:1::/64 and 2001:ABCD::/64;\n// // - R sends RA to n1's subnet (2001:2::/64);\n// // - n0 ping n1.\n// //\n// // - Tracing of queues and packet receptions to file \"radvd-two-prefix.tr\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n#include \"ns3/radvd-interface.h\"\n#include \"ns3/radvd-prefix.h\"\n#include \"ns3/radvd.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RadvdTwoPrefixExample\");\n\n/**\n * \\class IpAddressHelper\n * \\brief Helper to print a node's IP addresses.\n */\nclass IpAddressHelper\n{\n  public:\n    /**\n     * \\brief Print the node's IP addresses.\n     * \\param n the node\n     */\n    inline void PrintIpAddresses(Ptr<Node>& n)\n    {\n        Ptr<Ipv6> ipv6 = n->GetObject<Ipv6>();\n        uint32_t nInterfaces = ipv6->GetNInterfaces();\n\n        std::cout << \"Node: \" << ipv6->GetObject<Node>()->GetId()\n                  << \" Time: \" << Simulator::Now().GetSeconds() << \"s \"\n                  << \"IPv6 addresses\" << std::endl;\n        std::cout << \"(Interface index, Address index)\\t\"\n                  << \"IPv6 Address\" << std::endl;\n\n        for (uint32_t i = 0; i < nInterfaces; i++)\n        {\n            for (uint32_t j = 0; j < ipv6->GetNAddresses(i); j++)\n            {\n                std::cout << \"(\" << int(i) << \",\" << int(j) << \")\\t\" << ipv6->GetAddress(i, j)\n                          << std::endl;\n            }\n        }\n        std::cout << std::endl;\n    }\n};\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6RawSocketImpl\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"RadvdApplication\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ping\", LOG_LEVEL_ALL);\n    }\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> n0 = CreateObject<Node>();\n    Ptr<Node> r = CreateObject<Node>();\n    Ptr<Node> n1 = CreateObject<Node>();\n\n    NodeContainer net1(n0, r);\n    NodeContainer net2(r, n1);\n    NodeContainer all(n0, r, n1);\n\n    NS_LOG_INFO(\"Create IPv6 Internet Stack\");\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d1 = csma.Install(net1); /* n0 - R */\n    NetDeviceContainer d2 = csma.Install(net2); /* R - n1 */\n\n    NS_LOG_INFO(\"Create networks and assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n\n    /* first subnet */\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    NetDeviceContainer tmp;\n    tmp.Add(d1.Get(0));                                           /* n0 */\n    Ipv6InterfaceContainer iic1 = ipv6.AssignWithoutAddress(tmp); /* n0 interface */\n\n    NetDeviceContainer tmp2;\n    tmp2.Add(d1.Get(1)); /* R */\n    Ipv6InterfaceContainer iicr1 =\n        ipv6.Assign(tmp2); /* R interface to the first subnet is just statically assigned */\n    iicr1.SetForwarding(0, true);\n    iic1.Add(iicr1);\n\n    /* add another IPv6 address for second prefix advertised on first subnet */\n    ipv6.SetBase(Ipv6Address(\"2001:ABCD::\"), Ipv6Prefix(64));\n    ipv6.Assign(tmp2);\n\n    /* second subnet R - n1 */\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    NetDeviceContainer tmp3;\n    tmp3.Add(d2.Get(0));                              /* R */\n    Ipv6InterfaceContainer iicr2 = ipv6.Assign(tmp3); /* R interface */\n    iicr2.SetForwarding(0, true);\n\n    NetDeviceContainer tmp4;\n    tmp4.Add(d2.Get(1)); /* n1 */\n    Ipv6InterfaceContainer iic2 = ipv6.AssignWithoutAddress(tmp4);\n    iic2.Add(iicr2);\n\n    /* radvd configuration */\n    RadvdHelper radvdHelper;\n    /* R interface (n0 - R) */\n    radvdHelper.AddAnnouncedPrefix(iic1.GetInterfaceIndex(1), Ipv6Address(\"2001:ABCD::0\"), 64);\n    radvdHelper.AddAnnouncedPrefix(iic1.GetInterfaceIndex(1), Ipv6Address(\"2001:1::0\"), 64);\n\n    // Set some non-standard timers so the simulation is not taking ages\n    Ptr<RadvdInterface> routerInterface = radvdHelper.GetRadvdInterface(iic1.GetInterfaceIndex(1));\n    routerInterface->SetMaxRtrAdvInterval(2000);\n    routerInterface->SetMinRtrAdvInterval(1000);\n    RadvdInterface::RadvdPrefixList prefixList = routerInterface->GetPrefixes();\n    for (auto iter = prefixList.begin(); iter != prefixList.end(); iter++)\n    {\n        (*iter)->SetPreferredLifeTime(3);\n        (*iter)->SetValidLifeTime(5);\n    }\n\n    /* R interface (R - n1) */\n    radvdHelper.AddAnnouncedPrefix(iic2.GetInterfaceIndex(1), Ipv6Address(\"2001:2::0\"), 64);\n\n    // Set some non-standard timers so the simulation is not taking ages\n    routerInterface = radvdHelper.GetRadvdInterface(iic2.GetInterfaceIndex(1));\n    routerInterface->SetMaxRtrAdvInterval(2000);\n    routerInterface->SetMinRtrAdvInterval(1000);\n    prefixList = routerInterface->GetPrefixes();\n    for (auto iter = prefixList.begin(); iter != prefixList.end(); iter++)\n    {\n        (*iter)->SetPreferredLifeTime(3);\n        (*iter)->SetValidLifeTime(5);\n    }\n\n    ApplicationContainer radvdApps = radvdHelper.Install(r);\n    radvdApps.Start(Seconds(1.0));\n    radvdApps.Stop(Seconds(2.0));\n\n    /* Create a Ping application to send ICMPv6 echo request from n0 to n1 via R */\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 8;\n    PingHelper ping(\n        Ipv6Address(\"2001:2::200:ff:fe00:4\")); /* should be n1 address after autoconfiguration */\n    // ping.SetIfIndex(iic1.GetInterfaceIndex(0));\n\n    ping.SetAttribute(\"Count\", UintegerValue(maxPacketCount));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    ApplicationContainer apps = ping.Install(net1.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(5.0));\n\n    Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);\n    Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(2.0), n0, routingStream);\n    Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(10.0), n0, routingStream);\n\n    IpAddressHelper ipAddressHelper;\n    /* RA should be received, two prefixes + routes + default route should be present */\n    Simulator::Schedule(Seconds(2.0), &IpAddressHelper::PrintIpAddresses, &ipAddressHelper, n0);\n    /* at the end, RA addresses and routes should be cleared */\n    Simulator::Schedule(Seconds(10.0), &IpAddressHelper::PrintIpAddresses, &ipAddressHelper, n0);\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"radvd-two-prefix.tr\"));\n    csma.EnablePcapAll(std::string(\"radvd-two-prefix\"), true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a TCP connection between two nodes using a point-to-point link. The client sends data to the server, and the Round-Trip Time (RTT) is measured and logged during the communication. The point-to-point link has a data rate of 5 Mbps and a delay of 10 ms. The server starts at 1 second, and the client starts at 2 seconds. The simulation runs for 10 seconds, and the RTT value should be printed during the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-routing-helper.h\"\n#include \"ns3/tcp-header.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpRttExample\");\n\nvoid TraceRtt(Ptr<const TcpSocketState> state)\n{\n    // Print the RTT value\n    Time rtt = state->m_rtt;\n    NS_LOG_INFO(\"RTT: \" << rtt.GetSeconds() << \" seconds\");\n}\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"TcpRttExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link between nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install internet stack (IP, TCP, etc.)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfaces = ipv4.Assign(devices);\n\n    // Set up TCP server on node 1\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on node 0\n    TcpClientHelper tcpClient(ipInterfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Trace RTT for TCP connection\n    Config::Connect(\"/NodeList/0/DeviceList/0/$ns3::PointToPointNetDevice/TxQueue/Enqueue\", MakeCallback(&TraceRtt));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate an ad-hoc wireless network using ns-3 with the AODV routing protocol. Create 10 mobile nodes that move randomly within a 500m x 500m area. Simulate UDP traffic between nodes, starting at random times, and run the simulation for 30 seconds. Use pcap tracing to capture the packet transmissions. Measure and display the packet delivery ratio (PDR) and average end-to-end delay at the end of the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocAodvExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation parameters\n    double simulationTime = 30.0; // seconds\n    uint32_t numNodes = 10;\n    double txPower = 16.0; // dBm\n    double nodeSpeed = 20.0; // m/s (random speed for mobility)\n\n    // Create nodes\n    NodeContainer adhocNodes;\n    adhocNodes.Create(numNodes);\n\n    // Set up Wi-Fi for ad-hoc network\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.Set(\"TxPowerStart\", DoubleValue(txPower));\n    phy.Set(\"TxPowerEnd\", DoubleValue(txPower));\n\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::RangePropagationLossModel\", \"MaxRange\", DoubleValue(100.0));\n    phy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, adhocNodes);\n\n    // Set up mobility\n    MobilityHelper mobility;\n    Ptr<UniformRandomVariable> speed = CreateObject<UniformRandomVariable>();\n    speed->SetAttribute(\"Min\", DoubleValue(0.0));\n    speed->SetAttribute(\"Max\", DoubleValue(nodeSpeed));\n\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", PointerValue(speed),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=2.0]\"),\n                              \"PositionAllocator\", StringValue(\"ns3::RandomRectanglePositionAllocator\"),\n                              \"X\", DoubleValue(500.0), // Area of 500x500 meters\n                              \"Y\", DoubleValue(500.0));\n\n    mobility.Install(adhocNodes);\n\n    // Install internet stack and AODV routing protocol\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv); // AODV as the routing protocol\n    internet.Install(adhocNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP traffic: a UdpEchoServer on one node and a UdpEchoClient on another\n    uint16_t port = 9;\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApp = echoServer.Install(adhocNodes.Get(0)); // Server on node 0\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(0), port); // Client to node 0\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(adhocNodes.Get(numNodes - 1)); // Client on last node\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Enable pcap tracing\n    phy.EnablePcapAll(\"aodv-adhoc\");\n\n    // Install FlowMonitor for traffic statistics\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n\n    // Output flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    uint32_t sentPackets = 0;\n    uint32_t receivedPackets = 0;\n    double delaySum = 0.0;\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        sentPackets += i->second.txPackets;\n        receivedPackets += i->second.rxPackets;\n        delaySum += i->second.delaySum.GetSeconds();\n    }\n\n    double pdr = double(receivedPackets) / sentPackets * 100;\n    double averageDelay = delaySum / receivedPackets;\n\n    NS_LOG_UNCOND(\"Packet Delivery Ratio: \" << pdr << \"%\");\n    NS_LOG_UNCOND(\"Average End-to-End Delay: \" << averageDelay << \" s\");\n\n    // Clean up\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate NS-3 code that sets up a Wi-Fi network simulation with four independent networks, each consisting of one access point and one station working on different channels (36, 40, 44, 48). Configure each station to continuously transmit data packets to its respective AP with varying aggregation settings: station A should use default aggregation with A-MSDU disabled and A-MPDU enabled at 65 KB, station B should have both A-MPDU and A-MSDU disabled, station C should enable A-MSDU with 8 KB and disable A-MPDU, and station D should use two-level aggregation with A-MPDU at 32 KB and A-MSDU at 4 KB. Include command line options to modify payload size, simulation time, distance between stations and APs, and enable or disable RTS/CTS."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/wifi-mac.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This is an example that illustrates how 802.11n aggregation is configured.\n// It defines 4 independent Wi-Fi networks (working on different channels).\n// Each network contains one access point and one station. Each station\n// continuously transmits data packets to its respective AP.\n//\n// Network topology (numbers in parentheses are channel numbers):\n//\n//  Network A (36)   Network B (40)   Network C (44)   Network D (48)\n//   *      *          *      *         *      *          *      *\n//   |      |          |      |         |      |          |      |\n//  AP A   STA A      AP B   STA B     AP C   STA C      AP D   STA D\n//\n// The aggregation parameters are configured differently on the 4 stations:\n// - station A uses default aggregation parameter values (A-MSDU disabled, A-MPDU enabled with\n// maximum size of 65 kB);\n// - station B doesn't use aggregation (both A-MPDU and A-MSDU are disabled);\n// - station C enables A-MSDU (with maximum size of 8 kB) but disables A-MPDU;\n// - station D uses two-level aggregation (A-MPDU with maximum size of 32 kB and A-MSDU with maximum\n// size of 4 kB).\n//\n// Packets in this simulation belong to BestEffort Access Class (AC_BE).\n//\n// The user can select the distance between the stations and the APs and can enable/disable the\n// RTS/CTS mechanism. Example: ./ns3 run \"wifi-aggregation --distance=10 --enableRts=0\n// --simulationTime=20s\"\n//\n// The output prints the throughput measured for the 4 cases/networks described above. When default\n// aggregation parameters are enabled, the maximum A-MPDU size is 65 kB and the throughput is\n// maximal. When aggregation is disabled, the throughput is about the half of the physical bitrate.\n// When only A-MSDU is enabled, the throughput is increased but is not maximal, since the maximum\n// A-MSDU size is limited to 7935 bytes (whereas the maximum A-MPDU size is limited to 65535 bytes).\n// When A-MSDU and A-MPDU are both enabled (= two-level aggregation), the throughput is slightly\n// smaller than the first scenario since we set a smaller maximum A-MPDU size.\n//\n// When the distance is increased, the frame error rate gets higher, and the output shows how it\n// affects the throughput for the 4 networks. Even through A-MSDU has less overheads than A-MPDU,\n// A-MSDU is less robust against transmission errors than A-MPDU. When the distance is augmented,\n// the throughput for the third scenario is more affected than the throughput obtained in other\n// networks.\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleMpduAggregation\");\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t payloadSize{1472}; // bytes\n    Time simulationTime{\"10s\"};\n    meter_u distance{5};\n    bool enableRts{false};\n    bool enablePcap{false};\n    bool verifyResults{false}; // used for regression\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"payloadSize\", \"Payload size in bytes\", payloadSize);\n    cmd.AddValue(\"enableRts\", \"Enable or disable RTS/CTS\", enableRts);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the station and the access point\",\n                 distance);\n    cmd.AddValue(\"enablePcap\", \"Enable/disable pcap file generation\", enablePcap);\n    cmd.AddValue(\"verifyResults\",\n                 \"Enable/disable results verification at the end of the simulation\",\n                 verifyResults);\n    cmd.Parse(argc, argv);\n\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\",\n                       enableRts ? StringValue(\"0\") : StringValue(\"999999\"));\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(4);\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(4);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"HtMcs7\"),\n                                 \"ControlMode\",\n                                 StringValue(\"HtMcs0\"));\n    WifiMacHelper mac;\n\n    NetDeviceContainer staDeviceA;\n    NetDeviceContainer staDeviceB;\n    NetDeviceContainer staDeviceC;\n    NetDeviceContainer staDeviceD;\n    NetDeviceContainer apDeviceA;\n    NetDeviceContainer apDeviceB;\n    NetDeviceContainer apDeviceC;\n    NetDeviceContainer apDeviceD;\n    Ssid ssid;\n\n    // Network A\n    ssid = Ssid(\"network-A\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{36, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    staDeviceA = wifi.Install(phy, mac, wifiStaNodes.Get(0));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceA = wifi.Install(phy, mac, wifiApNodes.Get(0));\n\n    // Network B\n    ssid = Ssid(\"network-B\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{40, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    staDeviceB = wifi.Install(phy, mac, wifiStaNodes.Get(1));\n\n    // Disable A-MPDU\n    Ptr<NetDevice> dev = wifiStaNodes.Get(1)->GetDevice(0);\n    Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceB = wifi.Install(phy, mac, wifiApNodes.Get(1));\n\n    // Disable A-MPDU\n    dev = wifiApNodes.Get(1)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n\n    // Network C\n    ssid = Ssid(\"network-C\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{44, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    staDeviceC = wifi.Install(phy, mac, wifiStaNodes.Get(2));\n\n    // Disable A-MPDU and enable A-MSDU with the highest maximum size allowed by the standard (7935\n    // bytes)\n    dev = wifiStaNodes.Get(2)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(7935));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceC = wifi.Install(phy, mac, wifiApNodes.Get(2));\n\n    // Disable A-MPDU and enable A-MSDU with the highest maximum size allowed by the standard (7935\n    // bytes)\n    dev = wifiApNodes.Get(2)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(7935));\n\n    // Network D\n    ssid = Ssid(\"network-D\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{48, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    staDeviceD = wifi.Install(phy, mac, wifiStaNodes.Get(3));\n\n    // Enable A-MPDU with a smaller size than the default one and\n    // enable A-MSDU with the smallest maximum size allowed by the standard (3839 bytes)\n    dev = wifiStaNodes.Get(3)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(32768));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(3839));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceD = wifi.Install(phy, mac, wifiApNodes.Get(3));\n\n    // Enable A-MPDU with a smaller size than the default one and\n    // enable A-MSDU with the smallest maximum size allowed by the standard (3839 bytes)\n    dev = wifiApNodes.Get(3)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(32768));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(3839));\n\n    // Setting mobility model\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    // Set position for APs\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(10.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(20.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(30.0, 0.0, 0.0));\n    // Set position for STAs\n    positionAlloc->Add(Vector(distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(10 + distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(20 + distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(30 + distance, 0.0, 0.0));\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(wifiApNodes);\n    mobility.Install(wifiStaNodes);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceA;\n    StaInterfaceA = address.Assign(staDeviceA);\n    Ipv4InterfaceContainer ApInterfaceA;\n    ApInterfaceA = address.Assign(apDeviceA);\n\n    address.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceB;\n    StaInterfaceB = address.Assign(staDeviceB);\n    Ipv4InterfaceContainer ApInterfaceB;\n    ApInterfaceB = address.Assign(apDeviceB);\n\n    address.SetBase(\"192.168.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceC;\n    StaInterfaceC = address.Assign(staDeviceC);\n    Ipv4InterfaceContainer ApInterfaceC;\n    ApInterfaceC = address.Assign(apDeviceC);\n\n    address.SetBase(\"192.168.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceD;\n    StaInterfaceD = address.Assign(staDeviceD);\n    Ipv4InterfaceContainer ApInterfaceD;\n    ApInterfaceD = address.Assign(apDeviceD);\n\n    // Setting applications\n    uint16_t port = 9;\n    UdpServerHelper serverA(port);\n    ApplicationContainer serverAppA = serverA.Install(wifiStaNodes.Get(0));\n    serverAppA.Start(Seconds(0.0));\n    serverAppA.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientA(StaInterfaceA.GetAddress(0), port);\n    clientA.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientA.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientA.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppA = clientA.Install(wifiApNodes.Get(0));\n    clientAppA.Start(Seconds(1.0));\n    clientAppA.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverB(port);\n    ApplicationContainer serverAppB = serverB.Install(wifiStaNodes.Get(1));\n    serverAppB.Start(Seconds(0.0));\n    serverAppB.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientB(StaInterfaceB.GetAddress(0), port);\n    clientB.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientB.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientB.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppB = clientB.Install(wifiApNodes.Get(1));\n    clientAppB.Start(Seconds(1.0));\n    clientAppB.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverC(port);\n    ApplicationContainer serverAppC = serverC.Install(wifiStaNodes.Get(2));\n    serverAppC.Start(Seconds(0.0));\n    serverAppC.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientC(StaInterfaceC.GetAddress(0), port);\n    clientC.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientC.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientC.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppC = clientC.Install(wifiApNodes.Get(2));\n    clientAppC.Start(Seconds(1.0));\n    clientAppC.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverD(port);\n    ApplicationContainer serverAppD = serverD.Install(wifiStaNodes.Get(3));\n    serverAppD.Start(Seconds(0.0));\n    serverAppD.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientD(StaInterfaceD.GetAddress(0), port);\n    clientD.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientD.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientD.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppD = clientD.Install(wifiApNodes.Get(3));\n    clientAppD.Start(Seconds(1.0));\n    clientAppD.Stop(simulationTime + Seconds(1.0));\n\n    if (enablePcap)\n    {\n        phy.EnablePcap(\"AP_A\", apDeviceA.Get(0));\n        phy.EnablePcap(\"STA_A\", staDeviceA.Get(0));\n        phy.EnablePcap(\"AP_B\", apDeviceB.Get(0));\n        phy.EnablePcap(\"STA_B\", staDeviceB.Get(0));\n        phy.EnablePcap(\"AP_C\", apDeviceC.Get(0));\n        phy.EnablePcap(\"STA_C\", staDeviceC.Get(0));\n        phy.EnablePcap(\"AP_D\", apDeviceD.Get(0));\n        phy.EnablePcap(\"STA_D\", staDeviceD.Get(0));\n    }\n\n    Simulator::Stop(simulationTime + Seconds(1.0));\n    Simulator::Run();\n\n    // Show results\n    double totalPacketsThroughA = DynamicCast<UdpServer>(serverAppA.Get(0))->GetReceived();\n    double totalPacketsThroughB = DynamicCast<UdpServer>(serverAppB.Get(0))->GetReceived();\n    double totalPacketsThroughC = DynamicCast<UdpServer>(serverAppC.Get(0))->GetReceived();\n    double totalPacketsThroughD = DynamicCast<UdpServer>(serverAppD.Get(0))->GetReceived();\n\n    Simulator::Destroy();\n\n    auto throughput = totalPacketsThroughA * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Throughput with default configuration (A-MPDU aggregation enabled, 65kB): \"\n              << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 59.0 || throughput > 60.0))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    throughput = totalPacketsThroughB * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Throughput with aggregation disabled: \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 30 || throughput > 31))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    throughput = totalPacketsThroughC * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Throughput with A-MPDU disabled and A-MSDU enabled (8kB): \" << throughput\n              << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 51 || throughput > 52))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    throughput = totalPacketsThroughD * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Throughput with A-MPDU enabled (32kB) and A-MSDU enabled (4kB): \" << throughput\n              << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 58 || throughput > 59))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that models a hybrid topology combining a **star topology** and a **bus topology**. In the star topology, a central node (Node 0) is connected to three peripheral nodes (Nodes 1, 2, and 3) using point-to-point links. In the bus topology, three nodes (Nodes 4, 5, and 6) are connected sequentially with point-to-point links. Install the **Internet stack** on all nodes and assign appropriate **IP addresses**. Deploy a **UDP echo server** on Node 0 (central node in the star topology) and **UDP echo clients** on Nodes 4 and 5 from the bus topology. Use **FlowMonitor** to track performance metrics such as packet loss and delay, and run the simulation for 20 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"HybridTopologyExample\");\n\nint main (int argc, char *argv[])\n{\n    // Enable logging for simulation\n    LogComponentEnable(\"HybridTopologyExample\", LOG_LEVEL_INFO);\n\n    // Node containers for star topology and bus topology\n    NodeContainer starNodes;\n    starNodes.Create(4); // Star: 1 central node + 3 peripheral nodes\n\n    NodeContainer busNodes;\n    busNodes.Create(3);  // Bus: 3 nodes in bus topology\n\n    // Point-to-Point helper for both star and bus\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Central node connected to 3 peripheral nodes in star topology\n    NetDeviceContainer starDevices;\n    for (uint32_t i = 1; i < starNodes.GetN(); i++)\n    {\n        starDevices.Add(p2p.Install(starNodes.Get(0), starNodes.Get(i)));\n    }\n\n    // Bus topology connecting 3 nodes in sequence\n    NetDeviceContainer busDevices;\n    busDevices.Add(p2p.Install(busNodes.Get(0), busNodes.Get(1)));\n    busDevices.Add(p2p.Install(busNodes.Get(1), busNodes.Get(2)));\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper internet;\n    internet.Install(starNodes);\n    internet.Install(busNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(starDevices);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    ipv4.Assign(busDevices);\n\n    // Set up UDP echo server on node 0 (central node in star)\n    UdpEchoServerHelper echoServer(9); // Port 9\n    ApplicationContainer serverApp = echoServer.Install(starNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Set up UDP echo clients on nodes 4 and 5 (from bus topology)\n    UdpEchoClientHelper echoClient(starNodes.Get(0)->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal(), 9); // Talk to the server\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps;\n    clientApps.Add(echoClient.Install(busNodes.Get(0))); // Client on bus node 4\n    clientApps.Add(echoClient.Install(busNodes.Get(1))); // Client on bus node 5\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(20.0));\n\n    // Enable routing tables\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Enable FlowMonitor to collect statistics\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(20.0));\n    Simulator::Run();\n\n    // Print flow monitor statistics\n    monitor->CheckForLostPackets();\n    monitor->SerializeToXmlFile(\"hybrid-topology.flowmon\", true, true);\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless network using ns-3 with two Wi-Fi access points (APs) and a group of 6 mobile nodes. The nodes move randomly within a designated area and switch between the two APs based on signal strength. Use the RandomWalk2dMobilityModel to model the movement of nodes and visualize the network in NetAnim. Measure handover events and packet loss as nodes switch between APs."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiHandoverExample\");\n\nint main(int argc, char *argv[])\n{\n  LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n  LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n  // Create 2 AP nodes and 6 mobile nodes\n  NodeContainer wifiApNodes;\n  wifiApNodes.Create(2);\n\n  NodeContainer wifiStaNodes;\n  wifiStaNodes.Create(6);\n\n  // Set up Wi-Fi PHY and channel\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n  YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n  phy.SetChannel(channel.Create());\n\n  // Set up Wi-Fi\n  WifiHelper wifi;\n  wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n  WifiMacHelper mac;\n  Ssid ssid = Ssid(\"HandoverNetwork\");\n\n  // Access Point setup\n  mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n  NetDeviceContainer apDevices = wifi.Install(phy, mac, wifiApNodes);\n\n  // Station (Mobile) setup\n  mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n  NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n  // Install Internet stack\n  InternetStackHelper stack;\n  stack.Install(wifiApNodes);\n  stack.Install(wifiStaNodes);\n\n  // Assign IP addresses\n  Ipv4AddressHelper address;\n  address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer apInterfaces = address.Assign(apDevices);\n  Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n\n  // Mobility model for APs (static)\n  MobilityHelper mobility;\n  mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install(wifiApNodes);\n\n  // Mobility model for stations (random movement)\n  MobilityHelper mobilitySta;\n  mobilitySta.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                               \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n  mobilitySta.Install(wifiStaNodes);\n\n  // Set up UDP echo server on one of the AP nodes\n  UdpEchoServerHelper echoServer(9);\n  ApplicationContainer serverApps = echoServer.Install(wifiApNodes.Get(0));\n  serverApps.Start(Seconds(1.0));\n  serverApps.Stop(Seconds(20.0));\n\n  // Set up UDP echo clients on the mobile nodes\n  UdpEchoClientHelper echoClient(apInterfaces.GetAddress(0), 9);\n  echoClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n  echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n  echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n  ApplicationContainer clientApps = echoClient.Install(wifiStaNodes);\n  clientApps.Start(Seconds(2.0));\n  clientApps.Stop(Seconds(20.0));\n\n  // Enable Flow Monitor to measure performance\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n  // Set up NetAnim for visualization\n  AnimationInterface anim(\"wifi-handover.xml\");\n  anim.SetMaxPktsPerTraceFile(500000);\n  anim.SetMobilityPollInterval(Seconds(1));\n\n  // Run the simulation\n  Simulator::Stop(Seconds(20.0));\n  Simulator::Run();\n\n  // Print flow monitor statistics\n  monitor->SerializeToXmlFile(\"handover_flowmon.xml\", true, true);\n\n  Simulator::Destroy();\n  return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a 5G NR (mmWave) network. The network should include a single gNB (base station) and two UEs (user devices). The gNB should be stationary, while the UEs should use a random walk mobility model. Assign IPv4 addresses in the 192.168.1.0/24 subnet. The second UE should act as a UDP echo server on port 9, while the first UE should act as a client, sending five packets of 1024 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/mmwave-helper.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    Ptr<MmWaveHelper> mmwaveHelper = CreateObject<MmWaveHelper>();\n\n    NodeContainer gNbNodes, ueNodes;\n    gNbNodes.Create(1); // One gNB (Base Station)\n    ueNodes.Create(2);  // Two UEs (User Equipment)\n\n    MobilityHelper mobility;\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(gNbNodes);\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-10, 10, -10, 10)));\n    mobility.Install(ueNodes);\n\n    NetDeviceContainer gNbDevices = mmwaveHelper->InstallEnbDevice(gNbNodes);\n    NetDeviceContainer ueDevices = mmwaveHelper->InstallUeDevice(ueNodes);\n\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueInterfaces = address.Assign(ueDevices);\n\n    mmwaveHelper->Attach(ueDevices, gNbDevices.Get(0));\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(ueNodes.Get(1)); // Second UE as server\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(ueInterfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(ueNodes.Get(0)); // First UE as client\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple TCP connection over a point-to-point link between two nodes in ns-3. The simulation will involve two nodes, one acting as a TCP server and the other as a TCP client. The client will send data to the server using TCP, and the simulation will record the number of bytes successfully transmitted and received. Additionally, enable packet tracing to observe the packet-level behavior of TCP during the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for TCP\n    LogComponentEnable(\"TcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Create a point-to-point link between the nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP server on node 1\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = packetSinkHelper.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create a TCP client on node 0\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", Address(InetSocketAddress(interfaces.GetAddress(1), port)));\n    clientHelper.SetAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    clientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = clientHelper.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable packet tracing\n    pointToPoint.EnablePcapAll(\"tcp-point-to-point\");\n\n    // Monitor the flow\n    FlowMonitorHelper flowmonHelper;\n    Ptr<FlowMonitor> monitor = flowmonHelper.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(11.0));\n    Simulator::Run();\n\n    // Print flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 /\n                                            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n                                            1024 / 1024 << \" Mbps\");\n    }\n\n    // Clean up\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a wireless LAN (Wi-Fi) network using the 802.11n standard. The network should have three stations (STA) and one Access Point (AP). The AP should be configured with a fixed SSID 'ns3-wifi'. Each node should have a unique IPv4 address in the 192.168.1.0/24 subnet. One station should act as a UDP echo client sending five packets of 512 bytes each to the AP, which runs a UDP echo server on port 9. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create nodes (3 Stations + 1 Access Point)\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(3);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Configure Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Configure Wi-Fi helper\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Configure MAC for stations (STA)\n    WifiMacHelper macSta;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    macSta.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, macSta, wifiStaNodes);\n\n    // Configure MAC for Access Point (AP)\n    WifiMacHelper macAp;\n    macAp.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, macAp, wifiApNode);\n\n    // Set mobility models\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Set up a UDP echo server on the AP\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(wifiApNode.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP echo client on one of the stations\n    UdpEchoClientHelper echoClient(apInterface.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(wifiStaNodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 that simulates a simple Wi-Fi infrastructure network with two nodes operating on the 802.11b physical layer. One node acts as a station and the other as an access point. The station sends packets to the access point, and the signal strength is controlled by a FixedRssLossModel, independent of the distance between nodes. The user can configure parameters such as RSS, packet size, number of packets, interval between packets, and verbose logging via command-line options. The script should generate PCAP trace files and allow analysis of packet reception based on signal strength."}, {"role": "assistant", "content": "// This script configures two nodes on an 802.11b physical layer, with\n// 802.11b NICs in infrastructure mode, and by default, the station sends\n// one packet of 1000 (application) bytes to the access point.  Unlike\n// the default physical layer configuration in which the path loss increases\n// (and the received signal strength decreases) as the distance between the\n// nodes increases, this example uses an artificial path loss model that\n// allows the configuration of the received signal strength (RSS) regardless\n// of other transmitter parameters (such as transmit power) or distance.\n// Therefore, changing position of the nodes has no effect.\n//\n// There are a number of command-line options available to control\n// the default behavior.  The list of available command-line options\n// can be listed with the following command:\n// ./ns3 run \"wifi-simple-infra --help\"\n// Additional command-line options are available via the generic attribute\n// configuration system.\n//\n// For instance, for the default configuration, the physical layer will\n// stop successfully receiving packets when rss drops to -82 dBm or below.\n// To see this effect, try running:\n//\n// ./ns3 run \"wifi-simple-infra --rss=-80 --numPackets=20\"\n// ./ns3 run \"wifi-simple-infra --rss=-81 --numPackets=20\"\n// ./ns3 run \"wifi-simple-infra --rss=-82 --numPackets=20\"\n//\n// The last command (and any RSS value lower than this) results in no\n// packets received.  This is due to the preamble detection model that\n// dominates the reception performance.  By default, the\n// ThresholdPreambleDetectionModel is added to all WifiPhy objects, and this\n// model prevents reception unless the incoming signal has a RSS above its\n// 'MinimumRssi' value (default of -82 dBm) and has a SNR above the\n// 'Threshold' value (default of 4).\n//\n// If we relax these values, we can instead observe that signal reception\n// due to the 802.11b error model alone is much lower.  For instance,\n// setting the MinimumRssi to -101 (around the thermal noise floor).\n// and the SNR Threshold to -10 dB, shows that the DsssErrorRateModel can\n// successfully decode at RSS values of -97 or -98 dBm.\n//\n// ./ns3 run \"wifi-simple-infra --rss=-97 --numPackets=20\n// --ns3::ThresholdPreambleDetectionModel::Threshold=-10\n// --ns3::ThresholdPreambleDetectionModel::MinimumRssi=-101\"\n// ./ns3 run \"wifi-simple-infra --rss=-98 --numPackets=20\n// --ns3::ThresholdPreambleDetectionModel::Threshold=-10\n// --ns3::ThresholdPreambleDetectionModel::MinimumRssi=-101\"\n// ./ns3 run \"wifi-simple-infra --rss=-99 --numPackets=20\n// --ns3::ThresholdPreambleDetectionModel::Threshold=-10\n// --ns3::ThresholdPreambleDetectionModel::MinimumRssi=-101\"\n\n//\n// Note that all ns-3 attributes (not just the ones exposed in the below\n// script) can be changed at command line; see the documentation.\n//\n// This script can also be helpful to put the Wifi layer into verbose\n// logging mode; this command will turn on all wifi logging:\n//\n// ./ns3 run \"wifi-simple-infra --verbose=1\"\n//\n// When you are done, you will notice two pcap trace files in your directory.\n// If you have tcpdump installed, you can try this:\n//\n// tcpdump -r wifi-simple-infra-0-0.pcap -nn -tt\n//\n\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleInfra\");\n\n/**\n * Function called when a packet is received.\n *\n * \\param socket The receiving socket.\n */\nvoid\nReceivePacket(Ptr<Socket> socket)\n{\n    while (socket->Recv())\n    {\n        std::cout << \"Received one packet!\" << std::endl;\n    }\n}\n\n/**\n * Generate traffic.\n *\n * \\param socket The sending socket.\n * \\param pktSize The packet size.\n * \\param pktCount The packet count.\n * \\param pktInterval The interval between two packets.\n */\nstatic void\nGenerateTraffic(Ptr<Socket> socket, uint32_t pktSize, uint32_t pktCount, Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        NS_LOG_INFO(\"Generating one packet of size \" << pktSize);\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval,\n                            &GenerateTraffic,\n                            socket,\n                            pktSize,\n                            pktCount - 1,\n                            pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string phyMode{\"DsssRate1Mbps\"};\n    dBm_u rss{-80};\n    uint32_t packetSize{1000}; // bytes\n    uint32_t numPackets{1};\n    Time interval{\"1s\"};\n    bool verbose{false};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"phyMode\", \"Wifi Phy mode\", phyMode);\n    cmd.AddValue(\"rss\", \"received signal strength\", rss);\n    cmd.AddValue(\"packetSize\", \"size of application packet sent\", packetSize);\n    cmd.AddValue(\"numPackets\", \"number of packets generated\", numPackets);\n    cmd.AddValue(\"interval\", \"interval between packets\", interval);\n    cmd.AddValue(\"verbose\", \"turn on all WifiNetDevice log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    // Fix non-unicast data rate to be the same as that of unicast\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(phyMode));\n\n    NodeContainer c;\n    c.Create(2);\n\n    // The below set of helpers will help us to put together the wifi NICs we want\n    WifiHelper wifi;\n    if (verbose)\n    {\n        WifiHelper::EnableLogComponents(); // Turn on all Wifi logging\n    }\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy;\n    // This is one parameter that matters when using FixedRssLossModel\n    // set it to zero; otherwise, gain will be added\n    wifiPhy.Set(\"RxGain\", DoubleValue(0));\n    // ns-3 supports RadioTap and Prism tracing extensions for 802.11b\n    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    // The below FixedRssLossModel will cause the rss to be fixed regardless\n    // of the distance between the two stations, and the transmit power\n    wifiChannel.AddPropagationLoss(\"ns3::FixedRssLossModel\", \"Rss\", DoubleValue(rss));\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Add a mac and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n\n    // Setup the rest of the MAC\n    Ssid ssid = Ssid(\"wifi-default\");\n    // setup STA\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevice = wifi.Install(wifiPhy, wifiMac, c.Get(0));\n    NetDeviceContainer devices = staDevice;\n    // setup AP\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(wifiPhy, wifiMac, c.Get(1));\n    devices.Add(apDevice);\n\n    // Note that with FixedRssLossModel, the positions below are not\n    // used for received signal strength.\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(c.Get(0), tid);\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 80);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    Ptr<Socket> source = Socket::CreateSocket(c.Get(1), tid);\n    InetSocketAddress remote = InetSocketAddress(Ipv4Address(\"255.255.255.255\"), 80);\n    source->SetAllowBroadcast(true);\n    source->Connect(remote);\n\n    // Tracing\n    wifiPhy.EnablePcap(\"wifi-simple-infra\", devices);\n\n    // Output what we are doing\n    std::cout << \"Testing \" << numPackets << \" packets sent with receiver rss \" << rss << std::endl;\n\n    Simulator::ScheduleWithContext(source->GetNode()->GetId(),\n                                   Seconds(1.0),\n                                   &GenerateTraffic,\n                                   source,\n                                   packetSize,\n                                   numPackets,\n                                   interval);\n\n    Simulator::Stop(Seconds(30.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wireless Ad-Hoc Network (MANET) with 5 nodes using the AODV (Ad-hoc On-Demand Distance Vector) routing protocol in ns-3. Nodes are mobile and will move around in a specified area, maintaining communication between nodes even as they move. Collect mobility trace information and analyze the packet delivery using AODV."}, {"role": "assistant", "content": "#include \"ns3/aodv-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/animation-interface.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocAODVExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time and logging\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(5); // Create 5 mobile nodes\n\n    // Setup WiFi physical layer\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n    \n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Setup WiFi MAC layer (Ad-hoc mode)\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Install the AODV routing protocol on the nodes\n    AodvHelper aodv;\n    Ipv4ListRoutingHelper list;\n    list.Add(aodv, 100);\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(list);\n    internet.Install(nodes);\n\n    // Assign IP addresses to nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set mobility for nodes (they will move randomly in a rectangular field)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", StringValue(\"ns3::UniformRandomVariable[Min=1.0|Max=5.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=2.0]\"),\n                              \"PositionAllocator\", StringValue(\"ns3::RandomRectanglePositionAllocator\"));\n    mobility.Install(nodes);\n\n    // Create UDP server on node 4\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(4));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create UDP client on node 0 to send data to node 4\n    UdpClientHelper udpClient(interfaces.GetAddress(4), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable tracing\n    wifiPhy.EnablePcap(\"adhoc-aodv\", devices);\n    AnimationInterface anim(\"adhoc-aodv.xml\");\n\n    // Set up Flow Monitor to collect performance metrics\n    FlowMonitorHelper flowMonitor;\n    Ptr<FlowMonitor> monitor = flowMonitor.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Collect and print flow monitor statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitor.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"  Lost Packets: \" << i->second.lostPackets);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 /\n                                            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n                                            1024 / 1024 << \" Mbps\");\n    }\n\n    // End simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a two-node IPv6 network in NS-3 with a point-to-point link. The nodes are assigned IPv6 addresses in the 2001:1::/64 subnet. The client (node 0) sends ICMP Echo Requests (ping) to the server (node 1). Set the link data rate to 10Mbps and delay to 10ms. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv6-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Ipv6PingExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Point-to-Point link with IPv6\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install IPv6 stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IPv6 addresses\n    Ipv6AddressHelper address;\n    address.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Mask(\"/64\"));\n    Ipv6InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up ICMP Echo Request (ping) from node 0 to node 1\n    V4PingHelper ping(interfaces.GetAddress(1));\n    ApplicationContainer pingApp = ping.Install(nodes.Get(0));\n    pingApp.Start(Seconds(2.0));\n    pingApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a simple NS-3 simulation in C++ where a client communicates with a server using UDP. The server should listen for incoming packets and log them, while the client should send a packet every second. Use NS-3’s UdpEchoClient and UdpEchoServer applications, set up a point-to-point connection, and configure basic logging. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging for debugging\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create two nodes (Client and Server)\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up the UDP Echo Server on node 1\n    uint16_t port = 9;  // UDP port number\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the UDP Echo Client on node 0\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1), port);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Wi-Fi network with three nodes communicating using UDP. The network should use 802.11n, with nodes positioned in a grid layout. Node 0 should act as a UDP echo server listening on port 9, while Node 2 should act as a UDP echo client, sending five packets of 1024 bytes at 1-second intervals to Node 0. The simulation should run from 1 second to 10 seconds, using the 192.168.1.0/24 subnet."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create a Wi-Fi network with three nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(3);\n\n    // Set up Wi-Fi PHY and MAC layers\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    WifiMacHelper wifiMac;\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer wifiDevices;\n    wifiDevices = wifi.Install(wifiPhy, wifiMac, wifiNodes);\n\n    // Set mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer wifiInterfaces = address.Assign(wifiDevices);\n\n    // Set up UDP Echo Server on node 0\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(wifiNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP Echo Client on node 2\n    UdpEchoClientHelper echoClient(wifiInterfaces.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(wifiNodes.Get(2));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ simulation script for NS-3 that models an energy-efficient wireless communication system with two nodes. One node transmits packets every second to the other node for 10 seconds. Both nodes are powered by a basic energy source, and each is connected to a basic energy harvester. The script should set the initial energy of each node to 1 joule, and the WiFi radio should consume energy for packet transmission and reception, with transmission and reception currents set to 0.0174A and 0.0197A, respectively. The harvester provides a random power between 0 and 0.1 watts, updated every second. Track and log energy consumption, harvested power, and residual energy for the receiver node during the simulation. Each packet takes 0.0023 seconds to transmit, and the simulation should print energy statistics upon completion."}, {"role": "assistant", "content": "/**\n * This example extends the energy model example by connecting a basic energy\n * harvester to the nodes.\n *\n * The example considers a simple communication link between a source and a\n * destination node, where the source node sends a packet to the destination\n * every 1 second. Each node is powered by a BasicEnergySource, which is recharged\n * by a BasicEnergyHarvester, and the WiFi radio consumes energy for the transmission/\n * reception of the packets.\n *\n * For the receiver node, the example prints the energy consumption of the WiFi radio,\n * the power harvested by the energy harvester and the residual energy in the\n * energy source.\n *\n * The nodes initial energy is set to 1.0 J, the transmission and reception entail a\n * current consumption of 0.0174 A and 0.0197 A, respectively (default values in\n * WifiRadioEnergyModel). The energy harvester provides an amount of power that varies\n * according to a random variable uniformly distributed in [0 0.1] W, and is updated\n * every 1 s. The energy source voltage is 3 V (default value in BasicEnergySource) and\n * the residual energy level is updated every 1 second (default value).\n *\n * The simulation start at time 0 and it is hard stopped at time 10 seconds. Given the\n * packet size and the distance between the nodes, each transmission lasts 0.0023s.\n * As a result, the destination node receives 10 messages.\n *\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/energy-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-radio-energy-model-helper.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace ns3;\nusing namespace ns3::energy;\n\nNS_LOG_COMPONENT_DEFINE(\"EnergyWithHarvestingExample\");\n\n/**\n * Print a received packet\n *\n * \\param from sender address\n * \\return a string with the details of the packet: dst {IP, port}, time.\n */\nstatic inline std::string\nPrintReceivedPacket(Address& from)\n{\n    InetSocketAddress iaddr = InetSocketAddress::ConvertFrom(from);\n\n    std::ostringstream oss;\n    oss << \"--\\nReceived one packet! Socket: \" << iaddr.GetIpv4() << \" port: \" << iaddr.GetPort()\n        << \" at time = \" << Simulator::Now().GetSeconds() << \"\\n--\";\n\n    return oss.str();\n}\n\n/**\n * \\param socket Pointer to socket.\n *\n * Packet receiving sink.\n */\nvoid\nReceivePacket(Ptr<Socket> socket)\n{\n    Ptr<Packet> packet;\n    Address from;\n    while ((packet = socket->RecvFrom(from)))\n    {\n        if (packet->GetSize() > 0)\n        {\n            NS_LOG_UNCOND(PrintReceivedPacket(from));\n        }\n    }\n}\n\n/**\n * \\param socket Pointer to socket.\n * \\param pktSize Packet size.\n * \\param n Pointer to node.\n * \\param pktCount Number of packets to generate.\n * \\param pktInterval Packet sending interval.\n *\n * Traffic generator.\n */\nstatic void\nGenerateTraffic(Ptr<Socket> socket,\n                uint32_t pktSize,\n                Ptr<Node> n,\n                uint32_t pktCount,\n                Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval,\n                            &GenerateTraffic,\n                            socket,\n                            pktSize,\n                            n,\n                            pktCount - 1,\n                            pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\n/**\n * Trace function for remaining energy at node.\n *\n * \\param oldValue Old value\n * \\param remainingEnergy New value\n */\nvoid\nRemainingEnergy(double oldValue, double remainingEnergy)\n{\n    NS_LOG_UNCOND(Simulator::Now().GetSeconds()\n                  << \"s Current remaining energy = \" << remainingEnergy << \"J\");\n}\n\n/**\n * Trace function for total energy consumption at node.\n *\n * \\param oldValue Old value\n * \\param totalEnergy New value\n */\nvoid\nTotalEnergy(double oldValue, double totalEnergy)\n{\n    NS_LOG_UNCOND(Simulator::Now().GetSeconds()\n                  << \"s Total energy consumed by radio = \" << totalEnergy << \"J\");\n}\n\n/**\n * Trace function for the power harvested by the energy harvester.\n *\n * \\param oldValue Old value\n * \\param harvestedPower New value\n */\nvoid\nHarvestedPower(double oldValue, double harvestedPower)\n{\n    NS_LOG_UNCOND(Simulator::Now().GetSeconds()\n                  << \"s Current harvested power = \" << harvestedPower << \" W\");\n}\n\n/**\n * Trace function for the total energy harvested by the node.\n *\n * \\param oldValue Old value\n * \\param totalEnergyHarvested New value\n */\nvoid\nTotalEnergyHarvested(double oldValue, double totalEnergyHarvested)\n{\n    NS_LOG_UNCOND(Simulator::Now().GetSeconds()\n                  << \"s Total energy harvested by harvester = \" << totalEnergyHarvested << \" J\");\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string phyMode(\"DsssRate1Mbps\");\n    double Prss = -80;         // dBm\n    uint32_t PacketSize = 200; // bytes\n    bool verbose = false;\n\n    // simulation parameters\n    uint32_t numPackets = 10000; // number of packets to send\n    double interval = 1;         // seconds\n    double startTime = 0.0;      // seconds\n    double distanceToRx = 100.0; // meters\n\n    // Energy Harvester variables\n    double harvestingUpdateInterval = 1; // seconds\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"phyMode\", \"Wifi Phy mode\", phyMode);\n    cmd.AddValue(\"Prss\", \"Intended primary RSS (dBm)\", Prss);\n    cmd.AddValue(\"PacketSize\", \"size of application packet sent\", PacketSize);\n    cmd.AddValue(\"numPackets\", \"Total number of packets to send\", numPackets);\n    cmd.AddValue(\"startTime\", \"Simulation start time\", startTime);\n    cmd.AddValue(\"distanceToRx\", \"X-Axis distance between nodes\", distanceToRx);\n    cmd.AddValue(\"verbose\", \"Turn on all device log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    // Convert to time object\n    Time interPacketInterval = Seconds(interval);\n\n    // disable fragmentation for frames below 2200 bytes\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::FragmentationThreshold\",\n                       StringValue(\"2200\"));\n    // turn off RTS/CTS for frames below 2200 bytes\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"2200\"));\n    // Fix non-unicast data rate to be the same as that of unicast\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(phyMode));\n\n    NodeContainer c;\n    c.Create(2); // create 2 nodes\n    NodeContainer networkNodes;\n    networkNodes.Add(c.Get(0));\n    networkNodes.Add(c.Get(1));\n\n    // The below set of helpers will help us to put together the wifi NICs we want\n    WifiHelper wifi;\n    if (verbose)\n    {\n        WifiHelper::EnableLogComponents();\n    }\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    /** Wifi PHY **/\n    /***************************************************************************/\n    YansWifiPhyHelper wifiPhy;\n\n    /** wifi channel **/\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n\n    // create wifi channel\n    Ptr<YansWifiChannel> wifiChannelPtr = wifiChannel.Create();\n    wifiPhy.SetChannel(wifiChannelPtr);\n\n    /** MAC layer **/\n    // Add a MAC and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n    // Set it to ad-hoc mode\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    /** install PHY + MAC **/\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, networkNodes);\n\n    /** mobility **/\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(2 * distanceToRx, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    /** Energy Model **/\n    /***************************************************************************/\n    /* energy source */\n    BasicEnergySourceHelper basicSourceHelper;\n    // configure energy source\n    basicSourceHelper.Set(\"BasicEnergySourceInitialEnergyJ\", DoubleValue(1.0));\n    // install source\n    EnergySourceContainer sources = basicSourceHelper.Install(c);\n    /* device energy model */\n    WifiRadioEnergyModelHelper radioEnergyHelper;\n    // configure radio energy model\n    radioEnergyHelper.Set(\"TxCurrentA\", DoubleValue(0.0174));\n    radioEnergyHelper.Set(\"RxCurrentA\", DoubleValue(0.0197));\n    // install device model\n    DeviceEnergyModelContainer deviceModels = radioEnergyHelper.Install(devices, sources);\n\n    /* energy harvester */\n    BasicEnergyHarvesterHelper basicHarvesterHelper;\n    // configure energy harvester\n    basicHarvesterHelper.Set(\"PeriodicHarvestedPowerUpdateInterval\",\n                             TimeValue(Seconds(harvestingUpdateInterval)));\n    basicHarvesterHelper.Set(\"HarvestablePower\",\n                             StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=0.1]\"));\n    // install harvester on all energy sources\n    EnergyHarvesterContainer harvesters = basicHarvesterHelper.Install(sources);\n    /***************************************************************************/\n\n    /** Internet stack **/\n    InternetStackHelper internet;\n    internet.Install(networkNodes);\n\n    Ipv4AddressHelper ipv4;\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(networkNodes.Get(1), tid); // node 1, Destination\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 80);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    Ptr<Socket> source = Socket::CreateSocket(networkNodes.Get(0), tid); // node 0, Source\n    InetSocketAddress remote = InetSocketAddress(Ipv4Address::GetBroadcast(), 80);\n    source->SetAllowBroadcast(true);\n    source->Connect(remote);\n\n    /** connect trace sources **/\n    /***************************************************************************/\n    // all traces are connected to node 1 (Destination)\n    // energy source\n    Ptr<BasicEnergySource> basicSourcePtr = DynamicCast<BasicEnergySource>(sources.Get(1));\n    basicSourcePtr->TraceConnectWithoutContext(\"RemainingEnergy\", MakeCallback(&RemainingEnergy));\n    // device energy model\n    Ptr<DeviceEnergyModel> basicRadioModelPtr =\n        basicSourcePtr->FindDeviceEnergyModels(\"ns3::WifiRadioEnergyModel\").Get(0);\n    NS_ASSERT(basicRadioModelPtr);\n    basicRadioModelPtr->TraceConnectWithoutContext(\"TotalEnergyConsumption\",\n                                                   MakeCallback(&TotalEnergy));\n    // energy harvester\n    Ptr<BasicEnergyHarvester> basicHarvesterPtr =\n        DynamicCast<BasicEnergyHarvester>(harvesters.Get(1));\n    basicHarvesterPtr->TraceConnectWithoutContext(\"HarvestedPower\", MakeCallback(&HarvestedPower));\n    basicHarvesterPtr->TraceConnectWithoutContext(\"TotalEnergyHarvested\",\n                                                  MakeCallback(&TotalEnergyHarvested));\n    /***************************************************************************/\n\n    /** simulation setup **/\n    // start traffic\n    Simulator::Schedule(Seconds(startTime),\n                        &GenerateTraffic,\n                        source,\n                        PacketSize,\n                        networkNodes.Get(0),\n                        numPackets,\n                        interPacketInterval);\n\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    for (auto iter = deviceModels.Begin(); iter != deviceModels.End(); iter++)\n    {\n        double energyConsumed = (*iter)->GetTotalEnergyConsumption();\n        NS_LOG_UNCOND(\"End of simulation (\"\n                      << Simulator::Now().GetSeconds()\n                      << \"s) Total energy consumed by radio = \" << energyConsumed << \"J\");\n        NS_ASSERT(energyConsumed <= 1.0);\n    }\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ script using the ns-3 simulation library to simulate a simple network topology with five nodes (A, B, C, D, E), where node A broadcasts packets using multicast to the other nodes through a static routing setup. The nodes are connected through simple net devices, and specific links between nodes are blacklisted to control the flow of packets. Set up packet sinks on nodes B, C, D, and E to receive packets sent from node A. The script should configure multicast routing, handle packet transmission using an OnOffHelper for UDP traffic, and output packet statistics at the end of the simulation. Ensure pcap tracing and a simulation run with defined packet size and data rate."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/config.h\"\n#include \"ns3/data-rate.h\"\n#include \"ns3/double.h\"\n#include \"ns3/inet-socket-address.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-l3-protocol.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/ipv4-static-routing.h\"\n#include \"ns3/log.h\"\n#include \"ns3/names.h\"\n#include \"ns3/node.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/random-variable-stream.h\"\n#include \"ns3/simple-channel.h\"\n#include \"ns3/simple-net-device-helper.h\"\n#include \"ns3/simple-net-device.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/socket.h\"\n#include \"ns3/string.h\"\n#include \"ns3/test.h\"\n#include \"ns3/trace-helper.h\"\n#include \"ns3/traffic-control-layer.h\"\n#include \"ns3/udp-socket-factory.h\"\n#include \"ns3/udp-socket.h\"\n#include \"ns3/uinteger.h\"\n\n#include <functional>\n#include <limits>\n#include <string>\n\nusing namespace ns3;\n\n/**\n * Network topology:\n *\n *        /---- B ----\\\n *  A ----      |       ---- D ---- E\n *        \\---- C ----/\n *\n * This example demonstrates configuration of\n * static routing to realize broadcast-like\n * flooding of packets from node A\n * across the illustrated topology.\n */\nint\nmain(int argc, char* argv[])\n{\n    // multicast target\n    const std::string targetAddr = \"239.192.100.1\";\n    Config::SetDefault(\"ns3::Ipv4L3Protocol::EnableDuplicatePacketDetection\", BooleanValue(true));\n    Config::SetDefault(\"ns3::Ipv4L3Protocol::DuplicateExpire\", TimeValue(Seconds(10)));\n\n    // Create topology\n\n    // Create nodes\n    auto nodes = NodeContainer();\n    nodes.Create(5);\n\n    // Name nodes\n    Names::Add(\"A\", nodes.Get(0));\n    Names::Add(\"B\", nodes.Get(1));\n    Names::Add(\"C\", nodes.Get(2));\n    Names::Add(\"D\", nodes.Get(3));\n    Names::Add(\"E\", nodes.Get(4));\n\n    SimpleNetDeviceHelper simplenet;\n    auto devices = simplenet.Install(nodes);\n    // name devices\n    Names::Add(\"A/dev\", devices.Get(0));\n    Names::Add(\"B/dev\", devices.Get(1));\n    Names::Add(\"C/dev\", devices.Get(2));\n    Names::Add(\"D/dev\", devices.Get(3));\n    Names::Add(\"E/dev\", devices.Get(4));\n\n    // setup static routes to facilitate multicast flood\n    Ipv4ListRoutingHelper listRouting;\n    Ipv4StaticRoutingHelper staticRouting;\n    listRouting.Add(staticRouting, 0);\n\n    InternetStackHelper internet;\n    internet.SetIpv6StackInstall(false);\n    internet.SetIpv4ArpJitter(true);\n    internet.SetRoutingHelper(listRouting);\n    internet.Install(nodes);\n\n    Ipv4AddressHelper ipv4address;\n    ipv4address.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    ipv4address.Assign(devices);\n\n    // add static routes for each node / device\n    for (auto diter = devices.Begin(); diter != devices.End(); ++diter)\n    {\n        Ptr<Node> node = (*diter)->GetNode();\n\n        if (Names::FindName(node) == \"A\")\n        {\n            // route for host\n            // Use host routing entry according to note in Ipv4StaticRouting::RouteOutput:\n            //// Note:  Multicast routes for outbound packets are stored in the\n            //// normal unicast table.  An implication of this is that it is not\n            //// possible to source multicast datagrams on multiple interfaces.\n            //// This is a well-known property of sockets implementation on\n            //// many Unix variants.\n            //// So, we just log it and fall through to LookupStatic ()\n            auto ipv4 = node->GetObject<Ipv4>();\n            NS_ASSERT_MSG((bool)ipv4,\n                          \"Node \" << Names::FindName(node) << \" does not have Ipv4 aggregate\");\n            auto routing = staticRouting.GetStaticRouting(ipv4);\n            routing->AddHostRouteTo(targetAddr.c_str(), ipv4->GetInterfaceForDevice(*diter), 0);\n        }\n        else\n        {\n            // route for forwarding\n            staticRouting.AddMulticastRoute(node,\n                                            Ipv4Address::GetAny(),\n                                            targetAddr.c_str(),\n                                            *diter,\n                                            NetDeviceContainer(*diter));\n        }\n    }\n\n    // set the topology, by default fully-connected\n    auto channel = devices.Get(0)->GetChannel();\n    auto simplechannel = channel->GetObject<SimpleChannel>();\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"A/dev\"),\n                             Names::Find<SimpleNetDevice>(\"D/dev\"));\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"D/dev\"),\n                             Names::Find<SimpleNetDevice>(\"A/dev\"));\n\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"A/dev\"),\n                             Names::Find<SimpleNetDevice>(\"E/dev\"));\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"E/dev\"),\n                             Names::Find<SimpleNetDevice>(\"A/dev\"));\n\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"B/dev\"),\n                             Names::Find<SimpleNetDevice>(\"E/dev\"));\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"E/dev\"),\n                             Names::Find<SimpleNetDevice>(\"B/dev\"));\n\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"C/dev\"),\n                             Names::Find<SimpleNetDevice>(\"E/dev\"));\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"E/dev\"),\n                             Names::Find<SimpleNetDevice>(\"C/dev\"));\n    // ensure some time progress between re-transmissions\n    simplechannel->SetAttribute(\"Delay\", TimeValue(MilliSeconds(1)));\n\n    // sinks\n    PacketSinkHelper sinkHelper(\"ns3::UdpSocketFactory\",\n                                InetSocketAddress(Ipv4Address::GetAny(), 9));\n    auto sinks = sinkHelper.Install(\"B\");\n    sinks.Add(sinkHelper.Install(\"C\"));\n    sinks.Add(sinkHelper.Install(\"D\"));\n    sinks.Add(sinkHelper.Install(\"E\"));\n    sinks.Start(Seconds(1));\n\n    // source\n    OnOffHelper onoffHelper(\"ns3::UdpSocketFactory\", InetSocketAddress(targetAddr.c_str(), 9));\n    onoffHelper.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"8Mbps\")));\n    onoffHelper.SetAttribute(\"MaxBytes\", UintegerValue(10 * 1024));\n    auto source = onoffHelper.Install(\"A\");\n    source.Start(Seconds(1.1));\n\n    // pcap traces\n    for (auto end = nodes.End(), iter = nodes.Begin(); iter != end; ++iter)\n    {\n        internet.EnablePcapIpv4(\"smf-trace\", (*iter)->GetId(), 1, false);\n    }\n\n    // run simulation\n    Simulator::Run();\n\n    std::cout << \"Node A sent \" << 10 * 1024 << \" bytes\" << std::endl;\n    for (auto end = sinks.End(), iter = sinks.Begin(); iter != end; ++iter)\n    {\n        auto node = (*iter)->GetNode();\n        auto sink = (*iter)->GetObject<PacketSink>();\n        std::cout << \"Node \" << Names::FindName(node) << \" received \" << sink->GetTotalRx()\n                  << \" bytes\" << std::endl;\n    }\n\n    Simulator::Destroy();\n\n    Names::Clear();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that demonstrates a hybrid topology combining a ring, mesh, bus, line, star, and tree topology. This simulation will show the interconnection of nodes in different topology types within a single network. Use point-to-point links for connections, install Internet stacks on the nodes, and enable dynamic routing using OSPF for efficient routing between nodes. Additionally, enable tracing and NetAnim visualization to capture the network behavior"}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ospf-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"HybridTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"HybridTopologyExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for different topologies\n    NodeContainer ringNodes, meshNodes, busNodes, lineNodes, starNodes, treeNodes;\n    \n    ringNodes.Create(4);  // Ring topology (4 nodes)\n    meshNodes.Create(4);  // Mesh topology (4 nodes)\n    busNodes.Create(3);   // Bus topology (3 nodes)\n    lineNodes.Create(2);  // Line topology (2 nodes)\n    starNodes.Create(4);  // Star topology (1 central node + 3 leaf nodes)\n    treeNodes.Create(7);  // Tree topology (7 nodes)\n\n    // Create point-to-point helper for links\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install Internet stack with OSPF routing\n    OspfHelper ospfRouting;\n    Ipv4ListRoutingHelper listRouting;\n    listRouting.Add(ospfRouting, 10);\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(listRouting);\n\n    // Install on all nodes\n    internet.Install(ringNodes);\n    internet.Install(meshNodes);\n    internet.Install(busNodes);\n    internet.Install(lineNodes);\n    internet.Install(starNodes);\n    internet.Install(treeNodes);\n\n    // Set up IP addressing\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfaces;\n\n    // --------- Ring Topology ---------\n    NetDeviceContainer ringDevices;\n    for (uint32_t i = 0; i < ringNodes.GetN(); ++i)\n    {\n        ringDevices = p2p.Install(ringNodes.Get(i), ringNodes.Get((i + 1) % ringNodes.GetN()));\n        address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n        interfaces.Add(address.Assign(ringDevices));\n    }\n\n    // --------- Mesh Topology ---------\n    for (uint32_t i = 0; i < meshNodes.GetN(); ++i)\n    {\n        for (uint32_t j = i + 1; j < meshNodes.GetN(); ++j)\n        {\n            NetDeviceContainer meshDevices = p2p.Install(meshNodes.Get(i), meshNodes.Get(j));\n            address.SetBase(\"10.2.1.0\", \"255.255.255.0\");\n            interfaces.Add(address.Assign(meshDevices));\n        }\n    }\n\n    // --------- Bus Topology ---------\n    NetDeviceContainer busDevices;\n    for (uint32_t i = 0; i < busNodes.GetN() - 1; ++i)\n    {\n        busDevices = p2p.Install(busNodes.Get(i), busNodes.Get(i + 1));\n        address.SetBase(\"10.3.1.0\", \"255.255.255.0\");\n        interfaces.Add(address.Assign(busDevices));\n    }\n\n    // --------- Line Topology ---------\n    NetDeviceContainer lineDevices = p2p.Install(lineNodes.Get(0), lineNodes.Get(1));\n    address.SetBase(\"10.4.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(lineDevices));\n\n    // --------- Star Topology ---------\n    NetDeviceContainer starDevices;\n    for (uint32_t i = 1; i < starNodes.GetN(); ++i)\n    {\n        starDevices = p2p.Install(starNodes.Get(0), starNodes.Get(i));  // Central node is starNodes.Get(0)\n        address.SetBase(\"10.5.1.0\", \"255.255.255.0\");\n        interfaces.Add(address.Assign(starDevices));\n    }\n\n    // --------- Tree Topology ---------\n    // Connecting nodes in a basic binary tree fashion\n    NetDeviceContainer treeDevices;\n    treeDevices = p2p.Install(treeNodes.Get(0), treeNodes.Get(1));  // Root to left child\n    address.SetBase(\"10.6.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(treeDevices));\n\n    treeDevices = p2p.Install(treeNodes.Get(0), treeNodes.Get(2));  // Root to right child\n    address.SetBase(\"10.7.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(treeDevices));\n\n    treeDevices = p2p.Install(treeNodes.Get(1), treeNodes.Get(3));  // Left child to left grandchild\n    address.SetBase(\"10.8.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(treeDevices));\n\n    treeDevices = p2p.Install(treeNodes.Get(1), treeNodes.Get(4));  // Left child to right grandchild\n    address.SetBase(\"10.9.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(treeDevices));\n\n    treeDevices = p2p.Install(treeNodes.Get(2), treeNodes.Get(5));  // Right child to left grandchild\n    address.SetBase(\"10.10.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(treeDevices));\n\n    treeDevices = p2p.Install(treeNodes.Get(2), treeNodes.Get(6));  // Right child to right grandchild\n    address.SetBase(\"10.11.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(treeDevices));\n\n    // Populate routing tables using OSPF\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Set up traffic flow\n    uint16_t port = 50000;\n    OnOffHelper onOffHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(2), port));\n    onOffHelper.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    onOffHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = onOffHelper.Install(ringNodes.Get(0)); // Traffic from ringNode 0 to meshNode\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sinkHelper.Install(meshNodes.Get(0));\n    sinkApp.Start(Seconds(0.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Set up NetAnim\n    AnimationInterface anim(\"hybrid_topology_with_netanim.xml\");\n\n    // Set constant positions for better visualization in NetAnim\n    anim.SetConstantPosition(ringNodes.Get(0), 10, 10);\n    anim.SetConstantPosition(ringNodes.Get(1), 30, 10);\n    anim.SetConstantPosition(ringNodes.Get(2), 50, 10);\n    anim.SetConstantPosition(ringNodes.Get(3), 70, 10);\n\n    anim.SetConstantPosition(meshNodes.Get(0), 10, 30);\n    anim.SetConstantPosition(meshNodes.Get(1), 30, 30);\n    anim.SetConstantPosition(meshNodes.Get(2), 50, 30);\n    anim.SetConstantPosition(meshNodes.Get(3), 70, 30);\n\n    anim.SetConstantPosition(busNodes.Get(0), 10, 50);\n    anim.SetConstantPosition(busNodes.Get(1), 30, 50);\n    anim.SetConstantPosition(busNodes.Get(2), 50, 50);\n\n    anim.SetConstantPosition(lineNodes.Get(0), 10, 70);\n    anim.SetConstantPosition(lineNodes.Get(1), 30, 70);\n\n    anim.SetConstantPosition(starNodes.Get(0), 50, 70);  // Central node of star\n    anim.SetConstantPosition(starNodes.Get(1), 70, 70);\n    anim.SetConstantPosition(starNodes.Get(2), 70, 90);\n    anim.SetConstantPosition(starNodes.Get(3), 50, 90);\n\n    anim.SetConstantPosition(treeNodes.Get(0), 50, 50);  // Root of tree\n    anim.SetConstantPosition(treeNodes.Get(1), 70, 50);\n    anim.SetConstantPosition(treeNodes.Get(2), 50, 30);\n    anim.SetConstantPosition(treeNodes.Get(3), 70, 30);\n    anim.SetConstantPosition(treeNodes.Get(4), 50, 10);\n    anim.SetConstantPosition(treeNodes.Get(5), 70, 10);\n    anim.SetConstantPosition(treeNodes.Get(6), 90, 10);\n\n    anim.EnablePacketMetadata(true);\n\n    // Run simulation\n    Simulator::Stop(Seconds(12.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
