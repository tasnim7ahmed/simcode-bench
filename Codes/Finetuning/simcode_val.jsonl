{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a complete NS-3 simulation code that models a TCP pacing scenario using a specific network topology, derived from a real-world example. The topology includes six nodes interconnected with varying bandwidths and delays, including a bottleneck link with a TCP flow crossing from node n2 to n3. Enable TCP pacing on the sockets, configure the initial congestion window, and trace various TCP metrics such as congestion window size, pacing rate, and packet transmission/reception times. Ensure to include command-line options for configuring pacing, simulation time, and other relevant TCP parameters. At the end of the simulation, print flow statistics and generate data files that track changes in these metrics."}, {"role": "assistant", "content": "//    n0                          n4\n//    |                           |\n//    |(4x Mbps, 5ms)             |(4x Mbps, 5ms)\n//    |                           |\n//    |                           |\n//    |      (x Mbps, 40ms)       |\n//    n2 ------------------------ n3\n//    |                           |\n//    |                           |\n//    |(4x Mbps, 5ms)             |(4x Mbps, 5ms)\n//    |                           |\n//    n1                          n5\n//\n//\n\n// This example illustrates how TCP pacing can be enabled on a socket.\n// Two long-running TCP flows are instantiated at nodes n0 and n1 to\n// send data over a bottleneck link (n2->n3) to sink nodes n4 and n5.\n// At the end of the simulation, the IP-level flow monitor tool will\n// print out summary statistics of the flows.  The flow monitor detects\n// four flows, but that is because the flow records are unidirectional;\n// the latter two flows reported are actually ack streams.\n//\n// At the end of this simulation, data files are also generated\n// that track changes in Congestion Window, Slow Start threshold and\n// TCP pacing rate for the first flow (n0). Additionally, a data file\n// that contains information about packet transmission and reception times\n// (collected through TxTrace and RxTrace respectively) is also produced.\n// This transmission and reception (ack) trace is the most direct way to\n// observe the effects of pacing.  All the above information is traced\n// just for the single node n0.\n//\n// A small amount of randomness is introduced to the program to control\n// the start time of the flows.\n//\n// This example has pacing enabled by default, which means that TCP\n// does not send packets back-to-back, but instead paces them out over\n// an RTT. The size of initial congestion window is set to 10, and pacing\n// of the initial window is enabled. The available command-line options and\n// their default values can be observed in the usual way by running the\n// program to print the help info; i.e.: ./ns3 run 'tcp-pacing --PrintHelp'\n//\n// When pacing is disabled, TCP sends eligible packets back-to-back. The\n// differences in behaviour when pacing is disabled can be observed from the\n// packet transmission data file. For instance, one can observe that\n// packets in the initial window are sent one after the other simultaneously,\n// without any inter-packet gaps. Another instance is when n0 receives a\n// packet in the form of an acknowledgement, and sends out data packets without\n// pacing them.\n//\n// Although this example serves as a useful demonstration of how pacing could\n// be enabled/disabled in ns-3 TCP congestion controls, we could not observe\n// significant improvements in throughput for the above topology when pacing\n// was enabled. In future, one could try and incorporate models such as\n// TCP Prague and ACK-filtering, which may show a stronger performance\n// impact for TCP pacing.\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpPacingExample\");\n\nstd::ofstream cwndStream;\nstd::ofstream pacingRateStream;\nstd::ofstream ssThreshStream;\nstd::ofstream packetTraceStream;\n\nstatic void\nCwndTracer(uint32_t oldval, uint32_t newval)\n{\n    cwndStream << std::fixed << std::setprecision(6) << Simulator::Now().GetSeconds()\n               << std::setw(12) << newval << std::endl;\n}\n\nstatic void\nPacingRateTracer(DataRate oldval, DataRate newval)\n{\n    pacingRateStream << std::fixed << std::setprecision(6) << Simulator::Now().GetSeconds()\n                     << std::setw(12) << newval.GetBitRate() / 1e6 << std::endl;\n}\n\nstatic void\nSsThreshTracer(uint32_t oldval, uint32_t newval)\n{\n    ssThreshStream << std::fixed << std::setprecision(6) << Simulator::Now().GetSeconds()\n                   << std::setw(12) << newval << std::endl;\n}\n\nstatic void\nTxTracer(Ptr<const Packet> p, Ptr<Ipv4> ipv4, uint32_t interface)\n{\n    packetTraceStream << std::fixed << std::setprecision(6) << Simulator::Now().GetSeconds()\n                      << \" tx \" << p->GetSize() << std::endl;\n}\n\nstatic void\nRxTracer(Ptr<const Packet> p, Ptr<Ipv4> ipv4, uint32_t interface)\n{\n    packetTraceStream << std::fixed << std::setprecision(6) << Simulator::Now().GetSeconds()\n                      << \" rx \" << p->GetSize() << std::endl;\n}\n\nvoid\nConnectSocketTraces()\n{\n    Config::ConnectWithoutContext(\"/NodeList/0/$ns3::TcpL4Protocol/SocketList/0/CongestionWindow\",\n                                  MakeCallback(&CwndTracer));\n    Config::ConnectWithoutContext(\"/NodeList/0/$ns3::TcpL4Protocol/SocketList/0/PacingRate\",\n                                  MakeCallback(&PacingRateTracer));\n    Config::ConnectWithoutContext(\"/NodeList/0/$ns3::TcpL4Protocol/SocketList/0/SlowStartThreshold\",\n                                  MakeCallback(&SsThreshTracer));\n    Config::ConnectWithoutContext(\"/NodeList/0/$ns3::Ipv4L3Protocol/Tx\", MakeCallback(&TxTracer));\n    Config::ConnectWithoutContext(\"/NodeList/0/$ns3::Ipv4L3Protocol/Rx\", MakeCallback(&RxTracer));\n}\n\nint\nmain(int argc, char* argv[])\n{\n    bool tracing = false;\n\n    uint32_t maxBytes = 0; // value of zero corresponds to unlimited send\n    std::string transportProtocol = \"ns3::TcpCubic\";\n\n    Time simulationEndTime = Seconds(5);\n    DataRate bottleneckBandwidth(\"10Mbps\"); // value of x as shown in the above network topology\n    Time bottleneckDelay = MilliSeconds(40);\n    DataRate regLinkBandwidth(4 * bottleneckBandwidth.GetBitRate());\n    Time regLinkDelay = MilliSeconds(5);\n    DataRate maxPacingRate(\"4Gbps\");\n\n    bool isPacingEnabled = true;\n    bool useEcn = true;\n    bool useQueueDisc = true;\n    bool shouldPaceInitialWindow = true;\n\n    // Configure defaults that are not based on explicit command-line arguments\n    // They may be overridden by general attribute configuration of command line\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\",\n                       TypeIdValue(TypeId::LookupByName(transportProtocol)));\n    Config::SetDefault(\"ns3::TcpSocket::InitialCwnd\", UintegerValue(10));\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"tracing\", \"Flag to enable/disable Ascii and Pcap tracing\", tracing);\n    cmd.AddValue(\"maxBytes\", \"Total number of bytes for application to send\", maxBytes);\n    cmd.AddValue(\"isPacingEnabled\", \"Flag to enable/disable pacing in TCP\", isPacingEnabled);\n    cmd.AddValue(\"maxPacingRate\", \"Max Pacing Rate\", maxPacingRate);\n    cmd.AddValue(\"useEcn\", \"Flag to enable/disable ECN\", useEcn);\n    cmd.AddValue(\"useQueueDisc\", \"Flag to enable/disable queue disc on bottleneck\", useQueueDisc);\n    cmd.AddValue(\"shouldPaceInitialWindow\",\n                 \"Flag to enable/disable pacing of TCP initial window\",\n                 shouldPaceInitialWindow);\n    cmd.AddValue(\"simulationEndTime\", \"Simulation end time\", simulationEndTime);\n    cmd.Parse(argc, argv);\n\n    // Configure defaults based on command-line arguments\n    Config::SetDefault(\"ns3::TcpSocketState::EnablePacing\", BooleanValue(isPacingEnabled));\n    Config::SetDefault(\"ns3::TcpSocketState::PaceInitialWindow\",\n                       BooleanValue(shouldPaceInitialWindow));\n    Config::SetDefault(\"ns3::TcpSocketBase::UseEcn\",\n                       (useEcn ? EnumValue(TcpSocketState::On) : EnumValue(TcpSocketState::Off)));\n    Config::SetDefault(\"ns3::TcpSocketState::MaxPacingRate\", DataRateValue(maxPacingRate));\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer c;\n    c.Create(6);\n\n    NS_LOG_INFO(\"Create channels.\");\n    NodeContainer n0n2 = NodeContainer(c.Get(0), c.Get(2));\n    NodeContainer n1n2 = NodeContainer(c.Get(1), c.Get(2));\n\n    NodeContainer n2n3 = NodeContainer(c.Get(2), c.Get(3));\n\n    NodeContainer n3n4 = NodeContainer(c.Get(3), c.Get(4));\n    NodeContainer n3n5 = NodeContainer(c.Get(3), c.Get(5));\n\n    // Define Node link properties\n    PointToPointHelper regLink;\n    regLink.SetDeviceAttribute(\"DataRate\", DataRateValue(regLinkBandwidth));\n    regLink.SetChannelAttribute(\"Delay\", TimeValue(regLinkDelay));\n\n    NetDeviceContainer d0d2 = regLink.Install(n0n2);\n    NetDeviceContainer d1d2 = regLink.Install(n1n2);\n    NetDeviceContainer d3d4 = regLink.Install(n3n4);\n    NetDeviceContainer d3d5 = regLink.Install(n3n5);\n\n    PointToPointHelper bottleNeckLink;\n    bottleNeckLink.SetDeviceAttribute(\"DataRate\", DataRateValue(bottleneckBandwidth));\n    bottleNeckLink.SetChannelAttribute(\"Delay\", TimeValue(bottleneckDelay));\n\n    NetDeviceContainer d2d3 = bottleNeckLink.Install(n2n3);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(c);\n\n    // Install traffic control\n    if (useQueueDisc)\n    {\n        TrafficControlHelper tchBottleneck;\n        tchBottleneck.SetRootQueueDisc(\"ns3::FqCoDelQueueDisc\");\n        tchBottleneck.Install(d2d3);\n    }\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer regLinkInterface0 = ipv4.Assign(d0d2);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer regLinkInterface1 = ipv4.Assign(d1d2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer bottleneckInterface = ipv4.Assign(d2d3);\n\n    ipv4.SetBase(\"10.1.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer regLinkInterface4 = ipv4.Assign(d3d4);\n\n    ipv4.SetBase(\"10.1.5.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer regLinkInterface5 = ipv4.Assign(d3d5);\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    // Two Sink Applications at n4 and n5\n    uint16_t sinkPort = 8080;\n    Address sinkAddress4(\n        InetSocketAddress(regLinkInterface4.GetAddress(1), sinkPort)); // interface of n4\n    Address sinkAddress5(\n        InetSocketAddress(regLinkInterface5.GetAddress(1), sinkPort)); // interface of n5\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\",\n                                      InetSocketAddress(Ipv4Address::GetAny(), sinkPort));\n    ApplicationContainer sinkApps4 = packetSinkHelper.Install(c.Get(4)); // n4 as sink\n    ApplicationContainer sinkApps5 = packetSinkHelper.Install(c.Get(5)); // n5 as sink\n\n    sinkApps4.Start(Seconds(0));\n    sinkApps4.Stop(simulationEndTime);\n    sinkApps5.Start(Seconds(0));\n    sinkApps5.Stop(simulationEndTime);\n\n    // Randomize the start time between 0 and 1ms\n    Ptr<UniformRandomVariable> uniformRv = CreateObject<UniformRandomVariable>();\n    uniformRv->SetStream(0);\n\n    // Two Source Applications at n0 and n1\n    BulkSendHelper source0(\"ns3::TcpSocketFactory\", sinkAddress4);\n    BulkSendHelper source1(\"ns3::TcpSocketFactory\", sinkAddress5);\n    // Set the amount of data to send in bytes.  Zero is unlimited.\n    source0.SetAttribute(\"MaxBytes\", UintegerValue(maxBytes));\n    source1.SetAttribute(\"MaxBytes\", UintegerValue(maxBytes));\n    ApplicationContainer sourceApps0 = source0.Install(c.Get(0));\n    ApplicationContainer sourceApps1 = source1.Install(c.Get(1));\n\n    sourceApps0.Start(MicroSeconds(uniformRv->GetInteger(0, 1000)));\n    sourceApps0.Stop(simulationEndTime);\n    sourceApps1.Start(MicroSeconds(uniformRv->GetInteger(0, 1000)));\n    sourceApps1.Stop(simulationEndTime);\n\n    if (tracing)\n    {\n        AsciiTraceHelper ascii;\n        regLink.EnableAsciiAll(ascii.CreateFileStream(\"tcp-dynamic-pacing.tr\"));\n        regLink.EnablePcapAll(\"tcp-dynamic-pacing\", false);\n    }\n\n    cwndStream.open(\"tcp-dynamic-pacing-cwnd.dat\", std::ios::out);\n    cwndStream << \"#Time(s) Congestion Window (B)\" << std::endl;\n\n    pacingRateStream.open(\"tcp-dynamic-pacing-pacing-rate.dat\", std::ios::out);\n    pacingRateStream << \"#Time(s) Pacing Rate (Mb/s)\" << std::endl;\n\n    ssThreshStream.open(\"tcp-dynamic-pacing-ssthresh.dat\", std::ios::out);\n    ssThreshStream << \"#Time(s) Slow Start threshold (B)\" << std::endl;\n\n    packetTraceStream.open(\"tcp-dynamic-pacing-packet-trace.dat\", std::ios::out);\n    packetTraceStream << \"#Time(s) tx/rx size (B)\" << std::endl;\n\n    Simulator::Schedule(MicroSeconds(1001), &ConnectSocketTraces);\n\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Stop(simulationEndTime);\n    Simulator::Run();\n\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n    for (auto i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n\n        std::cout << \"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \"\n                  << t.destinationAddress << \")\\n\";\n        std::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n        std::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n        std::cout << \"  TxOffered:  \"\n                  << i->second.txBytes * 8.0 / simulationEndTime.GetSeconds() / 1000 / 1000\n                  << \" Mbps\\n\";\n        std::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n        std::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n        std::cout << \"  Throughput: \"\n                  << i->second.rxBytes * 8.0 / simulationEndTime.GetSeconds() / 1000 / 1000\n                  << \" Mbps\\n\";\n    }\n\n    cwndStream.close();\n    pacingRateStream.close();\n    ssThreshStream.close();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple point-to-point network with two nodes connected via a wired link. The link should have a bandwidth of 10 Mbps and a delay of 2 milliseconds. The first node should act as a TCP BulkSend application transmitting unlimited data to the second node, which runs a TCP PacketSink application on port 9. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create 2 nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up a point-to-point connection\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP BulkSend application on Node 0\n    uint16_t port = 9;\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    source.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n    ApplicationContainer sourceApp = source.Install(nodes.Get(0));\n    sourceApp.Start(Seconds(1.0));\n    sourceApp.Stop(Seconds(10.0));\n\n    // Create a PacketSink application on Node 1 to receive the data\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sink.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 that sets up a point-to-point network with two nodes and demonstrates the usage of the Token Bucket Filter (TBF) queue discipline. The program should allow configuration of the TBF parameters, including the size of the first and second buckets, the token arrival rate, and the peak rate via command-line arguments. Implement tracing for the number of tokens in both buckets during the simulation. The simulation should also include a basic OnOff traffic generator sending packets between the nodes, and output the TBF queue statistics at the end of the simulation."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n// This simple example shows how to use TrafficControlHelper to install a\n// QueueDisc on a device.\n//\n// Network topology\n//\n//       10.1.1.0\n// n0 -------------- n1\n//    point-to-point\n//\n// The output will consist of all the traced changes in\n// the number of tokens in TBF's first and second buckets:\n//\n//    FirstBucketTokens 0 to x\n//    SecondBucketTokens 0 to x\n//    FirstBucketTokens x to 0\n//    SecondBucketTokens x to 0\n//\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TbfExample\");\n\nvoid\nFirstBucketTokensTrace(uint32_t oldValue, uint32_t newValue)\n{\n    std::cout << \"FirstBucketTokens \" << oldValue << \" to \" << newValue << std::endl;\n}\n\nvoid\nSecondBucketTokensTrace(uint32_t oldValue, uint32_t newValue)\n{\n    std::cout << \"SecondBucketTokens \" << oldValue << \" to \" << newValue << std::endl;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double simulationTime = 10; // seconds\n    uint32_t burst = 10000;\n    uint32_t mtu = 0;\n    DataRate rate = DataRate(\"1Mbps\");\n    DataRate peakRate = DataRate(\"0bps\");\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"burst\", \"Size of first bucket in bytes\", burst);\n    cmd.AddValue(\"mtu\", \"Size of second bucket in bytes\", mtu);\n    cmd.AddValue(\"rate\", \"Rate of tokens arriving in first bucket\", rate);\n    cmd.AddValue(\"peakRate\", \"Rate of tokens arriving in second bucket\", peakRate);\n\n    cmd.Parse(argc, argv);\n\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"2Mb/s\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"0ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    TrafficControlHelper tch;\n    tch.SetRootQueueDisc(\"ns3::TbfQueueDisc\",\n                         \"Burst\",\n                         UintegerValue(burst),\n                         \"Mtu\",\n                         UintegerValue(mtu),\n                         \"Rate\",\n                         DataRateValue(DataRate(rate)),\n                         \"PeakRate\",\n                         DataRateValue(DataRate(peakRate)));\n    QueueDiscContainer qdiscs = tch.Install(devices);\n\n    Ptr<QueueDisc> q = qdiscs.Get(1);\n    q->TraceConnectWithoutContext(\"TokensInFirstBucket\", MakeCallback(&FirstBucketTokensTrace));\n    q->TraceConnectWithoutContext(\"TokensInSecondBucket\", MakeCallback(&SecondBucketTokensTrace));\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Flow\n    uint16_t port = 7;\n    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(0));\n\n    sinkApp.Start(Seconds(0.0));\n    sinkApp.Stop(Seconds(simulationTime + 0.1));\n\n    uint32_t payloadSize = 1448;\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n\n    OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n    onoff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onoff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0.2]\"));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n    onoff.SetAttribute(\"DataRate\", StringValue(\"1.1Mb/s\")); // bit/s\n    ApplicationContainer apps;\n\n    InetSocketAddress rmt(interfaces.GetAddress(0), port);\n    onoff.SetAttribute(\"Remote\", AddressValue(rmt));\n    onoff.SetAttribute(\"Tos\", UintegerValue(0xb8));\n\n    apps.Add(onoff.Install(nodes.Get(1)));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(simulationTime + 0.1));\n\n    Simulator::Stop(Seconds(simulationTime + 5));\n    Simulator::Run();\n\n    Simulator::Destroy();\n\n    std::cout << std::endl << \"*** TC Layer statistics ***\" << std::endl;\n    std::cout << q->GetStats() << std::endl;\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and organizes them in a linear topology. The program should connect each node sequentially using Point-to-Point links, forming a chain-like structure. The program should then print confirmation of the established connections. Keep the example simple, focusing only on node creation and topology setup."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"LinearTopologyExample\", LOG_LEVEL_INFO);\n\n    // Define the number of nodes in the chain\n    uint32_t numNodes = 5;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(numNodes);\n\n    // Point-to-Point Helper\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create links between consecutive nodes\n    for (uint32_t i = 0; i < numNodes - 1; ++i) {\n        NodeContainer link(nodes.Get(i), nodes.Get(i + 1));\n        NetDeviceContainer devices = p2p.Install(link);\n        NS_LOG_INFO(\"Connected Node \" << i << \" to Node \" << i + 1);\n    }\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where multiple client nodes send UDP packets to a single server over a shared Wi-Fi network. The server should log the reception of packets. Keep the setup simple, with basic Wi-Fi configuration and no advanced mobility models."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpWifiExample\");\n\n// Function to receive packets at the server\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a packet!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"UdpWifiExample\", LOG_LEVEL_INFO);\n\n    int numClients = 3;\n    uint16_t port = 5000;\n\n    // Create nodes (clients + 1 server)\n    NodeContainer wifiNodes;\n    wifiNodes.Create(numClients + 1);\n\n    NodeContainer serverNode = wifiNodes.Get(numClients); // Last node is the server\n\n    // Set up Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"udp-wifi-network\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer clientDevices = wifi.Install(phy, mac, wifiNodes.Get(0, numClients));\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer serverDevice = wifi.Install(phy, mac, serverNode);\n\n    // Mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(clientDevices);\n    Ipv4InterfaceContainer serverInterface = address.Assign(serverDevice);\n\n    // Setup UDP Server\n    Ptr<Socket> serverSocket = Socket::CreateSocket(serverNode, UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Clients\n    for (int i = 0; i < numClients; i++) {\n        Ptr<Socket> clientSocket = Socket::CreateSocket(wifiNodes.Get(i), UdpSocketFactory::GetTypeId());\n        Ptr<Packet> packet = Create<Packet>(128); // 128-byte packet\n        Simulator::Schedule(Seconds(1.0 + i), &Socket::SendTo, clientSocket, packet, 0, InetSocketAddress(serverInterface.GetAddress(0), port));\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(5.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple Wi-Fi network simulation in NS-3 with two nodes. Set up a wireless link using IEEE 802.11 standards and make one node send UDP packets to the other over a wireless connection. Use a mobility model with constant position for the nodes, and run the simulation for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Wi-Fi channel\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Configure Wi-Fi device\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-ssid\")));\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up a UDP server (Receiver) on Node 1\n    uint16_t port = 9;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP client (Sender) on Node 0\n    UdpClientHelper client(interfaces.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 to simulate a UDP Echo Client and Server for four nodes. Set up three point-to-point links: one between node 0 and node 1, another between node 1 and node 2, and a third between node 2 and node 3. All links should have a data rate of 5Mbps and a delay of 2ms. The client on node 0 should send UDP packets to the server on node 3, with nodes 1 and 2 acting as routers. Ensure proper routing and log packet transmission and reception during the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpEchoFourNodesExample\");\n\nint \nmain(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"UdpEchoFourNodesExample\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create four nodes\n    NodeContainer nodes;\n    nodes.Create(4); // Four nodes: n0 -> n1 -> n2 -> n3\n\n    // Configure point-to-point link between nodes n0 and n1\n    PointToPointHelper pointToPoint1;\n    pointToPoint1.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint1.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Configure point-to-point link between nodes n1 and n2\n    PointToPointHelper pointToPoint2;\n    pointToPoint2.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint2.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Configure point-to-point link between nodes n2 and n3\n    PointToPointHelper pointToPoint3;\n    pointToPoint3.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint3.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on the nodes and the links between them\n    NetDeviceContainer devices1, devices2, devices3;\n    devices1 = pointToPoint1.Install(nodes.Get(0), nodes.Get(1)); // Link n0 -> n1\n    devices2 = pointToPoint2.Install(nodes.Get(1), nodes.Get(2)); // Link n1 -> n2\n    devices3 = pointToPoint3.Install(nodes.Get(2), nodes.Get(3)); // Link n2 -> n3\n\n    // Install Internet stack (TCP/IP stack) on the nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes' links\n    Ipv4AddressHelper address;\n    \n    // IP address for the link between n0 and n1\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces1 = address.Assign(devices1);\n\n    // IP address for the link between n1 and n2\n    address.SetBase(\"10.2.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces2 = address.Assign(devices2);\n\n    // IP address for the link between n2 and n3\n    address.SetBase(\"10.3.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces3 = address.Assign(devices3);\n\n    // Enable routing on nodes n1 and n2 (routers)\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create and set up UDP Echo Server on node n3 (server)\n    uint16_t port = 9; // Echo server port number\n    UdpEchoServerHelper echoServer(port);\n\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(3)); // Server is node n3\n    serverApp.Start(Seconds(1.0)); // Start server at time = 1 second\n    serverApp.Stop(Seconds(10.0)); // Stop server at time = 10 seconds\n\n    // Create and set up UDP Echo Client on node n0 (client)\n    uint32_t packetSize = 1024;   // Packet size\n    uint32_t nPackets = 10;       // Number of packets to send\n    double interval = 1.0;        // Interval between packets (1 second)\n    \n    UdpEchoClientHelper echoClient(interfaces3.GetAddress(1), port); // Server's IP (n3)\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(nPackets));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(interval)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0)); // Client is node n0\n    clientApp.Start(Seconds(2.0)); // Start client at time = 2 seconds\n    clientApp.Stop(Seconds(10.0)); // Stop client at time = 10 seconds\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a vehicular network scenario using ns-3, where four vehicles are moving along a straight road. The vehicles should communicate using WiFi in ad-hoc mode. Use a constant velocity mobility model to simulate the movement of the vehicles. The vehicles should send periodic UDP packets to one another to mimic vehicle-to-vehicle communication. Collect metrics such as packet loss and delay, and visualize the simulation using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"VehicularNetworkSimulation\");\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable (\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n  LogComponentEnable (\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n  // Create nodes (vehicles)\n  NodeContainer vehicles;\n  vehicles.Create (4);\n\n  // Set up WiFi for ad-hoc communication\n  WifiHelper wifi;\n  wifi.SetStandard (WIFI_PHY_STANDARD_80211g);\n\n  YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default ();\n  YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default ();\n  wifiPhy.SetChannel (wifiChannel.Create ());\n\n  WifiMacHelper wifiMac;\n  wifiMac.SetType (\"ns3::AdhocWifiMac\");\n\n  NetDeviceContainer devices = wifi.Install (wifiPhy, wifiMac, vehicles);\n\n  // Install Internet stack\n  InternetStackHelper stack;\n  stack.Install (vehicles);\n\n  // Assign IP addresses\n  Ipv4AddressHelper ipv4;\n  ipv4.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer vehicleInterfaces = ipv4.Assign (devices);\n\n  // Set up mobility model for vehicles (straight road with constant velocity)\n  MobilityHelper mobility;\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0),\n                                 \"MinY\", DoubleValue (0.0),\n                                 \"DeltaX\", DoubleValue (50.0),\n                                 \"DeltaY\", DoubleValue (0.0),\n                                 \"GridWidth\", UintegerValue (4),\n                                 \"LayoutType\", StringValue (\"RowFirst\"));\n\n  mobility.SetMobilityModel (\"ns3::ConstantVelocityMobilityModel\");\n  mobility.Install (vehicles);\n\n  for (uint32_t i = 0; i < vehicles.GetN (); ++i)\n    {\n      Ptr<ConstantVelocityMobilityModel> mobility = vehicles.Get (i)->GetObject<ConstantVelocityMobilityModel> ();\n      mobility->SetVelocity (Vector (20.0, 0.0, 0.0)); // 20 m/s constant speed\n    }\n\n  // Set up UDP server on vehicle 0\n  uint16_t port = 9;\n  UdpEchoServerHelper echoServer (port);\n  ApplicationContainer serverApp = echoServer.Install (vehicles.Get (0));\n  serverApp.Start (Seconds (1.0));\n  serverApp.Stop (Seconds (10.0));\n\n  // Set up UDP clients on vehicles 1, 2, and 3\n  UdpEchoClientHelper echoClient (vehicleInterfaces.GetAddress (0), port);\n  echoClient.SetAttribute (\"MaxPackets\", UintegerValue (10));\n  echoClient.SetAttribute (\"Interval\", TimeValue (Seconds (1.0)));\n  echoClient.SetAttribute (\"PacketSize\", UintegerValue (1024));\n\n  ApplicationContainer clientApps;\n  for (uint32_t i = 1; i < vehicles.GetN (); ++i)\n    {\n      clientApps.Add (echoClient.Install (vehicles.Get (i)));\n    }\n  clientApps.Start (Seconds (2.0));\n  clientApps.Stop (Seconds (10.0));\n\n  // Enable pcap tracing\n  wifiPhy.EnablePcap (\"vehicular-network\", devices);\n\n  // FlowMonitor for performance analysis\n  FlowMonitorHelper flowMonitorHelper;\n  Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll ();\n\n  // NetAnim for visualization\n  AnimationInterface anim (\"vehicular-network-animation.xml\");\n  anim.SetConstantPosition (vehicles.Get (0), 0.0, 0.0);\n  anim.SetConstantPosition (vehicles.Get (1), 50.0, 0.0);\n  anim.SetConstantPosition (vehicles.Get (2), 100.0, 0.0);\n  anim.SetConstantPosition (vehicles.Get (3), 150.0, 0.0);\n\n  // Run the simulation\n  Simulator::Stop (Seconds (10.0));\n  Simulator::Run ();\n\n  // Analyze flow statistics\n  flowMonitor->CheckForLostPackets ();\n  Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowMonitorHelper.GetClassifier ());\n  FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats ();\n\n  for (auto it = stats.begin (); it != stats.end (); ++it)\n    {\n      Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (it->first);\n      std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n      std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n      std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n      std::cout << \"  Delay: \" << it->second.delaySum.GetSeconds () << \" seconds\" << std::endl;\n    }\n\n  Simulator::Destroy ();\n  return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a Wi-Fi 802.11ac network with one Access Point (AP) and two Wi-Fi stations (STAs). The AP is stationary, while the STAs move randomly within a 50x50 area. One STA acts as a TCP server on port 5000, while the other acts as a TCP client, sending 1024-byte packets at 100Mbps. The simulation should run for 10 seconds, with PCAP tracing enabled."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"WifiTcpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: 1 AP + 2 Stations (STAs)\n    NodeContainer wifiStaNodes, wifiApNode;\n    wifiStaNodes.Create(2);\n    wifiApNode.Create(1);\n\n    // Configure Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Configure Wi-Fi standard\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211ac);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\", StringValue(\"VhtMcs9\"),\n                                 \"ControlMode\", StringValue(\"VhtMcs0\"));\n\n    // Configure MAC layer\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-80211ac\");\n\n    // Configure STA devices\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure AP device\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Setup mobility\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(wifiStaNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(wifiStaNodes);\n    internet.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = ipv4.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = ipv4.Assign(apDevice);\n\n    // Setup TCP server on STA 1\n    uint16_t port = 5000;\n    PacketSinkHelper tcpServer(\"ns3::TcpSocketFactory\",\n                               InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = tcpServer.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup TCP client on STA 2\n    OnOffHelper tcpClient(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(staInterfaces.GetAddress(0), port));\n    tcpClient.SetAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(wifiStaNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing\n    phy.EnablePcapAll(\"wifi-tcp\");\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a Point-to-Point (P2P) network with two nodes connected by a 10Mbps link with a 2ms delay. Node 1 should act as a TCP server on port 5000, while Node 0 should act as a TCP client sending 1024-byte packets at 5Mbps. The simulation should run for 10 seconds, with PCAP tracing enabled."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"P2PTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"P2PTcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure Point-to-Point (P2P) link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install P2P devices\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Setup TCP server on Node 1\n    uint16_t port = 5000;\n    PacketSinkHelper tcpServer(\"ns3::TcpSocketFactory\",\n                               InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup TCP client on Node 0\n    OnOffHelper tcpClient(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(interfaces.GetAddress(1), port));\n    tcpClient.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing\n    pointToPoint.EnablePcapAll(\"p2p-tcp\");\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation of a wireless ad-hoc network with 3 nodes using the AODV routing protocol. Set up UDP communication between two nodes while the third node relays packets. Visualize the packet transmission and network topology using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/aodv-helper.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocAodvExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Set up Wi-Fi channel and physical layer\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Configure Wi-Fi with Ad-hoc mode\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Set up the AODV routing protocol\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install UDP server on node 1\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Install UDP client on node 0, sending packets to node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up NetAnim\n    AnimationInterface anim(\"aodv_netanim.xml\");\n\n    // Set positions for nodes in NetAnim\n    anim.SetConstantPosition(nodes.Get(0), 0.0, 0.0); // Node 0 (Client)\n    anim.SetConstantPosition(nodes.Get(1), 5.0, 5.0); // Node 1 (Server)\n    anim.SetConstantPosition(nodes.Get(2), 2.5, 2.5); // Node 2 (Relay)\n\n    // Enable packet metadata for detailed visualization in NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a simple NS-3 C++ WiFi network simulation with two nodes. The first node (client) sends TCP packets to the second node (server) over a WiFi link. Use a 1Gbps data rate, assign IPs in the 192.168.1.0/24 range, and ensure the Internet stack is installed. The server should run from 1s to 10s, while the client starts at 2s and sends packets at 0.1s intervals. The simulation should start at 1s and run for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set up nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Set up WiFi devices\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::StaWifiMac\",\n                    \"Ssid\", SsidValue(Ssid(\"wifi-default\")));\n\n    NetDeviceContainer wifiDevices;\n    wifiDevices = wifi.Install(wifiPhy, wifiMac, wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer wifiInterfaces = address.Assign(wifiDevices);\n\n    // Set up the TCP server on the second node (server)\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(wifiNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the TCP client on the first node (client)\n    TcpClientHelper tcpClient(wifiInterfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(wifiNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ code that sets up a network topology with RIPng routing in an ns-3 simulation. The network should consist of nodes SRC, A, B, C, D, and DST. The connections are as follows: SRC connects to A, A connects to both B and C, B connects to both C and D, and D connects to DST. All links have a cost of 1, except the direct link from C to D, which has a cost of 10. The routers A and D have static addresses, and packets will be exchanged between SRC and DST. After 3 seconds, the topology is built, and ping responses are received. At 40 seconds, the link between B and D breaks, causing route failure, and recovery occurs after 44 seconds. Include Split Horizon options in the routing strategy and add pcap and ascii tracing to monitor the network behavior."}, {"role": "assistant", "content": "// Network topology\n//\n//    SRC\n//     |<=== source network\n//     A-----B\n//      \\   / \\   all networks have cost 1, except\n//       \\ /  |   for the direct link from C to D, which\n//        C  /    has cost 10\n//        | /\n//        |/\n//        D\n//        |<=== target network\n//       DST\n//\n//\n// A, B, C and D are RIPng routers.\n// A and D are configured with static addresses.\n// SRC and DST will exchange packets.\n//\n// After about 3 seconds, the topology is built, and Echo Reply will be received.\n// After 40 seconds, the link between B and D will break, causing a route failure.\n// After 44 seconds from the failure, the routers will recovery from the failure.\n// Split Horizoning should affect the recovery time, but it is not. See the manual\n// for an explanation of this effect.\n//\n// If \"showPings\" is enabled, the user will see:\n// 1) if the ping has been acknowledged\n// 2) if a Destination Unreachable has been received by the sender\n// 3) nothing, when the Echo Request has been received by the destination but\n//    the Echo Reply is unable to reach the sender.\n// Examining the .pcap files with Wireshark can confirm this effect.\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RipNgSimpleRouting\");\n\nvoid\nTearDownLink(Ptr<Node> nodeA, Ptr<Node> nodeB, uint32_t interfaceA, uint32_t interfaceB)\n{\n    nodeA->GetObject<Ipv6>()->SetDown(interfaceA);\n    nodeB->GetObject<Ipv6>()->SetDown(interfaceB);\n}\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n    bool printRoutingTables = false;\n    bool showPings = false;\n    std::string SplitHorizon(\"PoisonReverse\");\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.AddValue(\"printRoutingTables\",\n                 \"Print routing tables at 30, 60 and 90 seconds\",\n                 printRoutingTables);\n    cmd.AddValue(\"showPings\", \"Show Ping reception\", showPings);\n    cmd.AddValue(\"splitHorizonStrategy\",\n                 \"Split Horizon strategy to use (NoSplitHorizon, SplitHorizon, PoisonReverse)\",\n                 SplitHorizon);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"RipNgSimpleRouting\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"RipNg\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"NdiscCache\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ping\", LOG_LEVEL_ALL);\n    }\n\n    if (SplitHorizon == \"NoSplitHorizon\")\n    {\n        Config::SetDefault(\"ns3::RipNg::SplitHorizon\", EnumValue(RipNg::NO_SPLIT_HORIZON));\n    }\n    else if (SplitHorizon == \"SplitHorizon\")\n    {\n        Config::SetDefault(\"ns3::RipNg::SplitHorizon\", EnumValue(RipNg::SPLIT_HORIZON));\n    }\n    else\n    {\n        Config::SetDefault(\"ns3::RipNg::SplitHorizon\", EnumValue(RipNg::POISON_REVERSE));\n    }\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> src = CreateObject<Node>();\n    Names::Add(\"SrcNode\", src);\n    Ptr<Node> dst = CreateObject<Node>();\n    Names::Add(\"DstNode\", dst);\n    Ptr<Node> a = CreateObject<Node>();\n    Names::Add(\"RouterA\", a);\n    Ptr<Node> b = CreateObject<Node>();\n    Names::Add(\"RouterB\", b);\n    Ptr<Node> c = CreateObject<Node>();\n    Names::Add(\"RouterC\", c);\n    Ptr<Node> d = CreateObject<Node>();\n    Names::Add(\"RouterD\", d);\n    NodeContainer net1(src, a);\n    NodeContainer net2(a, b);\n    NodeContainer net3(a, c);\n    NodeContainer net4(b, c);\n    NodeContainer net5(c, d);\n    NodeContainer net6(b, d);\n    NodeContainer net7(d, dst);\n    NodeContainer routers(a, b, c, d);\n    NodeContainer nodes(src, dst);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer ndc1 = csma.Install(net1);\n    NetDeviceContainer ndc2 = csma.Install(net2);\n    NetDeviceContainer ndc3 = csma.Install(net3);\n    NetDeviceContainer ndc4 = csma.Install(net4);\n    NetDeviceContainer ndc5 = csma.Install(net5);\n    NetDeviceContainer ndc6 = csma.Install(net6);\n    NetDeviceContainer ndc7 = csma.Install(net7);\n\n    NS_LOG_INFO(\"Create IPv6 and routing\");\n    RipNgHelper ripNgRouting;\n\n    // Rule of thumb:\n    // Interfaces are added sequentially, starting from 0\n    // However, interface 0 is always the loopback...\n    ripNgRouting.ExcludeInterface(a, 1);\n    ripNgRouting.ExcludeInterface(d, 3);\n\n    ripNgRouting.SetInterfaceMetric(c, 3, 10);\n    ripNgRouting.SetInterfaceMetric(d, 1, 10);\n\n    Ipv6ListRoutingHelper listRH;\n    listRH.Add(ripNgRouting, 0);\n    Ipv6StaticRoutingHelper staticRh;\n    listRH.Add(staticRh, 5);\n\n    InternetStackHelper internetv6;\n    internetv6.SetIpv4StackInstall(false);\n    internetv6.SetRoutingHelper(listRH);\n    internetv6.Install(routers);\n\n    InternetStackHelper internetv6Nodes;\n    internetv6Nodes.SetIpv4StackInstall(false);\n    internetv6Nodes.Install(nodes);\n\n    // Assign addresses.\n    // The source and destination networks have global addresses\n    // The \"core\" network just needs link-local addresses for routing.\n    // We assign global addresses to the routers as well to receive\n    // ICMPv6 errors.\n    NS_LOG_INFO(\"Assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic1 = ipv6.Assign(ndc1);\n    iic1.SetForwarding(1, true);\n    iic1.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:0:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic2 = ipv6.Assign(ndc2);\n    iic2.SetForwarding(0, true);\n    iic2.SetForwarding(1, true);\n\n    ipv6.SetBase(Ipv6Address(\"2001:0:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic3 = ipv6.Assign(ndc3);\n    iic3.SetForwarding(0, true);\n    iic3.SetForwarding(1, true);\n\n    ipv6.SetBase(Ipv6Address(\"2001:0:3::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic4 = ipv6.Assign(ndc4);\n    iic4.SetForwarding(0, true);\n    iic4.SetForwarding(1, true);\n\n    ipv6.SetBase(Ipv6Address(\"2001:0:4::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic5 = ipv6.Assign(ndc5);\n    iic5.SetForwarding(0, true);\n    iic5.SetForwarding(1, true);\n\n    ipv6.SetBase(Ipv6Address(\"2001:0:5::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic6 = ipv6.Assign(ndc6);\n    iic6.SetForwarding(0, true);\n    iic6.SetForwarding(1, true);\n\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic7 = ipv6.Assign(ndc7);\n    iic7.SetForwarding(0, true);\n    iic7.SetDefaultRouteInAllNodes(0);\n\n    if (printRoutingTables)\n    {\n        Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);\n\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(30.0), a, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(30.0), b, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(30.0), c, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(30.0), d, routingStream);\n\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(60.0), a, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(60.0), b, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(60.0), c, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(60.0), d, routingStream);\n\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(90.0), a, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(90.0), b, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(90.0), c, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(90.0), d, routingStream);\n    }\n\n    NS_LOG_INFO(\"Create Applications.\");\n    uint32_t packetSize = 1024;\n    Time interPacketInterval = Seconds(1.0);\n    PingHelper ping(iic7.GetAddress(1, 1));\n\n    ping.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    if (showPings)\n    {\n        ping.SetAttribute(\"VerboseMode\", EnumValue(Ping::VerboseMode::VERBOSE));\n    }\n    ApplicationContainer apps = ping.Install(src);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(110.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"ripng-simple-routing.tr\"));\n    csma.EnablePcapAll(\"ripng-simple-routing\", true);\n\n    Simulator::Schedule(Seconds(40), &TearDownLink, b, d, 3, 2);\n\n    /* Now, do the actual simulation. */\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Stop(Seconds(120));\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a simple Wi-Fi network with 2 nodes. The nodes use 802.11b Wi-Fi and are configured with the ConstantPositionMobilityModel for stationary behavior. Node 0 (the sender) transmits UDP packets to Node 1 (the receiver) at a constant rate of 500kb/s. The simulation should last for 10 seconds, with the application starting at 1 second and stopping at 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"WifiSimpleExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2); // Two nodes (sender and receiver)\n\n    // Set up mobility model for nodes (stationary)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Wi-Fi setup (using 802.11b standard)\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_PHY_STANDARD_80211b);\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns-3-simple-wifi\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices = wifiHelper.Install(wifiPhy, wifiMac, nodes);\n\n    // Install internet stack and assign IP addresses\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfaces = ipv4.Assign(devices);\n\n    // Create UDP application on node 0 (sender)\n    OnOffHelper onOffHelper(\"ns3::UdpSocketFactory\", Address(InetSocketAddress(ipInterfaces.GetAddress(1), 9))); // Sending to node 1\n    onOffHelper.SetConstantRate(DataRate(\"500kb/s\"));\n    ApplicationContainer senderApp = onOffHelper.Install(nodes.Get(0));\n    senderApp.Start(Seconds(1.0));\n    senderApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on node 1 (receiver)\n    UdpServerHelper udpServer(9);\n    ApplicationContainer receiverApp = udpServer.Install(nodes.Get(1));\n    receiverApp.Start(Seconds(1.0));\n    receiverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a Wi-Fi network with one access point (AP) and two stations (STA) using the 802.11g standard. The network should use the 192.168.1.0/24 subnet. One STA should act as a UDP server on port 8080, while the other STA should be a UDP client sending 10 packets of 1024 bytes at 1-second intervals. The server should start at 1 second, and the client should start at 2 seconds, with the simulation running for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create nodes: 1 Access Point (AP) + 2 Stations (STAs)\n    NodeContainer wifiStaNodes, wifiApNode;\n    wifiStaNodes.Create(2);\n    wifiApNode.Create(1);\n\n    // Configure Wi-Fi PHY and MAC\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211g);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Configure STA devices\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure AP device\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Configure UDP Server on one STA\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Configure UDP Client on the other STA\n    UdpClientHelper udpClient(staInterfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run Simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simulation in ns-3 for a vehicular ad-hoc network (VANET) with five vehicles moving along a straight road. Each vehicle is equipped with Wi-Fi and uses the IEEE 802.11p standard for vehicle-to-vehicle (V2V) communication. The vehicles are configured to exchange information using a UDP client-server model, where one vehicle acts as a server and the others send data at regular intervals. The mobility model should ensure that the vehicles move in the same direction with varying speeds. Collect and display metrics such as packet delivery ratio and end-to-end delay, and visualize the vehicle movements and communication with NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"VanetExample\");\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n  LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n  // Create nodes (5 vehicles)\n  NodeContainer vehicles;\n  vehicles.Create(5);\n\n  // Set up 802.11p Wi-Fi (vehicular communication)\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n  YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n  phy.SetChannel(channel.Create());\n\n  WifiHelper wifi;\n  wifi.SetStandard(WIFI_PHY_STANDARD_80211p);\n\n  NqosWaveMacHelper mac = NqosWaveMacHelper::Default();\n  Wifi80211pHelper wifi80211p = Wifi80211pHelper::Default();\n  NetDeviceContainer devices = wifi80211p.Install(phy, mac, vehicles);\n\n  // Install Internet stack\n  InternetStackHelper internet;\n  internet.Install(vehicles);\n\n  // Assign IP addresses\n  Ipv4AddressHelper ipv4;\n  ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer vehicleInterfaces = ipv4.Assign(devices);\n\n  // Set up mobility model for vehicles\n  MobilityHelper mobility;\n  mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n  \n  Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n  positionAlloc->Add(Vector(0.0, 0.0, 0.0));    // First vehicle position\n  positionAlloc->Add(Vector(20.0, 0.0, 0.0));   // Second vehicle\n  positionAlloc->Add(Vector(40.0, 0.0, 0.0));   // Third vehicle\n  positionAlloc->Add(Vector(60.0, 0.0, 0.0));   // Fourth vehicle\n  positionAlloc->Add(Vector(80.0, 0.0, 0.0));   // Fifth vehicle\n  mobility.SetPositionAllocator(positionAlloc);\n  mobility.Install(vehicles);\n\n  // Set different speeds for the vehicles\n  for (uint32_t i = 0; i < vehicles.GetN(); ++i) {\n    Ptr<ConstantVelocityMobilityModel> mob = vehicles.Get(i)->GetObject<ConstantVelocityMobilityModel>();\n    mob->SetVelocity(Vector(10.0 + i, 0.0, 0.0));  // Speed varies slightly for each vehicle\n  }\n\n  // Set up UDP echo server on the first vehicle\n  uint16_t port = 9;\n  UdpEchoServerHelper echoServer(port);\n  ApplicationContainer serverApp = echoServer.Install(vehicles.Get(0));\n  serverApp.Start(Seconds(1.0));\n  serverApp.Stop(Seconds(20.0));\n\n  // Set up UDP echo clients on the other vehicles\n  UdpEchoClientHelper echoClient(vehicleInterfaces.GetAddress(0), port);\n  echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n  echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(2.0)));\n  echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n  ApplicationContainer clientApps;\n  for (uint32_t i = 1; i < vehicles.GetN(); ++i)\n  {\n    clientApps.Add(echoClient.Install(vehicles.Get(i)));\n  }\n  clientApps.Start(Seconds(2.0));\n  clientApps.Stop(Seconds(20.0));\n\n  // Enable tracing for Wi-Fi packets\n  phy.EnablePcapAll(\"vanet-example\");\n\n  // Set up FlowMonitor for performance metrics\n  FlowMonitorHelper flowMonitorHelper;\n  Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n  // Set up NetAnim for visualization\n  AnimationInterface anim(\"vanet-animation.xml\");\n  anim.SetConstantPosition(vehicles.Get(0), 0.0, 0.0);\n  anim.SetConstantPosition(vehicles.Get(1), 20.0, 0.0);\n  anim.SetConstantPosition(vehicles.Get(2), 40.0, 0.0);\n  anim.SetConstantPosition(vehicles.Get(3), 60.0, 0.0);\n  anim.SetConstantPosition(vehicles.Get(4), 80.0, 0.0);\n\n  // Run the simulation\n  Simulator::Stop(Seconds(20.0));\n  Simulator::Run();\n\n  // FlowMonitor statistics\n  flowMonitor->CheckForLostPackets();\n  Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitorHelper.GetClassifier());\n  FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n\n  for (auto it = stats.begin(); it != stats.end(); ++it)\n  {\n    Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(it->first);\n    std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n    std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n    std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n    std::cout << \"  Throughput: \" << it->second.rxBytes * 8.0 / 20.0 / 1000 / 1000 << \" Mbps\" << std::endl;\n    std::cout << \"  End-to-End Delay: \" << it->second.delaySum.GetSeconds() << \" seconds\" << std::endl;\n  }\n\n  // Clean up and exit\n  Simulator::Destroy();\n  return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to model a disaster recovery network consisting of a central command node, three medical units, and three teams of responders, each with five nodes. Implement a WiFi ad hoc network where the teams have random mobility while the medical units and the central command remain stationary. Configure the nodes with appropriate IP addresses and enable RTS/CTS for improved performance. Set up a UDP echo server for each team and corresponding clients to send packets every two seconds. Integrate a flow monitor to capture statistics such as packet delivery ratios, end-to-end delays, and throughput, and output these metrics after the simulation. Additionally, create an animation file to visualize the network activity during the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/aodv-module.h\" // Include AODV header\n\nusing namespace ns3;\nNS_LOG_COMPONENT_DEFINE (\"AdhocNetworkExample\");\n\nint main (int argc, char *argv[])\n{\n   LogComponentEnable (\"AdhocNetworkExample\", LOG_LEVEL_INFO);\n  // Basic setup\n  NodeContainer centralCommand;\n  centralCommand.Create (1);\n\n  NodeContainer medicalUnits;\n  medicalUnits.Create (3);\n\n  NodeContainer teamA, teamB, teamC;\n  teamA.Create (5);\n  teamB.Create (5);\n  teamC.Create (5);\n\n  // Setup WiFi\n  WifiHelper wifi;\n  WifiMacHelper mac;\n  mac.SetType (\"ns3::AdhocWifiMac\");\n  YansWifiPhyHelper phy;\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n  phy.SetChannel(channel.Create());\n  phy.Set(\"TxPowerStart\", DoubleValue(20));\n  phy.Set(\"TxPowerEnd\", DoubleValue(20));\n  phy.Set(\"TxGain\", DoubleValue(0.0));\n  phy.Set(\"RxGain\", DoubleValue(0.0));\n  \n  Ssid ssid = Ssid (\"DisasterRecoveryNet\");\n\n  // Setup AP and Medical Units\n  mac.SetType (\"ns3::StaWifiMac\", \"Ssid\", SsidValue (ssid));\n  NetDeviceContainer medicalDevices = wifi.Install (phy, mac, medicalUnits);\n\n  mac.SetType (\"ns3::ApWifiMac\", \"Ssid\", SsidValue (ssid));\n  NetDeviceContainer apDevice = wifi.Install (phy, mac, centralCommand.Get (0));\n\n  // Mobility model for fixed positions\n  MobilityHelper mobility;\n  mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install (centralCommand);\n  mobility.Install (medicalUnits);\n\n  // Setup Ad Hoc Networks for teams\n  NetDeviceContainer teamADevices, teamBDevices, teamCDevices;\n\n  mac.SetType (\"ns3::AdhocWifiMac\");\n  teamADevices = wifi.Install (phy, mac, teamA);\n  teamBDevices = wifi.Install (phy, mac, teamB);\n  teamCDevices = wifi.Install (phy, mac, teamC);\n\n  // Mobility model for random movement\n  MobilityHelper teamMobility;\n  teamMobility.SetMobilityModel (\"ns3::RandomWalk2dMobilityModel\");\n  teamMobility.Install(teamA);\n  teamMobility.Install(teamB);\n  teamMobility.Install(teamC);\n\n  // Internet stack and routing protocols\n  InternetStackHelper stack1,stack2,stack3,stack4,stack5;\n  AodvHelper aodv;\n  stack1.SetRoutingHelper(aodv);\n  stack2.SetRoutingHelper(aodv);\n  stack3.SetRoutingHelper(aodv);\n  stack4.SetRoutingHelper(aodv);\n  stack5.SetRoutingHelper(aodv);\n  stack1.Install(teamA);\n  stack2.Install(teamB);\n  stack3.Install(teamC);\n  stack4.Install(medicalUnits);\n  stack5.Install(centralCommand);\n\n\n  // Assign IP addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer apInterface;\n  apInterface = address.Assign (apDevice);\n  address.Assign (medicalDevices);\n\n  address.SetBase (\"10.1.2.0\", \"255.255.255.0\");\n  address.Assign (teamADevices);\n\n  address.SetBase (\"10.1.3.0\", \"255.255.255.0\");\n  address.Assign (teamBDevices);\n\n  address.SetBase (\"10.1.4.0\", \"255.255.255.0\");\n  address.Assign (teamCDevices);\n  \n //enable RTS/CTS\n  bool enableCtsRts = true;\n  UintegerValue ctsThr = (enableCtsRts ? UintegerValue(100) : UintegerValue(2200));\n  Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", ctsThr);\n \n  // UDP Echo Client/Server application setup for teamA, teamB, teamC\n  int16_t port = 9; // well-known echo port number\n  UdpEchoServerHelper echoServer (port);\n  ApplicationContainer serverApps;\n  for (NodeContainer team : {teamA, teamB, teamC})\n  {\n\n    for (uint32_t i = 0; i < team.GetN (); ++i)\n    {\n      serverApps.Add (echoServer.Install (team.Get (i)));\n    }\n    serverApps.Start (Seconds (1.0));\n    serverApps.Stop (Seconds (100.0));\n\n    // Create UDP echo client application on each node\n    ApplicationContainer clientApps[team.GetN ()];\n\n    for (uint32_t i = 0; i < team.GetN (); ++i)\n    {\n      UdpEchoClientHelper echoClient (team.Get ((i + 1) % team.GetN ())->GetObject<Ipv4> ()->GetAddress (1, 0).GetLocal (), port);\n      echoClient.SetAttribute (\"MaxPackets\", UintegerValue (100)); // Adjust as needed\n      echoClient.SetAttribute (\"Interval\", TimeValue (Seconds (2.0)));\n      echoClient.SetAttribute (\"PacketSize\", UintegerValue (1024));\n      clientApps[i].Add (echoClient.Install (team.Get (i)));\n    }\n\n    // Start and stop client applications\n    for (uint32_t i = 0; i < team.GetN (); i+4)\n    {\n      clientApps[i].Start (Seconds (2.0 + 10 * i));\n      clientApps[i].Stop (Seconds (100.0));\n    }\n  } \n\n  // Define a flow monitor object\n    Ptr<FlowMonitor> flowMonitor;\n    FlowMonitorHelper flowHelper;\n    flowMonitor = flowHelper.InstallAll();\n\n    Simulator::Stop(Seconds(100.0));\n\n    // Animation\n    AnimationInterface anim(\"final.xml\");\n\n    // Run simulation\n    Simulator::Run ();\n\n    // Calculate packet delivery ratio and end-to-end delay and throughput\n    uint32_t packetsDelivered = 0;\n    uint32_t totalPackets = 0;\n    double totalDelay = 0;\n\n    // Retrieve the flow statistics\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n    for(auto & it: stats) {\n        FlowId flowId = it.first;\n        std::cout << \"Flow \" << flowId << std::endl;\n        std::cout << \" Tx Packets: \" << it.second.txPackets << std::endl;\n        std::cout << \" Tx Bytes: \" << it.second.txBytes << std::endl;\n        std::cout << \" Rx Packets: \" << it.second.rxPackets << std::endl;\n        std::cout << \" Rx Bytes: \" << it.second.rxBytes << std::endl;\n\n        if(it.second.rxPackets > 0) {\n            packetsDelivered += it.second.rxPackets;\n            totalPackets += it.second.txPackets;\n            totalDelay += (it.second.delaySum.ToDouble(ns3::Time::S) / it.second.rxPackets);\n        }\n    }\n\n    double packetDeliveryRatio = (double) packetsDelivered / totalPackets;\n    double averageEndToEndDelay = totalDelay / packetsDelivered;\n    double throughput = (double) packetsDelivered * 1024 * 8 / (100.0 - 0.0) / 1000000;\n\n    // Print the results\n    std::cout << \"Packets Delivered Ratio: \" << packetDeliveryRatio << std::endl;\n    std::cout << \"Average End-to-End Delay: \" << averageEndToEndDelay << std::endl;\n    std::cout << \"Throughput: \" << throughput << std::endl;\n\n    Simulator::Destroy ();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 that sets up a dumbbell network topology with configurable leaf nodes and queue types, supporting either RED or NLRED queue disciplines. The program should accept command-line arguments to adjust settings such as the number of leaf nodes, queue disc limits, packet size, data rates, and RED queue thresholds. Implement the ability to toggle between packet-based and byte-based queue modes. The OnOff application should be installed on right-side nodes, with random On/Off periods, and the program should display statistics about packet drops in the queue. Ensure appropriate handling of errors and conditions in the queue disc statistics."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-layout-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <iomanip>\n#include <iostream>\n#include <map>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t nLeaf = 10;\n    uint32_t maxPackets = 100;\n    bool modeBytes = false;\n    uint32_t queueDiscLimitPackets = 1000;\n    double minTh = 5;\n    double maxTh = 15;\n    uint32_t pktSize = 512;\n    std::string appDataRate = \"10Mbps\";\n    std::string queueDiscType = \"RED\";\n    uint16_t port = 5001;\n    std::string bottleNeckLinkBw = \"1Mbps\";\n    std::string bottleNeckLinkDelay = \"50ms\";\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nLeaf\", \"Number of left and right side leaf nodes\", nLeaf);\n    cmd.AddValue(\"maxPackets\", \"Max Packets allowed in the device queue\", maxPackets);\n    cmd.AddValue(\"queueDiscLimitPackets\",\n                 \"Max Packets allowed in the queue disc\",\n                 queueDiscLimitPackets);\n    cmd.AddValue(\"queueDiscType\", \"Set Queue disc type to RED or NLRED\", queueDiscType);\n    cmd.AddValue(\"appPktSize\", \"Set OnOff App Packet Size\", pktSize);\n    cmd.AddValue(\"appDataRate\", \"Set OnOff App DataRate\", appDataRate);\n    cmd.AddValue(\"modeBytes\", \"Set Queue disc mode to Packets (false) or bytes (true)\", modeBytes);\n\n    cmd.AddValue(\"redMinTh\", \"RED queue minimum threshold\", minTh);\n    cmd.AddValue(\"redMaxTh\", \"RED queue maximum threshold\", maxTh);\n    cmd.Parse(argc, argv);\n\n    if ((queueDiscType != \"RED\") && (queueDiscType != \"NLRED\"))\n    {\n        std::cout << \"Invalid queue disc type: Use --queueDiscType=RED or --queueDiscType=NLRED\"\n                  << std::endl;\n        exit(1);\n    }\n\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(pktSize));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(appDataRate));\n\n    Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, maxPackets)));\n\n    if (!modeBytes)\n    {\n        Config::SetDefault(\n            \"ns3::RedQueueDisc::MaxSize\",\n            QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, queueDiscLimitPackets)));\n    }\n    else\n    {\n        Config::SetDefault(\n            \"ns3::RedQueueDisc::MaxSize\",\n            QueueSizeValue(QueueSize(QueueSizeUnit::BYTES, queueDiscLimitPackets * pktSize)));\n        minTh *= pktSize;\n        maxTh *= pktSize;\n    }\n\n    Config::SetDefault(\"ns3::RedQueueDisc::MinTh\", DoubleValue(minTh));\n    Config::SetDefault(\"ns3::RedQueueDisc::MaxTh\", DoubleValue(maxTh));\n    Config::SetDefault(\"ns3::RedQueueDisc::LinkBandwidth\", StringValue(bottleNeckLinkBw));\n    Config::SetDefault(\"ns3::RedQueueDisc::LinkDelay\", StringValue(bottleNeckLinkDelay));\n    Config::SetDefault(\"ns3::RedQueueDisc::MeanPktSize\", UintegerValue(pktSize));\n\n    if (queueDiscType == \"NLRED\")\n    {\n        // Turn on NLRED\n        Config::SetDefault(\"ns3::RedQueueDisc::NLRED\", BooleanValue(true));\n    }\n\n    // Create the point-to-point link helpers\n    PointToPointHelper bottleNeckLink;\n    bottleNeckLink.SetDeviceAttribute(\"DataRate\", StringValue(bottleNeckLinkBw));\n    bottleNeckLink.SetChannelAttribute(\"Delay\", StringValue(bottleNeckLinkDelay));\n\n    PointToPointHelper pointToPointLeaf;\n    pointToPointLeaf.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPointLeaf.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    PointToPointDumbbellHelper d(nLeaf, pointToPointLeaf, nLeaf, pointToPointLeaf, bottleNeckLink);\n\n    // Install Stack\n    InternetStackHelper stack;\n    for (uint32_t i = 0; i < d.LeftCount(); ++i)\n    {\n        stack.Install(d.GetLeft(i));\n    }\n    for (uint32_t i = 0; i < d.RightCount(); ++i)\n    {\n        stack.Install(d.GetRight(i));\n    }\n\n    stack.Install(d.GetLeft());\n    stack.Install(d.GetRight());\n    TrafficControlHelper tchBottleneck;\n    QueueDiscContainer queueDiscs;\n    tchBottleneck.SetRootQueueDisc(\"ns3::RedQueueDisc\");\n    tchBottleneck.Install(d.GetLeft()->GetDevice(0));\n    queueDiscs = tchBottleneck.Install(d.GetRight()->GetDevice(0));\n\n    // Assign IP Addresses\n    d.AssignIpv4Addresses(Ipv4AddressHelper(\"10.1.1.0\", \"255.255.255.0\"),\n                          Ipv4AddressHelper(\"10.2.1.0\", \"255.255.255.0\"),\n                          Ipv4AddressHelper(\"10.3.1.0\", \"255.255.255.0\"));\n\n    // Install on/off app on all right side nodes\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", Address());\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::UniformRandomVariable[Min=0.|Max=1.]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::UniformRandomVariable[Min=0.|Max=1.]\"));\n    Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n    ApplicationContainer sinkApps;\n    for (uint32_t i = 0; i < d.LeftCount(); ++i)\n    {\n        sinkApps.Add(packetSinkHelper.Install(d.GetLeft(i)));\n    }\n    sinkApps.Start(Seconds(0.0));\n    sinkApps.Stop(Seconds(30.0));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < d.RightCount(); ++i)\n    {\n        // Create an on/off app sending packets to the left side\n        AddressValue remoteAddress(InetSocketAddress(d.GetLeftIpv4Address(i), port));\n        clientHelper.SetAttribute(\"Remote\", remoteAddress);\n        clientApps.Add(clientHelper.Install(d.GetRight(i)));\n    }\n    clientApps.Start(Seconds(1.0)); // Start 1 second after sink\n    clientApps.Stop(Seconds(15.0)); // Stop before the sink\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    std::cout << \"Running the simulation\" << std::endl;\n    Simulator::Run();\n\n    QueueDisc::Stats st = queueDiscs.Get(0)->GetStats();\n\n    if (st.GetNDroppedPackets(RedQueueDisc::UNFORCED_DROP) == 0)\n    {\n        std::cout << \"There should be some unforced drops\" << std::endl;\n        exit(1);\n    }\n\n    if (st.GetNDroppedPackets(QueueDisc::INTERNAL_QUEUE_DROP) != 0)\n    {\n        std::cout << \"There should be zero drops due to queue full\" << std::endl;\n        exit(1);\n    }\n\n    std::cout << \"*** Stats from the bottleneck queue disc ***\" << std::endl;\n    std::cout << st << std::endl;\n    std::cout << \"Destroying the simulation\" << std::endl;\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple LTE network with one eNodeB and two UEs (User Equipment) using ns-3. Configure the UEs to send UDP traffic to a remote host via the LTE core network (PGW). Visualize the packet flow and network configuration using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteSimulationExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time\n    double simulationTime = 10.0;\n\n    // Create LTE Helper and EPC Helper for LTE core\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    // Create nodes: 1 eNodeB, 2 UEs (User Equipments), and 1 Remote Host\n    NodeContainer ueNodes;\n    ueNodes.Create(2);\n    NodeContainer enbNodes;\n    enbNodes.Create(1);\n\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n\n    // Create a remote host\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // Configure the remote host to use a point-to-point link with the PGW (Packet Gateway)\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.01)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n\n    Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress(1);\n\n    // Set up the routing between UEs and the remote host\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting = ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n\n    // Install the LTE stack on UEs and eNodeB\n    NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueLteDevs = lteHelper->InstallUeDevice(ueNodes);\n\n    // Set up mobility model for eNodeB and UEs\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(enbNodes);\n    mobility.Install(ueNodes);\n\n    // Install the IP stack on UEs\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIfaces = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLteDevs));\n\n    // Set up default gateways for UEs\n    for (uint32_t i = 0; i < ueNodes.GetN(); ++i)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting = ipv4RoutingHelper.GetStaticRouting(ueNodes.Get(i)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // Attach UEs to the eNodeB\n    lteHelper->Attach(ueLteDevs, enbLteDevs.Get(0));\n\n    // Install UDP traffic applications on UEs\n    uint16_t dlPort = 1234;\n    uint16_t ulPort = 2000;\n\n    UdpClientHelper dlClient(remoteHostAddr, dlPort);\n    dlClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    dlClient.SetAttribute(\"MaxPackets\", UintegerValue(1000000));\n    dlClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps;\n    clientApps.Add(dlClient.Install(ueNodes.Get(0)));\n    clientApps.Add(dlClient.Install(ueNodes.Get(1)));\n\n    UdpServerHelper ulServer(ulPort);\n    ApplicationContainer serverApps = ulServer.Install(remoteHost);\n\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(simulationTime));\n\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(simulationTime));\n\n    // Enable NetAnim for visualization\n    AnimationInterface anim(\"lte_netanim.xml\");\n    anim.SetConstantPosition(enbNodes.Get(0), 50.0, 50.0); // eNodeB\n    anim.SetConstantPosition(ueNodes.Get(0), 60.0, 50.0);  // UE 1\n    anim.SetConstantPosition(ueNodes.Get(1), 70.0, 50.0);  // UE 2\n    anim.EnablePacketMetadata(true);                       // Enable packet tracking\n\n    // Run simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Mobile Ad-Hoc Network (MANET) with 5 nodes. The nodes use the AODV routing protocol, and their movement is simulated with the RandomWaypointMobilityModel. The nodes randomly move within a 100x100m area. Node 0 sends UDP packets to node 4, while node 4 receives the data. The network communication occurs using Wi-Fi with the 802.11b standard. The simulation runs for 10 seconds, with the application starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ManetExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"ManetExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the MANET\n    NodeContainer nodes;\n    nodes.Create(5);\n\n    // Set up mobility model for nodes (random movement)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"MinX\", DoubleValue(0.0),\n                              \"MinY\", DoubleValue(0.0),\n                              \"MaxX\", DoubleValue(100.0),\n                              \"MaxY\", DoubleValue(100.0),\n                              \"Speed\", StringValue(\"ns3::UniformRandomVariable[Min=5.0|Max=10.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"));\n    mobility.Install(nodes);\n\n    // Install AODV routing protocol\n    AodvHelper aodv;\n    InternetStackHelper stack;\n    stack.SetRoutingHelper(aodv); // Use AODV as the routing protocol\n    stack.Install(nodes);\n\n    // Set up point-to-point devices (Wi-Fi or similar)\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_PHY_STANDARD_80211b);\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns-3-manet\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices = wifiHelper.Install(wifiPhy, wifiMac, nodes);\n\n    // Install the internet stack and assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfaces = ipv4.Assign(devices);\n\n    // Set up application on node 0 (sending data)\n    OnOffHelper onOffHelper(\"ns3::UdpSocketFactory\", Address(InetSocketAddress(ipInterfaces.GetAddress(4), 9))); // Send to node 4\n    onOffHelper.SetConstantRate(DataRate(\"500kb/s\"));\n    ApplicationContainer senderApp = onOffHelper.Install(nodes.Get(0));\n    senderApp.Start(Seconds(2.0));\n    senderApp.Stop(Seconds(10.0));\n\n    // Set up application on node 4 (receiving data)\n    UdpServerHelper udpServer(9);\n    ApplicationContainer receiverApp = udpServer.Install(nodes.Get(4));\n    receiverApp.Start(Seconds(2.0));\n    receiverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple TCP communication between two nodes in NS-3. Use a point-to-point link with a data rate of 5 Mbps and a delay of 2 ms. The sender (Node 0) sends TCP packets to the receiver (Node 1) over the connection. The simulation runs for 10 seconds and uses TCP as the transport protocol."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Point-to-Point link between the nodes\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer devices = p2p.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up TCP server (Receiver) on Node 1\n    uint16_t port = 9;\n    TcpServerHelper server(port);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up TCP client (Sender) on Node 0\n    TcpClientHelper client(interfaces.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simulation in ns-3 to compare the performance of TCP and UDP traffic in a simple network topology. Use a point-to-point topology with two nodes. Install both TCP and UDP applications on the network, transmitting data between the nodes. Measure and compare the key performance metrics, including throughput, latency, and packet delivery ratio for each protocol. Use FlowMonitor to capture and analyze these metrics, and visualize the traffic and node movements using NetAnim. Ensure that the simulation runs for 10 seconds, and print out the performance results for comparison between TCP and UDP."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpVsUdpComparison\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time\n    double simTime = 10.0;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Create point-to-point channel\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a UDP server on node 1\n    uint16_t udpPort = 9;\n    UdpServerHelper udpServer(udpPort);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simTime));\n\n    // Create a UDP client on node 0\n    UdpClientHelper udpClient(interfaces.GetAddress(1), udpPort);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simTime));\n\n    // Create a TCP server (Packet Sink) on node 1\n    uint16_t tcpPort = 8080;\n    PacketSinkHelper tcpSink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), tcpPort));\n    ApplicationContainer sinkApp = tcpSink.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(simTime));\n\n    // Create a TCP client on node 0\n    OnOffHelper tcpClient(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), tcpPort));\n    tcpClient.SetAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    tcpClient.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    tcpClient.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    ApplicationContainer clientAppTcp = tcpClient.Install(nodes.Get(0));\n    clientAppTcp.Start(Seconds(3.0));\n    clientAppTcp.Stop(Seconds(simTime));\n\n    // Set up FlowMonitor\n    FlowMonitorHelper flowMonitorHelper;\n    Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n    // NetAnim configuration\n    AnimationInterface anim(\"tcp_vs_udp.xml\");\n    anim.SetConstantPosition(nodes.Get(0), 10.0, 20.0);\n    anim.SetConstantPosition(nodes.Get(1), 30.0, 20.0);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n\n    // Flow monitor statistics\n    flowMonitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitorHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n\n    for (auto it = stats.begin(); it != stats.end(); ++it)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(it->first);\n        std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n        std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n        std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n        std::cout << \"  Throughput: \" << it->second.rxBytes * 8.0 / simTime / 1000 / 1000 << \" Mbps\" << std::endl;\n        std::cout << \"  Packet Delivery Ratio: \" << (double)it->second.rxPackets / it->second.txPackets * 100 << \"%\" << std::endl;\n        std::cout << \"  Delay: \" << it->second.delaySum.GetSeconds() << \" seconds\" << std::endl;\n    }\n\n    // Cleanup\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Wi-Fi network with two nodes: one acting as an Access Point (AP) and the other as a Wi-Fi client. The AP should run a UDP server on port 8080, while the client should run a UDP client sending 20 packets of size 512 bytes at an interval of 0.5 seconds. The simulation should assign IP addresses in the 192.168.1.0/24 subnet, with the AP at 192.168.1.1. Both nodes should have a constant position mobility model, and the simulation should run for 10 seconds, starting the server at 1 second and the client at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create a Wi-Fi network with 2 nodes (1 AP + 1 Client)\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Configure Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    // Configure Wi-Fi MAC layer\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Configure AP (Access Point)\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiNodes.Get(0));\n\n    // Configure Client\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer clientDevice = wifi.Install(phy, mac, wifiNodes.Get(1));\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(apDevice);\n    interfaces.Add(address.Assign(clientDevice));\n\n    // Create a UDP server on the AP\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create a UDP client on the Client node\n    UdpClientHelper udpClient(interfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(20));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.5)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a group of nodes communicates using UDP over a VANET (Vehicular Ad-Hoc Network). The nodes should use the DSDV (Destination-Sequenced Distance-Vector) routing protocol for maintaining up-to-date routes. Vehicles should move along a highway using the WaypointMobilityModel, and each vehicle should periodically send UDP packets to a central roadside unit (RSU). The simulation should run for 30 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/dsdv-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpVANETExample\");\n\n// Function to send UDP packets from vehicles to the RSU\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address dstAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(512); // 512-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(dstAddr, port));\n    Simulator::Schedule(Seconds(1.5), &SendPacket, socket, dstAddr, port); // Schedule next packet\n}\n\n// Function to receive packets at the RSU\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"RSU received a packet from a vehicle!\");\n    }\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpVANETExample\", LOG_LEVEL_INFO);\n\n    int numVehicles = 10;\n    double simTime = 30.0;\n\n    // Create nodes (vehicles + 1 RSU)\n    NodeContainer vehicles;\n    vehicles.Create(numVehicles);\n\n    NodeContainer rsu;\n    rsu.Create(1);\n\n    // Configure Wi-Fi (Ad-Hoc Mode for VANET)\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211p); // 802.11p for vehicular communication\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(phy, mac, vehicles);\n    NetDeviceContainer rsuDevice = wifi.Install(phy, mac, rsu);\n\n    // Set up mobility (vehicles moving along a highway)\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    \n    for (int i = 0; i < numVehicles; i++) {\n        positionAlloc->Add(Vector(i * 20.0, 0.0, 0.0)); // Vehicles spaced 20m apart\n    }\n    positionAlloc->Add(Vector(100.0, 50.0, 0.0)); // RSU position\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::WaypointMobilityModel\");\n    mobility.Install(vehicles);\n    mobility.Install(rsu);\n\n    // Install Internet stack with DSDV routing\n    DsdvHelper dsdv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(dsdv);\n    internet.Install(vehicles);\n    internet.Install(rsu);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vehicleInterfaces = address.Assign(devices);\n    Ipv4InterfaceContainer rsuInterface = address.Assign(rsuDevice);\n\n    uint16_t port = 8080; // UDP port\n\n    // Setup UDP Server at RSU\n    Ptr<Socket> rsuSocket = Socket::CreateSocket(rsu.Get(0), UdpSocketFactory::GetTypeId());\n    rsuSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    rsuSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Clients in Vehicles\n    for (int i = 0; i < numVehicles; i++) {\n        Ptr<Socket> vehicleSocket = Socket::CreateSocket(vehicles.Get(i), UdpSocketFactory::GetTypeId());\n        Simulator::Schedule(Seconds(2.0 + i * 0.5), &SendPacket, vehicleSocket, rsuInterface.GetAddress(0), port);\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using ns-3 to create a star topology network, where the central node (hub) connects to eight surrounding nodes (spokes) using point-to-point links. Install the internet stack on all nodes and assign IPv4 addresses. Set default application configurations: an OnOffApplication with a packet size of 137 bytes and a data rate of 14kbps. Create a packet sink on the hub node to receive TCP traffic on port 50000, and configure each spoke node to send TCP traffic to the hub using OnOff applications. Enable static global routing and capture pcap traces for all devices. Run the simulation for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-layout-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n// Network topology (default)\n//\n//        n2 n3 n4              .\n//         \\ | /                .\n//          \\|/                 .\n//     n1--- n0---n5            .\n//          /|\\                 .\n//         / | \\                .\n//        n8 n7 n6              .\n//\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Star\");\n\nint\nmain(int argc, char* argv[])\n{\n    //\n    // Set up some default values for the simulation.\n    //\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(137));\n\n    // ??? try and stick 15kb/s into the data rate\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(\"14kb/s\"));\n\n    //\n    // Default number of nodes in the star.  Overridable by command line argument.\n    //\n    uint32_t nSpokes = 8;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nSpokes\", \"Number of nodes to place in the star\", nSpokes);\n    cmd.Parse(argc, argv);\n\n    NS_LOG_INFO(\"Build star topology.\");\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    PointToPointStarHelper star(nSpokes, pointToPoint);\n\n    NS_LOG_INFO(\"Install internet stack on all nodes.\");\n    InternetStackHelper internet;\n    star.InstallStack(internet);\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    star.AssignIpv4Addresses(Ipv4AddressHelper(\"10.1.1.0\", \"255.255.255.0\"));\n\n    NS_LOG_INFO(\"Create applications.\");\n    //\n    // Create a packet sink on the star \"hub\" to receive packets.\n    //\n    uint16_t port = 50000;\n    Address hubLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", hubLocalAddress);\n    ApplicationContainer hubApp = packetSinkHelper.Install(star.GetHub());\n    hubApp.Start(Seconds(1.0));\n    hubApp.Stop(Seconds(10.0));\n\n    //\n    // Create OnOff applications to send TCP to the hub, one on each spoke node.\n    //\n    OnOffHelper onOffHelper(\"ns3::TcpSocketFactory\", Address());\n    onOffHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    ApplicationContainer spokeApps;\n\n    for (uint32_t i = 0; i < star.SpokeCount(); ++i)\n    {\n        AddressValue remoteAddress(InetSocketAddress(star.GetHubIpv4Address(i), port));\n        onOffHelper.SetAttribute(\"Remote\", remoteAddress);\n        spokeApps.Add(onOffHelper.Install(star.GetSpokeNode(i)));\n    }\n    spokeApps.Start(Seconds(1.0));\n    spokeApps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Enable static global routing.\");\n    //\n    // Turn on global static routing so we can actually be routed across the star.\n    //\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    NS_LOG_INFO(\"Enable pcap tracing.\");\n    //\n    // Do pcap tracing on all point-to-point devices on all nodes.\n    //\n    pointToPoint.EnablePcapAll(\"star\");\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a simple C++ program using the ns-3 simulation library to set up a branch topology with three nodes. Configure the nodes to communicate using a point-to-point network where node 0 acts as the central node connected to nodes 1 and 2 via separate links. Use UDP traffic to generate communication between the nodes, and assign IP addresses accordingly. The simulation should run for 10 seconds, and PCAP tracing should be enabled for traffic analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BranchTopology3Nodes\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"BranchTopology3Nodes\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Set up point-to-point links\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install point-to-point links between node 0 and node 1, and between node 0 and node 2\n    NetDeviceContainer device01, device02;\n    device01 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));  // Link between node 0 and node 1\n    device02 = pointToPoint.Install(nodes.Get(0), nodes.Get(2));  // Link between node 0 and node 2\n\n    // Install internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces01 = address.Assign(device01);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces02 = address.Assign(device02);\n\n    // Set up a UDP Echo server on node 0\n    UdpEchoServerHelper echoServer(9);  // Port number\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 1 to send packets to node 0\n    UdpEchoClientHelper echoClient(interfaces01.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(1));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Set up another UDP Echo client on node 2 to send packets to node 0\n    UdpEchoClientHelper echoClient2(interfaces02.GetAddress(0), 9);\n    echoClient2.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient2.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient2.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApps2 = echoClient2.Install(nodes.Get(2));\n    clientApps2.Start(Seconds(3.0));\n    clientApps2.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing to capture the packet flow\n    pointToPoint.EnablePcapAll(\"branch-topology-3-nodes\");\n\n    // Run the simulation\n    Simulator::Run();\n\n    // End the simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a simple 5G NR network with one User Equipment (UE), one gNB (5G base station), and the 5G Core Network (CN). The gNB should communicate with the UE using UDP. The UE should run a UDP server on port 9, and the gNB should send 1,000 UDP packets of 1024 bytes each, with a packet interval of 0.01 seconds. The simulation should run for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/gnb-module.h\"\n#include \"ns3/ue-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Simple5GExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"Simple5GExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: UE (User Equipment), gNB (5G Base Station), and 5G Core Network\n    NodeContainer ueNodes, gnbNodes, coreNetworkNodes;\n    ueNodes.Create(1);\n    gnbNodes.Create(1);\n    coreNetworkNodes.Create(1);\n\n    // Set up 5G NR helpers\n    Ptr<GnbHelper> gnbHelper = CreateObject<GnbHelper>();\n    Ptr<UeHelper> ueHelper = CreateObject<UeHelper>();\n    Ptr<CoreNetworkHelper> coreNetworkHelper = CreateObject<CoreNetworkHelper>();\n    gnbHelper->SetCoreNetworkHelper(coreNetworkHelper);\n\n    // Set up the gNB (base station) and UE\n    NetDeviceContainer ueDevices, gnbDevices;\n    gnbDevices = gnbHelper->InstallGnbDevice(gnbNodes);\n    ueDevices = ueHelper->InstallUeDevice(ueNodes);\n\n    // Install the internet stack (IP, TCP, UDP)\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    internet.Install(gnbNodes);\n    internet.Install(coreNetworkNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface = ipv4.Assign(ueDevices);\n    Ipv4InterfaceContainer gnbIpIface = ipv4.Assign(gnbDevices);\n\n    // Attach UE to the gNB (5G base station)\n    gnbHelper->Attach(ueDevices.Get(0), gnbDevices.Get(0));\n\n    // Set up UDP server on the UE node (User Equipment)\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ueNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the gNB node\n    UdpClientHelper udpClient(ueIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(gnbNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 to simulate a UDP Echo Client and Server between two nodes. Set up a point-to-point connection between the nodes with a link of 5Mbps data rate and 2ms delay. The client on one node should send UDP packets to the server on the other node, and the simulation should log packet transmission and reception. Include packet size, interval, and the number of packets to be transmitted in the configuration."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpEchoExample\");\n\nint \nmain(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"UdpEchoExample\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2); // Two nodes, one for client and one for server\n\n    // Configure point-to-point link between the nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on the nodes and the link between them\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack (TCP/IP stack) on the nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create and set up UDP Echo Server on node 1 (server)\n    uint16_t port = 9; // Echo server port number\n    UdpEchoServerHelper echoServer(port);\n\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(1)); // Server is node 1\n    serverApp.Start(Seconds(1.0)); // Start server at time = 1 second\n    serverApp.Stop(Seconds(10.0)); // Stop server at time = 10 seconds\n\n    // Create and set up UDP Echo Client on node 0 (client)\n    uint32_t packetSize = 1024;   // Packet size\n    uint32_t nPackets = 10;       // Number of packets to send\n    double interval = 1.0;        // Interval between packets (1 second)\n    \n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1), port); // Server's IP (node 1)\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(nPackets));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(interval)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0)); // Client is node 0\n    clientApp.Start(Seconds(2.0)); // Start client at time = 2 seconds\n    clientApp.Stop(Seconds(10.0)); // Stop client at time = 10 seconds\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using ns-3 that simulates an 802.11n Wi-Fi network with MPDU aggregation support, consisting of an access point (AP) and two hidden stations. Allow the user to configure options for RTS/CTS, the number of aggregated MPDUs, payload size, simulation time, and expected throughput via command-line arguments. Set up the simulation to limit the wireless range to 5 meters, ensuring a hidden node scenario, and use UDP traffic with saturated flow from the stations to the AP. The program should generate PCAP and ASCII trace files, calculate throughput, and verify it against the user-specified bounds."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/rng-seed-manager.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This example considers two hidden stations in an 802.11n network which supports MPDU aggregation.\n// The user can specify whether RTS/CTS is used and can set the number of aggregated MPDUs.\n//\n// Example: ./ns3 run \"wifi-simple-ht-hidden-stations --enableRts=1 --nMpdus=8\"\n//\n// Network topology:\n//\n//   Wifi 192.168.1.0\n//\n//        AP\n//   *    *    *\n//   |    |    |\n//   n1   n2   n3\n//\n// Packets in this simulation belong to BestEffort Access Class (AC_BE).\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimplesHtHiddenStations\");\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t payloadSize{1472}; // bytes\n    Time simulationTime{\"10s\"};\n    uint32_t nMpdus{1};\n    uint32_t maxAmpduSize{0};\n    bool enableRts{false};\n    double minExpectedThroughput{0};\n    double maxExpectedThroughput{0};\n\n    RngSeedManager::SetSeed(1);\n    RngSeedManager::SetRun(7);\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nMpdus\", \"Number of aggregated MPDUs\", nMpdus);\n    cmd.AddValue(\"payloadSize\", \"Payload size in bytes\", payloadSize);\n    cmd.AddValue(\"enableRts\", \"Enable RTS/CTS\", enableRts);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"minExpectedThroughput\",\n                 \"if set, simulation fails if the lowest throughput is below this value\",\n                 minExpectedThroughput);\n    cmd.AddValue(\"maxExpectedThroughput\",\n                 \"if set, simulation fails if the highest throughput is above this value\",\n                 maxExpectedThroughput);\n    cmd.Parse(argc, argv);\n\n    if (!enableRts)\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"999999\"));\n    }\n    else\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"0\"));\n    }\n\n    // Set the maximum size for A-MPDU with regards to the payload size\n    maxAmpduSize = nMpdus * (payloadSize + 200);\n\n    // Set the maximum wireless range to 5 meters in order to reproduce a hidden nodes scenario,\n    // i.e. the distance between hidden stations is larger than 5 meters\n    Config::SetDefault(\"ns3::RangePropagationLossModel::MaxRange\", DoubleValue(5));\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    channel.AddPropagationLoss(\n        \"ns3::RangePropagationLossModel\"); // wireless range limited to 5 meters!\n\n    YansWifiPhyHelper phy;\n    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    phy.SetChannel(channel.Create());\n    phy.Set(\"ChannelSettings\", StringValue(\"{36, 0, BAND_5GHZ, 0}\"));\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"HtMcs7\"),\n                                 \"ControlMode\",\n                                 StringValue(\"HtMcs0\"));\n    WifiMacHelper mac;\n\n    Ssid ssid = Ssid(\"simple-mpdu-aggregation\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/BE_MaxAmpduSize\",\n                UintegerValue(maxAmpduSize));\n\n    int64_t streamNumber = 20;\n    streamNumber += WifiHelper::AssignStreams(apDevice, streamNumber);\n    streamNumber += WifiHelper::AssignStreams(staDevices, streamNumber);\n\n    // Setting mobility model\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n    // AP is between the two stations, each station being located at 5 meters from the AP.\n    // The distance between the two stations is thus equal to 10 meters.\n    // Since the wireless range is limited to 5 meters, the two stations are hidden from each other.\n    positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(10.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNodes);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n    streamNumber += stack.AssignStreams(wifiApNode, streamNumber);\n    streamNumber += stack.AssignStreams(wifiStaNodes, streamNumber);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterface;\n    StaInterface = address.Assign(staDevices);\n    Ipv4InterfaceContainer ApInterface;\n    ApInterface = address.Assign(apDevice);\n\n    // Setting applications\n    uint16_t port = 9;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiApNode);\n    serverApp.Start(Seconds(0.0));\n    serverApp.Stop(simulationTime + Seconds(1.0));\n    streamNumber += server.AssignStreams(wifiApNode, streamNumber);\n\n    UdpClientHelper client(ApInterface.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    client.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    // Saturated UDP traffic from stations to AP\n    ApplicationContainer clientApp1 = client.Install(wifiStaNodes);\n    clientApp1.Start(Seconds(1.0));\n    clientApp1.Stop(simulationTime + Seconds(1.0));\n    streamNumber += client.AssignStreams(wifiStaNodes, streamNumber);\n\n    phy.EnablePcap(\"SimpleHtHiddenStations_Ap\", apDevice.Get(0));\n    phy.EnablePcap(\"SimpleHtHiddenStations_Sta1\", staDevices.Get(0));\n    phy.EnablePcap(\"SimpleHtHiddenStations_Sta2\", staDevices.Get(1));\n\n    AsciiTraceHelper ascii;\n    phy.EnableAsciiAll(ascii.CreateFileStream(\"SimpleHtHiddenStations.tr\"));\n\n    Simulator::Stop(simulationTime + Seconds(1.0));\n\n    Simulator::Run();\n\n    double totalPacketsThrough = DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n\n    Simulator::Destroy();\n\n    auto throughput = totalPacketsThrough * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s\" << '\\n';\n    if (throughput < minExpectedThroughput ||\n        (maxExpectedThroughput > 0 && throughput > maxExpectedThroughput))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a code that configures and simulates an IEEE 802.11ax Wi-Fi network using the NS-3 simulator to analyze UDP or TCP traffic performance under varying Modulation and Coding Scheme (MCS) values, channel widths, and guard intervals. It sets up an access point (AP) and one or more stations, allowing you to customize parameters such as the distance between the AP and stations, the acknowledgment sequence for downlink (DL) MU PPDUs, and options like enabling RTS/CTS, 80+80 MHz channels, extended block acknowledgment, or UL OFDMA. You can simulate 2.4, 5, or 6 GHz bands with Yans or Spectrum PHY models. The code lets you adjust the number of stations, packet payload size, and target throughput. Depending on your choice, it initializes UDP or TCP flows and produces throughput results for different MCS values and channel widths. You can also schedule channel access and assess network performance across various configurations and topologies."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/he-phy.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/wifi-acknowledgment.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <functional>\n\n// This is a simple example in order to show how to configure an IEEE 802.11ax Wi-Fi network.\n//\n// It outputs the UDP or TCP goodput for every HE MCS value, which depends on the MCS value (0 to\n// 11), the channel width (20, 40, 80 or 160 MHz) and the guard interval (800ns, 1600ns or 3200ns).\n// The PHY bitrate is constant over all the simulation run. The user can also specify the distance\n// between the access point and the station: the larger the distance the smaller the goodput.\n//\n// The simulation assumes a configurable number of stations in an infrastructure network:\n//\n//  STA     AP\n//    *     *\n//    |     |\n//   n1     n2\n//\n// Packets in this simulation belong to BestEffort Access Class (AC_BE).\n// By selecting an acknowledgment sequence for DL MU PPDUs, it is possible to aggregate a\n// Round Robin scheduler to the AP, so that DL MU PPDUs are sent by the AP via DL OFDMA.\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"he-wifi-network\");\n\nint\nmain(int argc, char* argv[])\n{\n    bool udp{true};\n    bool downlink{true};\n    bool useRts{false};\n    bool use80Plus80{false};\n    bool useExtendedBlockAck{false};\n    Time simulationTime{\"10s\"};\n    meter_u distance{1.0};\n    double frequency{5}; // whether 2.4, 5 or 6 GHz\n    std::size_t nStations{1};\n    std::string dlAckSeqType{\"NO-OFDMA\"};\n    bool enableUlOfdma{false};\n    bool enableBsrp{false};\n    int mcs{-1}; // -1 indicates an unset value\n    uint32_t payloadSize =\n        700; // must fit in the max TX duration when transmitting at MCS 0 over an RU of 26 tones\n    std::string phyModel{\"Yans\"};\n    double minExpectedThroughput{0};\n    double maxExpectedThroughput{0};\n    Time accessReqInterval{0};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"frequency\",\n                 \"Whether working in the 2.4, 5 or 6 GHz band (other values gets rejected)\",\n                 frequency);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the station and the access point\",\n                 distance);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"udp\", \"UDP if set to 1, TCP otherwise\", udp);\n    cmd.AddValue(\"downlink\",\n                 \"Generate downlink flows if set to 1, uplink flows otherwise\",\n                 downlink);\n    cmd.AddValue(\"useRts\", \"Enable/disable RTS/CTS\", useRts);\n    cmd.AddValue(\"use80Plus80\", \"Enable/disable use of 80+80 MHz\", use80Plus80);\n    cmd.AddValue(\"useExtendedBlockAck\", \"Enable/disable use of extended BACK\", useExtendedBlockAck);\n    cmd.AddValue(\"nStations\", \"Number of non-AP HE stations\", nStations);\n    cmd.AddValue(\"dlAckType\",\n                 \"Ack sequence type for DL OFDMA (NO-OFDMA, ACK-SU-FORMAT, MU-BAR, AGGR-MU-BAR)\",\n                 dlAckSeqType);\n    cmd.AddValue(\"enableUlOfdma\",\n                 \"Enable UL OFDMA (useful if DL OFDMA is enabled and TCP is used)\",\n                 enableUlOfdma);\n    cmd.AddValue(\"enableBsrp\",\n                 \"Enable BSRP (useful if DL and UL OFDMA are enabled and TCP is used)\",\n                 enableBsrp);\n    cmd.AddValue(\n        \"muSchedAccessReqInterval\",\n        \"Duration of the interval between two requests for channel access made by the MU scheduler\",\n        accessReqInterval);\n    cmd.AddValue(\"mcs\", \"if set, limit testing to a specific MCS (0-11)\", mcs);\n    cmd.AddValue(\"payloadSize\", \"The application payload size in bytes\", payloadSize);\n    cmd.AddValue(\"phyModel\",\n                 \"PHY model to use when OFDMA is disabled (Yans or Spectrum). If 80+80 MHz or \"\n                 \"OFDMA is enabled \"\n                 \"then Spectrum is automatically selected\",\n                 phyModel);\n    cmd.AddValue(\"minExpectedThroughput\",\n                 \"if set, simulation fails if the lowest throughput is below this value\",\n                 minExpectedThroughput);\n    cmd.AddValue(\"maxExpectedThroughput\",\n                 \"if set, simulation fails if the highest throughput is above this value\",\n                 maxExpectedThroughput);\n    cmd.Parse(argc, argv);\n\n    if (useRts)\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"0\"));\n        Config::SetDefault(\"ns3::WifiDefaultProtectionManager::EnableMuRts\", BooleanValue(true));\n    }\n\n    if (dlAckSeqType == \"ACK-SU-FORMAT\")\n    {\n        Config::SetDefault(\"ns3::WifiDefaultAckManager::DlMuAckSequenceType\",\n                           EnumValue(WifiAcknowledgment::DL_MU_BAR_BA_SEQUENCE));\n    }\n    else if (dlAckSeqType == \"MU-BAR\")\n    {\n        Config::SetDefault(\"ns3::WifiDefaultAckManager::DlMuAckSequenceType\",\n                           EnumValue(WifiAcknowledgment::DL_MU_TF_MU_BAR));\n    }\n    else if (dlAckSeqType == \"AGGR-MU-BAR\")\n    {\n        Config::SetDefault(\"ns3::WifiDefaultAckManager::DlMuAckSequenceType\",\n                           EnumValue(WifiAcknowledgment::DL_MU_AGGREGATE_TF));\n    }\n    else if (dlAckSeqType != \"NO-OFDMA\")\n    {\n        NS_ABORT_MSG(\"Invalid DL ack sequence type (must be NO-OFDMA, ACK-SU-FORMAT, MU-BAR or \"\n                     \"AGGR-MU-BAR)\");\n    }\n\n    if (phyModel != \"Yans\" && phyModel != \"Spectrum\")\n    {\n        NS_ABORT_MSG(\"Invalid PHY model (must be Yans or Spectrum)\");\n    }\n    if (use80Plus80 || (dlAckSeqType != \"NO-OFDMA\"))\n    {\n        // SpectrumWifiPhy is required for 80+80 MHz and OFDMA\n        phyModel = \"Spectrum\";\n    }\n\n    double prevThroughput[12] = {0};\n\n    std::cout << \"MCS value\"\n              << \"\\t\\t\"\n              << \"Channel width\"\n              << \"\\t\\t\"\n              << \"GI\"\n              << \"\\t\\t\\t\"\n              << \"Throughput\" << '\\n';\n    int minMcs = 0;\n    int maxMcs = 11;\n    if (mcs >= 0 && mcs <= 11)\n    {\n        minMcs = mcs;\n        maxMcs = mcs;\n    }\n    for (int mcs = minMcs; mcs <= maxMcs; mcs++)\n    {\n        uint8_t index = 0;\n        double previous = 0;\n        uint8_t maxChannelWidth = frequency == 2.4 ? 40 : 160;\n        int minGi = enableUlOfdma ? 1600 : 800;\n        for (int channelWidth = 20; channelWidth <= maxChannelWidth;) // MHz\n        {\n            const auto is80Plus80 = (use80Plus80 && (channelWidth == 160));\n            const std::string widthStr = is80Plus80 ? \"80+80\" : std::to_string(channelWidth);\n            const auto segmentWidthStr = is80Plus80 ? \"80\" : widthStr;\n            for (int gi = 3200; gi >= minGi;) // Nanoseconds\n            {\n                if (!udp)\n                {\n                    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n                }\n\n                NodeContainer wifiStaNodes;\n                wifiStaNodes.Create(nStations);\n                NodeContainer wifiApNode;\n                wifiApNode.Create(1);\n\n                NetDeviceContainer apDevice;\n                NetDeviceContainer staDevices;\n                WifiMacHelper mac;\n                WifiHelper wifi;\n                std::string channelStr(\"{0, \" + segmentWidthStr + \", \");\n                StringValue ctrlRate;\n                auto nonHtRefRateMbps = HePhy::GetNonHtReferenceRate(mcs) / 1e6;\n\n                std::ostringstream ossDataMode;\n                ossDataMode << \"HeMcs\" << mcs;\n\n                if (frequency == 6)\n                {\n                    ctrlRate = StringValue(ossDataMode.str());\n                    channelStr += \"BAND_6GHZ, 0}\";\n                    Config::SetDefault(\"ns3::LogDistancePropagationLossModel::ReferenceLoss\",\n                                       DoubleValue(48));\n                }\n                else if (frequency == 5)\n                {\n                    std::ostringstream ossControlMode;\n                    ossControlMode << \"OfdmRate\" << nonHtRefRateMbps << \"Mbps\";\n                    ctrlRate = StringValue(ossControlMode.str());\n                    channelStr += \"BAND_5GHZ, 0}\";\n                }\n                else if (frequency == 2.4)\n                {\n                    std::ostringstream ossControlMode;\n                    ossControlMode << \"ErpOfdmRate\" << nonHtRefRateMbps << \"Mbps\";\n                    ctrlRate = StringValue(ossControlMode.str());\n                    channelStr += \"BAND_2_4GHZ, 0}\";\n                    Config::SetDefault(\"ns3::LogDistancePropagationLossModel::ReferenceLoss\",\n                                       DoubleValue(40));\n                }\n                else\n                {\n                    NS_FATAL_ERROR(\"Wrong frequency value!\");\n                }\n\n                if (is80Plus80)\n                {\n                    channelStr += std::string(\";\") + channelStr;\n                }\n\n                wifi.SetStandard(WIFI_STANDARD_80211ax);\n                wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                             \"DataMode\",\n                                             StringValue(ossDataMode.str()),\n                                             \"ControlMode\",\n                                             ctrlRate);\n                // Set guard interval\n                wifi.ConfigHeOptions(\"GuardInterval\", TimeValue(NanoSeconds(gi)));\n\n                Ssid ssid = Ssid(\"ns3-80211ax\");\n\n                if (phyModel == \"Spectrum\")\n                {\n                    auto spectrumChannel = CreateObject<MultiModelSpectrumChannel>();\n\n                    auto lossModel = CreateObject<LogDistancePropagationLossModel>();\n                    spectrumChannel->AddPropagationLossModel(lossModel);\n\n                    SpectrumWifiPhyHelper phy;\n                    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n                    phy.SetChannel(spectrumChannel);\n\n                    mac.SetType(\"ns3::StaWifiMac\",\n                                \"Ssid\",\n                                SsidValue(ssid),\n                                \"MpduBufferSize\",\n                                UintegerValue(useExtendedBlockAck ? 256 : 64));\n                    phy.Set(\"ChannelSettings\", StringValue(channelStr));\n                    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n                    if (dlAckSeqType != \"NO-OFDMA\")\n                    {\n                        mac.SetMultiUserScheduler(\"ns3::RrMultiUserScheduler\",\n                                                  \"EnableUlOfdma\",\n                                                  BooleanValue(enableUlOfdma),\n                                                  \"EnableBsrp\",\n                                                  BooleanValue(enableBsrp),\n                                                  \"AccessReqInterval\",\n                                                  TimeValue(accessReqInterval));\n                    }\n                    mac.SetType(\"ns3::ApWifiMac\",\n                                \"EnableBeaconJitter\",\n                                BooleanValue(false),\n                                \"Ssid\",\n                                SsidValue(ssid));\n                    apDevice = wifi.Install(phy, mac, wifiApNode);\n                }\n                else\n                {\n                    auto channel = YansWifiChannelHelper::Default();\n                    YansWifiPhyHelper phy;\n                    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n                    phy.SetChannel(channel.Create());\n\n                    mac.SetType(\"ns3::StaWifiMac\",\n                                \"Ssid\",\n                                SsidValue(ssid),\n                                \"MpduBufferSize\",\n                                UintegerValue(useExtendedBlockAck ? 256 : 64));\n                    phy.Set(\"ChannelSettings\", StringValue(channelStr));\n                    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n                    mac.SetType(\"ns3::ApWifiMac\",\n                                \"EnableBeaconJitter\",\n                                BooleanValue(false),\n                                \"Ssid\",\n                                SsidValue(ssid));\n                    apDevice = wifi.Install(phy, mac, wifiApNode);\n                }\n\n                int64_t streamNumber = 150;\n                streamNumber += WifiHelper::AssignStreams(apDevice, streamNumber);\n                streamNumber += WifiHelper::AssignStreams(staDevices, streamNumber);\n\n                // mobility.\n                MobilityHelper mobility;\n                Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n                positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n                positionAlloc->Add(Vector(distance, 0.0, 0.0));\n                mobility.SetPositionAllocator(positionAlloc);\n\n                mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n                mobility.Install(wifiApNode);\n                mobility.Install(wifiStaNodes);\n\n                /* Internet stack*/\n                InternetStackHelper stack;\n                stack.Install(wifiApNode);\n                stack.Install(wifiStaNodes);\n                streamNumber += stack.AssignStreams(wifiApNode, streamNumber);\n                streamNumber += stack.AssignStreams(wifiStaNodes, streamNumber);\n\n                Ipv4AddressHelper address;\n                address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n                Ipv4InterfaceContainer staNodeInterfaces;\n                Ipv4InterfaceContainer apNodeInterface;\n\n                staNodeInterfaces = address.Assign(staDevices);\n                apNodeInterface = address.Assign(apDevice);\n\n                /* Setting applications */\n                ApplicationContainer serverApp;\n                auto serverNodes = downlink ? std::ref(wifiStaNodes) : std::ref(wifiApNode);\n                Ipv4InterfaceContainer serverInterfaces;\n                NodeContainer clientNodes;\n                for (std::size_t i = 0; i < nStations; i++)\n                {\n                    serverInterfaces.Add(downlink ? staNodeInterfaces.Get(i)\n                                                  : apNodeInterface.Get(0));\n                    clientNodes.Add(downlink ? wifiApNode.Get(0) : wifiStaNodes.Get(i));\n                }\n\n                const auto maxLoad =\n                    HePhy::GetDataRate(mcs, channelWidth, NanoSeconds(gi), 1) / nStations;\n                if (udp)\n                {\n                    // UDP flow\n                    uint16_t port = 9;\n                    UdpServerHelper server(port);\n                    serverApp = server.Install(serverNodes.get());\n                    streamNumber += server.AssignStreams(serverNodes.get(), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n                    const auto packetInterval = payloadSize * 8.0 / maxLoad;\n\n                    for (std::size_t i = 0; i < nStations; i++)\n                    {\n                        UdpClientHelper client(serverInterfaces.GetAddress(i), port);\n                        client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n                        client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n                        client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                        ApplicationContainer clientApp = client.Install(clientNodes.Get(i));\n                        streamNumber += client.AssignStreams(clientNodes.Get(i), streamNumber);\n\n                        clientApp.Start(Seconds(1.0));\n                        clientApp.Stop(simulationTime + Seconds(1.0));\n                    }\n                }\n                else\n                {\n                    // TCP flow\n                    uint16_t port = 50000;\n                    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n                    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n                    serverApp = packetSinkHelper.Install(serverNodes.get());\n                    streamNumber += packetSinkHelper.AssignStreams(serverNodes.get(), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n\n                    for (std::size_t i = 0; i < nStations; i++)\n                    {\n                        OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n                        onoff.SetAttribute(\"OnTime\",\n                                           StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n                        onoff.SetAttribute(\"OffTime\",\n                                           StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n                        onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                        onoff.SetAttribute(\"DataRate\", DataRateValue(maxLoad));\n                        AddressValue remoteAddress(\n                            InetSocketAddress(serverInterfaces.GetAddress(i), port));\n                        onoff.SetAttribute(\"Remote\", remoteAddress);\n                        ApplicationContainer clientApp = onoff.Install(clientNodes.Get(i));\n                        streamNumber += onoff.AssignStreams(clientNodes.Get(i), streamNumber);\n\n                        clientApp.Start(Seconds(1.0));\n                        clientApp.Stop(simulationTime + Seconds(1.0));\n                    }\n                }\n\n                Simulator::Schedule(Seconds(0), &Ipv4GlobalRoutingHelper::PopulateRoutingTables);\n\n                Simulator::Stop(simulationTime + Seconds(1.0));\n                Simulator::Run();\n\n                // When multiple stations are used, there are chances that association requests\n                // collide and hence the throughput may be lower than expected. Therefore, we relax\n                // the check that the throughput cannot decrease by introducing a scaling factor (or\n                // tolerance)\n                auto tolerance = 0.10;\n                auto rxBytes = 0.0;\n                if (udp)\n                {\n                    for (uint32_t i = 0; i < serverApp.GetN(); i++)\n                    {\n                        rxBytes +=\n                            payloadSize * DynamicCast<UdpServer>(serverApp.Get(i))->GetReceived();\n                    }\n                }\n                else\n                {\n                    for (uint32_t i = 0; i < serverApp.GetN(); i++)\n                    {\n                        rxBytes += DynamicCast<PacketSink>(serverApp.Get(i))->GetTotalRx();\n                    }\n                }\n                auto throughput = (rxBytes * 8) / simulationTime.GetMicroSeconds(); // Mbit/s\n\n                Simulator::Destroy();\n\n                std::cout << +mcs << \"\\t\\t\\t\" << widthStr << \" MHz\\t\\t\"\n                          << (widthStr.size() > 3 ? \"\" : \"\\t\") << gi << \" ns\\t\\t\\t\" << throughput\n                          << \" Mbit/s\" << std::endl;\n\n                // test first element\n                if (mcs == minMcs && channelWidth == 20 && gi == 3200)\n                {\n                    if (throughput * (1 + tolerance) < minExpectedThroughput)\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                }\n                // test last element\n                if (mcs == maxMcs && channelWidth == maxChannelWidth && gi == 800)\n                {\n                    if (maxExpectedThroughput > 0 &&\n                        throughput > maxExpectedThroughput * (1 + tolerance))\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                }\n                // Skip comparisons with previous cases if more than one stations are present\n                // because, e.g., random collisions in the establishment of Block Ack agreements\n                // have an impact on throughput\n                if (nStations == 1)\n                {\n                    // test previous throughput is smaller (for the same mcs)\n                    if (throughput * (1 + tolerance) > previous)\n                    {\n                        previous = throughput;\n                    }\n                    else if (throughput > 0)\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                    // test previous throughput is smaller (for the same channel width and GI)\n                    if (throughput * (1 + tolerance) > prevThroughput[index])\n                    {\n                        prevThroughput[index] = throughput;\n                    }\n                    else if (throughput > 0)\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                }\n                index++;\n                gi /= 2;\n            }\n            channelWidth *= 2;\n        }\n    }\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a WiFi network in NS-3 with three nodes, where Node 1 is the access point and Node 2 sends UDP packets to Node 3 through the access point. Use a simple grid mobility model, and the simulation should last for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWiFiNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Set up WiFi PHY and MAC\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up WiFi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up WiFi device\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"simple-wifi\");\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set up mobility model (constant position for simplicity)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP client application on Node 2 (sending)\n    uint16_t port = 9;\n    UdpClientHelper udpClient(interfaces.GetAddress(2), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(1));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on Node 3 (receiving)\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(2));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSet up a simple LTE network in NS-3 with two nodes: one as an eNodeB (base station) and the other as a UE (user equipment). The UE sends TCP packets to the eNodeB. Use the default LTE parameters and run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer ueNode;\n    NodeContainer enbNode;\n    ueNode.Create(1);\n    enbNode.Create(1);\n\n    // Install LTE stack\n    LteHelper lte;\n    InternetStackHelper internet;\n    internet.Install(ueNode);\n    internet.Install(enbNode);\n\n    // Set up the eNodeB and UE devices\n    NetDeviceContainer ueDevice;\n    NetDeviceContainer enbDevice;\n    enbDevice = lte.InstallEnbDevice(enbNode);\n    ueDevice = lte.InstallUeDevice(ueNode);\n\n    // Set up IP addressing and assign IP to UE\n    Ipv4InterfaceContainer ueIpInterface;\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ueIpInterface = ipv4h.Assign(ueDevice);\n\n    // Attach UE to eNodeB\n    lte.Attach(ueDevice, enbDevice.Get(0));\n\n    // Set up TCP application on UE (client)\n    uint16_t port = 9;\n    TcpClientHelper tcpClient(ueIpInterface.GetAddress(0), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = tcpClient.Install(enbNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up TCP server application on eNodeB (server)\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(ueNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a sender transmits packets over a wireless (Wi-Fi) network to multiple receivers using multicast communication. The sender should send UDP packets, and the receivers should log the received packets."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpMulticastExample\");\n\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Receiver received a UDP multicast packet!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"WifiUdpMulticastExample\", LOG_LEVEL_INFO);\n\n    uint16_t port = 5000;\n    Ipv4Address multicastGroup(\"225.1.2.3\");\n\n    // Create nodes (1 sender, 2 receivers)\n    NodeContainer nodes;\n    nodes.Create(3);\n    Ptr<Node> sender = nodes.Get(0);\n    Ptr<Node> receiver1 = nodes.Get(1);\n    Ptr<Node> receiver2 = nodes.Get(2);\n\n    // Setup Wi-Fi Network\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\"); // Ad-hoc network\n\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Mobility model (static nodes)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Setup Multicast Routing\n    Ipv4StaticRoutingHelper multicastRouting;\n    Ptr<Ipv4StaticRouting> receiver1Routing = multicastRouting.GetStaticRouting(receiver1->GetObject<Ipv4>());\n    receiver1Routing->AddMulticastRoute(interfaces.GetAddress(0), multicastGroup, 1);\n\n    Ptr<Ipv4StaticRouting> receiver2Routing = multicastRouting.GetStaticRouting(receiver2->GetObject<Ipv4>());\n    receiver2Routing->AddMulticastRoute(interfaces.GetAddress(0), multicastGroup, 1);\n\n    // Setup UDP Receiver (Multicast Group Members)\n    Ptr<Socket> receiverSocket1 = Socket::CreateSocket(receiver1, UdpSocketFactory::GetTypeId());\n    receiverSocket1->Bind(InetSocketAddress(multicastGroup, port));\n    receiverSocket1->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    Ptr<Socket> receiverSocket2 = Socket::CreateSocket(receiver2, UdpSocketFactory::GetTypeId());\n    receiverSocket2->Bind(InetSocketAddress(multicastGroup, port));\n    receiverSocket2->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Sender\n    Ptr<Socket> senderSocket = Socket::CreateSocket(sender, UdpSocketFactory::GetTypeId());\n    InetSocketAddress multicastAddr(multicastGroup, port);\n    multicastAddr.SetTos(0xb8); // Best-effort traffic\n\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, senderSocket, Create<Packet>(128), 0, multicastAddr);\n    Simulator::Schedule(Seconds(2.0), &Socket::SendTo, senderSocket, Create<Packet>(128), 0, multicastAddr);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(5.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network with 2 access points (APs) and 4 stations (STA) using ns-3. Configure the stations to connect to the nearest access point and exchange UDP traffic. Visualize the network and traffic flow using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimulationExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time\n    double simulationTime = 10.0;\n\n    // Create 2 access points and 4 stations (STAs)\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(4);\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(2);\n\n    // Configure the Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up Wi-Fi helper and configure for 802.11n standard\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n\n    WifiMacHelper mac;\n    Ssid ssid1 = Ssid(\"AP1\");\n    Ssid ssid2 = Ssid(\"AP2\");\n\n    // Install Wi-Fi devices on AP nodes (Access Points)\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid1));\n    NetDeviceContainer ap1Devices = wifi.Install(phy, mac, wifiApNodes.Get(0));\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid2));\n    NetDeviceContainer ap2Devices = wifi.Install(phy, mac, wifiApNodes.Get(1));\n\n    // Install Wi-Fi devices on STA nodes (Stations)\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid1));\n    NetDeviceContainer staDevices1 = wifi.Install(phy, mac, wifiStaNodes.Get(0));\n    staDevices1.Add(wifi.Install(phy, mac, wifiStaNodes.Get(1)));\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid2));\n    NetDeviceContainer staDevices2 = wifi.Install(phy, mac, wifiStaNodes.Get(2));\n    staDevices2.Add(wifi.Install(phy, mac, wifiStaNodes.Get(3)));\n\n    // Set up mobility model for APs (fixed)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNodes);\n\n    // Set up mobility for STAs (random)\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(wifiStaNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ap1Interfaces = address.Assign(ap1Devices);\n    Ipv4InterfaceContainer sta1Interfaces = address.Assign(staDevices1);\n\n    address.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ap2Interfaces = address.Assign(ap2Devices);\n    Ipv4InterfaceContainer sta2Interfaces = address.Assign(staDevices2);\n\n    // Create UDP traffic application\n    uint16_t port = 9; // Discard port\n    UdpEchoServerHelper echoServer(port);\n\n    // Install server on STA 1 and STA 3\n    ApplicationContainer serverApps = echoServer.Install(wifiStaNodes.Get(0));\n    serverApps.Add(echoServer.Install(wifiStaNodes.Get(2)));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(simulationTime));\n\n    // Install clients on STA 2 and STA 4 to send packets to STA 1 and STA 3\n    UdpEchoClientHelper echoClient(sta1Interfaces.GetAddress(0), port);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(wifiStaNodes.Get(1));\n    echoClient.SetAttribute(\"RemoteAddress\", AddressValue(sta2Interfaces.GetAddress(0)));\n    clientApps.Add(echoClient.Install(wifiStaNodes.Get(3)));\n\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(simulationTime));\n\n    // Enable NetAnim\n    AnimationInterface anim(\"wifi_netanim.xml\");\n\n    // Set positions for visualization\n    anim.SetConstantPosition(wifiApNodes.Get(0), 0, 0);    // AP1 at origin\n    anim.SetConstantPosition(wifiApNodes.Get(1), 10, 0);   // AP2 at (10,0)\n    anim.SetConstantPosition(wifiStaNodes.Get(0), -5, -5); // STA 1\n    anim.SetConstantPosition(wifiStaNodes.Get(1), 5, -5);  // STA 2\n    anim.SetConstantPosition(wifiStaNodes.Get(2), -5, 5);  // STA 3\n    anim.SetConstantPosition(wifiStaNodes.Get(3), 5, 5);   // STA 4\n\n    anim.EnablePacketMetadata(true); // Enable packet metadata for tracking\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a simulation code in ns-3 to compare the performance of mesh and tree topologies. In the simulation, create a mesh network with 4 nodes and a tree network with 4 nodes. Use UDP traffic applications for both topologies, and measure key performance metrics such as throughput, latency, and packet delivery ratio. Use FlowMonitor to capture statistics and visualize the topologies with NetAnim. Ensure the simulation runs for 20 seconds, and output the final results comparing the two topologies. Animate the node movements and traffic using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MeshVsTreeComparison\");\n\nint main(int argc, char *argv[])\n{\n    // Simulation time\n    double simTime = 20.0;\n\n    // Create nodes\n    NodeContainer meshNodes;\n    meshNodes.Create(4);\n\n    NodeContainer treeNodes;\n    treeNodes.Create(4);\n\n    // Install Internet Stack\n    InternetStackHelper internet;\n    internet.Install(meshNodes);\n    internet.Install(treeNodes);\n\n    // Configure mesh topology\n    MeshHelper mesh;\n    mesh.SetStackInstaller(\"ns3::Dot11sStack\");\n    mesh.SetSpreadInterfaceChannels(MeshHelper::SPREAD_CHANNELS);\n    mesh.SetStandard(WIFI_PHY_STANDARD_80211s);\n    \n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    MeshPointDeviceContainer meshDevices = mesh.Install(wifiPhy, meshNodes);\n    Ipv4AddressHelper addressMesh;\n    addressMesh.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer meshInterfaces = addressMesh.Assign(meshDevices);\n\n    // Configure tree topology\n    Ipv4AddressHelper addressTree;\n    addressTree.SetBase(\"10.2.2.0\", \"255.255.255.0\");\n\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer treeDevices1 = p2p.Install(treeNodes.Get(0), treeNodes.Get(1));\n    NetDeviceContainer treeDevices2 = p2p.Install(treeNodes.Get(0), treeNodes.Get(2));\n    NetDeviceContainer treeDevices3 = p2p.Install(treeNodes.Get(1), treeNodes.Get(3));\n\n    Ipv4InterfaceContainer treeInterfaces1 = addressTree.Assign(treeDevices1);\n    Ipv4InterfaceContainer treeInterfaces2 = addressTree.Assign(treeDevices2);\n    Ipv4InterfaceContainer treeInterfaces3 = addressTree.Assign(treeDevices3);\n\n    // Set mobility models\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(meshNodes);\n    mobility.Install(treeNodes);\n\n    // UDP traffic configuration\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverAppsMesh = udpServer.Install(meshNodes.Get(0));\n    serverAppsMesh.Start(Seconds(1.0));\n    serverAppsMesh.Stop(Seconds(simTime));\n\n    UdpServerHelper udpServerTree(port);\n    ApplicationContainer serverAppsTree = udpServerTree.Install(treeNodes.Get(0));\n    serverAppsTree.Start(Seconds(1.0));\n    serverAppsTree.Stop(Seconds(simTime));\n\n    UdpClientHelper udpClientMesh(meshInterfaces.GetAddress(0), port);\n    udpClientMesh.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClientMesh.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClientMesh.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientAppsMesh = udpClientMesh.Install(meshNodes.Get(1));\n    clientAppsMesh.Start(Seconds(2.0));\n    clientAppsMesh.Stop(Seconds(simTime));\n\n    UdpClientHelper udpClientTree(treeInterfaces1.GetAddress(0), port);\n    udpClientTree.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClientTree.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClientTree.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientAppsTree = udpClientTree.Install(treeNodes.Get(1));\n    clientAppsTree.Start(Seconds(2.0));\n    clientAppsTree.Stop(Seconds(simTime));\n\n    // Set up FlowMonitor to gather statistics\n    FlowMonitorHelper flowMonitorHelper;\n    Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n    // NetAnim setup\n    AnimationInterface anim(\"mesh_vs_tree.xml\");\n    anim.SetConstantPosition(meshNodes.Get(0), 10, 20);\n    anim.SetConstantPosition(meshNodes.Get(1), 20, 30);\n    anim.SetConstantPosition(meshNodes.Get(2), 30, 40);\n    anim.SetConstantPosition(meshNodes.Get(3), 40, 50);\n\n    anim.SetConstantPosition(treeNodes.Get(0), 50, 20);\n    anim.SetConstantPosition(treeNodes.Get(1), 60, 30);\n    anim.SetConstantPosition(treeNodes.Get(2), 70, 40);\n    anim.SetConstantPosition(treeNodes.Get(3), 80, 50);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n\n    // Flow monitor statistics\n    flowMonitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitorHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n\n    for (auto it = stats.begin(); it != stats.end(); ++it)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(it->first);\n        std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n        std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n        std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n        std::cout << \"  Throughput: \" << it->second.rxBytes * 8.0 / simTime / 1000 / 1000 << \" Mbps\" << std::endl;\n        std::cout << \"  Packet Delivery Ratio: \" << (double)it->second.rxPackets / it->second.txPackets * 100 << \"%\" << std::endl;\n    }\n\n    // Clean up\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 simulation library to model an ad hoc wireless network with two nodes. Configure the nodes to use an IEEE 802.11 protocol with ad hoc mode, set up a mobility model that allows nodes to randomly walk within specified bounds, and install the Internet stack on both nodes. Assign IPv4 addresses and implement a UDP echo server on one node and a corresponding client on the other to exchange packets. Utilize the Flow Monitor to collect statistics such as packet delivery ratio, end-to-end delay, and throughput. Additionally, generate an animation file to visualize the network. Ensure to log detailed statistics for the simulation's performance analysis and output the results after the simulation concludes."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"AdhocNetworkExample\");\n\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable (\"AdhocNetworkExample\", LOG_LEVEL_INFO);\n\n  // Create two wireless nodes\n  NodeContainer nodes;\n  nodes.Create (2);\n\n  // Configure wireless parameters\n  WifiHelper wifi;\n\n  WifiMacHelper mac;\n  mac.SetType (\"ns3::AdhocWifiMac\");\n  \n\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n  YansWifiPhyHelper phy;\n  phy.SetChannel(channel.Create());\n  //phy.Set(\"TxPowerStart\", DoubleValue(10.0));\n  //phy.Set(\"TxPowerEnd\", DoubleValue(10.0));\n  //phy.Set(\"TxGain\", DoubleValue(0.0));\n  //phy.Set(\"RxGain\", DoubleValue(0.0));\n\n  \n\n  NetDeviceContainer devices = wifi.Install (phy, mac, nodes);\n  \n\n  // Set up mobility model\n  MobilityHelper mobility;\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0),\n                                 \"MinY\", DoubleValue (0.0),\n                                 \"DeltaX\", DoubleValue (5.0),\n                                 \"DeltaY\", DoubleValue (5.0),\n                                 \"GridWidth\", UintegerValue (2),\n                                 \"LayoutType\", StringValue (\"RowFirst\"));\n                                 \n                                \n  mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue(Rectangle(-25, 25, -25, 25)));\n  mobility.Install (nodes);\n  \n\n  // Set up network stack\n  InternetStackHelper stack;\n  stack.Install (nodes);\n\n  // Assign IPv4 addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  // Create a UDP echo server application on node 1\n  uint16_t port = 9; // well-known echo port number\n  UdpEchoServerHelper server (port);\n  ApplicationContainer serverApps = server.Install (nodes.Get (1));\n  serverApps.Start (Seconds (1.0));\n  serverApps.Stop (Seconds (100.0));\n\n  // Create a UDP echo client application on node 0\n  UdpEchoClientHelper client (interfaces.GetAddress (1), port);\n  client.SetAttribute (\"MaxPackets\", UintegerValue (1));\n  client.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps = client.Install (nodes.Get (0));\n  clientApps.Start (Seconds (2.0));\n  clientApps.Stop (Seconds (100.0));\n  \n  // Define a flow monitor object\n  Ptr<FlowMonitor> flowMonitor;\n  FlowMonitorHelper flowHelper;\n  flowMonitor = flowHelper.InstallAll();\n \n  \n  \n  Simulator::Stop(Seconds(100.0));\n  \n  \n  // Animation\n  AnimationInterface anim(\"two_wireless_nodes.xml\");\n  \n\n  // Run simulation\n  Simulator::Run ();\n  \n  // Calculate packet delivery ratio and end to end delay and throughput\n  uint32_t packetsDelivered = 0;\n  uint32_t totalPackets = 0;\n  double totalDelay = 0;\n  \n  \n  // Retrive the flow statistics\n  FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n  for(auto & it: stats)\n  {\n  \tFlowId flowId = it.first;\n    \tstd::cout << \"Flow \" << flowId << std::endl;\n    \tstd::cout << \" Tx Packets: \" << it.second.txPackets << std::endl;\n    \tstd::cout << \" Tx Bytes: \" << it.second.txBytes << std::endl;\n    \tstd::cout << \" Rx Packets: \" << it.second.rxPackets << std::endl;\n    \tstd::cout << \" Rx Bytes: \" << it.second.rxBytes << std::endl;\n    \t\n  \tif(it.second.rxPackets > 0)\n  \t{\n  \t\tpacketsDelivered += it.second.rxPackets;\n  \t\ttotalPackets += it.second.txPackets;\n  \t\ttotalDelay += (it.second.delaySum.ToDouble(ns3::Time::S) / it.second.rxPackets);\n  \t}\n  }\n  \n  double packetDeliveryRatio = (double) packetsDelivered / totalPackets;\n  double averageEndToEndDelay = totalDelay / packetsDelivered;\n  double throughput = (double) packetsDelivered * 1024 * 8 / (100.0 - 0.0) / 1000000;\n  \n  // Printing the results\n  std::cout << \"Packets Delivered Ratio: \" << packetDeliveryRatio << std::endl;\n  std::cout << \"Average End-to-End Delay: \" << averageEndToEndDelay << std::endl;\n  std::cout << \"Throughput: \" << throughput << std::endl;\n  \n  Simulator::Destroy ();\n\n  return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library to simulate a simple LAN topology with two nodes (n0 and n1) connected via a CSMA link, where n0 sends UDP packets to n1 using IPv6. The receiver (n1) should log incoming packets, including the TCLASS and HOPLIMIT values. The sender (n0) should allow setting socket options for IPv6 TCLASS and HOPLIMIT, and the receiver should be able to process RECVTCLASS and RECVHOPLIMIT options. Include command-line parameters to configure the packet size, number of packets, interval, and IPv6 socket options."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0              n1\n//       |               |\n//       =================\n//              LAN\n//\n// - UDP flows from n0 to n1\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SocketOptionsIpv6\");\n\nvoid\nReceivePacket(Ptr<Socket> socket)\n{\n    NS_LOG_INFO(\"Received one packet!\");\n    Ptr<Packet> packet = socket->Recv();\n    SocketIpv6TclassTag tclassTag;\n    if (packet->RemovePacketTag(tclassTag))\n    {\n        NS_LOG_INFO(\" TCLASS = \" << (uint32_t)tclassTag.GetTclass());\n    }\n    SocketIpv6HopLimitTag hoplimitTag;\n    if (packet->RemovePacketTag(hoplimitTag))\n    {\n        NS_LOG_INFO(\" HOPLIMIT = \" << (uint32_t)hoplimitTag.GetHopLimit());\n    }\n}\n\nstatic void\nSendPacket(Ptr<Socket> socket, uint32_t pktSize, uint32_t pktCount, Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval, &SendPacket, socket, pktSize, pktCount - 1, pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    //\n    // Allow the user to override any of the defaults and the above Bind() at\n    // run-time, via command-line arguments\n    //\n    uint32_t packetSize = 1024;\n    uint32_t packetCount = 10;\n    double packetInterval = 1.0;\n\n    // Socket options for IPv6, currently TCLASS, HOPLIMIT, RECVTCLASS, and RECVHOPLIMIT\n    uint32_t ipv6Tclass = 0;\n    bool ipv6RecvTclass = true;\n    uint32_t ipv6Hoplimit = 0;\n    bool ipv6RecvHoplimit = true;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"PacketSize\", \"Packet size in bytes\", packetSize);\n    cmd.AddValue(\"PacketCount\", \"Number of packets to send\", packetCount);\n    cmd.AddValue(\"Interval\", \"Interval between packets\", packetInterval);\n    cmd.AddValue(\"IPV6_TCLASS\", \"IPV6_TCLASS\", ipv6Tclass);\n    cmd.AddValue(\"IPV6_RECVTCLASS\", \"IPV6_RECVTCLASS\", ipv6RecvTclass);\n    cmd.AddValue(\"IPV6_HOPLIMIT\", \"IPV6_HOPLIMIT\", ipv6Hoplimit);\n    cmd.AddValue(\"IPV6_RECVHOPLIMIT\", \"IPV6_RECVHOPLIMIT\", ipv6RecvHoplimit);\n    cmd.Parse(argc, argv);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer n;\n    n.Create(2);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    Address serverAddress;\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv6AddressHelper ipv6;\n    ipv6.SetBase(\"2001:0000:f00d:cafe::\", Ipv6Prefix(64));\n    Ipv6InterfaceContainer i6 = ipv6.Assign(d);\n    serverAddress = Address(i6.GetAddress(1, 1));\n\n    NS_LOG_INFO(\"Create sockets.\");\n    // Receiver socket on n1\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(n.Get(1), tid);\n    Inet6SocketAddress local = Inet6SocketAddress(Ipv6Address::GetAny(), 4477);\n    recvSink->SetIpv6RecvTclass(ipv6RecvTclass);\n    recvSink->SetIpv6RecvHopLimit(ipv6RecvHoplimit);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Sender socket on n0\n    Ptr<Socket> source = Socket::CreateSocket(n.Get(0), tid);\n    Inet6SocketAddress remote = Inet6SocketAddress(i6.GetAddress(1, 1), 4477);\n    // Set socket options, it is also possible to set the options after the socket has been\n    // created/connected.\n    if (ipv6Tclass != 0)\n    {\n        source->SetIpv6Tclass(ipv6Tclass);\n    }\n\n    if (ipv6Hoplimit > 0)\n    {\n        source->SetIpv6HopLimit(ipv6Hoplimit);\n    }\n    source->Connect(remote);\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"socket-options-ipv6.tr\"));\n    csma.EnablePcapAll(\"socket-options-ipv6\", false);\n\n    // Schedule SendPacket\n    Time interPacketInterval = Seconds(packetInterval);\n    Simulator::ScheduleWithContext(source->GetNode()->GetId(),\n                                   Seconds(1.0),\n                                   &SendPacket,\n                                   source,\n                                   packetSize,\n                                   packetCount,\n                                   interPacketInterval);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where two nodes communicate using TCP over a point-to-point link. The client should send a small amount of data to the server using a TCP socket. The server should log the reception. Keep the setup minimal and the simulation short."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MinimalTcpExample\");\n\nint main() {\n    LogComponentEnable(\"MinimalTcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes (client and server)\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up a point-to-point connection\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    uint16_t port = 5000; // TCP port\n\n    // Setup TCP Server on node 1\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = sink.Install(nodes.Get(1));\n    serverApp.Start(Seconds(0.0));\n    serverApp.Stop(Seconds(2.0));\n\n    // Setup TCP Client on node 0\n    OnOffHelper client(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    client.SetConstantRate(DataRate(\"1Mbps\"), 512); // Send 512-byte packets\n    ApplicationContainer clientApp = client.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(2.0));\n\n    // Run the simulation\n    Simulator::Stop(Seconds(2.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a simulation program using the ns-3 network simulator to experiment with 802.11ax spatial reuse mechanisms. The scenario should involve two Basic Service Sets (BSS) represented by two access points (AP1, AP2) and their corresponding stations (STA1, STA2), each transmitting data with configurable parameters like distance (d1, d2, d3), transmit power, CCA-ED thresholds, and OBSS-PD thresholds. The prompt should explain that STA1 sends data to AP1, while STA2 sends to AP2, both continuously transmitting with specified traffic loads (intervals, packet size). OBSS-PD spatial reuse, which allows stations to ignore transmissions below a certain threshold, can be enabled or disabled, affecting the throughput. The model should support dynamic configuration through command-line arguments, logging reset events related to spatial reuse in text files, and output the resulting throughput of each BSS at the end of the simulation. The simulation should also include appropriate channel configuration, such as handling varying channel widths (20 MHz, 40 MHz, 80 MHz), and the corresponding effects on RSSI and collision probability."}, {"role": "assistant", "content": "//  This example program can be used to experiment with spatial\n//  reuse mechanisms of 802.11ax.\n//\n//  The geometry is as follows:\n//\n//                STA1          STA2\n//                 |              |\n//              d1 |              |d2\n//                 |       d3     |\n//                AP1 -----------AP2\n//\n//  STA1 and AP1 are in one BSS (with color set to 1), while STA2 and AP2 are in\n//  another BSS (with color set to 2). The distances are configurable (d1 through d3).\n//\n//  STA1 is continuously transmitting data to AP1, while STA2 is continuously sending data to AP2.\n//  Each STA has configurable traffic loads (inter packet interval and packet size).\n//  It is also possible to configure TX power per node as well as their CCA-ED thresholds.\n//  OBSS_PD spatial reuse feature can be enabled (default) or disabled, and the OBSS_PD\n//  threshold can be set as well (default: -72 dBm).\n//  A simple Friis path loss model is used and a constant PHY rate is considered.\n//\n//  In general, the program can be configured at run-time by passing command-line arguments.\n//  The following command will display all of the available run-time help options:\n//    ./ns3 run \"wifi-spatial-reuse --help\"\n//\n//  According to the Wi-Fi models of ns-3.36 release, throughput with\n//  OBSS PD enabled (--enableObssPd=True) was roughly 6.5 Mbps, and with\n//  it disabled (--enableObssPd=False) was roughly 3.5 Mbps.\n//\n//  This difference between those results is because OBSS_PD spatial\n//  reuse enables to ignore transmissions from another BSS when the\n//  received power is below the configured threshold, and therefore\n//  either defer during ongoing transmission or transmit at the same\n//  time.\n//\n//  Note that, by default, this script configures a network using a\n//  channel width of 20 MHz. Changing this value alone (through\n//  the --channelWidth argument) without properly adjusting other\n//  parameters will void the effect of spatial reuse: since energy is\n//  measured over the 20 MHz primary channel regardless of the channel\n//  width, doubling the transmission bandwidth creates a 3 dB drop in\n//  the measured energy level (i.e., a halving of the measured\n//  energy). Because of this, when using the channelWidth argument\n//  users should also adjust the CCA-ED Thresholds (via --ccaEdTrSta1,\n//  --ccaEdTrSta2, --ccaEdTrAp1, and --ccaEdTrAp2), the Minimum RSSI\n//  for preamble detection (via --minimumRssi), and the OBSS PD\n//  Threshold (via --obssPdThreshold) appropriately. For instance,\n//  this can be accomplished for a channel width of 40 MHz by lowering\n//  all these values by 3 dB compared to their defaults.\n//\n//  In addition, consider that adapting the adjustments shown above\n//  for an 80 MHz channel width (using a 6 dB threshold adjustment instead\n//  of 3 dB) will not produce any changes when enableObssPd is enabled\n//  or disabled. The cause for this is the insufficient amount of\n//  traffic that is generated by default in the example: increasing\n//  the channel width shortens the frame durations, and lowers the\n//  collision probability. Collisions between BSSs are a necessary\n//  condition to see the improvements brought by spatial reuse, and\n//  thus increasing the amount of generated traffic by setting the\n//  interval argument to a lower value is necessary to see the\n//  benefits of spatial reuse in this scenario. This can, for\n//  instance, be accomplished by setting --interval=100us.\n//\n//  Spatial reuse reset events are traced in two text files:\n//  - wifi-spatial-reuse-resets-bss-1.txt (for STA 1)\n//  - wifi-spatial-reuse-resets-bss-2.txt (for STA 2)\n\n#include \"ns3/abort.h\"\n#include \"ns3/ap-wifi-mac.h\"\n#include \"ns3/application-container.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/he-configuration.h\"\n#include \"ns3/he-phy.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/obss-pd-algorithm.h\"\n#include \"ns3/packet-socket-client.h\"\n#include \"ns3/packet-socket-helper.h\"\n#include \"ns3/packet-socket-server.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/wifi-net-device.h\"\n\nusing namespace ns3;\n\nstd::vector<uint32_t> bytesReceived(4);\nstd::ofstream g_resetFile1;\nstd::ofstream g_resetFile2;\n\nuint32_t\nContextToNodeId(std::string context)\n{\n    std::string sub = context.substr(10);\n    uint32_t pos = sub.find(\"/Device\");\n    return std::stoi(sub.substr(0, pos));\n}\n\nvoid\nSocketRx(std::string context, Ptr<const Packet> p, const Address& addr)\n{\n    uint32_t nodeId = ContextToNodeId(context);\n    bytesReceived[nodeId] += p->GetSize();\n}\n\nvoid\nResetTrace(std::string context,\n           uint8_t bssColor,\n           double rssiDbm,\n           bool powerRestricted,\n           double txPowerMaxDbmSiso,\n           double txPowerMaxDbmMimo)\n{\n    if (context == \"1\")\n    {\n        g_resetFile1 << Simulator::Now().GetSeconds() << \" bssColor: \" << +bssColor\n                     << \" rssiDbm: \" << rssiDbm << \" powerRestricted: \" << powerRestricted\n                     << \" txPowerMaxDbmSiso: \" << txPowerMaxDbmSiso\n                     << \" txPowerMaxDbmMimo: \" << txPowerMaxDbmMimo << std::endl;\n    }\n    else if (context == \"2\")\n    {\n        g_resetFile2 << Simulator::Now().GetSeconds() << \" bssColor: \" << +bssColor\n                     << \" rssiDbm: \" << rssiDbm << \" powerRestricted: \" << powerRestricted\n                     << \" txPowerMaxDbmSiso: \" << txPowerMaxDbmSiso\n                     << \" txPowerMaxDbmMimo: \" << txPowerMaxDbmMimo << std::endl;\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Unknown context \" << context);\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    Time duration{\"10s\"};\n    meter_u d1{30.0};\n    meter_u d2{30.0};\n    meter_u d3{150.0};\n    dBm_u powSta1{10.0};\n    dBm_u powSta2{10.0};\n    dBm_u powAp1{21.0};\n    dBm_u powAp2{21.0};\n    dBm_u ccaEdTrSta1{-62};\n    dBm_u ccaEdTrSta2{-62};\n    dBm_u ccaEdTrAp1{-62};\n    dBm_u ccaEdTrAp2{-62};\n    dBm_u minimumRssi{-82};\n    int channelWidth{20};       // MHz\n    uint32_t payloadSize{1500}; // bytes\n    uint32_t mcs{0};            // MCS value\n    Time interval{\"1ms\"};\n    bool enableObssPd{true};\n    dBm_u obssPdThreshold{-72.0};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"duration\", \"Duration of simulation\", duration);\n    cmd.AddValue(\"interval\", \"Inter packet interval\", interval);\n    cmd.AddValue(\"enableObssPd\", \"Enable/disable OBSS_PD\", enableObssPd);\n    cmd.AddValue(\"d1\", \"Distance between STA1 and AP1 (m)\", d1);\n    cmd.AddValue(\"d2\", \"Distance between STA2 and AP2 (m)\", d2);\n    cmd.AddValue(\"d3\", \"Distance between AP1 and AP2 (m)\", d3);\n    cmd.AddValue(\"powSta1\", \"Power of STA1 (dBm)\", powSta1);\n    cmd.AddValue(\"powSta2\", \"Power of STA2 (dBm)\", powSta2);\n    cmd.AddValue(\"powAp1\", \"Power of AP1 (dBm)\", powAp1);\n    cmd.AddValue(\"powAp2\", \"Power of AP2 (dBm)\", powAp2);\n    cmd.AddValue(\"ccaEdTrSta1\", \"CCA-ED Threshold of STA1 (dBm)\", ccaEdTrSta1);\n    cmd.AddValue(\"ccaEdTrSta2\", \"CCA-ED Threshold of STA2 (dBm)\", ccaEdTrSta2);\n    cmd.AddValue(\"ccaEdTrAp1\", \"CCA-ED Threshold of AP1 (dBm)\", ccaEdTrAp1);\n    cmd.AddValue(\"ccaEdTrAp2\", \"CCA-ED Threshold of AP2 (dBm)\", ccaEdTrAp2);\n    cmd.AddValue(\"minimumRssi\",\n                 \"Minimum RSSI for the ThresholdPreambleDetectionModel\",\n                 minimumRssi);\n    cmd.AddValue(\"channelWidth\", \"Bandwidth of the channel in MHz [20, 40, or 80]\", channelWidth);\n    cmd.AddValue(\"obssPdThreshold\", \"Threshold for the OBSS PD Algorithm\", obssPdThreshold);\n    cmd.AddValue(\"mcs\", \"The constant MCS value to transmit HE PPDUs\", mcs);\n    cmd.Parse(argc, argv);\n\n    g_resetFile1.open(\"wifi-spatial-reuse-resets-bss-1.txt\", std::ofstream::out);\n    g_resetFile2.open(\"wifi-spatial-reuse-resets-bss-2.txt\", std::ofstream::out);\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(2);\n\n    SpectrumWifiPhyHelper spectrumPhy;\n    Ptr<MultiModelSpectrumChannel> spectrumChannel = CreateObject<MultiModelSpectrumChannel>();\n    Ptr<FriisPropagationLossModel> lossModel = CreateObject<FriisPropagationLossModel>();\n    spectrumChannel->AddPropagationLossModel(lossModel);\n    Ptr<ConstantSpeedPropagationDelayModel> delayModel =\n        CreateObject<ConstantSpeedPropagationDelayModel>();\n    spectrumChannel->SetPropagationDelayModel(delayModel);\n\n    spectrumPhy.SetChannel(spectrumChannel);\n    spectrumPhy.SetErrorRateModel(\"ns3::YansErrorRateModel\");\n    switch (channelWidth)\n    {\n    case 20:\n        spectrumPhy.Set(\"ChannelSettings\", StringValue(\"{36, 20, BAND_5GHZ, 0}\"));\n        break;\n    case 40:\n        spectrumPhy.Set(\"ChannelSettings\", StringValue(\"{62, 40, BAND_5GHZ, 0}\"));\n        break;\n    case 80:\n        spectrumPhy.Set(\"ChannelSettings\", StringValue(\"{171, 80, BAND_5GHZ, 0}\"));\n        break;\n    default:\n        NS_ABORT_MSG(\"Unrecognized channel width: \" << channelWidth);\n        break;\n    }\n    spectrumPhy.SetPreambleDetectionModel(\"ns3::ThresholdPreambleDetectionModel\",\n                                          \"MinimumRssi\",\n                                          DoubleValue(minimumRssi));\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211ax);\n    if (enableObssPd)\n    {\n        wifi.SetObssPdAlgorithm(\"ns3::ConstantObssPdAlgorithm\",\n                                \"ObssPdLevel\",\n                                DoubleValue(obssPdThreshold));\n    }\n\n    WifiMacHelper mac;\n    std::ostringstream oss;\n    oss << \"HeMcs\" << mcs;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(oss.str()),\n                                 \"ControlMode\",\n                                 StringValue(oss.str()));\n\n    spectrumPhy.Set(\"TxPowerStart\", DoubleValue(powSta1));\n    spectrumPhy.Set(\"TxPowerEnd\", DoubleValue(powSta1));\n    spectrumPhy.Set(\"CcaEdThreshold\", DoubleValue(ccaEdTrSta1));\n    spectrumPhy.Set(\"RxSensitivity\", DoubleValue(-92.0));\n\n    Ssid ssidA = Ssid(\"A\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssidA));\n    NetDeviceContainer staDeviceA = wifi.Install(spectrumPhy, mac, wifiStaNodes.Get(0));\n\n    spectrumPhy.Set(\"TxPowerStart\", DoubleValue(powAp1));\n    spectrumPhy.Set(\"TxPowerEnd\", DoubleValue(powAp1));\n    spectrumPhy.Set(\"CcaEdThreshold\", DoubleValue(ccaEdTrAp1));\n    spectrumPhy.Set(\"RxSensitivity\", DoubleValue(-92.0));\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssidA));\n    NetDeviceContainer apDeviceA = wifi.Install(spectrumPhy, mac, wifiApNodes.Get(0));\n\n    Ptr<WifiNetDevice> apDevice = apDeviceA.Get(0)->GetObject<WifiNetDevice>();\n    Ptr<ApWifiMac> apWifiMac = apDevice->GetMac()->GetObject<ApWifiMac>();\n    if (enableObssPd)\n    {\n        apDevice->GetHeConfiguration()->SetAttribute(\"BssColor\", UintegerValue(1));\n    }\n\n    spectrumPhy.Set(\"TxPowerStart\", DoubleValue(powSta2));\n    spectrumPhy.Set(\"TxPowerEnd\", DoubleValue(powSta2));\n    spectrumPhy.Set(\"CcaEdThreshold\", DoubleValue(ccaEdTrSta2));\n    spectrumPhy.Set(\"RxSensitivity\", DoubleValue(-92.0));\n\n    Ssid ssidB = Ssid(\"B\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssidB));\n    NetDeviceContainer staDeviceB = wifi.Install(spectrumPhy, mac, wifiStaNodes.Get(1));\n\n    spectrumPhy.Set(\"TxPowerStart\", DoubleValue(powAp2));\n    spectrumPhy.Set(\"TxPowerEnd\", DoubleValue(powAp2));\n    spectrumPhy.Set(\"CcaEdThreshold\", DoubleValue(ccaEdTrAp2));\n    spectrumPhy.Set(\"RxSensitivity\", DoubleValue(-92.0));\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssidB));\n    NetDeviceContainer apDeviceB = wifi.Install(spectrumPhy, mac, wifiApNodes.Get(1));\n\n    Ptr<WifiNetDevice> ap2Device = apDeviceB.Get(0)->GetObject<WifiNetDevice>();\n    apWifiMac = ap2Device->GetMac()->GetObject<ApWifiMac>();\n    if (enableObssPd)\n    {\n        ap2Device->GetHeConfiguration()->SetAttribute(\"BssColor\", UintegerValue(2));\n    }\n\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0)); // AP1\n    positionAlloc->Add(Vector(d3, 0.0, 0.0));  // AP2\n    positionAlloc->Add(Vector(0.0, d1, 0.0));  // STA1\n    positionAlloc->Add(Vector(d3, d2, 0.0));   // STA2\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(wifiApNodes);\n    mobility.Install(wifiStaNodes);\n\n    PacketSocketHelper packetSocket;\n    packetSocket.Install(wifiApNodes);\n    packetSocket.Install(wifiStaNodes);\n    ApplicationContainer apps;\n\n    // BSS 1\n    {\n        PacketSocketAddress socketAddr;\n        socketAddr.SetSingleDevice(staDeviceA.Get(0)->GetIfIndex());\n        socketAddr.SetPhysicalAddress(apDeviceA.Get(0)->GetAddress());\n        socketAddr.SetProtocol(1);\n        Ptr<PacketSocketClient> client = CreateObject<PacketSocketClient>();\n        client->SetRemote(socketAddr);\n        wifiStaNodes.Get(0)->AddApplication(client);\n        client->SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n        client->SetAttribute(\"MaxPackets\", UintegerValue(0));\n        client->SetAttribute(\"Interval\", TimeValue(interval));\n        Ptr<PacketSocketServer> server = CreateObject<PacketSocketServer>();\n        server->SetLocal(socketAddr);\n        wifiApNodes.Get(0)->AddApplication(server);\n    }\n\n    // BSS 2\n    {\n        PacketSocketAddress socketAddr;\n        socketAddr.SetSingleDevice(staDeviceB.Get(0)->GetIfIndex());\n        socketAddr.SetPhysicalAddress(apDeviceB.Get(0)->GetAddress());\n        socketAddr.SetProtocol(1);\n        Ptr<PacketSocketClient> client = CreateObject<PacketSocketClient>();\n        client->SetRemote(socketAddr);\n        wifiStaNodes.Get(1)->AddApplication(client);\n        client->SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n        client->SetAttribute(\"MaxPackets\", UintegerValue(0));\n        client->SetAttribute(\"Interval\", TimeValue(interval));\n        Ptr<PacketSocketServer> server = CreateObject<PacketSocketServer>();\n        server->SetLocal(socketAddr);\n        wifiApNodes.Get(1)->AddApplication(server);\n    }\n\n    Config::Connect(\"/NodeList/*/ApplicationList/*/$ns3::PacketSocketServer/Rx\",\n                    MakeCallback(&SocketRx));\n\n    // Obtain pointers to the ObssPdAlgorithm objects and hook trace sinks\n    // to the Reset trace source on each STA.  Note that this trace connection\n    // cannot be done through the Config path system, so pointers are used.\n    auto deviceA = staDeviceA.Get(0)->GetObject<WifiNetDevice>();\n    auto hePhyA = DynamicCast<HePhy>(deviceA->GetPhy()->GetPhyEntity(WIFI_MOD_CLASS_HE));\n    // Pass in the context string \"1\" to allow the trace to distinguish objects\n    hePhyA->GetObssPdAlgorithm()->TraceConnect(\"Reset\", \"1\", MakeCallback(&ResetTrace));\n    auto deviceB = staDeviceB.Get(0)->GetObject<WifiNetDevice>();\n    auto hePhyB = DynamicCast<HePhy>(deviceB->GetPhy()->GetPhyEntity(WIFI_MOD_CLASS_HE));\n    // Pass in the context string \"2\" to allow the trace to distinguish objects\n    hePhyB->GetObssPdAlgorithm()->TraceConnect(\"Reset\", \"2\", MakeCallback(&ResetTrace));\n\n    Simulator::Stop(duration);\n    Simulator::Run();\n\n    Simulator::Destroy();\n\n    for (uint32_t i = 0; i < 2; i++)\n    {\n        const auto throughput = bytesReceived[2 + i] * 8.0 / duration.GetMicroSeconds();\n        std::cout << \"Throughput for BSS \" << i + 1 << \": \" << throughput << \" Mbit/s\" << std::endl;\n    }\n\n    g_resetFile1.close();\n    g_resetFile2.close();\n\n    return 0;\n}"}]}
{"messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate an ad-hoc wireless network with five nodes using the AODV routing protocol in NS-3. The nodes are randomly placed in a 100x100 meter area and communicate wirelessly. One node acts as a server, while another node acts as a client, sending UDP packets to the server. Track the dynamic creation of routes using AODV and enable packet tracing to observe the packet flow."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/aodv-helper.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AodvAdhocExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for AODV and related components\n    LogComponentEnable(\"AodvAdhocExample\", LOG_LEVEL_INFO);\n\n    // Number of nodes\n    uint32_t numNodes = 5;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(numNodes);\n\n    // Set up wireless devices using the Wi-Fi standard\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Assign mobility to nodes, randomly placing them in a 100x100 meter area\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install AODV as the routing protocol\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ifaces = ipv4.Assign(devices);\n\n    // Set up a UDP server on node 4\n    uint16_t port = 9;\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(4));  // Server on node 4\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP client on node 0 to communicate with node 4 (server)\n    UdpEchoClientHelper echoClient(ifaces.GetAddress(4), port);  // Node 0 communicates with node 4\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));  // Client on node 0\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable pcap tracing to observe packet transmission\n    wifiPhy.EnablePcapAll(\"aodv-adhoc\");\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
