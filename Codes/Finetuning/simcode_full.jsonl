{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an NS-3 simulation in C++ that models a simple point-to-point network consisting of two nodes connected directly to each other. The link between the nodes should have a data transmission rate of 5 Mbps and a propagation delay of 2 milliseconds. The nodes should use standard Internet protocols for communication. Assign IP addresses to both nodes, and configure one node to act as a UDP echo server listening on port 9, while the other node should act as a UDP echo client. The server should start at 1 second and stop at 10 seconds, while the client should start at 2 seconds, sending a single 1024-byte message to the server. After receiving the message, the server should send the message back to the client. Additionally, capture the network traffic in a `.pcap` file for analysis. The simulation should run for 10 seconds, concluding after all messages are exchanged."}, {"role": "assistant", "content": "/* -*- Mode:C++; c-file-style:\"gnu\"; indent-tabs-mode:nil; -*- */\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"FirstScriptExample\");\n\nint main(int argc, char *argv[])\n{\n  CommandLine cmd;\n  cmd.Parse(argc, argv);\n\n  // Create two nodes\n  NodeContainer nodes;\n  nodes.Create(2);\n\n  // Set up the point-to-point link between the two nodes\n  PointToPointHelper pointToPoint;\n  pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5 Mbps\"));\n  pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2 ms\"));\n\n  // Install network devices on the nodes\n  NetDeviceContainer devices;\n  devices = pointToPoint.Install(nodes);\n\n  // Install the Internet stack (IP protocol)\n  InternetStackHelper stack;\n  stack.Install(nodes);\n\n  // Assign IP addresses to the devices\n  Ipv4AddressHelper address;\n  address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n  // Create a UDP echo server on node 1\n  UdpEchoServerHelper echoServer(9);\n  ApplicationContainer serverApps = echoServer.Install(nodes.Get(1));\n  serverApps.Start(Seconds(1.0));\n  serverApps.Stop(Seconds(10.0));\n\n  // Create a UDP echo client on node 0\n  UdpEchoClientHelper echoClient(interfaces.GetAddress(1), 9);\n  echoClient.SetAttribute(\"MaxPackets\", UintegerValue(1));\n  echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n  echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n  ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));\n  clientApps.Start(Seconds(2.0));\n  clientApps.Stop(Seconds(10.0));\n\n  // Enable packet capture\n  pointToPoint.EnablePcapAll(\"simple-point-to-point\");\n\n  // Run the simulation\n  Simulator::Run();\n  Simulator::Destroy();\n\n  return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the NS-3 simulation framework to simulate a network topology where four nodes (n0, n1, n2, n3) are connected to a LAN using CSMA. The program should simulate UDP flows from node n0 to node n1 and back, with a UDP echo server on n1 (port 9) and a UDP echo client on n0. The client sends one 1024-byte packet at 1-second intervals, starting at 2 seconds and stopping at 10 seconds. Include both IPv4 and IPv6 options, allowing the user to choose via command-line arguments. Configure the CSMA channel with a 5 Mbps data rate, 2 ms delay, and 1400-byte MTU. Enable tracing of queue events and packet receptions, saving the results in a file called \"udp-echo.tr\", and also enable pcap tracing. Allow for additional logging for specific sections. Use the required NS-3 modules (applications, core, csma, and internet), and ensure the program runs the simulation with appropriate log outputs."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1   n2   n3\n//       |     |    |    |\n//       =================\n//              LAN\n//\n// - UDP flows from n0 to n1 and back\n// - DropTail queues\n// - Tracing of queues and packet receptions to file \"udp-echo.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpEchoExample\");\n\nint\nmain(int argc, char* argv[])\n{\n//\n// Users may find it convenient to turn on explicit debugging\n// for selected modules; the below lines suggest how to do this\n//\n#if 0\n  LogComponentEnable (\"UdpEchoExample\", LOG_LEVEL_INFO);\n  LogComponentEnable (\"UdpEchoClientApplication\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"UdpEchoServerApplication\", LOG_LEVEL_ALL);\n#endif\n    //\n    // Allow the user to override any of the defaults and the above Bind() at\n    // run-time, via command-line arguments\n    //\n    bool useV6 = false;\n    Address serverAddress;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"useIpv6\", \"Use Ipv6\", useV6);\n    cmd.Parse(argc, argv);\n    //\n    // Explicitly create the nodes required by the topology (shown above).\n    //\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer n;\n    n.Create(4);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    NS_LOG_INFO(\"Create channels.\");\n    //\n    // Explicitly create the channels required by the topology (shown above).\n    //\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    //\n    // We've got the \"hardware\" in place.  Now we need to add IP addresses.\n    //\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    if (!useV6)\n    {\n        Ipv4AddressHelper ipv4;\n        ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer i = ipv4.Assign(d);\n        serverAddress = Address(i.GetAddress(1));\n    }\n    else\n    {\n        Ipv6AddressHelper ipv6;\n        ipv6.SetBase(\"2001:0000:f00d:cafe::\", Ipv6Prefix(64));\n        Ipv6InterfaceContainer i6 = ipv6.Assign(d);\n        serverAddress = Address(i6.GetAddress(1, 1));\n    }\n\n    NS_LOG_INFO(\"Create Applications.\");\n    //\n    // Create a UdpEchoServer application on node one.\n    //\n    uint16_t port = 9; // well-known echo port number\n    UdpEchoServerHelper server(port);\n    ApplicationContainer apps = server.Install(n.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    //\n    // Create a UdpEchoClient application to send UDP datagrams from node zero to\n    // node one.\n    //\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 1;\n    Time interPacketInterval = Seconds(1.);\n    UdpEchoClientHelper client(serverAddress, port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n    apps = client.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n#if 0\n//\n// Users may find it convenient to initialize echo packets with actual data;\n// the below lines suggest how to do this\n//\n  client.SetFill (apps.Get (0), \"Hello World\");\n\n  client.SetFill (apps.Get (0), 0xa5, 1024);\n\n  uint8_t fill[] = { 0, 1, 2, 3, 4, 5, 6};\n  client.SetFill (apps.Get (0), fill, sizeof(fill), 1024);\n#endif\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"udp-echo.tr\"));\n    csma.EnablePcapAll(\"udp-echo\", false);\n\n    //\n    // Now, do the actual simulation.\n    //\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a network simulation code in ns-3 that models two Local Area Networks (LANs) connected by a Wide Area Network (WAN), illustrating how global-router-interface source code supports bridging multiple Layer 2 (L2) switches between Layer 3 (L3) routers. Configure one LAN at the top with subnet 192.168.1/24 and another at the bottom with subnet 192.168.2/24, each connected through a router to a 5Mbit/s, 50ms WAN link (76.1.1.*). On each LAN, implement UDP echo clients and servers for testing connectivity. The \"top\" LAN uses four switches (ts1, ts2, ts3, ts4) and two UDP endpoints (t2 and t3), while the \"bottom\" LAN employs five switches (bs1 to bs5) and two endpoints (b2 and b3). Ensure that t2 communicates with b2 across multiple switches, and t3 with b3 through a single switch, both LANs interconnected via routers (tr and br). Allow for adjustable CSMA link speeds (100Mbit or 10Mbit) using command-line options, and include PCAP trace points at key network locations."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/bridge-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <fstream>\n#include <iostream>\n\nusing namespace ns3;\n\n// ########################################################################\n// Main routine\n// ########################################################################\nNS_LOG_COMPONENT_DEFINE(\"GlobalRoutingMultiSwitchPlusRouter\");\n\n#define vssearch(loc, vec) std::find((vec).begin(), (vec).end(), (loc)) != (vec).end()\n\nint\nmain(int argc, char* argv[])\n{\n    // ----------------------------------------------------------------------\n    // Default values for command line arguments\n    // ----------------------------------------------------------------------\n    bool verbose = true;\n\n    int simDurationSeconds = 60;\n\n    bool enableUdpMultiSW = true;\n    bool enableUdpSingleSW = true;\n\n    std::string pcapLocations = \"\";\n    uint32_t snapLen = PcapFile::SNAPLEN_DEFAULT;\n\n    std::string csmaXLinkDataRate = \"100Mbps\";\n    std::string csmaXLinkDelay = \"500ns\";\n\n    std::string csmaYLinkDataRate = \"10Mbps\";\n    std::string csmaYLinkDelay = \"500ns\";\n\n    std::string p2pLinkDataRate = \"5Mbps\";\n    std::string p2pLinkDelay = \"50ms\";\n\n    uint16_t udpEchoPort = 9; // The well-known UDP echo port\n\n    // ----------------------------------------------------------------------\n    // Create command line options and get them\n    // ----------------------------------------------------------------------\n    CommandLine cmd(__FILE__);\n\n    cmd.Usage(\"NOTE: valid --pcap arguments are: 't2,t3,b2,b3,trlan,trwan,brlan,brwan'\");\n\n    cmd.AddValue(\"verbose\", \"Enable printing informational messages\", verbose);\n\n    cmd.AddValue(\"duration\", \"Duration of simulation.\", simDurationSeconds);\n\n    cmd.AddValue(\"udpMultiSW\", \"Enable udp over multi-switch links\", enableUdpMultiSW);\n    cmd.AddValue(\"udpSingleSW\", \"Enable udp over single-switch links\", enableUdpSingleSW);\n\n    cmd.AddValue(\"pcap\", \"Comma separated list of PCAP Locations to tap\", pcapLocations);\n    cmd.AddValue(\"snapLen\", \"PCAP packet capture length\", snapLen);\n\n    cmd.AddValue(\"csmaXRate\", \"CSMA X Link data rate\", csmaXLinkDataRate);\n    cmd.AddValue(\"csmaXDelay\", \"CSMA X Link delay\", csmaXLinkDelay);\n\n    cmd.AddValue(\"csmaYRate\", \"CSMA Y Link data rate\", csmaYLinkDataRate);\n    cmd.AddValue(\"csmaYDelay\", \"CSMA Y Link delay\", csmaYLinkDelay);\n\n    cmd.AddValue(\"p2pRate\", \"P2P Link data rate\", p2pLinkDataRate);\n    cmd.AddValue(\"p2pDelay\", \"P2P Link delay\", p2pLinkDelay);\n\n    cmd.Parse(argc, argv);\n\n    // --------------------------------------------------------------------\n    // Users may find it convenient to turn on explicit debugging\n    // for selected modules; the below lines suggest how to do this\n    // --------------------------------------------------------------------\n    if (verbose)\n    {\n        LogComponentEnable(\"GlobalRoutingMultiSwitchPlusRouter\", LOG_LEVEL_INFO);\n    }\n\n    // ======================================================================\n    // Define the list of valid PCAP taps\n    // ----------------------------------------------------------------------\n    const std::vector<std::string> pcapTaps{\n        \"t2\",    // multi-switch  UDP echo client\n        \"t3\",    // single-switch UDP echo server\n        \"b2\",    // multi-switch  UDP echo server\n        \"b3\",    // single-switch UDP echo client\n        \"trlan\", // top router    LAN side\n        \"trwan\", // top router    WAN side\n        \"brlan\", // bottom router LAN side\n        \"brwan\", // bottom router WAN side\n    };\n\n    // ----------------------------------------------------------------------\n    // Parse the pcapLocations string into pcapLocationVec\n    // ----------------------------------------------------------------------\n    std::vector<std::string> pcapLocationVec;\n    if (!pcapLocations.empty())\n    {\n        std::stringstream sStream(pcapLocations);\n\n        while (sStream.good())\n        {\n            std::string substr;\n            getline(sStream, substr, ',');\n            if (vssearch(substr, pcapTaps))\n            {\n                pcapLocationVec.push_back(substr);\n            }\n            else\n            {\n                NS_LOG_ERROR(\"WARNING: Unrecognized PCAP location: <\" + substr + \">\");\n            }\n        }\n\n        for (auto ploc = pcapLocationVec.begin(); ploc != pcapLocationVec.end(); ++ploc)\n        {\n            NS_LOG_INFO(\"PCAP capture at: <\" + *ploc + \">\");\n        }\n    }\n\n    // ======================================================================\n    // Set some simulator-wide values\n    // ======================================================================\n\n    // ----------------------------------------------------------------------\n    // Set PCAP packet capture maximum packet length\n    // ----------------------------------------------------------------------\n    if (snapLen != PcapFile::SNAPLEN_DEFAULT)\n    {\n        Config::SetDefault(\"ns3::PcapFileWrapper::CaptureSize\", UintegerValue(snapLen));\n    }\n\n    // ======================================================================\n    // Create the nodes & links required for the topology shown in comments above.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"INFO: Create nodes.\");   // - - - - - - - - - - - - - - - -\n                                          // Node IP     : Description\n                                          // - - - - - - - - - - - - - - - -\n    Ptr<Node> t2 = CreateObject<Node>();  // 192.168.1.2 : Top multi-switch udp echo client\n    Ptr<Node> t3 = CreateObject<Node>();  // 192.168.1.3 : Top single-switch   udp echo server\n                                          //             :\n    Ptr<Node> ts1 = CreateObject<Node>(); // <no IP>     : Top switch #1 (bridge)\n    Ptr<Node> ts2 = CreateObject<Node>(); // <no IP>     : Top switch #2 (bridge)\n    Ptr<Node> ts3 = CreateObject<Node>(); // <no IP>     : Top switch #3 (bridge)\n    Ptr<Node> ts4 = CreateObject<Node>(); // <no IP>     : Top switch #4 (bridge)\n                                          //             :\n    Ptr<Node> tr = CreateObject<Node>();  // 192.168.1.1 : Router connecting top LAN & WAN\n                                          // 76.1.1.1    :\n                                          //             :\n    Ptr<Node> br = CreateObject<Node>();  // 76.1.1.2    : Router connecting WAN & bottom LANs\n                                          // 192.168.2.1 :\n                                          //             :\n    Ptr<Node> bs1 = CreateObject<Node>(); // <no IP>     : Bottom switch #1 (bridge)\n    Ptr<Node> bs2 = CreateObject<Node>(); // <no IP>     : Bottom switch #2 (bridge)\n    Ptr<Node> bs3 = CreateObject<Node>(); // <no IP>     : Bottom switch #3 (bridge)\n    Ptr<Node> bs4 = CreateObject<Node>(); // <no IP>     : Bottom switch #4 (bridge)\n    Ptr<Node> bs5 = CreateObject<Node>(); // <no IP>     : Bottom switch #5 (bridge)\n                                          //             :\n    Ptr<Node> b2 = CreateObject<Node>();  // 192.168.2.2 : Bottom multi-switch udp echo server\n\n    Ptr<Node> b3 = CreateObject<Node>(); // 192.168.2.3 : Bottom single-switch   udp echo client\n                                         // - - - - - - - - - - - - - - - -\n\n    // ----------------------------------------------------------------------\n    // Give the nodes names\n    // ----------------------------------------------------------------------\n    Names::Add(\"t2\", t2);\n    Names::Add(\"t3\", t3);\n    Names::Add(\"ts1\", ts1);\n    Names::Add(\"ts2\", ts2);\n    Names::Add(\"ts3\", ts3);\n    Names::Add(\"ts4\", ts4);\n    Names::Add(\"tr\", tr);\n    Names::Add(\"br\", br);\n    Names::Add(\"bs1\", bs1);\n    Names::Add(\"bs2\", bs2);\n    Names::Add(\"bs3\", bs3);\n    Names::Add(\"bs4\", bs4);\n    Names::Add(\"bs5\", bs5);\n    Names::Add(\"b2\", b2);\n    Names::Add(\"b3\", b3);\n\n    // ======================================================================\n    // Create CSMA links to use for connecting LAN nodes together\n    // ----------------------------------------------------------------------\n\n    // ----------------------------------------\n    // CSMA [X]\n    // ----------------------------------------\n    NS_LOG_INFO(\"L2: Create a \" << csmaXLinkDataRate << \" \" << csmaXLinkDelay\n                                << \" CSMA link for csmaX for LANs.\");\n    CsmaHelper csmaX;\n    csmaX.SetChannelAttribute(\"DataRate\", StringValue(csmaXLinkDataRate));\n    csmaX.SetChannelAttribute(\"Delay\", StringValue(csmaXLinkDelay));\n\n    // ----------------------------------------\n    // CSMA [Y]\n    // ----------------------------------------\n    NS_LOG_INFO(\"L2: Create a \" << csmaYLinkDataRate << \" \" << csmaYLinkDelay\n                                << \" CSMA link for csmaY for LANs.\");\n    CsmaHelper csmaY;\n    csmaY.SetChannelAttribute(\"DataRate\", StringValue(csmaYLinkDataRate));\n    csmaY.SetChannelAttribute(\"Delay\", StringValue(csmaYLinkDelay));\n\n    // ----------------------------------------------------------------------\n    // Now, connect the top LAN nodes together with csma links.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Connect nodes on top LAN together with half-duplex CSMA links.\");\n\n    // Multi-switch top LAN chain: t2-ts4-ts3-ts2-ts1-tr\n    NetDeviceContainer link_t2_ts4 = csmaX.Install(NodeContainer(t2, ts4));\n    NetDeviceContainer link_ts4_ts3 = csmaY.Install(NodeContainer(ts4, ts3));\n    NetDeviceContainer link_ts3_ts2 = csmaX.Install(NodeContainer(ts3, ts2));\n    NetDeviceContainer link_ts2_ts1 = csmaY.Install(NodeContainer(ts2, ts1));\n\n    // Single-switch top LAN link: t3-ts1-tr\n    NetDeviceContainer link_t3_ts1 = csmaX.Install(NodeContainer(t3, ts1));\n\n    // Common link for top LAN between ts1 and tr (for t2 and t3 to get to tr)\n    NetDeviceContainer link_tr_ts1 = csmaY.Install(NodeContainer(tr, ts1));\n\n    // ----------------------------------------------------------------------\n    // And repeat above steps to connect the bottom LAN nodes together\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Connect nodes on bottom LAN together with half-duplex CSMA links.\");\n\n    // Multi-switch bottom LAN chain: b2-bs5-bs4-bs3-bs2-bs1-br\n    NetDeviceContainer link_b2_bs5 = csmaY.Install(NodeContainer(b2, bs5));\n    NetDeviceContainer link_bs5_bs4 = csmaX.Install(NodeContainer(bs5, bs4));\n    NetDeviceContainer link_bs4_bs3 = csmaY.Install(NodeContainer(bs4, bs3));\n    NetDeviceContainer link_bs3_bs2 = csmaX.Install(NodeContainer(bs3, bs2));\n    NetDeviceContainer link_bs2_bs1 = csmaY.Install(NodeContainer(bs2, bs1));\n\n    // Single-switch bottom LAN link: b3-bs1-br\n    NetDeviceContainer link_b3_bs1 = csmaY.Install(NodeContainer(b3, bs1));\n\n    // Common link for bottom LAN between bs1 and br (for b2 and b3 to get to br)\n    NetDeviceContainer link_br_bs1 = csmaX.Install(NodeContainer(br, bs1));\n\n    // ======================================================================\n    // Create a point-to-point link for connecting WAN nodes together\n    // (this type of link is full-duplex)\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Create a \" << p2pLinkDataRate << \" \" << p2pLinkDelay\n                                << \" Point-to-Point link for the WAN.\");\n\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(p2pLinkDataRate));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(p2pLinkDelay));\n\n    // ----------------------------------------------------------------------\n    // Now, connect top router to bottom router with a p2p WAN link\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Connect the routers together with the Point-to-Point WAN link.\");\n\n    NetDeviceContainer link_tr_br;\n    link_tr_br = p2p.Install(NodeContainer(tr, br));\n\n    // ======================================================================\n    // Manually create the list of NetDevices for each switch\n    // ----------------------------------------------------------------------\n\n    // Top Switch 4 NetDevices\n    NetDeviceContainer ts4nd;\n    ts4nd.Add(link_t2_ts4.Get(1));\n    ts4nd.Add(link_ts4_ts3.Get(0));\n\n    // Top Switch 3 NetDevices\n    NetDeviceContainer ts3nd;\n    ts3nd.Add(link_ts4_ts3.Get(1));\n    ts3nd.Add(link_ts3_ts2.Get(0));\n\n    // Top Switch 2 NetDevices\n    NetDeviceContainer ts2nd;\n    ts2nd.Add(link_ts3_ts2.Get(1));\n    ts2nd.Add(link_ts2_ts1.Get(0));\n\n    // Top Switch 1 NetDevices\n    NetDeviceContainer ts1nd;\n    ts1nd.Add(link_ts2_ts1.Get(1));\n    ts1nd.Add(link_t3_ts1.Get(1));\n    ts1nd.Add(link_tr_ts1.Get(1));\n\n    // Bottom Switch 1 NetDevices\n    NetDeviceContainer bs1nd;\n    bs1nd.Add(link_br_bs1.Get(1));\n    bs1nd.Add(link_bs2_bs1.Get(1));\n    bs1nd.Add(link_b3_bs1.Get(1));\n\n    // Bottom Switch 2 NetDevices\n    NetDeviceContainer bs2nd;\n    bs2nd.Add(link_bs2_bs1.Get(0));\n    bs2nd.Add(link_bs3_bs2.Get(1));\n\n    // Bottom Switch 3 NetDevices\n    NetDeviceContainer bs3nd;\n    bs3nd.Add(link_bs3_bs2.Get(0));\n    bs3nd.Add(link_bs4_bs3.Get(1));\n\n    // Bottom Switch 4 NetDevices\n    NetDeviceContainer bs4nd;\n    bs4nd.Add(link_bs4_bs3.Get(0));\n    bs4nd.Add(link_bs5_bs4.Get(1));\n\n    // Bottom Switch 5 NetDevices\n    NetDeviceContainer bs5nd;\n    bs5nd.Add(link_bs5_bs4.Get(0));\n    bs5nd.Add(link_b2_bs5.Get(1));\n\n    // ======================================================================\n    // Install bridging code on each switch\n    // ----------------------------------------------------------------------\n    BridgeHelper bridge;\n\n    bridge.Install(ts1, ts1nd);\n    bridge.Install(ts2, ts2nd);\n    bridge.Install(ts3, ts3nd);\n    bridge.Install(ts4, ts4nd);\n\n    bridge.Install(bs1, bs1nd);\n    bridge.Install(bs2, bs2nd);\n    bridge.Install(bs3, bs3nd);\n    bridge.Install(bs4, bs4nd);\n    bridge.Install(bs5, bs5nd);\n\n    // ======================================================================\n    // Install the L3 internet stack  (TCP/IP)\n    // ----------------------------------------------------------------------\n    InternetStackHelper ns3IpStack;\n\n    // ----------------------------------------------------------------------\n    // Install the L3 internet stack on UDP endpoints\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Install the ns3 IP stack on udp client and server nodes.\");\n    NodeContainer endpointNodes(t2, t3, b2, b3);\n    ns3IpStack.Install(endpointNodes);\n\n    // ----------------------------------------------------------------------\n    // Install the L3 internet stack on routers.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Install the ns3 IP stack on routers.\");\n    NodeContainer routerNodes(tr, br);\n    ns3IpStack.Install(routerNodes);\n\n    // ======================================================================\n    // Assign top LAN IP addresses\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Assign top LAN IP Addresses.\");\n\n    NetDeviceContainer topLanIpDevices;      // - - - - - -- - - - - - -\n    topLanIpDevices.Add(link_tr_ts1.Get(0)); // NOTE: order matters here\n    topLanIpDevices.Add(link_t2_ts4.Get(0)); //       for IP address\n    topLanIpDevices.Add(link_t3_ts1.Get(0)); //       assignment\n                                             // - - - - - -- - - - - - -\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    ipv4.Assign(topLanIpDevices);\n\n    // ----------------------------------------------------------------------\n    // Assign bottom LAN IP addresses\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Assign bottom LAN IP Addresses.\");\n\n    NetDeviceContainer botLanIpDevices;      // - - - - - -- - - - - - -\n    botLanIpDevices.Add(link_br_bs1.Get(0)); // NOTE: order matters here\n    botLanIpDevices.Add(link_b2_bs5.Get(0)); //       for IP address\n    botLanIpDevices.Add(link_b3_bs1.Get(0)); //       assignment\n                                             // - - - - - -- - - - - - -\n\n    ipv4.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    ipv4.Assign(botLanIpDevices);\n\n    // ----------------------------------------------------------------------\n    // Assign WAN IP addresses\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Assign WAN IP Addresses.\");\n\n    ipv4.SetBase(\"76.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(link_tr_br);\n\n    // ======================================================================\n    // Calculate and populate routing tables\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Populate routing tables.\");\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // ======================================================================\n    // Multi-Switch UDP traffic generation\n    // ----------------------------------------------------------------------\n    ApplicationContainer apps;\n\n    if (enableUdpMultiSW)\n    {\n        // ------------------------------------------------------------------\n        // Install multi-switch UDP echo server on b2\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Multi-Switch UDP server (on node b2 of bottom LAN)\");\n\n        UdpEchoServerHelper server(udpEchoPort);\n\n        ApplicationContainer serverApp = server.Install(b2);\n        serverApp.Start(Seconds(0.5));\n        serverApp.Stop(Seconds(simDurationSeconds));\n\n        // ------------------------------------------------------------------\n        // Install multi-switch UDP echo client on t2\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Multi-Switch UDP client (on node t2 of top LAN)\");\n\n        Time interPacketInterval = Seconds(0.005);\n        uint32_t packetSize = 1000;\n        uint32_t maxPacketCount = (simDurationSeconds - 2.0) / 0.005;\n\n        UdpEchoClientHelper client(Ipv4Address(\"192.168.2.2\"), udpEchoPort);\n\n        client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n        client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n        client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n        ApplicationContainer clientApp = client.Install(t2);\n        clientApp.Start(Seconds(0.5));\n        clientApp.Stop(Seconds(simDurationSeconds));\n    }\n\n    // ======================================================================\n    // Single-Switch UDP traffic generation\n    // ----------------------------------------------------------------------\n    if (enableUdpSingleSW)\n    {\n        // ------------------------------------------------------------------\n        // Install single-switch UDP echo server on t3\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Single-Switch UDP server (on node t3 of top LAN)\");\n\n        UdpEchoServerHelper server(udpEchoPort);\n\n        ApplicationContainer serverApp = server.Install(t3);\n        serverApp.Start(Seconds(0.5));\n        serverApp.Stop(Seconds(simDurationSeconds));\n\n        // ------------------------------------------------------------------\n        // Install single-switch UDP echo client on b3\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Single-Switch UDP client (on node b3 bottom LAN)\");\n\n        Time interPacketInterval = Seconds(0.005);\n        uint32_t packetSize = 1000;\n        uint32_t maxPacketCount = (simDurationSeconds - 2.0) / 0.005;\n\n        UdpEchoClientHelper client(Ipv4Address(\"192.168.1.3\"), udpEchoPort);\n\n        client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n        client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n        client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n        ApplicationContainer clientApp = client.Install(b3);\n        clientApp.Start(Seconds(0.5));\n        clientApp.Stop(Seconds(simDurationSeconds));\n    }\n\n    // ======================================================================\n    // Print routing tables at T=0.1\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    // NOTE: Node 0 and Node 13 must have non-empty tables (except for local\n    //       loopback and local LAN) if routing is operating correctly.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"Set up to print routing tables at T=0.1s\");\n\n    Ptr<OutputStreamWrapper> routingStream =\n        Create<OutputStreamWrapper>(\"global-routing-multi-switch-plus-router.routes\",\n                                    std::ios::out);\n\n    Ipv4RoutingHelper::PrintRoutingTableAllAt(Seconds(0.1), routingStream);\n\n    // ======================================================================\n    // Configure PCAP traces\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"Configure PCAP Tracing (if any configured).\");\n\n    // - - - - - - - - - - - - - -\n    // multi-switch UDP echo client\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"t2\", pcapLocationVec))\n    {\n        csmaX.EnablePcap(\"t2.pcap\", topLanIpDevices.Get(1), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // multi-switch UDP echo server\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"b2\", pcapLocationVec))\n    {\n        csmaY.EnablePcap(\"b2.pcap\", botLanIpDevices.Get(1), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // single-switch UDP echo client\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"b3\", pcapLocationVec))\n    {\n        csmaY.EnablePcap(\"b3.pcap\", botLanIpDevices.Get(2), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // single-switch UDP echo server\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"t3\", pcapLocationVec))\n    {\n        csmaX.EnablePcap(\"t3.pcap\", topLanIpDevices.Get(2), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // top router, LAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"trlan\", pcapLocationVec))\n    {\n        csmaY.EnablePcap(\"trlan.pcap\", topLanIpDevices.Get(0), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // bottom router, LAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"brlan\", pcapLocationVec))\n    {\n        csmaX.EnablePcap(\"brlan.pcap\", botLanIpDevices.Get(0), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // top router, WAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"trwan\", pcapLocationVec))\n    {\n        p2p.EnablePcap(\"trwan.pcap\", link_tr_br.Get(0), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // bottom router, WAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"brwan\", pcapLocationVec))\n    {\n        p2p.EnablePcap(\"brwan.pcap\", link_tr_br.Get(1), true, true);\n    }\n\n    // ======================================================================\n    // Now, do the actual simulation.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"Run Simulation for \" << simDurationSeconds << \" seconds.\");\n\n    Simulator::Stop(Seconds(simDurationSeconds));\n    Simulator::Run();\n\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ script using the ns-3 simulation library to simulate a point-to-point network topology with four nodes. The topology should include three point-to-point links: n0 to n2 and n1 to n2 with a bandwidth of 5 Mbps and delay of 2 ms, and n2 to n3 with a bandwidth of 1.5 Mbps and delay of 10 ms. Set up CBR/UDP traffic from n0 to n3 and n3 to n1, using a packet size of 210 bytes and a data rate of 448 kbps. Additionally, set up an FTP/TCP flow from n0 to n3 starting at 1.2 seconds and ending at 1.35 seconds. Use DropTail queues and enable tracing to a file called 'simple-global-routing.tr'."}, {"role": "assistant", "content": "// Network topology\n//\n//  n0\n//     \\ 5 Mb/s, 2ms\n//      \\          1.5Mb/s, 10ms\n//       n2 -------------------------n3\n//      /\n//     / 5 Mb/s, 2ms\n//   n1\n//\n// - all links are point-to-point links with indicated one-way BW/delay\n// - CBR/UDP flows from n0 to n3, and from n3 to n1\n// - FTP/TCP flow from n0 to n3, starting at time 1.2 to time 1.35 sec.\n// - UDP packet size of 210 bytes, with per-packet interval 0.00375 sec.\n//   (i.e., DataRate of 448,000 bps)\n// - DropTail queues\n// - Tracing of queues and packet receptions to file \"simple-global-routing.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleGlobalRoutingExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Users may find it convenient to turn on explicit debugging\n    // for selected modules; the below lines suggest how to do this\n#if 0\n  LogComponentEnable (\"SimpleGlobalRoutingExample\", LOG_LEVEL_INFO);\n#endif\n\n    // Set up some default values for the simulation.  Use the\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(210));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(\"448kb/s\"));\n\n    // DefaultValue::Bind (\"DropTailQueue::m_maxPackets\", 30);\n\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    bool enableFlowMonitor = false;\n    cmd.AddValue(\"EnableMonitor\", \"Enable Flow Monitor\", enableFlowMonitor);\n    cmd.Parse(argc, argv);\n\n    // Here, we will explicitly create four nodes.  In more sophisticated\n    // topologies, we could configure a node factory.\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer c;\n    c.Create(4);\n    NodeContainer n0n2 = NodeContainer(c.Get(0), c.Get(2));\n    NodeContainer n1n2 = NodeContainer(c.Get(1), c.Get(2));\n    NodeContainer n3n2 = NodeContainer(c.Get(3), c.Get(2));\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // We create the channels first without any IP addressing information\n    NS_LOG_INFO(\"Create channels.\");\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d0d2 = p2p.Install(n0n2);\n\n    NetDeviceContainer d1d2 = p2p.Install(n1n2);\n\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1500kbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    NetDeviceContainer d3d2 = p2p.Install(n3n2);\n\n    // Later, we add IP addresses.\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i0i2 = ipv4.Assign(d0d2);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1i2 = ipv4.Assign(d1d2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i3i2 = ipv4.Assign(d3d2);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    NS_LOG_INFO(\"Create Applications.\");\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(i3i2.GetAddress(0), port)));\n    onoff.SetConstantRate(DataRate(\"448kb/s\"));\n    ApplicationContainer apps = onoff.Install(c.Get(0));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(c.Get(3));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a similar flow from n3 to n1, starting at time 1.1 seconds\n    onoff.SetAttribute(\"Remote\", AddressValue(InetSocketAddress(i1i2.GetAddress(0), port)));\n    apps = onoff.Install(c.Get(3));\n    apps.Start(Seconds(1.1));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    apps = sink.Install(c.Get(1));\n    apps.Start(Seconds(1.1));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"simple-global-routing.tr\"));\n    p2p.EnablePcapAll(\"simple-global-routing\");\n\n    // Flow Monitor\n    FlowMonitorHelper flowmonHelper;\n    if (enableFlowMonitor)\n    {\n        flowmonHelper.InstallAll();\n    }\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Stop(Seconds(11));\n    Simulator::Run();\n    NS_LOG_INFO(\"Done.\");\n\n    if (enableFlowMonitor)\n    {\n        flowmonHelper.SerializeToXmlFile(\"simple-global-routing.flowmon\", false, false);\n    }\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ script using the ns-3 simulation library to simulate a simple network topology with five nodes (A, B, C, D, E), where node A broadcasts packets using multicast to the other nodes through a static routing setup. The nodes are connected through simple net devices, and specific links between nodes are blacklisted to control the flow of packets. Set up packet sinks on nodes B, C, D, and E to receive packets sent from node A. The script should configure multicast routing, handle packet transmission using an OnOffHelper for UDP traffic, and output packet statistics at the end of the simulation. Ensure pcap tracing and a simulation run with defined packet size and data rate."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/config.h\"\n#include \"ns3/data-rate.h\"\n#include \"ns3/double.h\"\n#include \"ns3/inet-socket-address.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-l3-protocol.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/ipv4-static-routing.h\"\n#include \"ns3/log.h\"\n#include \"ns3/names.h\"\n#include \"ns3/node.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/random-variable-stream.h\"\n#include \"ns3/simple-channel.h\"\n#include \"ns3/simple-net-device-helper.h\"\n#include \"ns3/simple-net-device.h\"\n#include \"ns3/simulator.h\"\n#include \"ns3/socket.h\"\n#include \"ns3/string.h\"\n#include \"ns3/test.h\"\n#include \"ns3/trace-helper.h\"\n#include \"ns3/traffic-control-layer.h\"\n#include \"ns3/udp-socket-factory.h\"\n#include \"ns3/udp-socket.h\"\n#include \"ns3/uinteger.h\"\n\n#include <functional>\n#include <limits>\n#include <string>\n\nusing namespace ns3;\n\n/**\n * Network topology:\n *\n *        /---- B ----\\\n *  A ----      |       ---- D ---- E\n *        \\---- C ----/\n *\n * This example demonstrates configuration of\n * static routing to realize broadcast-like\n * flooding of packets from node A\n * across the illustrated topology.\n */\nint\nmain(int argc, char* argv[])\n{\n    // multicast target\n    const std::string targetAddr = \"239.192.100.1\";\n    Config::SetDefault(\"ns3::Ipv4L3Protocol::EnableDuplicatePacketDetection\", BooleanValue(true));\n    Config::SetDefault(\"ns3::Ipv4L3Protocol::DuplicateExpire\", TimeValue(Seconds(10)));\n\n    // Create topology\n\n    // Create nodes\n    auto nodes = NodeContainer();\n    nodes.Create(5);\n\n    // Name nodes\n    Names::Add(\"A\", nodes.Get(0));\n    Names::Add(\"B\", nodes.Get(1));\n    Names::Add(\"C\", nodes.Get(2));\n    Names::Add(\"D\", nodes.Get(3));\n    Names::Add(\"E\", nodes.Get(4));\n\n    SimpleNetDeviceHelper simplenet;\n    auto devices = simplenet.Install(nodes);\n    // name devices\n    Names::Add(\"A/dev\", devices.Get(0));\n    Names::Add(\"B/dev\", devices.Get(1));\n    Names::Add(\"C/dev\", devices.Get(2));\n    Names::Add(\"D/dev\", devices.Get(3));\n    Names::Add(\"E/dev\", devices.Get(4));\n\n    // setup static routes to facilitate multicast flood\n    Ipv4ListRoutingHelper listRouting;\n    Ipv4StaticRoutingHelper staticRouting;\n    listRouting.Add(staticRouting, 0);\n\n    InternetStackHelper internet;\n    internet.SetIpv6StackInstall(false);\n    internet.SetIpv4ArpJitter(true);\n    internet.SetRoutingHelper(listRouting);\n    internet.Install(nodes);\n\n    Ipv4AddressHelper ipv4address;\n    ipv4address.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    ipv4address.Assign(devices);\n\n    // add static routes for each node / device\n    for (auto diter = devices.Begin(); diter != devices.End(); ++diter)\n    {\n        Ptr<Node> node = (*diter)->GetNode();\n\n        if (Names::FindName(node) == \"A\")\n        {\n            // route for host\n            // Use host routing entry according to note in Ipv4StaticRouting::RouteOutput:\n            //// Note:  Multicast routes for outbound packets are stored in the\n            //// normal unicast table.  An implication of this is that it is not\n            //// possible to source multicast datagrams on multiple interfaces.\n            //// This is a well-known property of sockets implementation on\n            //// many Unix variants.\n            //// So, we just log it and fall through to LookupStatic ()\n            auto ipv4 = node->GetObject<Ipv4>();\n            NS_ASSERT_MSG((bool)ipv4,\n                          \"Node \" << Names::FindName(node) << \" does not have Ipv4 aggregate\");\n            auto routing = staticRouting.GetStaticRouting(ipv4);\n            routing->AddHostRouteTo(targetAddr.c_str(), ipv4->GetInterfaceForDevice(*diter), 0);\n        }\n        else\n        {\n            // route for forwarding\n            staticRouting.AddMulticastRoute(node,\n                                            Ipv4Address::GetAny(),\n                                            targetAddr.c_str(),\n                                            *diter,\n                                            NetDeviceContainer(*diter));\n        }\n    }\n\n    // set the topology, by default fully-connected\n    auto channel = devices.Get(0)->GetChannel();\n    auto simplechannel = channel->GetObject<SimpleChannel>();\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"A/dev\"),\n                             Names::Find<SimpleNetDevice>(\"D/dev\"));\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"D/dev\"),\n                             Names::Find<SimpleNetDevice>(\"A/dev\"));\n\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"A/dev\"),\n                             Names::Find<SimpleNetDevice>(\"E/dev\"));\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"E/dev\"),\n                             Names::Find<SimpleNetDevice>(\"A/dev\"));\n\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"B/dev\"),\n                             Names::Find<SimpleNetDevice>(\"E/dev\"));\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"E/dev\"),\n                             Names::Find<SimpleNetDevice>(\"B/dev\"));\n\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"C/dev\"),\n                             Names::Find<SimpleNetDevice>(\"E/dev\"));\n    simplechannel->BlackList(Names::Find<SimpleNetDevice>(\"E/dev\"),\n                             Names::Find<SimpleNetDevice>(\"C/dev\"));\n    // ensure some time progress between re-transmissions\n    simplechannel->SetAttribute(\"Delay\", TimeValue(MilliSeconds(1)));\n\n    // sinks\n    PacketSinkHelper sinkHelper(\"ns3::UdpSocketFactory\",\n                                InetSocketAddress(Ipv4Address::GetAny(), 9));\n    auto sinks = sinkHelper.Install(\"B\");\n    sinks.Add(sinkHelper.Install(\"C\"));\n    sinks.Add(sinkHelper.Install(\"D\"));\n    sinks.Add(sinkHelper.Install(\"E\"));\n    sinks.Start(Seconds(1));\n\n    // source\n    OnOffHelper onoffHelper(\"ns3::UdpSocketFactory\", InetSocketAddress(targetAddr.c_str(), 9));\n    onoffHelper.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"8Mbps\")));\n    onoffHelper.SetAttribute(\"MaxBytes\", UintegerValue(10 * 1024));\n    auto source = onoffHelper.Install(\"A\");\n    source.Start(Seconds(1.1));\n\n    // pcap traces\n    for (auto end = nodes.End(), iter = nodes.Begin(); iter != end; ++iter)\n    {\n        internet.EnablePcapIpv4(\"smf-trace\", (*iter)->GetId(), 1, false);\n    }\n\n    // run simulation\n    Simulator::Run();\n\n    std::cout << \"Node A sent \" << 10 * 1024 << \" bytes\" << std::endl;\n    for (auto end = sinks.End(), iter = sinks.Begin(); iter != end; ++iter)\n    {\n        auto node = (*iter)->GetNode();\n        auto sink = (*iter)->GetObject<PacketSink>();\n        std::cout << \"Node \" << Names::FindName(node) << \" received \" << sink->GetTotalRx()\n                  << \" bytes\" << std::endl;\n    }\n\n    Simulator::Destroy();\n\n    Names::Clear();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ script using the ns-3 library to simulate a basic network topology with three nodes (n0, r, n1) where n0 and n1 are connected through a router (r) using IPv6. Set up the nodes with an IPv6 internet stack, and connect them using CSMA channels with a specified data rate and delay. Assign IPv6 addresses to the network interfaces and configure forwarding and default routes on the router. Include a ping application on n0 to send ICMPv6 echo requests to n1, and enable ASCII and pcap tracing to log the simulation to a file. Print the IPv6 routing table of node n0."}, {"role": "assistant", "content": "// Network topology\n// //\n// //             n0   r    n1\n// //             |    _    |\n// //             ====|_|====\n// //                router\n// //\n// // - Tracing of queues and packet receptions to file \"simple-routing-ping6.tr\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleRoutingPing6Example\");\n\n/**\n * \\class StackHelper\n * \\brief Helper to set or get some IPv6 information about nodes.\n */\nclass StackHelper\n{\n  public:\n    /**\n     * \\brief Add an address to a IPv6 node.\n     * \\param n node\n     * \\param interface interface index\n     * \\param address IPv6 address to add\n     */\n    inline void AddAddress(Ptr<Node>& n, uint32_t interface, Ipv6Address address)\n    {\n        Ptr<Ipv6> ipv6 = n->GetObject<Ipv6>();\n        ipv6->AddAddress(interface, address);\n    }\n\n    /**\n     * \\brief Print the routing table.\n     * \\param n the node\n     */\n    inline void PrintRoutingTable(Ptr<Node>& n)\n    {\n        Ptr<Ipv6StaticRouting> routing = nullptr;\n        Ipv6StaticRoutingHelper routingHelper;\n        Ptr<Ipv6> ipv6 = n->GetObject<Ipv6>();\n        uint32_t nbRoutes = 0;\n        Ipv6RoutingTableEntry route;\n\n        routing = routingHelper.GetStaticRouting(ipv6);\n\n        std::cout << \"Routing table of \" << n << \" : \" << std::endl;\n        std::cout << \"Destination\\t\\t\\t\\t\"\n                  << \"Gateway\\t\\t\\t\\t\\t\"\n                  << \"Interface\\t\"\n                  << \"Prefix to use\" << std::endl;\n\n        nbRoutes = routing->GetNRoutes();\n        for (uint32_t i = 0; i < nbRoutes; i++)\n        {\n            route = routing->GetRoute(i);\n            std::cout << route.GetDest() << \"\\t\" << route.GetGateway() << \"\\t\"\n                      << route.GetInterface() << \"\\t\" << route.GetPrefixToUse() << \"\\t\"\n                      << std::endl;\n        }\n    }\n};\n\nint\nmain(int argc, char** argv)\n{\n#if 0\n  LogComponentEnable (\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"Ipv6Interface\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"Ping\", LOG_LEVEL_ALL);\n#endif\n\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    StackHelper stackHelper;\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> n0 = CreateObject<Node>();\n    Ptr<Node> r = CreateObject<Node>();\n    Ptr<Node> n1 = CreateObject<Node>();\n\n    NodeContainer net1(n0, r);\n    NodeContainer net2(r, n1);\n    NodeContainer all(n0, r, n1);\n\n    NS_LOG_INFO(\"Create IPv6 Internet Stack\");\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d1 = csma.Install(net1);\n    NetDeviceContainer d2 = csma.Install(net2);\n\n    NS_LOG_INFO(\"Create networks and assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i1 = ipv6.Assign(d1);\n    i1.SetForwarding(1, true);\n    i1.SetDefaultRouteInAllNodes(1);\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i2 = ipv6.Assign(d2);\n    i2.SetForwarding(0, true);\n    i2.SetDefaultRouteInAllNodes(0);\n\n    stackHelper.PrintRoutingTable(n0);\n\n    /* Create a Ping application to send ICMPv6 echo request from n0 to n1 via r */\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 5;\n    PingHelper ping(i2.GetAddress(1, 1));\n\n    ping.SetAttribute(\"Count\", UintegerValue(maxPacketCount));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    ApplicationContainer apps = ping.Install(net1.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(20.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"simple-routing-ping6.tr\"));\n    csma.EnablePcapAll(\"simple-routing-ping6\", true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library to simulate a three-router network topology where nodes A, B, and C are connected via point-to-point links. Configure static routing for the communication between the nodes, using /32 IP addressing for specific interfaces. Set up point-to-point channels with a specified data rate and delay. Assign appropriate IP addresses to the interfaces, and configure static routes from node A to node C through node B. Additionally, create an OnOff application on node A to send UDP packets to node C, and a packet sink on node C to receive these packets. Enable tracing and packet capture for the simulation."}, {"role": "assistant", "content": "// Test program for this 3-router scenario, using static routing\n//\n// (a.a.a.a/32)A<--x.x.x.0/30-->B<--y.y.y.0/30-->C(c.c.c.c/32)\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"StaticRoutingSlash32Test\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Ptr<Node> nA = CreateObject<Node>();\n    Ptr<Node> nB = CreateObject<Node>();\n    Ptr<Node> nC = CreateObject<Node>();\n\n    NodeContainer c = NodeContainer(nA, nB, nC);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // Point-to-point links\n    NodeContainer nAnB = NodeContainer(nA, nB);\n    NodeContainer nBnC = NodeContainer(nB, nC);\n\n    // We create the channels first without any IP addressing information\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer dAdB = p2p.Install(nAnB);\n\n    NetDeviceContainer dBdC = p2p.Install(nBnC);\n\n    Ptr<CsmaNetDevice> deviceA = CreateObject<CsmaNetDevice>();\n    deviceA->SetAddress(Mac48Address::Allocate());\n    nA->AddDevice(deviceA);\n    deviceA->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    Ptr<CsmaNetDevice> deviceC = CreateObject<CsmaNetDevice>();\n    deviceC->SetAddress(Mac48Address::Allocate());\n    nC->AddDevice(deviceC);\n    deviceC->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    // Later, we add IP addresses.\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iAiB = ipv4.Assign(dAdB);\n\n    ipv4.SetBase(\"10.1.1.4\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iBiC = ipv4.Assign(dBdC);\n\n    Ptr<Ipv4> ipv4A = nA->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4B = nB->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4C = nC->GetObject<Ipv4>();\n\n    int32_t ifIndexA = ipv4A->AddInterface(deviceA);\n    int32_t ifIndexC = ipv4C->AddInterface(deviceC);\n\n    Ipv4InterfaceAddress ifInAddrA =\n        Ipv4InterfaceAddress(Ipv4Address(\"172.16.1.1\"), Ipv4Mask(\"/32\"));\n    ipv4A->AddAddress(ifIndexA, ifInAddrA);\n    ipv4A->SetMetric(ifIndexA, 1);\n    ipv4A->SetUp(ifIndexA);\n\n    Ipv4InterfaceAddress ifInAddrC =\n        Ipv4InterfaceAddress(Ipv4Address(\"192.168.1.1\"), Ipv4Mask(\"/32\"));\n    ipv4C->AddAddress(ifIndexC, ifInAddrC);\n    ipv4C->SetMetric(ifIndexC, 1);\n    ipv4C->SetUp(ifIndexC);\n\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    // Create static routes from A to C\n    Ptr<Ipv4StaticRouting> staticRoutingA = ipv4RoutingHelper.GetStaticRouting(ipv4A);\n    // The ifIndex for this outbound route is 1; the first p2p link added\n    staticRoutingA->AddHostRouteTo(Ipv4Address(\"192.168.1.1\"), Ipv4Address(\"10.1.1.2\"), 1);\n    Ptr<Ipv4StaticRouting> staticRoutingB = ipv4RoutingHelper.GetStaticRouting(ipv4B);\n    // The ifIndex we want on node B is 2; 0 corresponds to loopback, and 1 to the first point to\n    // point link\n    staticRoutingB->AddHostRouteTo(Ipv4Address(\"192.168.1.1\"), Ipv4Address(\"10.1.1.6\"), 2);\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(ifInAddrC.GetLocal(), port)));\n    onoff.SetConstantRate(DataRate(6000));\n    ApplicationContainer apps = onoff.Install(nA);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(nC);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"static-routing-slash32.tr\"));\n    p2p.EnablePcapAll(\"static-routing-slash32\");\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library that simulates a simple IPv6 network topology with three nodes: two end nodes (n0 and n1) connected via a router (r). Configure CSMA channels between the nodes with specified data rate and delay. Install an IPv6 Internet stack on all nodes and assign IPv6 addresses with appropriate forwarding and default routes. Create a UDP echo client-server application where n0 sends fragmented packets to n1 through the router. Enable logging for key components, and save traces of queue and packet reception events to a file named 'fragmentation-ipv6.tr'. Additionally, capture packet traces using pcap."}, {"role": "assistant", "content": "// Network topology\n// //\n// //             n0   r    n1\n// //             |    _    |\n// //             ====|_|====\n// //                router\n// //\n// // - Tracing of queues and packet receptions to file \"fragmentation-ipv6.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"FragmentationIpv6Example\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_ALL);\n    }\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> n0 = CreateObject<Node>();\n    Ptr<Node> r = CreateObject<Node>();\n    Ptr<Node> n1 = CreateObject<Node>();\n\n    NodeContainer net1(n0, r);\n    NodeContainer net2(r, n1);\n    NodeContainer all(n0, r, n1);\n\n    NS_LOG_INFO(\"Create IPv6 Internet Stack\");\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d1 = csma.Install(net1);\n    NetDeviceContainer d2 = csma.Install(net2);\n\n    NS_LOG_INFO(\"Create networks and assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i1 = ipv6.Assign(d1);\n    i1.SetForwarding(1, true);\n    i1.SetDefaultRouteInAllNodes(1);\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i2 = ipv6.Assign(d2);\n    i2.SetForwarding(0, true);\n    i2.SetDefaultRouteInAllNodes(0);\n\n    Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);\n    Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(0), n0, routingStream);\n\n    /* Create a UdpEchoClient and UdpEchoServer application to send packets from n0 to n1 via r */\n    uint32_t packetSize = 4096;\n    uint32_t maxPacketCount = 5;\n\n    UdpEchoClientHelper echoClient(i2.GetAddress(1, 1), 42);\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    ApplicationContainer clientApps = echoClient.Install(net1.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(20.0));\n\n    UdpEchoServerHelper echoServer(42);\n    ApplicationContainer serverApps = echoServer.Install(net2.Get(1));\n    serverApps.Start(Seconds(0.0));\n    serverApps.Stop(Seconds(30.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"fragmentation-ipv6.tr\"));\n    csma.EnablePcapAll(std::string(\"fragmentation-ipv6\"), true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library that simulates a multi-router IPv6 network with three segments. The network consists of five nodes (Src, n0, r1, n1, r2, n2) connected via routers with varying MTU sizes (5000, 2000, 1500). Use CSMA and Point-to-Point channels, setting the respective MTU values for each link. Install IPv6 internet stacks, configure forwarding and default routes, and set up UDP echo client-server applications between the nodes. Ensure that packet fragmentation occurs due to varying MTUs. Enable logging and tracing of packet receptions to the file 'fragmentation-ipv6-PMTU.tr'."}, {"role": "assistant", "content": "// Network topology\n// //\n// //      Src  n0        r1     n1      r2        n2\n// //           |         _      |       _         |\n// //           =========|_|============|_|=========\n// //      MTU   5000           2000          1500\n// //\n// // - Tracing of queues and packet receptions to file \"fragmentation-ipv6-PMTU.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"FragmentationIpv6PmtuExample\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_ALL);\n    }\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> n0 = CreateObject<Node>();\n    Ptr<Node> r1 = CreateObject<Node>();\n    Ptr<Node> n1 = CreateObject<Node>();\n    Ptr<Node> r2 = CreateObject<Node>();\n    Ptr<Node> n2 = CreateObject<Node>();\n\n    NodeContainer net1(n0, r1);\n    NodeContainer net2(r1, n1, r2);\n    NodeContainer net3(r2, n2);\n    NodeContainer all(n0, r1, n1, r2, n2);\n\n    NS_LOG_INFO(\"Create IPv6 Internet Stack\");\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(2000));\n    NetDeviceContainer d2 = csma.Install(net2); // CSMA Network with MTU 2000\n\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(5000));\n    NetDeviceContainer d1 = csma.Install(net1); // CSMA Network with MTU 5000\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", DataRateValue(5000000));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    pointToPoint.SetDeviceAttribute(\"Mtu\", UintegerValue(1500));\n    NetDeviceContainer d3 = pointToPoint.Install(net3); // P2P Network with MTU 1500\n\n    NS_LOG_INFO(\"Create networks and assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i1 = ipv6.Assign(d1);\n    i1.SetForwarding(1, true);\n    i1.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i2 = ipv6.Assign(d2);\n    i2.SetForwarding(0, true);\n    i2.SetDefaultRouteInAllNodes(0);\n    i2.SetForwarding(1, true);\n    i2.SetDefaultRouteInAllNodes(0);\n    i2.SetForwarding(2, true);\n    i2.SetDefaultRouteInAllNodes(2);\n\n    ipv6.SetBase(Ipv6Address(\"2001:3::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i3 = ipv6.Assign(d3);\n    i3.SetForwarding(0, true);\n    i3.SetDefaultRouteInAllNodes(0);\n\n    Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);\n    Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(0), r1, routingStream);\n\n    // Create an UDP Echo server on n2\n    UdpEchoServerHelper echoServer(42);\n    ApplicationContainer serverApps = echoServer.Install(n2);\n    serverApps.Start(Seconds(0.0));\n    serverApps.Stop(Seconds(30.0));\n\n    uint32_t maxPacketCount = 5;\n\n    // Create an UDP Echo client on n1 to send UDP packets to n2 via r1\n    uint32_t packetSizeN1 = 1600; // Packet should fragment as intermediate link MTU is 1500\n    UdpEchoClientHelper echoClient(i3.GetAddress(1, 1), 42);\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSizeN1));\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    ApplicationContainer clientAppsN1 = echoClient.Install(n1);\n    clientAppsN1.Start(Seconds(2.0));\n    clientAppsN1.Stop(Seconds(10.0));\n\n    // Create an UDP Echo client on n0 to send UDP packets to n2 via r0 and r1\n    uint32_t packetSizeN2 = 4000; // Packet should fragment as intermediate link MTU is 1500\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSizeN2));\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    ApplicationContainer clientAppsN2 = echoClient.Install(n1);\n    clientAppsN2.Start(Seconds(11.0));\n    clientAppsN2.Stop(Seconds(20.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"fragmentation-ipv6-PMTU.tr\"));\n    csma.EnablePcapAll(std::string(\"fragmentation-ipv6-PMTU\"), true);\n    pointToPoint.EnablePcapAll(std::string(\"fragmentation-ipv6-PMTU\"), true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library that simulates an IPv6 network topology with two segments. The network consists of three nodes (Src, n0, r, n1, Dst), where the link between `n0` and `r` has an MTU of 5000, and the link between `r` and `n1` has an MTU of 1500. Set up a CSMA network, install IPv6 internet stacks, assign IPv6 addresses, and enable forwarding and routing. Implement UDP echo client-server applications, sending packets from `n0` to `n1` through the router. Enable tracing of queues and packet receptions to a file named 'fragmentation-ipv6-two-mtu.tr'."}, {"role": "assistant", "content": "// Network topology\n// //\n// //     Src     n0   r    n1    Dst\n// //             |    _    |\n// //     MTU     ====|_|====     MTU\n// //     5000       router       1500\n// //\n// // - Tracing of queues and packet receptions to file \"fragmentation-ipv6-two-mtu.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"FragmentationIpv6TwoMtuExample\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_ALL);\n    }\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> n0 = CreateObject<Node>();\n    Ptr<Node> r = CreateObject<Node>();\n    Ptr<Node> n1 = CreateObject<Node>();\n\n    NodeContainer net1(n0, r);\n    NodeContainer net2(r, n1);\n    NodeContainer all(n0, r, n1);\n\n    NS_LOG_INFO(\"Create IPv6 Internet Stack\");\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d2 = csma.Install(net2);\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(5000));\n    NetDeviceContainer d1 = csma.Install(net1);\n\n    NS_LOG_INFO(\"Create networks and assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i1 = ipv6.Assign(d1);\n    i1.SetForwarding(1, true);\n    i1.SetDefaultRouteInAllNodes(1);\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i2 = ipv6.Assign(d2);\n    i2.SetForwarding(0, true);\n    i2.SetDefaultRouteInAllNodes(0);\n\n    Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);\n    Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(0), n0, routingStream);\n\n    /* Create a UdpEchoClient and UdpEchoServer application to send packets from n0 to n1 via r */\n    uint32_t packetSize = 4096;\n    uint32_t maxPacketCount = 5;\n\n    UdpEchoClientHelper echoClient(i2.GetAddress(1, 1), 42);\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    ApplicationContainer clientApps = echoClient.Install(net1.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(20.0));\n\n    UdpEchoServerHelper echoServer(42);\n    ApplicationContainer serverApps = echoServer.Install(net2.Get(1));\n    serverApps.Start(Seconds(0.0));\n    serverApps.Stop(Seconds(30.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"fragmentation-ipv6-two-mtu.tr\"));\n    csma.EnablePcapAll(std::string(\"fragmentation-ipv6-two-mtu\"), true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 library to simulate a network topology featuring two routers (R1, R2) and two station nodes (STA1, STA2). Implement the following configuration: STA1 uses R1 as its default route, R1 has a static route to STA2 via R2, and STA2 uses R2 as its default route. Have STA1 send an Echo Request to STA2 through R1, which forwards it to R2. Afterward, R1 sends an ICMPv6 Redirection message to STA1, indicating that future Echo Requests to STA2 should go directly to R2. Include tracing of packet flows to a file named 'icmpv6-redirect.tr'."}, {"role": "assistant", "content": "\u0002\n// Network topology\n//\n//             STA2\n//              |\n//              |\n//   R1         R2\n//   |          |\n//   |          |\n//   ------------\n//           |\n//           |\n//          STA 1\n//\n// - Initial configuration :\n//         - STA1 default route : R1\n//         - R1 static route to STA2 : R2\n//         - STA2 default route : R2\n// - STA1 send Echo Request to STA2 using its default route to R1\n// - R1 receive Echo Request from STA1, and forward it to R2\n// - R1 send an ICMPv6 Redirection to STA1 with Target STA2 and Destination R2\n// - Next Echo Request from STA1 to STA2 are directly sent to R2\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Icmpv6RedirectExample\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Icmpv6RedirectExample\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"NdiscCache\", LOG_LEVEL_ALL);\n    }\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> sta1 = CreateObject<Node>();\n    Ptr<Node> r1 = CreateObject<Node>();\n    Ptr<Node> r2 = CreateObject<Node>();\n    Ptr<Node> sta2 = CreateObject<Node>();\n    NodeContainer net1(sta1, r1, r2);\n    NodeContainer net2(r2, sta2);\n    NodeContainer all(sta1, r1, r2, sta2);\n\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer ndc1 = csma.Install(net1);\n    NetDeviceContainer ndc2 = csma.Install(net2);\n\n    NS_LOG_INFO(\"Assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic1 = ipv6.Assign(ndc1);\n    iic1.SetForwarding(2, true);\n    iic1.SetForwarding(1, true);\n    iic1.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic2 = ipv6.Assign(ndc2);\n    iic2.SetForwarding(0, true);\n    iic2.SetDefaultRouteInAllNodes(0);\n\n    Ipv6StaticRoutingHelper routingHelper;\n\n    // manually inject a static route to the second router.\n    Ptr<Ipv6StaticRouting> routing = routingHelper.GetStaticRouting(r1->GetObject<Ipv6>());\n    routing->AddHostRouteTo(iic2.GetAddress(1, 1),\n                            iic1.GetAddress(2, 0),\n                            iic1.GetInterfaceIndex(1));\n\n    Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);\n    Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(0.0), r1, routingStream);\n    Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(3.0), sta1, routingStream);\n\n    NS_LOG_INFO(\"Create Applications.\");\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 5;\n    PingHelper ping(iic2.GetAddress(1, 1));\n\n    ping.SetAttribute(\"Count\", UintegerValue(maxPacketCount));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    ApplicationContainer apps = ping.Install(sta1);\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"icmpv6-redirect.tr\"));\n    csma.EnablePcapAll(\"icmpv6-redirect\", true);\n\n    /* Now, do the actual simulation. */\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to model a network topology with multiple hosts and routers, including Host 0, Host 1, Router 0, Router 1, Router 2, and Router 3. Configure the network so that Host 0 communicates with Host 1 through a series of routers using loose source routing. Ensure that the program sets up the necessary connections between the nodes, assigns IPv6 addresses, and configures routing appropriately. Implement ICMPv6 echo requests from Host 0 to Host 1, using specified routers in the source routing process. Additionally, set up packet tracing to a file named 'loose-routing-ipv6.tr'."}, {"role": "assistant", "content": "// Network topology\n// //\n// //\n// //                               +------------+\n// //  +------------+           |---|  Router 1  |---|\n// //  |   Host 0   |--|        |   [------------]   |\n// //  [------------]  |        |                    |\n// //                  |  +------------+             |\n// //                  +--|            |       +------------+\n// //                     |  Router 0  |       |  Router 2  |\n// //                  +--|            |       [------------]\n// //                  |  [------------]             |\n// //  +------------+  |        |                    |\n// //  |   Host 1   |--|        |   +------------+   |\n// //  [------------]           |---|  Router 3  |---|\n// //                               [------------]\n// //\n// //\n// // - Tracing of queues and packet receptions to file \"loose-routing-ipv6.tr\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-header.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LooseRoutingIpv6Example\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        // LogComponentEnable(\"Ipv6ExtensionLooseRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Extension\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"NdiscCache\", LOG_LEVEL_ALL);\n    }\n\n    // LogComponentEnable(\"Ping\", LOG_LEVEL_INFO);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> h0 = CreateObject<Node>();\n    Ptr<Node> h1 = CreateObject<Node>();\n    Ptr<Node> r0 = CreateObject<Node>();\n    Ptr<Node> r1 = CreateObject<Node>();\n    Ptr<Node> r2 = CreateObject<Node>();\n    Ptr<Node> r3 = CreateObject<Node>();\n\n    NodeContainer net1(h0, r0);\n    NodeContainer net2(h1, r0);\n    NodeContainer net3(r0, r1);\n    NodeContainer net4(r1, r2);\n    NodeContainer net5(r2, r3);\n    NodeContainer net6(r3, r0);\n    NodeContainer all;\n    all.Add(h0);\n    all.Add(h1);\n    all.Add(r0);\n    all.Add(r1);\n    all.Add(r2);\n    all.Add(r3);\n\n    NS_LOG_INFO(\"Create IPv6 Internet Stack\");\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1500));\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d1 = csma.Install(net1);\n    NetDeviceContainer d2 = csma.Install(net2);\n    NetDeviceContainer d3 = csma.Install(net3);\n    NetDeviceContainer d4 = csma.Install(net4);\n    NetDeviceContainer d5 = csma.Install(net5);\n    NetDeviceContainer d6 = csma.Install(net6);\n\n    NS_LOG_INFO(\"Create networks and assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i1 = ipv6.Assign(d1);\n    i1.SetForwarding(1, true);\n    i1.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i2 = ipv6.Assign(d2);\n    i2.SetForwarding(1, true);\n    i2.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:3::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i3 = ipv6.Assign(d3);\n    i3.SetForwarding(0, true);\n    i3.SetDefaultRouteInAllNodes(0);\n    i3.SetForwarding(1, true);\n    i3.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:4::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i4 = ipv6.Assign(d4);\n    i4.SetForwarding(0, true);\n    i4.SetDefaultRouteInAllNodes(0);\n    i4.SetForwarding(1, true);\n    i4.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:5::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i5 = ipv6.Assign(d5);\n    i5.SetForwarding(0, true);\n    i5.SetDefaultRouteInAllNodes(0);\n    i5.SetForwarding(1, true);\n    i5.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:6::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i6 = ipv6.Assign(d6);\n    i6.SetForwarding(0, true);\n    i6.SetDefaultRouteInAllNodes(0);\n    i6.SetForwarding(1, true);\n    i6.SetDefaultRouteInAllNodes(1);\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    /**\n     * ICMPv6 Echo from h0 to h1 port 7\n     */\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 1;\n    Time interPacketInterval = Seconds(1.0);\n\n    std::vector<Ipv6Address> routersAddress;\n    routersAddress.push_back(i3.GetAddress(1, 1));\n    routersAddress.push_back(i4.GetAddress(1, 1));\n    routersAddress.push_back(i5.GetAddress(1, 1));\n    routersAddress.push_back(i6.GetAddress(1, 1));\n    routersAddress.push_back(i2.GetAddress(0, 1));\n\n    // remote address is first routers in RH0 => source routing\n    PingHelper client(i1.GetAddress(1, 1));\n    client.SetAttribute(\"Count\", UintegerValue(maxPacketCount));\n    client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    client.SetAttribute(\"Size\", UintegerValue(packetSize));\n    ApplicationContainer apps = client.Install(h0);\n    DynamicCast<Ping>(apps.Get(0))->SetRouters(routersAddress);\n\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(20.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"loose-routing-ipv6.tr\"));\n    csma.EnablePcapAll(\"loose-routing-ipv6\", true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the NS-3 simulation framework to simulate a network topology with two nodes (n0, n1) connected via a CSMA LAN. The program should simulate a UDP flow from node n0 to node n1, where the client on n0 sends 1024-byte packets at 50 ms intervals, for a maximum of 320 packets or until the simulation ends. The user should be able to select either IPv4 or IPv6 addressing via command-line arguments, and there should be an option to enable or disable logging statements. If logging is enabled, log detailed information for the UDP client and server. The CSMA channel should be configured with a data rate of 5 Mbps, a delay of 2 ms, and an MTU of 1400 bytes. The server should run on port 4000, and the client should start sending packets at 2 seconds, with the simulation running for a total of 10 seconds. Ensure the program uses the necessary NS-3 modules (applications, core, csma, and internet) and outputs appropriate log messages during the simulation."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1\n//       |     |\n//       =======\n//         LAN (CSMA)\n//\n// - UDP flow from n0 to n1 of 1024 byte packets at intervals of 50 ms\n//   - maximum of 320 packets sent (or limited by simulation duration)\n//   - option to use IPv4 or IPv6 addressing\n//   - option to disable logging statements\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpClientServerExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Declare variables used in command-line arguments\n    bool useV6 = false;\n    bool logging = true;\n    Address serverAddress;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"useIpv6\", \"Use Ipv6\", useV6);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.Parse(argc, argv);\n\n    if (logging)\n    {\n        LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n    }\n\n    NS_LOG_INFO(\"Create nodes in above topology.\");\n    NodeContainer n;\n    n.Create(2);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    NS_LOG_INFO(\"Create channel between the two nodes.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    if (!useV6)\n    {\n        Ipv4AddressHelper ipv4;\n        ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer i = ipv4.Assign(d);\n        serverAddress = Address(i.GetAddress(1));\n    }\n    else\n    {\n        Ipv6AddressHelper ipv6;\n        ipv6.SetBase(\"2001:0000:f00d:cafe::\", Ipv6Prefix(64));\n        Ipv6InterfaceContainer i6 = ipv6.Assign(d);\n        serverAddress = Address(i6.GetAddress(1, 1));\n    }\n\n    NS_LOG_INFO(\"Create UdpServer application on node 1.\");\n    uint16_t port = 4000;\n    UdpServerHelper server(port);\n    ApplicationContainer apps = server.Install(n.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Create UdpClient application on node 0 to send to node 1.\");\n    uint32_t MaxPacketSize = 1024;\n    Time interPacketInterval = Seconds(0.05);\n    uint32_t maxPacketCount = 320;\n    UdpClientHelper client(serverAddress, port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    client.SetAttribute(\"PacketSize\", UintegerValue(MaxPacketSize));\n    apps = client.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 simulation library to model a simple network topology consisting of two nodes (n0 and n1) connected via a LAN using a CSMA channel. Implement ICMPv6 echo requests flowing from n0 to n1 and back, simulating echo replies. Configure the network with DropTail queues and set up tracing of queues and packet receptions, outputting to a file named 'ping6.tr'. Include the installation of the IPv6 stack, address assignment, and the creation of a Ping application that sends a specified number of echo requests from n0 to n1."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1\n//       |     |\n//       =================\n//              LAN\n//\n// - ICMPv6 echo request flows from n0 to n1 and back with ICMPv6 echo reply\n// - DropTail queues\n// - Tracing of queues and packet receptions to file \"ping6.tr\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Ping6Example\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n    bool allNodes = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.AddValue(\"allNodes\", \"Ping all the nodes (true) or just one neighbor (false)\", allNodes);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Ping6Example\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"Ipv6EndPointDemux\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6ListRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ping\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"NdiscCache\", LOG_LEVEL_ALL);\n    }\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer n;\n    n.Create(4);\n\n    /* Install IPv4/IPv6 stack */\n    InternetStackHelper internetv6;\n    internetv6.SetIpv4StackInstall(false);\n    internetv6.Install(n);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d = csma.Install(n);\n\n    Ipv6AddressHelper ipv6;\n    NS_LOG_INFO(\"Assign IPv6 Addresses.\");\n    Ipv6InterfaceContainer i = ipv6.Assign(d);\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    // Create a Ping application to send ICMPv6 echo request from node zero\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 5;\n\n    Ipv6Address destination = allNodes ? Ipv6Address::GetAllNodesMulticast() : i.GetAddress(1, 0);\n    PingHelper ping(destination);\n\n    ping.SetAttribute(\"Count\", UintegerValue(maxPacketCount));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    ping.SetAttribute(\"InterfaceAddress\", AddressValue(i.GetAddress(0, 0)));\n\n    ApplicationContainer apps = ping.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"ping6.tr\"));\n    csma.EnablePcapAll(std::string(\"ping6\"), true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to model a network topology that includes two nodes (n0 and n1) connected through a router (R) via a CSMA channel. Configure the router to send Router Advertisements (RAs) to both n0's subnet (2001:1::/64) and n1's subnet (2001:2::/64). Implement a Ping application where n0 sends ICMPv6 echo requests to n1. Include tracing of queues and packet receptions, saving the output to a file named 'radvd.tr'. Ensure to set up the IPv6 Internet stack, assign IPv6 addresses, and configure the Radvd application appropriately."}, {"role": "assistant", "content": "// Network topology\n// //\n// //             n0   R    n1\n// //             |    _    |\n// //             ====|_|====\n// //                router\n// // - R sends RA to n0's subnet (2001:1::/64);\n// // - R sends RA to n1's subnet (2001:2::/64);\n// // - n0 ping n1.\n// //\n// // - Tracing of queues and packet receptions to file \"radvd.tr\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/radvd-interface.h\"\n#include \"ns3/radvd-prefix.h\"\n#include \"ns3/radvd.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RadvdExample\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6RawSocketImpl\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"RadvdApplication\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ping\", LOG_LEVEL_ALL);\n    }\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> n0 = CreateObject<Node>();\n    Ptr<Node> r = CreateObject<Node>();\n    Ptr<Node> n1 = CreateObject<Node>();\n\n    NodeContainer net1(n0, r);\n    NodeContainer net2(r, n1);\n    NodeContainer all(n0, r, n1);\n\n    NS_LOG_INFO(\"Create IPv6 Internet Stack\");\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d1 = csma.Install(net1); /* n0 - R */\n    NetDeviceContainer d2 = csma.Install(net2); /* R - n1 */\n\n    NS_LOG_INFO(\"Create networks and assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n\n    /* first subnet */\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    NetDeviceContainer tmp;\n    tmp.Add(d1.Get(0));                                           /* n0 */\n    Ipv6InterfaceContainer iic1 = ipv6.AssignWithoutAddress(tmp); /* n0 interface */\n\n    NetDeviceContainer tmp2;\n    tmp2.Add(d1.Get(1)); /* R */\n    Ipv6InterfaceContainer iicr1 =\n        ipv6.Assign(tmp2); /* R interface to the first subnet is just statically assigned */\n    iicr1.SetForwarding(0, true);\n    iic1.Add(iicr1);\n\n    /* second subnet R - n1 */\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    NetDeviceContainer tmp3;\n    tmp3.Add(d2.Get(0));                              /* R */\n    Ipv6InterfaceContainer iicr2 = ipv6.Assign(tmp3); /* R interface */\n    iicr2.SetForwarding(0, true);\n\n    NetDeviceContainer tmp4;\n    tmp4.Add(d2.Get(1)); /* n1 */\n    Ipv6InterfaceContainer iic2 = ipv6.AssignWithoutAddress(tmp4);\n    iic2.Add(iicr2);\n\n    /* radvd configuration */\n    RadvdHelper radvdHelper;\n\n    /* R interface (n0 - R) */\n    /* n0 will receive unsolicited (periodic) RA */\n    radvdHelper.AddAnnouncedPrefix(iic1.GetInterfaceIndex(1), Ipv6Address(\"2001:1::0\"), 64);\n\n    /* R interface (R - n1) */\n    /* n1 will have to use RS, as RA are not sent automatically */\n    radvdHelper.AddAnnouncedPrefix(iic2.GetInterfaceIndex(1), Ipv6Address(\"2001:2::0\"), 64);\n    radvdHelper.GetRadvdInterface(iic2.GetInterfaceIndex(1))->SetSendAdvert(false);\n\n    ApplicationContainer radvdApps = radvdHelper.Install(r);\n    radvdApps.Start(Seconds(1.0));\n    radvdApps.Stop(Seconds(10.0));\n\n    /* Create a Ping application to send ICMPv6 echo request from n0 to n1 via R */\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 5;\n    PingHelper ping(\n        Ipv6Address(\"2001:2::200:ff:fe00:4\")); /* should be n1 address after autoconfiguration */\n\n    ping.SetAttribute(\"Count\", UintegerValue(maxPacketCount));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    ApplicationContainer apps = ping.Install(net1.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(7.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"radvd.tr\"));\n    csma.EnablePcapAll(std::string(\"radvd\"), true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 simulation library to model a network topology featuring two nodes (n0 and n1) connected via a router (R) over a CSMA channel. Configure the router to send Router Advertisements (RAs) to n0's subnet with two prefixes: 2001:1::/64 and 2001:ABCD::/64, ensuring that the R interface to n0 has both addresses assigned. Additionally, configure the router to send RAs to n1's subnet (2001:2::/64). Implement a Ping application where n0 sends ICMPv6 echo requests to n1. Incorporate tracing of queues and packet receptions, saving the output to a file named 'radvd-two-prefix.tr'. Include appropriate logging and IP address printing functionality within the simulation."}, {"role": "assistant", "content": "// Network topology\n// //\n// //             n0   R    n1\n// //             |    _    |\n// //             ====|_|====\n// //                router\n// // - R sends RA to n0's subnet (2001:1::/64 and 2001:ABCD::/64);\n// // - R interface to n0 has two addresses with following prefixes 2001:1::/64 and 2001:ABCD::/64;\n// // - R sends RA to n1's subnet (2001:2::/64);\n// // - n0 ping n1.\n// //\n// // - Tracing of queues and packet receptions to file \"radvd-two-prefix.tr\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n#include \"ns3/radvd-interface.h\"\n#include \"ns3/radvd-prefix.h\"\n#include \"ns3/radvd.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RadvdTwoPrefixExample\");\n\n/**\n * \\class IpAddressHelper\n * \\brief Helper to print a node's IP addresses.\n */\nclass IpAddressHelper\n{\n  public:\n    /**\n     * \\brief Print the node's IP addresses.\n     * \\param n the node\n     */\n    inline void PrintIpAddresses(Ptr<Node>& n)\n    {\n        Ptr<Ipv6> ipv6 = n->GetObject<Ipv6>();\n        uint32_t nInterfaces = ipv6->GetNInterfaces();\n\n        std::cout << \"Node: \" << ipv6->GetObject<Node>()->GetId()\n                  << \" Time: \" << Simulator::Now().GetSeconds() << \"s \"\n                  << \"IPv6 addresses\" << std::endl;\n        std::cout << \"(Interface index, Address index)\\t\"\n                  << \"IPv6 Address\" << std::endl;\n\n        for (uint32_t i = 0; i < nInterfaces; i++)\n        {\n            for (uint32_t j = 0; j < ipv6->GetNAddresses(i); j++)\n            {\n                std::cout << \"(\" << int(i) << \",\" << int(j) << \")\\t\" << ipv6->GetAddress(i, j)\n                          << std::endl;\n            }\n        }\n        std::cout << std::endl;\n    }\n};\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6RawSocketImpl\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"RadvdApplication\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ping\", LOG_LEVEL_ALL);\n    }\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> n0 = CreateObject<Node>();\n    Ptr<Node> r = CreateObject<Node>();\n    Ptr<Node> n1 = CreateObject<Node>();\n\n    NodeContainer net1(n0, r);\n    NodeContainer net2(r, n1);\n    NodeContainer all(n0, r, n1);\n\n    NS_LOG_INFO(\"Create IPv6 Internet Stack\");\n    InternetStackHelper internetv6;\n    internetv6.Install(all);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d1 = csma.Install(net1); /* n0 - R */\n    NetDeviceContainer d2 = csma.Install(net2); /* R - n1 */\n\n    NS_LOG_INFO(\"Create networks and assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n\n    /* first subnet */\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    NetDeviceContainer tmp;\n    tmp.Add(d1.Get(0));                                           /* n0 */\n    Ipv6InterfaceContainer iic1 = ipv6.AssignWithoutAddress(tmp); /* n0 interface */\n\n    NetDeviceContainer tmp2;\n    tmp2.Add(d1.Get(1)); /* R */\n    Ipv6InterfaceContainer iicr1 =\n        ipv6.Assign(tmp2); /* R interface to the first subnet is just statically assigned */\n    iicr1.SetForwarding(0, true);\n    iic1.Add(iicr1);\n\n    /* add another IPv6 address for second prefix advertised on first subnet */\n    ipv6.SetBase(Ipv6Address(\"2001:ABCD::\"), Ipv6Prefix(64));\n    ipv6.Assign(tmp2);\n\n    /* second subnet R - n1 */\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    NetDeviceContainer tmp3;\n    tmp3.Add(d2.Get(0));                              /* R */\n    Ipv6InterfaceContainer iicr2 = ipv6.Assign(tmp3); /* R interface */\n    iicr2.SetForwarding(0, true);\n\n    NetDeviceContainer tmp4;\n    tmp4.Add(d2.Get(1)); /* n1 */\n    Ipv6InterfaceContainer iic2 = ipv6.AssignWithoutAddress(tmp4);\n    iic2.Add(iicr2);\n\n    /* radvd configuration */\n    RadvdHelper radvdHelper;\n    /* R interface (n0 - R) */\n    radvdHelper.AddAnnouncedPrefix(iic1.GetInterfaceIndex(1), Ipv6Address(\"2001:ABCD::0\"), 64);\n    radvdHelper.AddAnnouncedPrefix(iic1.GetInterfaceIndex(1), Ipv6Address(\"2001:1::0\"), 64);\n\n    // Set some non-standard timers so the simulation is not taking ages\n    Ptr<RadvdInterface> routerInterface = radvdHelper.GetRadvdInterface(iic1.GetInterfaceIndex(1));\n    routerInterface->SetMaxRtrAdvInterval(2000);\n    routerInterface->SetMinRtrAdvInterval(1000);\n    RadvdInterface::RadvdPrefixList prefixList = routerInterface->GetPrefixes();\n    for (auto iter = prefixList.begin(); iter != prefixList.end(); iter++)\n    {\n        (*iter)->SetPreferredLifeTime(3);\n        (*iter)->SetValidLifeTime(5);\n    }\n\n    /* R interface (R - n1) */\n    radvdHelper.AddAnnouncedPrefix(iic2.GetInterfaceIndex(1), Ipv6Address(\"2001:2::0\"), 64);\n\n    // Set some non-standard timers so the simulation is not taking ages\n    routerInterface = radvdHelper.GetRadvdInterface(iic2.GetInterfaceIndex(1));\n    routerInterface->SetMaxRtrAdvInterval(2000);\n    routerInterface->SetMinRtrAdvInterval(1000);\n    prefixList = routerInterface->GetPrefixes();\n    for (auto iter = prefixList.begin(); iter != prefixList.end(); iter++)\n    {\n        (*iter)->SetPreferredLifeTime(3);\n        (*iter)->SetValidLifeTime(5);\n    }\n\n    ApplicationContainer radvdApps = radvdHelper.Install(r);\n    radvdApps.Start(Seconds(1.0));\n    radvdApps.Stop(Seconds(2.0));\n\n    /* Create a Ping application to send ICMPv6 echo request from n0 to n1 via R */\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 8;\n    PingHelper ping(\n        Ipv6Address(\"2001:2::200:ff:fe00:4\")); /* should be n1 address after autoconfiguration */\n    // ping.SetIfIndex(iic1.GetInterfaceIndex(0));\n\n    ping.SetAttribute(\"Count\", UintegerValue(maxPacketCount));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    ApplicationContainer apps = ping.Install(net1.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(5.0));\n\n    Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);\n    Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(2.0), n0, routingStream);\n    Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(10.0), n0, routingStream);\n\n    IpAddressHelper ipAddressHelper;\n    /* RA should be received, two prefixes + routes + default route should be present */\n    Simulator::Schedule(Seconds(2.0), &IpAddressHelper::PrintIpAddresses, &ipAddressHelper, n0);\n    /* at the end, RA addresses and routes should be cleared */\n    Simulator::Schedule(Seconds(10.0), &IpAddressHelper::PrintIpAddresses, &ipAddressHelper, n0);\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"radvd-two-prefix.tr\"));\n    csma.EnablePcapAll(std::string(\"radvd-two-prefix\"), true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library that tests the creation of IPv6 addresses by autoconfiguring them from a set of MAC addresses. Initialize an array of 10 MAC addresses and set them to specific values. Use two different IPv6 prefixes, '2001:1::' and '2002:1:1::', and for each prefix, generate an autoconfigured IPv6 address for each MAC address in the array. Log the process, displaying the prefix and each corresponding generated IPv6 address in the console. Ensure to include the necessary ns-3 headers and set up logging for the program."}, {"role": "assistant", "content": "#include \"ns3/ipv6-address.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mac48-address.h\"\n#include \"ns3/node.h\"\n#include \"ns3/simulator.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TestIpv6\");\n\nint\nmain(int argc, char* argv[])\n{\n    LogComponentEnable(\"TestIpv6\", LOG_LEVEL_ALL);\n\n    NS_LOG_INFO(\"Test Ipv6\");\n\n    Mac48Address m_addresses[10];\n\n    m_addresses[0] = (\"00:00:00:00:00:01\");\n    m_addresses[1] = (\"00:00:00:00:00:02\");\n    m_addresses[2] = (\"00:00:00:00:00:03\");\n    m_addresses[3] = (\"00:00:00:00:00:04\");\n    m_addresses[4] = (\"00:00:00:00:00:05\");\n    m_addresses[5] = (\"00:00:00:00:00:06\");\n    m_addresses[6] = (\"00:00:00:00:00:07\");\n    m_addresses[7] = (\"00:00:00:00:00:08\");\n    m_addresses[8] = (\"00:00:00:00:00:09\");\n    m_addresses[9] = (\"00:00:00:00:00:10\");\n\n    Ipv6Address prefix1(\"2001:1::\");\n    NS_LOG_INFO(\"prefix = \" << prefix1);\n    for (uint32_t i = 0; i < 10; ++i)\n    {\n        NS_LOG_INFO(\"address = \" << m_addresses[i]);\n        Ipv6Address ipv6address = Ipv6Address::MakeAutoconfiguredAddress(m_addresses[i], prefix1);\n        NS_LOG_INFO(\"address = \" << ipv6address);\n    }\n\n    Ipv6Address prefix2(\"2002:1:1::\");\n\n    NS_LOG_INFO(\"prefix = \" << prefix2);\n    for (uint32_t i = 0; i < 10; ++i)\n    {\n        Ipv6Address ipv6address = Ipv6Address::MakeAutoconfiguredAddress(m_addresses[i], prefix2);\n        NS_LOG_INFO(\"address = \" << ipv6address);\n    }\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to model a Wireless Sensor Network (WSN) with two nodes communicating over an IEEE 802.15.4 network. Implement ICMPv6 echo requests and replies between the nodes, utilizing DropTail queues. Create a simulation environment where both nodes are stationary, and assign them specific IPv6 addresses within a defined prefix. Log the details of the packet flows and create a trace file named 'wsn-ping6.tr' for analyzing queue behavior and packet receptions. Include necessary headers and enable verbose logging for debugging the simulation process."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1\n//       |     |\n//       =================\n//        WSN (802.15.4)\n//\n// - ICMPv6 echo request flows from n0 to n1 and back with ICMPv6 echo reply\n// - DropTail queues\n// - Tracing of queues and packet receptions to file \"wsn-ping6.tr\"\n//\n// This example is based on the \"ping6.cc\" example.\n\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lr-wpan-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/sixlowpan-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Ping6WsnExample\");\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"Ping6WsnExample\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"Ipv6EndPointDemux\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6StaticRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6ListRouting\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ping\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"NdiscCache\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"SixLowPanNetDevice\", LOG_LEVEL_ALL);\n    }\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set seed for random numbers\n    SeedManager::SetSeed(167);\n\n    // Install mobility\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    Ptr<ListPositionAllocator> nodesPositionAlloc = CreateObject<ListPositionAllocator>();\n    nodesPositionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    nodesPositionAlloc->Add(Vector(50.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(nodesPositionAlloc);\n    mobility.Install(nodes);\n\n    NS_LOG_INFO(\"Create channels.\");\n    LrWpanHelper lrWpanHelper;\n    // Add and install the LrWpanNetDevice for each node\n    // lrWpanHelper.EnableLogComponents();\n    NetDeviceContainer devContainer = lrWpanHelper.Install(nodes);\n    lrWpanHelper.CreateAssociatedPan(devContainer, 10);\n\n    std::cout << \"Created \" << devContainer.GetN() << \" devices\" << std::endl;\n    std::cout << \"There are \" << nodes.GetN() << \" nodes\" << std::endl;\n\n    /* Install IPv4/IPv6 stack */\n    NS_LOG_INFO(\"Install Internet stack.\");\n    InternetStackHelper internetv6;\n    internetv6.SetIpv4StackInstall(false);\n    internetv6.Install(nodes);\n\n    // Install 6LowPan layer\n    NS_LOG_INFO(\"Install 6LoWPAN.\");\n    SixLowPanHelper sixlowpan;\n    NetDeviceContainer six1 = sixlowpan.Install(devContainer);\n\n    NS_LOG_INFO(\"Assign addresses.\");\n    Ipv6AddressHelper ipv6;\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer i = ipv6.Assign(six1);\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    /* Create a Ping application to send ICMPv6 echo request from node zero to\n     * all-nodes (ff02::1).\n     */\n    uint32_t packetSize = 16;\n    uint32_t maxPacketCount = 5;\n    Time interPacketInterval = Seconds(1.);\n    PingHelper ping(i.GetAddress(1, 1));\n\n    ping.SetAttribute(\"Count\", UintegerValue(maxPacketCount));\n    ping.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    ApplicationContainer apps = ping.Install(nodes.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    lrWpanHelper.EnableAsciiAll(ascii.CreateFileStream(\"ping6wsn.tr\"));\n    lrWpanHelper.EnablePcapAll(std::string(\"ping6wsn\"), true);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 simulation library to model an ad hoc wireless network with two nodes. Configure the nodes to use an IEEE 802.11 protocol with ad hoc mode, set up a mobility model that allows nodes to randomly walk within specified bounds, and install the Internet stack on both nodes. Assign IPv4 addresses and implement a UDP echo server on one node and a corresponding client on the other to exchange packets. Utilize the Flow Monitor to collect statistics such as packet delivery ratio, end-to-end delay, and throughput. Additionally, generate an animation file to visualize the network. Ensure to log detailed statistics for the simulation's performance analysis and output the results after the simulation concludes."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"AdhocNetworkExample\");\n\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable (\"AdhocNetworkExample\", LOG_LEVEL_INFO);\n\n  // Create two wireless nodes\n  NodeContainer nodes;\n  nodes.Create (2);\n\n  // Configure wireless parameters\n  WifiHelper wifi;\n\n  WifiMacHelper mac;\n  mac.SetType (\"ns3::AdhocWifiMac\");\n  \n\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n  YansWifiPhyHelper phy;\n  phy.SetChannel(channel.Create());\n  //phy.Set(\"TxPowerStart\", DoubleValue(10.0));\n  //phy.Set(\"TxPowerEnd\", DoubleValue(10.0));\n  //phy.Set(\"TxGain\", DoubleValue(0.0));\n  //phy.Set(\"RxGain\", DoubleValue(0.0));\n\n  \n\n  NetDeviceContainer devices = wifi.Install (phy, mac, nodes);\n  \n\n  // Set up mobility model\n  MobilityHelper mobility;\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0),\n                                 \"MinY\", DoubleValue (0.0),\n                                 \"DeltaX\", DoubleValue (5.0),\n                                 \"DeltaY\", DoubleValue (5.0),\n                                 \"GridWidth\", UintegerValue (2),\n                                 \"LayoutType\", StringValue (\"RowFirst\"));\n                                 \n                                \n  mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue(Rectangle(-25, 25, -25, 25)));\n  mobility.Install (nodes);\n  \n\n  // Set up network stack\n  InternetStackHelper stack;\n  stack.Install (nodes);\n\n  // Assign IPv4 addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  // Create a UDP echo server application on node 1\n  uint16_t port = 9; // well-known echo port number\n  UdpEchoServerHelper server (port);\n  ApplicationContainer serverApps = server.Install (nodes.Get (1));\n  serverApps.Start (Seconds (1.0));\n  serverApps.Stop (Seconds (100.0));\n\n  // Create a UDP echo client application on node 0\n  UdpEchoClientHelper client (interfaces.GetAddress (1), port);\n  client.SetAttribute (\"MaxPackets\", UintegerValue (1));\n  client.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps = client.Install (nodes.Get (0));\n  clientApps.Start (Seconds (2.0));\n  clientApps.Stop (Seconds (100.0));\n  \n  // Define a flow monitor object\n  Ptr<FlowMonitor> flowMonitor;\n  FlowMonitorHelper flowHelper;\n  flowMonitor = flowHelper.InstallAll();\n \n  \n  \n  Simulator::Stop(Seconds(100.0));\n  \n  \n  // Animation\n  AnimationInterface anim(\"two_wireless_nodes.xml\");\n  \n\n  // Run simulation\n  Simulator::Run ();\n  \n  // Calculate packet delivery ratio and end to end delay and throughput\n  uint32_t packetsDelivered = 0;\n  uint32_t totalPackets = 0;\n  double totalDelay = 0;\n  \n  \n  // Retrive the flow statistics\n  FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n  for(auto & it: stats)\n  {\n  \tFlowId flowId = it.first;\n    \tstd::cout << \"Flow \" << flowId << std::endl;\n    \tstd::cout << \" Tx Packets: \" << it.second.txPackets << std::endl;\n    \tstd::cout << \" Tx Bytes: \" << it.second.txBytes << std::endl;\n    \tstd::cout << \" Rx Packets: \" << it.second.rxPackets << std::endl;\n    \tstd::cout << \" Rx Bytes: \" << it.second.rxBytes << std::endl;\n    \t\n  \tif(it.second.rxPackets > 0)\n  \t{\n  \t\tpacketsDelivered += it.second.rxPackets;\n  \t\ttotalPackets += it.second.txPackets;\n  \t\ttotalDelay += (it.second.delaySum.ToDouble(ns3::Time::S) / it.second.rxPackets);\n  \t}\n  }\n  \n  double packetDeliveryRatio = (double) packetsDelivered / totalPackets;\n  double averageEndToEndDelay = totalDelay / packetsDelivered;\n  double throughput = (double) packetsDelivered * 1024 * 8 / (100.0 - 0.0) / 1000000;\n  \n  // Printing the results\n  std::cout << \"Packets Delivered Ratio: \" << packetDeliveryRatio << std::endl;\n  std::cout << \"Average End-to-End Delay: \" << averageEndToEndDelay << std::endl;\n  std::cout << \"Throughput: \" << throughput << std::endl;\n  \n  Simulator::Destroy ();\n\n  return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to model an ad hoc wireless network with two nodes. Configure the nodes to use the IEEE 802.11 protocol in ad hoc mode and set up a mobility model where nodes move randomly within defined boundaries. Install the Internet stack on the nodes and assign IPv4 addresses from the subnet 192.9.39.0/24. Implement UDP echo server and client applications on both nodes to facilitate bidirectional communication, allowing each node to send echo requests to the other. Incorporate flow monitoring to capture network statistics, including packet delivery ratios, end-to-end delays, and throughput. Generate an animation file to visualize the network activity during the simulation. Finally, output the collected flow statistics and performance metrics after running the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/propagation-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"AdhocNetworkExample\");\n\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable (\"AdhocNetworkExample\", LOG_LEVEL_INFO);\n\n  // Create two wireless nodes\n  NodeContainer nodes;\n  nodes.Create (2);\n\n  // Configure wireless parameters\n  WifiHelper wifi;\n\n  WifiMacHelper mac;\n  mac.SetType (\"ns3::AdhocWifiMac\");\n  \n\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default(); //define channel default configuration\n  YansWifiPhyHelper phy; //configure wifiPHY\n  phy.SetChannel(channel.Create());\n\n  NetDeviceContainer devices = wifi.Install (phy, mac, nodes); //create wifiNetDevice\n  \n\n  // Set up mobility model\n  MobilityHelper mobility; //to set position of nodes\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0), //starting node x axis\n                                 \"MinY\", DoubleValue (0.0), //starting node y axis\n                                 \"DeltaX\", DoubleValue (5.0), //gap before next node in row\n                                 \"DeltaY\", DoubleValue (5.0), //gap before next node in column\n                                 \"GridWidth\", UintegerValue (2), // max number of nodes based on the layout type\n                                 \"LayoutType\", StringValue (\"RowFirst\")); //nodes will first fill up the rows then columns\n                                 \n                                \n  mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue(Rectangle(-25, 25, -25, 25))); //nodes over randomly in 2D\n                                                                                          //nodes movement bound in rectangle   (Xmin,Xmax,Ymin,Ymax)        \n  mobility.Install (nodes); //install the nodes\n  \n  // Set up network stack\n  InternetStackHelper stack;\n  stack.Install (nodes);\n\n  // Assign IPv4 addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"192.9.39.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  UdpEchoServerHelper server10(9);\n  ApplicationContainer serverApps10 = server10.Install (nodes.Get (1));\n  serverApps10.Start (Seconds (1.0));\n  serverApps10.Stop (Seconds (100.0));\n\n  // Create a UDP echo client application on node 0\n  UdpEchoClientHelper client10 (interfaces.GetAddress (1), 9);\n  client10.SetAttribute (\"MaxPackets\", UintegerValue (10));\n  client10.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client10.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps10 = client10.Install (nodes.Get (0));\n  clientApps10.Start (Seconds (2.0));\n  clientApps10.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server01(10);\n  ApplicationContainer serverApps01 = server01.Install (nodes.Get (0));\n  serverApps10.Start (Seconds (1.0));\n  serverApps10.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client01 (interfaces.GetAddress (0), 10);\n  client01.SetAttribute (\"MaxPackets\", UintegerValue (10));\n  client01.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client01.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps01 = client01.Install (nodes.Get (1));\n  clientApps01.Start (Seconds (2.0));\n  clientApps01.Stop (Seconds (100.0));\n  \n  // Define a flow monitor object\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();\n  Simulator::Stop(Seconds(100.0));\n  \n  \n  // Animation\n  AnimationInterface anim(\"239_task1.xml\");\n  \n\n  // Run simulation\n  Simulator::Run ();\n  \n \n  \n Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());\n std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats ();\nfor (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n{\n // Calculate packet delivery ratio and end to end delay and throughput\n  uint32_t packetsDelivered = 0;\n  uint32_t totalPackets = 0;\n  double totalDelay = 0;\n Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);\nstd::cout << \"FlowId: \" << i->first << \"\\n\";\nstd::cout << \"Sender: \"<< t.sourceAddress << \"\\n\"; \nstd::cout << \"Receiver: \"<< t.destinationAddress << \"\\n\"; \nstd::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\nstd::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n\nstd::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\nstd::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\nif(i->second.rxPackets > 0)\n  \t{\n  \t\tpacketsDelivered += i->second.rxPackets;\n  \t\ttotalPackets += i->second.txPackets;\n  \t\ttotalDelay += (i->second.delaySum.ToDouble(ns3::Time::S) / i->second.rxPackets);\n  \t}\n       \n  double packetDeliveryRatio = (double) packetsDelivered / totalPackets;\n  double averageEndToEndDelay = totalDelay / packetsDelivered;\n  double throughput = (double) packetsDelivered * 1024 * 8 / (100.0 - 0.0) / 1000000;\n  \n  // Printing the results\n  std::cout << \"Packets Delivered Ratio: \" << packetDeliveryRatio << std::endl;\n  std::cout << \"Average End-to-End Delay: \" << averageEndToEndDelay << std::endl;\n  std::cout << \"Throughput: \" << throughput << std::endl;\n   }\n  \n \n  \n  Simulator::Destroy ();\n\n  return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 simulation library to model an ad hoc wireless network consisting of two nodes. Configure the nodes to operate with IEEE 802.11 in ad hoc mode and set the transmission power for both nodes to 50.0 dBm. Implement a mobility model where the nodes move randomly within defined rectangular boundaries. Install the Internet stack and assign IPv4 addresses from the subnet 192.9.39.0/24 to the nodes. Establish UDP echo server applications on both nodes, enabling bidirectional communication where each node sends echo requests to the other with a maximum of 50 packets sent at half-second intervals. Integrate a flow monitor to capture network statistics, including packet delivery ratios, end-to-end delays, and throughput. Generate an animation file to visualize the network activity during the simulation. Finally, output the collected flow statistics and performance metrics after running the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/propagation-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"AdhocNetworkExample\");\n\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable (\"AdhocNetworkExample\", LOG_LEVEL_INFO);\n\n  // Create two wireless nodes\n  NodeContainer nodes;\n  nodes.Create (2);\n\n  // Configure wireless parameters\n  WifiHelper wifi;\n\n  WifiMacHelper mac;\n  mac.SetType (\"ns3::AdhocWifiMac\");\n  \n\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default(); //define channel default configuration\n  YansWifiPhyHelper phy; //configure wifiPHY\n  phy.SetChannel(channel.Create());\n\n  //lower pvalues means more power andmore pckets sent\n  phy.Set(\"TxPowerStart\", DoubleValue(50.0)); //starts trandmission power\n  phy.Set(\"TxPowerEnd\", DoubleValue(50.0));//ends transmission power\n  \n\n  NetDeviceContainer devices = wifi.Install (phy, mac, nodes); //create wifiNetDevice\n  \n\n  // Set up mobility model\n  MobilityHelper mobility; //to set position of nodes\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0), //starting node x axis\n                                 \"MinY\", DoubleValue (0.0), //starting node y axis\n                                 \"DeltaX\", DoubleValue (5.0), //gap before next node in row\n                                 \"DeltaY\", DoubleValue (5.0), //gap before next node in column\n                                 \"GridWidth\", UintegerValue (2), // max number of nodes based on the layout type\n                                 \"LayoutType\", StringValue (\"RowFirst\")); //nodes will first fill up the rows then columns\n                                 \n                                \n  mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue(Rectangle(-25, 25, -25, 25))); //nodes over randomly in 2D\n                                                                                          //nodes movement bound in rectangle   (Xmin,Xmax,Ymin,Ymax)        \n  mobility.Install (nodes); //install the nodes\n  \n  // Set up network stack\n  InternetStackHelper stack;\n  stack.Install (nodes);\n\n  // Assign IPv4 addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"192.9.39.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  UdpEchoServerHelper server10(9);\n  ApplicationContainer serverApps10 = server10.Install (nodes.Get (1));\n  serverApps10.Start (Seconds (1.0));\n  serverApps10.Stop (Seconds (100.0));\n\n  // Create a UDP echo client application on node 0\n  UdpEchoClientHelper client10 (interfaces.GetAddress (1), 9);\n  client10.SetAttribute (\"MaxPackets\", UintegerValue (50));\n  client10.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client10.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps10 = client10.Install (nodes.Get (0));\n  clientApps10.Start (Seconds (2.0));\n  clientApps10.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server01(10);\n  ApplicationContainer serverApps01 = server01.Install (nodes.Get (0));\n  serverApps10.Start (Seconds (1.0));\n  serverApps10.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client01 (interfaces.GetAddress (0), 10);\n  client01.SetAttribute (\"MaxPackets\", UintegerValue (50));\n  client01.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client01.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps01 = client01.Install (nodes.Get (1));\n  clientApps01.Start (Seconds (2.0));\n  clientApps01.Stop (Seconds (100.0));\n  \n  // Define a flow monitor object\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();\n  Simulator::Stop(Seconds(100.0));\n  \n  \n  // Animation\n  AnimationInterface anim(\"239_task2.xml\");\n  \n\n  // Run simulation\n  Simulator::Run ();\n  \n \n  \n Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());\n std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats ();\nfor (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n{\n // Calculate packet delivery ratio and end to end delay and throughput\n  uint32_t packetsDelivered = 0;\n  uint32_t totalPackets = 0;\n  double totalDelay = 0;\n Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);\nstd::cout << \"FlowId: \" << i->first << \"\\n\";\nstd::cout << \"Sender: \"<< t.sourceAddress << \"\\n\"; \nstd::cout << \"Receiver: \"<< t.destinationAddress << \"\\n\"; \nstd::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\nstd::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n\nstd::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\nstd::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\nif(i->second.rxPackets > 0)\n  \t{\n  \t\tpacketsDelivered += i->second.rxPackets;\n  \t\ttotalPackets += i->second.txPackets;\n  \t\ttotalDelay += (i->second.delaySum.ToDouble(ns3::Time::S) / i->second.rxPackets);\n  \t}\n       \n  double packetDeliveryRatio = (double) packetsDelivered / totalPackets;\n  double averageEndToEndDelay = totalDelay / packetsDelivered;\n  double throughput = (double) packetsDelivered * 1024 * 8 / (100.0 - 0.0) / 1000000;\n  \n  // Printing the results\n  std::cout << \"Packets Delivered Ratio: \" << packetDeliveryRatio << std::endl;\n  std::cout << \"Average End-to-End Delay: \" << averageEndToEndDelay << std::endl;\n  std::cout << \"Throughput: \" << throughput << std::endl;\n   }\n  \n \n  \n  Simulator::Destroy ();\n\n  return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to create an ad hoc wireless network with four nodes. Configure the nodes to use IEEE 802.11 in ad hoc mode and set up a grid mobility model that positions them initially in a grid layout, allowing for random movement within a specified rectangular area. Install the Internet stack and assign IPv4 addresses from the subnet 192.9.39.0/24. Establish UDP echo server applications on each node, enabling them to communicate in a ring topology where each node sends echo requests to the next. Set the maximum number of packets for each client to 20, with an interval of half a second. Integrate a flow monitor to capture statistics such as packet delivery ratios, end-to-end delays, and throughput for all communications. Generate an animation file to visualize the network activity during the simulation. Finally, output the collected flow statistics and performance metrics after running the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/propagation-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"AdhocNetworkExample\");\n\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable (\"AdhocNetworkExample\", LOG_LEVEL_INFO);\n\n  // Create two wireless nodes\n  NodeContainer nodes;\n  nodes.Create (4);\n\n  // Configure wireless parameters\n  WifiHelper wifi;\n\n  WifiMacHelper mac;\n  mac.SetType (\"ns3::AdhocWifiMac\");\n  \n\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default(); //define channel default configuration\n  YansWifiPhyHelper phy; //configure wifiPHY\n  phy.SetChannel(channel.Create());\n\n  \n\n  NetDeviceContainer devices = wifi.Install (phy, mac, nodes); //create wifiNetDevice\n  \n\n  // Set up mobility model\n  MobilityHelper mobility; //to set position of nodes\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0), //starting node x axis\n                                 \"MinY\", DoubleValue (0.0), //starting node y axis\n                                 \"DeltaX\", DoubleValue (2.0), //gap before next node in row\n                                 \"DeltaY\", DoubleValue (2.0), //gap before next node in column\n                                 \"GridWidth\", UintegerValue (5), // max number of nodes based on the layout type\n                                 \"LayoutType\", StringValue (\"RowFirst\")); //nodes will first fill up the rows then columns\n                                 \n                                \n  mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue(Rectangle(-100, 100, -100,100))); //nodes over randomly in 2D\n                                                                                          //nodes movement bound in rectangle   (Xmin,Xmax,Ymin,Ymax)        \n  mobility.Install (nodes); //install the nodes\n  \n  // Set up network stack\n  InternetStackHelper stack;\n  stack.Install (nodes);\n\n  // Assign IPv4 addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"192.9.39.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  UdpEchoServerHelper server01(10);\n  ApplicationContainer serverApps01 = server01.Install (nodes.Get (0));\n  serverApps01.Start (Seconds (1.0));\n  serverApps01.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client01 (interfaces.GetAddress (0), 10);\n  client01.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client01.SetAttribute (\"Interval\", TimeValue (Seconds(0.5)));\n  client01.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps01 = client01.Install (nodes.Get (1));\n  clientApps01.Start (Seconds (2.0));\n  clientApps01.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server12(15);\n\n  ApplicationContainer serverApps12 = server12.Install (nodes.Get (1));\n  serverApps12.Start (Seconds (1.0));\n  serverApps12.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client12 (interfaces.GetAddress (1), 15);\n  client12.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client12.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client12.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps12 = client12.Install (nodes.Get (2));\n  clientApps12.Start (Seconds (2.0));\n  clientApps12.Stop (Seconds (100.0));\n\n   UdpEchoServerHelper server23(17);\n\n  ApplicationContainer serverApps23 = server23.Install (nodes.Get (2));\n  serverApps23.Start (Seconds (1.0));\n  serverApps23.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client23 (interfaces.GetAddress (2), 17);\n  client23.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client23.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client23.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps23 = client23.Install (nodes.Get (3));\n  clientApps23.Start (Seconds (2.0));\n  clientApps23.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server30(22);\n\n  ApplicationContainer serverApps30 = server30.Install (nodes.Get (3));\n  serverApps30.Start (Seconds (1.0));\n  serverApps30.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client30 (interfaces.GetAddress (3), 22);\n  client30.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client30.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client30.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps30 = client30.Install (nodes.Get (0));\n  clientApps30.Start (Seconds (2.0));\n  clientApps30.Stop (Seconds (100.0));\n  \n  // Define a flow monitor object\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();\n  Simulator::Stop(Seconds(100.0));\n  \n  \n  // Animation\n  AnimationInterface anim(\"239_task4_4nodes.xml\");\n  \n\n  // Run simulation\n  Simulator::Run ();\n  \n \n  \n Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());\n std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats ();\nfor (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n{\n // Calculate packet delivery ratio and end to end delay and throughput\n  uint32_t packetsDelivered = 0;\n  uint32_t totalPackets = 0;\n  double totalDelay = 0;\n Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);\nstd::cout << \"FlowId: \" << i->first << \"\\n\";\nstd::cout << \"Sender: \"<< t.sourceAddress << \"\\n\"; \nstd::cout << \"Receiver: \"<< t.destinationAddress << \"\\n\"; \nstd::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\nstd::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n\nstd::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\nstd::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\nif(i->second.rxPackets > 0)\n  \t{\n  \t\tpacketsDelivered += i->second.rxPackets;\n  \t\ttotalPackets += i->second.txPackets;\n  \t\ttotalDelay += (i->second.delaySum.ToDouble(ns3::Time::S) / i->second.rxPackets);\n  \t}\n       \n  double packetDeliveryRatio = (double) packetsDelivered / totalPackets;\n  double averageEndToEndDelay = totalDelay / packetsDelivered;\n  double throughput = (double) packetsDelivered * 1024 * 8 / (100.0 - 0.0) / 1000000;\n  \n  // Printing the results\n  std::cout << \"Packets Delivered Ratio: \" << packetDeliveryRatio << std::endl;\n  std::cout << \"Average End-to-End Delay: \" << averageEndToEndDelay << std::endl;\n  std::cout << \"Throughput: \" << throughput << std::endl;\n   }\n  \n \n  \n  Simulator::Destroy ();\n\n  return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 simulation library to set up an ad hoc wireless network with six nodes. Configure these nodes to operate in ad hoc mode using IEEE 802.11 and implement a grid mobility model that arranges them in a grid layout while allowing for random movement within a specified rectangular area. Install the Internet stack on each node and assign them IPv4 addresses from the 192.9.39.0/24 subnet. Establish UDP echo server applications on each node to facilitate communication in a ring topology where each node sends echo requests to the next. Limit each client to a maximum of 20 packets sent at half-second intervals. Integrate a flow monitor to collect statistics, including packet delivery ratios, end-to-end delays, and throughput for all communications. Generate an animation file to visualize the network activity during the simulation. After running the simulation, output the flow statistics and performance metrics to the console."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/propagation-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"AdhocNetworkExample\");\n\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable (\"AdhocNetworkExample\", LOG_LEVEL_INFO);\n\n  // Create two wireless nodes\n  NodeContainer nodes;\n  nodes.Create (6);\n\n  // Configure wireless parameters\n  WifiHelper wifi;\n\n  WifiMacHelper mac;\n  mac.SetType (\"ns3::AdhocWifiMac\");\n  \n\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default(); //define channel default configuration\n  YansWifiPhyHelper phy; //configure wifiPHY\n  phy.SetChannel(channel.Create());\n\n  \n\n  NetDeviceContainer devices = wifi.Install (phy, mac, nodes); //create wifiNetDevice\n  \n\n  // Set up mobility model\n  MobilityHelper mobility; //to set position of nodes\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0), //starting node x axis\n                                 \"MinY\", DoubleValue (0.0), //starting node y axis\n                                 \"DeltaX\", DoubleValue (2.0), //gap before next node in row\n                                 \"DeltaY\", DoubleValue (2.0), //gap before next node in column\n                                 \"GridWidth\", UintegerValue (5), // max number of nodes based on the layout type\n                                 \"LayoutType\", StringValue (\"RowFirst\")); //nodes will first fill up the rows then columns\n                                 \n                                \n  mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue(Rectangle(-100, 100, -100,100))); //nodes over randomly in 2D\n                                                                                          //nodes movement bound in rectangle   (Xmin,Xmax,Ymin,Ymax)        \n  mobility.Install (nodes); //install the nodes\n  \n  // Set up network stack\n  InternetStackHelper stack;\n  stack.Install (nodes);\n\n  // Assign IPv4 addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"192.9.39.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  UdpEchoServerHelper server01(10);\n\n  ApplicationContainer serverApps01 = server01.Install (nodes.Get (0));\n  serverApps01.Start (Seconds (1.0));\n  serverApps01.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client01 (interfaces.GetAddress (0), 10);\n  client01.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client01.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client01.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps01 = client01.Install (nodes.Get (1));\n  clientApps01.Start (Seconds (2.0));\n  clientApps01.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server12(21);\n\n  ApplicationContainer serverApps12 = server12.Install (nodes.Get (1));\n  serverApps12.Start (Seconds (1.0));\n  serverApps12.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client12 (interfaces.GetAddress (1), 21);\n  client12.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client12.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client12.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps12 = client12.Install (nodes.Get (2));\n  clientApps12.Start (Seconds (2.0));\n  clientApps12.Stop (Seconds (100.0));\n\n    UdpEchoServerHelper server23(27);\n\n  ApplicationContainer serverApps23 = server23.Install (nodes.Get (2));\n  serverApps23.Start (Seconds (1.0));\n  serverApps23.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client23 (interfaces.GetAddress (2), 27);\n  client23.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client23.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client23.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps23 = client23.Install (nodes.Get (3));\n  clientApps23.Start (Seconds (2.0));\n  clientApps23.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server34(33);\n\n  ApplicationContainer serverApps34 = server34.Install (nodes.Get (3));\n  serverApps34.Start (Seconds (1.0));\n  serverApps34.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client34 (interfaces.GetAddress (3), 33);\n  client34.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client34.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client34.SetAttribute (\"PacketSize\", UintegerValue (1024));\n\n  ApplicationContainer clientApps34 = client34.Install (nodes.Get (4));\n  clientApps34.Start (Seconds (2.0));\n  clientApps34.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server45(39);\n\n  ApplicationContainer serverApps45 = server45.Install (nodes.Get (4));\n  serverApps45.Start (Seconds (1.0));\n  serverApps45.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client45 (interfaces.GetAddress (4), 39);\n  client45.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client45.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client45.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps45 = client45.Install (nodes.Get (5));\n  clientApps45.Start (Seconds (2.0));\n  clientApps45.Stop (Seconds (100.0));\n\n  UdpEchoServerHelper server50(17);\n\n  ApplicationContainer serverApps50 = server50.Install (nodes.Get (5));\n  serverApps50.Start (Seconds (1.0));\n  serverApps50.Stop (Seconds (100.0));\n\n  UdpEchoClientHelper client50 (interfaces.GetAddress (5), 17);\n  client50.SetAttribute (\"MaxPackets\", UintegerValue (20));\n  client50.SetAttribute (\"Interval\", TimeValue (Seconds (0.5)));\n  client50.SetAttribute (\"PacketSize\", UintegerValue (1024));\n  \n  ApplicationContainer clientApps50 = client50.Install (nodes.Get (0));\n  clientApps50.Start (Seconds (2.0));\n  clientApps50.Stop (Seconds (100.0));\n\n\n\n  // Define a flow monitor object\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();\n  Simulator::Stop(Seconds(100.0));\n  \n  \n  // Animation\n  AnimationInterface anim(\"239_task5_6nodes.xml\");\n  \n\n  // Run simulation\n  Simulator::Run ();\n  \n \n  \n Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());\n std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats ();\nfor (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n{\n // Calculate packet delivery ratio and end to end delay and throughput\n  uint32_t packetsDelivered = 0;\n  uint32_t totalPackets = 0;\n  double totalDelay = 0;\n Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);\nstd::cout << \"FlowId: \" << i->first << \"\\n\";\nstd::cout << \"Sender: \"<< t.sourceAddress << \"\\n\"; \nstd::cout << \"Receiver: \"<< t.destinationAddress << \"\\n\"; \nstd::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\nstd::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n\nstd::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\nstd::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\nif(i->second.rxPackets > 0)\n  \t{\n  \t\tpacketsDelivered += i->second.rxPackets;\n  \t\ttotalPackets += i->second.txPackets;\n  \t\ttotalDelay += (i->second.delaySum.ToDouble(ns3::Time::S) / i->second.rxPackets);\n  \t}\n       \n  double packetDeliveryRatio = (double) packetsDelivered / totalPackets;\n  double averageEndToEndDelay = totalDelay / packetsDelivered;\n  double throughput = (double) packetsDelivered * 1024 * 8 / (100.0 - 0.0) / 1000000;\n  \n  // Printing the results\n  std::cout << \"Packets Delivered Ratio: \" << packetDeliveryRatio << std::endl;\n  std::cout << \"Average End-to-End Delay: \" << averageEndToEndDelay << std::endl;\n  std::cout << \"Throughput: \" << throughput << std::endl;\n   }\n  \n \n  \n  Simulator::Destroy ();\n\n  return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the NS-3 simulation framework to simulate a network topology with two nodes (n0 and n1) connected via a CSMA LAN. The program should simulate a UDP flow from node n0 to node n1, where the client on n0 sends packets based on the data read from a trace file. The user should be able to select between IPv4 and IPv6 addressing via command-line arguments and also have the option to enable or disable logging statements. When logging is enabled, it should provide detailed logs for both the UDP client and server. Configure the CSMA channel with a data rate of 5 Mbps, a delay of 2 ms, and an MTU of 1500 bytes. The UDP server should run on port 4000 and be installed on node n1, starting at 1 second and stopping at 10 seconds. The UDP client should back off 28 bytes (20 for IP and 8 for UDP) from the MTU to set the maximum packet size at 1472 bytes and start sending packets at 2 seconds, stopping at 10 seconds. Use the required NS-3 modules (applications, core, csma, and internet), and ensure the program runs with appropriate logging and simulation outputs."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1\n//       |     |\n//       =======\n//         LAN (CSMA)\n//\n// - UDP flow from n0 to n1 of packets drawn from a trace file\n//  -- option to use IPv4 or IPv6 addressing\n//  -- option to disable logging statements\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpTraceClientServerExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Declare variables used in command-line arguments\n    bool useV6 = false;\n    bool logging = true;\n    Address serverAddress;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"useIpv6\", \"Use Ipv6\", useV6);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.Parse(argc, argv);\n\n    if (logging)\n    {\n        LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n    }\n\n    NS_LOG_INFO(\"Create nodes in above topology.\");\n    NodeContainer n;\n    n.Create(2);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    NS_LOG_INFO(\"Create channel between the two nodes.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1500));\n    NetDeviceContainer d = csma.Install(n);\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    if (!useV6)\n    {\n        Ipv4AddressHelper ipv4;\n        ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer i = ipv4.Assign(d);\n        serverAddress = Address(i.GetAddress(1));\n    }\n    else\n    {\n        Ipv6AddressHelper ipv6;\n        ipv6.SetBase(\"2001:0000:f00d:cafe::\", Ipv6Prefix(64));\n        Ipv6InterfaceContainer i6 = ipv6.Assign(d);\n        serverAddress = Address(i6.GetAddress(1, 1));\n    }\n\n    NS_LOG_INFO(\"Create UdpServer application on node 1.\");\n    uint16_t port = 4000;\n    UdpServerHelper server(port);\n    ApplicationContainer apps = server.Install(n.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Create UdpClient application on node 0 to send to node 1.\");\n    uint32_t MaxPacketSize = 1472; // Back off 20 (IP) + 8 (UDP) bytes from MTU\n    UdpTraceClientHelper client(serverAddress, port, \"\");\n    client.SetAttribute(\"MaxPacketSize\", UintegerValue(MaxPacketSize));\n    apps = client.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 simulation library to model an ad hoc network with 10 nodes utilizing AODV routing protocol. Configure these nodes in a grid layout and enable random mobility within a defined area. Implement a UDP echo server on each node, allowing them to send echo requests to the next node in a circular manner, with clients sending requests every 4 seconds. Set the simulation parameters to enable PCAP tracing and optional printing of routing tables at specified intervals. Integrate a flow monitor to capture network statistics, including packet delivery ratios, end-to-end delays, and throughput, and output these metrics after the simulation completes. Additionally, create an animation file to visualize the simulation's activity."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/aodv-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocNetworkExample\");\n\nvoid UpdateNodePositions(NodeContainer &nodes)\n{\n    Ptr<UniformRandomVariable> rand = CreateObject<UniformRandomVariable>();\n    for (NodeContainer::Iterator it = nodes.Begin(); it != nodes.End(); ++it)\n    {\n        Ptr<MobilityModel> mobility = (*it)->GetObject<MobilityModel>();\n        double x = rand->GetValue(-100, 100);\n        double y = rand->GetValue(-100, 100);\n        mobility->SetPosition(Vector(x, y, 0.0));\n    }\n    Simulator::Schedule(Seconds(5.0), &UpdateNodePositions, nodes);\n}\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"AdhocNetworkExample\", LOG_LEVEL_INFO);\n\n    int size = 10;\n    int step = 50;\n    int totalTime = 100;\n    bool pcap = true;\n    bool printRoutes = true;\n\n    NodeContainer nodes;\n    nodes.Create(size);\n    CommandLine cmd(__FILE__);\n\n    cmd.AddValue(\"pcap\", \"Write PCAP traces.\", pcap);\n    cmd.AddValue(\"printRoutes\", \"Print routing table dumps.\", printRoutes);\n    cmd.AddValue(\"size\", \"Number of nodes.\", size);\n    cmd.AddValue(\"time\", \"Simulation time, s.\", totalTime);\n    cmd.AddValue(\"step\", \"Grid step, m\", step);\n\n    cmd.Parse(argc, argv);\n\n    WifiHelper wifi;\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n    phy.Set(\"TxPowerStart\", DoubleValue(20));\n    phy.Set(\"TxPowerEnd\", DoubleValue(20));\n    phy.Set(\"TxGain\", DoubleValue(0.0));\n    phy.Set(\"RxGain\", DoubleValue(0.0));\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(20.0),\n                                  \"DeltaY\", DoubleValue(20.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue(Rectangle(-100, 100, -100, 100)));\n    mobility.Install(nodes);\n\n    if (pcap)\n    {\n        phy.EnablePcapAll(std::string(\"aodv\"));\n    }\n    AodvHelper aodv;\n    InternetStackHelper stack;\n    stack.SetRoutingHelper(aodv);\n    stack.Install(nodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.2.22.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    if (printRoutes)\n    {\n        Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(\"scratch/routingTable_update.routes\", std::ios::out);\n        for (int i = 2; i <= totalTime; i += 2)\n        {\n            aodv.PrintRoutingTableAllAt(Seconds(i), routingStream);\n            Simulator::Schedule(Seconds(i), &UpdateNodePositions, nodes); // Schedule position update\n        }\n    }\n    uint16_t port = 9;\n    UdpEchoServerHelper server(port);\n    ApplicationContainer serverApps;\n\n    for (int i = 0; i < size; i++)\n    {\n        serverApps.Add(server.Install(nodes.Get(i)));\n    }\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(totalTime));\n    ApplicationContainer clientApps[size];\n\n    for (int i = 0; i < size; i++)\n    {\n        UdpEchoClientHelper client(interfaces.GetAddress((i + 1) % size), port);\n        client.SetAttribute(\"MaxPackets\", UintegerValue(50));\n        client.SetAttribute(\"Interval\", TimeValue(Seconds(4.0)));\n        client.SetAttribute(\"PacketSize\", UintegerValue(512));\n        clientApps[i].Add(client.Install(nodes.Get(i)));\n    }\n\n    // Start and stop client applications\n    for (int i = 0; i < size; i++)\n    {\n        clientApps[i].Start(Seconds(2.0 + 10 * i));\n        clientApps[i].Stop(Seconds(totalTime));\n    }\n\n    // Define a flow monitor object\n    Ptr<FlowMonitor> flowMonitor;\n    FlowMonitorHelper flowHelper;\n    flowMonitor = flowHelper.InstallAll();\n\n    Simulator::Stop(Seconds(totalTime));\n\n    // Animation\n    AnimationInterface anim(\"ten_nodes_aodv.xml\");\n\n    // Run simulation\n    Simulator::Run();\n\n    // Calculate packet delivery ratio and end-to-end delay and throughput\n    uint32_t packetsDelivered = 0;\n    uint32_t totalPackets = 0;\n    double totalDelay = 0;\n\n    // Retrieve the flow statistics\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n    for (auto &it : stats)\n    {\n        FlowId flowId = it.first;\n        std::cout << \"Flow \" << flowId << std::endl;\n        std::cout << \" Tx Packets: \" << it.second.txPackets << std::endl;\n        std::cout << \" Tx Bytes: \" << it.second.txBytes << std::endl;\n        std::cout << \" Rx Packets: \" << it.second.rxPackets << std::endl;\n        std::cout << \" Rx Bytes: \" << it.second.rxBytes << std::endl;\n\n        if (it.second.rxPackets > 0)\n        {\n            packetsDelivered += it.second.rxPackets;\n            totalPackets += it.second.txPackets;\n            totalDelay += (it.second.delaySum.ToDouble(ns3::Time::S) / it.second.rxPackets);\n        }\n    }\n\n    double packetDeliveryRatio = (double)packetsDelivered / totalPackets;\n    double averageEndToEndDelay = totalDelay / packetsDelivered;\n    double throughput = (double)packetsDelivered * 512 * 8 / (totalTime - 1.0) / 1000000;\n\n    // Print the results\n    std::cout << \"Packets Delivered Ratio: \" << packetDeliveryRatio << std::endl;\n    std::cout << \"Average End-to-End Delay: \" << averageEndToEndDelay << std::endl;\n    std::cout << \"Throughput: \" << throughput << std::endl;\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to model a disaster recovery network consisting of a central command node, three medical units, and three teams of responders, each with five nodes. Implement a WiFi ad hoc network where the teams have random mobility while the medical units and the central command remain stationary. Configure the nodes with appropriate IP addresses and enable RTS/CTS for improved performance. Set up a UDP echo server for each team and corresponding clients to send packets every two seconds. Integrate a flow monitor to capture statistics such as packet delivery ratios, end-to-end delays, and throughput, and output these metrics after the simulation. Additionally, create an animation file to visualize the network activity during the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/aodv-module.h\" // Include AODV header\n\nusing namespace ns3;\nNS_LOG_COMPONENT_DEFINE (\"AdhocNetworkExample\");\n\nint main (int argc, char *argv[])\n{\n   LogComponentEnable (\"AdhocNetworkExample\", LOG_LEVEL_INFO);\n  // Basic setup\n  NodeContainer centralCommand;\n  centralCommand.Create (1);\n\n  NodeContainer medicalUnits;\n  medicalUnits.Create (3);\n\n  NodeContainer teamA, teamB, teamC;\n  teamA.Create (5);\n  teamB.Create (5);\n  teamC.Create (5);\n\n  // Setup WiFi\n  WifiHelper wifi;\n  WifiMacHelper mac;\n  mac.SetType (\"ns3::AdhocWifiMac\");\n  YansWifiPhyHelper phy;\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n  phy.SetChannel(channel.Create());\n  phy.Set(\"TxPowerStart\", DoubleValue(20));\n  phy.Set(\"TxPowerEnd\", DoubleValue(20));\n  phy.Set(\"TxGain\", DoubleValue(0.0));\n  phy.Set(\"RxGain\", DoubleValue(0.0));\n  \n  Ssid ssid = Ssid (\"DisasterRecoveryNet\");\n\n  // Setup AP and Medical Units\n  mac.SetType (\"ns3::StaWifiMac\", \"Ssid\", SsidValue (ssid));\n  NetDeviceContainer medicalDevices = wifi.Install (phy, mac, medicalUnits);\n\n  mac.SetType (\"ns3::ApWifiMac\", \"Ssid\", SsidValue (ssid));\n  NetDeviceContainer apDevice = wifi.Install (phy, mac, centralCommand.Get (0));\n\n  // Mobility model for fixed positions\n  MobilityHelper mobility;\n  mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install (centralCommand);\n  mobility.Install (medicalUnits);\n\n  // Setup Ad Hoc Networks for teams\n  NetDeviceContainer teamADevices, teamBDevices, teamCDevices;\n\n  mac.SetType (\"ns3::AdhocWifiMac\");\n  teamADevices = wifi.Install (phy, mac, teamA);\n  teamBDevices = wifi.Install (phy, mac, teamB);\n  teamCDevices = wifi.Install (phy, mac, teamC);\n\n  // Mobility model for random movement\n  MobilityHelper teamMobility;\n  teamMobility.SetMobilityModel (\"ns3::RandomWalk2dMobilityModel\");\n  teamMobility.Install(teamA);\n  teamMobility.Install(teamB);\n  teamMobility.Install(teamC);\n\n  // Internet stack and routing protocols\n  InternetStackHelper stack1,stack2,stack3,stack4,stack5;\n  AodvHelper aodv;\n  stack1.SetRoutingHelper(aodv);\n  stack2.SetRoutingHelper(aodv);\n  stack3.SetRoutingHelper(aodv);\n  stack4.SetRoutingHelper(aodv);\n  stack5.SetRoutingHelper(aodv);\n  stack1.Install(teamA);\n  stack2.Install(teamB);\n  stack3.Install(teamC);\n  stack4.Install(medicalUnits);\n  stack5.Install(centralCommand);\n\n\n  // Assign IP addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer apInterface;\n  apInterface = address.Assign (apDevice);\n  address.Assign (medicalDevices);\n\n  address.SetBase (\"10.1.2.0\", \"255.255.255.0\");\n  address.Assign (teamADevices);\n\n  address.SetBase (\"10.1.3.0\", \"255.255.255.0\");\n  address.Assign (teamBDevices);\n\n  address.SetBase (\"10.1.4.0\", \"255.255.255.0\");\n  address.Assign (teamCDevices);\n  \n //enable RTS/CTS\n  bool enableCtsRts = true;\n  UintegerValue ctsThr = (enableCtsRts ? UintegerValue(100) : UintegerValue(2200));\n  Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", ctsThr);\n \n  // UDP Echo Client/Server application setup for teamA, teamB, teamC\n  int16_t port = 9; // well-known echo port number\n  UdpEchoServerHelper echoServer (port);\n  ApplicationContainer serverApps;\n  for (NodeContainer team : {teamA, teamB, teamC})\n  {\n\n    for (uint32_t i = 0; i < team.GetN (); ++i)\n    {\n      serverApps.Add (echoServer.Install (team.Get (i)));\n    }\n    serverApps.Start (Seconds (1.0));\n    serverApps.Stop (Seconds (100.0));\n\n    // Create UDP echo client application on each node\n    ApplicationContainer clientApps[team.GetN ()];\n\n    for (uint32_t i = 0; i < team.GetN (); ++i)\n    {\n      UdpEchoClientHelper echoClient (team.Get ((i + 1) % team.GetN ())->GetObject<Ipv4> ()->GetAddress (1, 0).GetLocal (), port);\n      echoClient.SetAttribute (\"MaxPackets\", UintegerValue (100)); // Adjust as needed\n      echoClient.SetAttribute (\"Interval\", TimeValue (Seconds (2.0)));\n      echoClient.SetAttribute (\"PacketSize\", UintegerValue (1024));\n      clientApps[i].Add (echoClient.Install (team.Get (i)));\n    }\n\n    // Start and stop client applications\n    for (uint32_t i = 0; i < team.GetN (); i+4)\n    {\n      clientApps[i].Start (Seconds (2.0 + 10 * i));\n      clientApps[i].Stop (Seconds (100.0));\n    }\n  } \n\n  // Define a flow monitor object\n    Ptr<FlowMonitor> flowMonitor;\n    FlowMonitorHelper flowHelper;\n    flowMonitor = flowHelper.InstallAll();\n\n    Simulator::Stop(Seconds(100.0));\n\n    // Animation\n    AnimationInterface anim(\"final.xml\");\n\n    // Run simulation\n    Simulator::Run ();\n\n    // Calculate packet delivery ratio and end-to-end delay and throughput\n    uint32_t packetsDelivered = 0;\n    uint32_t totalPackets = 0;\n    double totalDelay = 0;\n\n    // Retrieve the flow statistics\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n    for(auto & it: stats) {\n        FlowId flowId = it.first;\n        std::cout << \"Flow \" << flowId << std::endl;\n        std::cout << \" Tx Packets: \" << it.second.txPackets << std::endl;\n        std::cout << \" Tx Bytes: \" << it.second.txBytes << std::endl;\n        std::cout << \" Rx Packets: \" << it.second.rxPackets << std::endl;\n        std::cout << \" Rx Bytes: \" << it.second.rxBytes << std::endl;\n\n        if(it.second.rxPackets > 0) {\n            packetsDelivered += it.second.rxPackets;\n            totalPackets += it.second.txPackets;\n            totalDelay += (it.second.delaySum.ToDouble(ns3::Time::S) / it.second.rxPackets);\n        }\n    }\n\n    double packetDeliveryRatio = (double) packetsDelivered / totalPackets;\n    double averageEndToEndDelay = totalDelay / packetsDelivered;\n    double throughput = (double) packetsDelivered * 1024 * 8 / (100.0 - 0.0) / 1000000;\n\n    // Print the results\n    std::cout << \"Packets Delivered Ratio: \" << packetDeliveryRatio << std::endl;\n    std::cout << \"Average End-to-End Delay: \" << averageEndToEndDelay << std::endl;\n    std::cout << \"Throughput: \" << throughput << std::endl;\n\n    Simulator::Destroy ();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 that creates a basic point-to-point network with two nodes connected by a point-to-point link. Assign IP addresses to the nodes, set up a UDP communication between them, and enable packet tracing. Finally, generate a NetAnim XML trace file for visualizing the network simulation. The animation should include node positions and packet transmission animations."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleNetAnimExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for debugging\n    LogComponentEnable(\"SimpleNetAnimExample\", LOG_LEVEL_INFO);\n\n    // Step 1: Create two nodes\n    NS_LOG_INFO(\"Creating nodes.\");\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Step 2: Set up a point-to-point link between nodes\n    NS_LOG_INFO(\"Creating point-to-point link.\");\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Step 3: Install the internet stack on the nodes\n    NS_LOG_INFO(\"Installing internet stack.\");\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Step 4: Assign IP addresses to the nodes\n    NS_LOG_INFO(\"Assigning IP addresses.\");\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Step 5: Set up UDP communication\n    NS_LOG_INFO(\"Setting up UDP server and client.\");\n    uint16_t port = 9; // port number for the application\n\n    // UDP Server on node 1\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // UDP Client on node 0\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Step 6: Enable packet tracing\n    NS_LOG_INFO(\"Enabling packet tracing.\");\n    AsciiTraceHelper ascii;\n    pointToPoint.EnableAsciiAll(ascii.CreateFileStream(\"simple-netanim.tr\"));\n\n    // Step 7: Set up NetAnim for visualizing the network\n    NS_LOG_INFO(\"Setting up NetAnim.\");\n    AnimationInterface anim(\"simple-netanim.xml\");\n\n    // Set node positions for visualization\n    anim.SetConstantPosition(nodes.Get(0), 0.0, 0.0);  // Node 0 at (0,0)\n    anim.SetConstantPosition(nodes.Get(1), 10.0, 0.0); // Node 1 at (10,0)\n\n    // Step 8: Run the simulation\n    NS_LOG_INFO(\"Running the simulation.\");\n    Simulator::Run();\n\n    // Step 9: Clean up and destroy the simulation\n    NS_LOG_INFO(\"Destroying the simulation.\");\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 that sets up a simple network with four nodes connected in a square topology. Use point-to-point links between the nodes and configure OSPF (Open Shortest Path First) as the routing protocol. Assign IP addresses to the nodes and set up UDP communication between two of the nodes. Enable packet tracing and create a pcap trace file for each point-to-point link. The network should use OSPF to dynamically find the best route for packets. Additionally, display the routing tables at the end of the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ospf-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OSPFExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for debugging\n    LogComponentEnable(\"OSPFExample\", LOG_LEVEL_INFO);\n\n    // Step 1: Create four nodes in a square topology\n    NS_LOG_INFO(\"Creating nodes.\");\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Step 2: Set up point-to-point links between the nodes\n    NS_LOG_INFO(\"Creating point-to-point links.\");\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devicesAB, devicesBC, devicesCD, devicesDA;\n    devicesAB = pointToPoint.Install(nodes.Get(0), nodes.Get(1)); // Link between node 0 and node 1\n    devicesBC = pointToPoint.Install(nodes.Get(1), nodes.Get(2)); // Link between node 1 and node 2\n    devicesCD = pointToPoint.Install(nodes.Get(2), nodes.Get(3)); // Link between node 2 and node 3\n    devicesDA = pointToPoint.Install(nodes.Get(3), nodes.Get(0)); // Link between node 3 and node 0\n\n    // Step 3: Install the internet stack with OSPF routing\n    NS_LOG_INFO(\"Installing internet stack.\");\n    OspfHelper ospf; // Helper to set up OSPF\n    Ipv4ListRoutingHelper listRouting;\n    listRouting.Add(ospf, 10); // Add OSPF with priority 10\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(listRouting); // Set the routing protocol to OSPF\n    internet.Install(nodes);\n\n    // Step 4: Assign IP addresses to the nodes\n    NS_LOG_INFO(\"Assigning IP addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfacesAB = ipv4.Assign(devicesAB);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfacesBC = ipv4.Assign(devicesBC);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfacesCD = ipv4.Assign(devicesCD);\n\n    ipv4.SetBase(\"10.1.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfacesDA = ipv4.Assign(devicesDA);\n\n    // Step 5: Set up UDP communication\n    NS_LOG_INFO(\"Setting up UDP communication.\");\n    uint16_t port = 9; // Port number for the UDP application\n\n    // UDP Server on node 3\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(3));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // UDP Client on node 0\n    UdpClientHelper udpClient(interfacesCD.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Step 6: Enable packet tracing\n    NS_LOG_INFO(\"Enabling packet tracing.\");\n    pointToPoint.EnablePcapAll(\"ospf-routing-example\");\n\n    // Step 7: Display the routing tables\n    NS_LOG_INFO(\"Printing routing tables.\");\n    for (uint32_t i = 0; i < nodes.GetN(); i++)\n    {\n        Ptr<Ipv4> ipv4 = nodes.Get(i)->GetObject<Ipv4>();\n        ipv4->GetRoutingProtocol()->PrintRoutingTable(Create<OutputStreamWrapper>(&std::cout));\n    }\n\n    // Step 8: Run the simulation\n    NS_LOG_INFO(\"Running the simulation.\");\n    Simulator::Run();\n\n    // Step 9: Clean up and destroy the simulation\n    NS_LOG_INFO(\"Destroying the simulation.\");\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 that simulates a network with a hub and trunk ports. The hub connects four nodes, where three nodes belong to different subnets (acting as separate VLANs) and communicate with each other via a central hub node. The hub node acts as a router, routing traffic between the subnets. Use the CSMA helper to simulate the shared medium, assign different subnets to each node, and set up routing tables. Enable packet tracing to capture the traffic and generate a pcap trace file."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TrunkPortSimulation\");\n\nint main(int argc, char *argv[])\n{\n    // Step 1: Create nodes\n    NodeContainer hubNode; // Central hub node\n    hubNode.Create(1);\n\n    NodeContainer clientNodes;\n    clientNodes.Create(3); // Three client nodes representing VLANs\n\n    // Step 2: Create a CSMA network (shared medium like a hub)\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install CSMA devices to the nodes\n    NodeContainer allNodes = NodeContainer(hubNode, clientNodes);\n    NetDeviceContainer devices = csma.Install(allNodes);\n\n    // Step 3: Install the internet stack\n    InternetStackHelper internet;\n    internet.Install(allNodes);\n\n    // Step 4: Assign IP addresses to different VLANs (subnets)\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vlan1Interfaces = ipv4.Assign(devices.Get(0)); // Hub side\n    vlan1Interfaces.Add(ipv4.Assign(devices.Get(1)));                     // Client 1\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vlan2Interfaces = ipv4.Assign(devices.Get(2)); // Client 2\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vlan3Interfaces = ipv4.Assign(devices.Get(3)); // Client 3\n\n    // Step 5: Set up routing between the VLANs\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Step 6: Create applications to simulate communication between VLANs\n    // UDP Echo Server on node 1 (Client 1 in VLAN 1)\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(clientNodes.Get(0)); // Client 1\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // UDP Echo Client on node 2 (Client 2 in VLAN 2), sending to Client 1\n    UdpEchoClientHelper echoClient(vlan1Interfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(clientNodes.Get(1)); // Client 2\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Step 7: Enable packet tracing (pcap tracing)\n    csma.EnablePcap(\"trunk-port-simulation\", devices);\n\n    // Step 8: Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 that simulates the Routing Information Protocol (RIP) over a network with multiple nodes. The simulation should create a simple network topology where RIP is used to exchange routing information between routers. Implement a star topology with one central node (the main router) and four edge nodes (subnet routers). Assign IP addresses to each node and use RIP for dynamic routing. Capture and trace the routing tables as the simulation runs."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/rip-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RipExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Step 1: Create nodes\n    NodeContainer centralRouter;\n    centralRouter.Create(1); // The central router\n\n    NodeContainer edgeRouters;\n    edgeRouters.Create(4); // 4 edge routers\n\n    // Step 2: Create point-to-point links\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create links between central router and each edge router\n    NetDeviceContainer devices[4];\n    for (int i = 0; i < 4; ++i)\n    {\n        devices[i] = p2p.Install(centralRouter.Get(0), edgeRouters.Get(i));\n    }\n\n    // Step 3: Install internet stacks\n    RipHelper ripRouting;\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(ripRouting); // Set RIP as the routing protocol\n    internet.Install(centralRouter);\n    internet.Install(edgeRouters);\n\n    // Step 4: Assign IP addresses\n    Ipv4AddressHelper ipv4;\n\n    Ipv4InterfaceContainer interfaces[4];\n    for (int i = 0; i < 4; ++i)\n    {\n        std::ostringstream subnet;\n        subnet << \"10.1.\" << i + 1 << \".0\";\n        ipv4.SetBase(subnet.str().c_str(), \"255.255.255.0\");\n        interfaces[i] = ipv4.Assign(devices[i]);\n    }\n\n    // Step 5: Set up routing information protocol (RIP)\n    for (int i = 0; i < 4; ++i)\n    {\n        ripRouting.AddNetworkRouteTo(centralRouter.Get(0), interfaces[i].GetAddress(0), interfaces[i].GetAddress(1), 1);\n    }\n\n    // Step 6: Add a simple UDP Echo application\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(edgeRouters.Get(0)); // Install the server on the first edge router\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces[0].GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(edgeRouters.Get(1)); // Install the client on the second edge router\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Step 7: Enable tracing (pcap trace)\n    p2p.EnablePcapAll(\"rip-routing\");\n\n    // Step 8: Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 to simulate Distance Vector Routing (DVR) in a small network. Create a simple network topology with three routers and four subnetworks, where Distance Vector Routing is used to dynamically compute the best path between nodes. The topology should include point-to-point links between the routers and allow traffic between subnetworks using the dynamic routing information generated by DVR. Also, include pcap tracing to capture the data flow and routing exchanges."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/rip-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"DVRSimulation\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Command-line options\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Step 1: Create nodes (3 routers)\n    NodeContainer routers;\n    routers.Create(3);\n\n    // Step 2: Create point-to-point links between routers\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer routerLink1 = p2p.Install(routers.Get(0), routers.Get(1)); // Link between router 0 and router 1\n    NetDeviceContainer routerLink2 = p2p.Install(routers.Get(1), routers.Get(2)); // Link between router 1 and router 2\n    NetDeviceContainer routerLink3 = p2p.Install(routers.Get(0), routers.Get(2)); // Link between router 0 and router 2\n\n    // Step 3: Install internet stacks\n    RipHelper ripRouting;\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(ripRouting); // Use RIP as the routing protocol\n    internet.Install(routers);\n\n    // Step 4: Assign IP addresses to the links\n    Ipv4AddressHelper ipv4;\n\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iRouter1 = ipv4.Assign(routerLink1);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iRouter2 = ipv4.Assign(routerLink2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iRouter3 = ipv4.Assign(routerLink3);\n\n    // Step 5: Enable Global Routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Step 6: Add a UDP echo server on router 2\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(routers.Get(2)); // Server on router 2\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Step 7: Add a UDP echo client on router 0\n    UdpEchoClientHelper echoClient(iRouter2.GetAddress(1), 9); // Targeting router 2 IP\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(routers.Get(0)); // Client on router 0\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Step 8: Enable tracing (pcap files)\n    p2p.EnablePcapAll(\"dvr-routing\");\n\n    // Step 9: Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 to simulate a small network running Link State Routing. Create a topology of four routers connected by point-to-point links, where OSPF (Open Shortest Path First) is used to simulate Link State Routing. The program should allow dynamic route discovery using the OSPF protocol, include traffic generation from one end of the network to another, and generate pcap tracing files to observe routing behavior and data traffic."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/ospf-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LinkStateRoutingExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Command-line options\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Step 1: Create 4 routers\n    NodeContainer routers;\n    routers.Create(4);\n\n    // Step 2: Create point-to-point links between routers\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create the links between the routers\n    NetDeviceContainer link1 = p2p.Install(routers.Get(0), routers.Get(1)); // Link between router 0 and 1\n    NetDeviceContainer link2 = p2p.Install(routers.Get(1), routers.Get(2)); // Link between router 1 and 2\n    NetDeviceContainer link3 = p2p.Install(routers.Get(2), routers.Get(3)); // Link between router 2 and 3\n    NetDeviceContainer link4 = p2p.Install(routers.Get(0), routers.Get(3)); // Link between router 0 and 3\n\n    // Step 3: Install internet stacks with OSPF (Link State Routing) on the routers\n    OspfHelper ospfRouting;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(ospfRouting);\n    internet.Install(routers);\n\n    // Step 4: Assign IP addresses to the links\n    Ipv4AddressHelper ipv4;\n\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1 = ipv4.Assign(link1);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i2 = ipv4.Assign(link2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i3 = ipv4.Assign(link3);\n\n    ipv4.SetBase(\"10.1.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i4 = ipv4.Assign(link4);\n\n    // Step 5: Enable OSPF (Link State Routing) on all routers\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Step 6: Create a UDP echo server on router 3\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(routers.Get(3)); // Server on router 3\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Step 7: Create a UDP echo client on router 0\n    UdpEchoClientHelper echoClient(i3.GetAddress(1), 9); // Send to router 3 IP\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(routers.Get(0)); // Client on router 0\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Step 8: Enable tracing (pcap files)\n    p2p.EnablePcapAll(\"ospf-linkstate\");\n\n    // Step 9: Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 to simulate a network where routers exchange Link State Advertisements (LSAs) as part of Link State Routing. Create a topology with four routers connected via point-to-point links, where OSPF is used for route discovery and link state updates. Simulate the transmission of LSAs between the routers as network changes occur, and visualize the LSA process using pcap tracing. Also, generate traffic from one node to another to observe how link state routing adapts."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ospf-helper.h\"\n#include \"ns3/traffic-control-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LinkStateAdvertisementExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for OSPF\n    LogComponentEnable(\"OspfHelper\", LOG_LEVEL_INFO);\n\n    // Parse command line arguments\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Step 1: Create 4 routers\n    NodeContainer routers;\n    routers.Create(4);\n\n    // Step 2: Create point-to-point links between routers\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create the links between the routers\n    NetDeviceContainer link1 = p2p.Install(routers.Get(0), routers.Get(1)); // R0 <-> R1\n    NetDeviceContainer link2 = p2p.Install(routers.Get(1), routers.Get(2)); // R1 <-> R2\n    NetDeviceContainer link3 = p2p.Install(routers.Get(2), routers.Get(3)); // R2 <-> R3\n    NetDeviceContainer link4 = p2p.Install(routers.Get(0), routers.Get(3)); // R0 <-> R3\n\n    // Step 3: Install Internet Stack with OSPF on routers\n    OspfHelper ospfRouting;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(ospfRouting);  // Use OSPF for routing\n    internet.Install(routers);\n\n    // Step 4: Assign IP addresses to the links\n    Ipv4AddressHelper ipv4;\n\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1 = ipv4.Assign(link1);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i2 = ipv4.Assign(link2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i3 = ipv4.Assign(link3);\n\n    ipv4.SetBase(\"10.1.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i4 = ipv4.Assign(link4);\n\n    // Step 5: Populate routing tables with OSPF\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Step 6: Create traffic flow (UDP echo)\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(routers.Get(3));  // Server on router R3\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(i4.GetAddress(1), 9);  // Send to R3 (link4's IP)\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(routers.Get(0));  // Client on router R0\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Step 7: Enable pcap tracing\n    p2p.EnablePcapAll(\"lsa-ospf\");\n\n    // Step 8: Run the simulation\n    Simulator::Stop(Seconds(12.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a network in NS-3 where VLANs are configured on a Layer 3 switch, and a router is used to route between them (inter-VLAN routing). Also, configure a DHCP server that dynamically assigns IP addresses to each VLAN. The network should consist of three VLANs, where each VLAN has its own subnet. Generate traffic between hosts in different VLANs and verify that inter-VLAN communication is working. Capture pcap traces of DHCP request/offer packets."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/dhcp-helper.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/bridge-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"InterVLANRoutingWithDHCP\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create 6 nodes: 1 router, 2 nodes for each of the 3 VLANs\n    NodeContainer router;\n    router.Create(1); // Router node\n\n    NodeContainer vlan1Hosts, vlan2Hosts, vlan3Hosts;\n    vlan1Hosts.Create(2);\n    vlan2Hosts.Create(2);\n    vlan3Hosts.Create(2);\n\n    // Create point-to-point links between the router and each VLAN switch\n    NodeContainer vlan1Switch, vlan2Switch, vlan3Switch;\n    vlan1Switch.Create(1);\n    vlan2Switch.Create(1);\n    vlan3Switch.Create(1);\n\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer vlan1RouterDevices, vlan2RouterDevices, vlan3RouterDevices;\n    vlan1RouterDevices = p2p.Install(router.Get(0), vlan1Switch.Get(0));\n    vlan2RouterDevices = p2p.Install(router.Get(0), vlan2Switch.Get(0));\n    vlan3RouterDevices = p2p.Install(router.Get(0), vlan3Switch.Get(0));\n\n    // Add bridges for the VLANs\n    NetDeviceContainer vlan1Devices, vlan2Devices, vlan3Devices;\n    BridgeHelper bridge;\n    vlan1Devices.Add(vlan1RouterDevices.Get(1));\n    vlan2Devices.Add(vlan2RouterDevices.Get(1));\n    vlan3Devices.Add(vlan3RouterDevices.Get(1));\n\n    NetDeviceContainer vlan1HostDevices = bridge.Install(vlan1Switch.Get(0), vlan1Devices);\n    NetDeviceContainer vlan2HostDevices = bridge.Install(vlan2Switch.Get(0), vlan2Devices);\n    NetDeviceContainer vlan3HostDevices = bridge.Install(vlan3Switch.Get(0), vlan3Devices);\n\n    // Install Internet Stack\n    InternetStackHelper internet;\n    internet.Install(router);\n    internet.Install(vlan1Hosts);\n    internet.Install(vlan2Hosts);\n    internet.Install(vlan3Hosts);\n\n    // Assign IP addresses to the router's interfaces\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vlan1Interfaces = ipv4.Assign(vlan1RouterDevices.Get(0));\n\n    ipv4.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vlan2Interfaces = ipv4.Assign(vlan2RouterDevices.Get(0));\n\n    ipv4.SetBase(\"192.168.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vlan3Interfaces = ipv4.Assign(vlan3RouterDevices.Get(0));\n\n    // Create DHCP server and client configuration\n    DhcpHelper dhcp;\n    dhcp.SetRouter(router.Get(0));\n\n    dhcp.InstallDhcpServer(vlan1RouterDevices.Get(1), Ipv4Address(\"192.168.1.1\"));\n    dhcp.InstallDhcpServer(vlan2RouterDevices.Get(1), Ipv4Address(\"192.168.2.1\"));\n    dhcp.InstallDhcpServer(vlan3RouterDevices.Get(1), Ipv4Address(\"192.168.3.1\"));\n\n    dhcp.InstallDhcpClient(vlan1HostDevices);\n    dhcp.InstallDhcpClient(vlan2HostDevices);\n    dhcp.InstallDhcpClient(vlan3HostDevices);\n\n    // Enable pcap tracing to capture DHCP traffic\n    p2p.EnablePcapAll(\"inter-vlan-dhcp\");\n\n    // Create UDP Echo server on one of the VLAN3 hosts\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(vlan3Hosts.Get(1));\n    serverApp.Start(Seconds(2.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create a UDP Echo client on VLAN1 to send requests to the server in VLAN3\n    UdpEchoClientHelper echoClient(vlan3Interfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(vlan1Hosts.Get(0));\n    clientApp.Start(Seconds(3.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Configure routing on the router for inter-VLAN routing\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> routerStaticRouting = ipv4RoutingHelper.GetStaticRouting(router.Get(0)->GetObject<Ipv4>());\n    routerStaticRouting->SetDefaultRoute(\"192.168.1.1\", 1);\n    routerStaticRouting->SetDefaultRoute(\"192.168.2.1\", 2);\n    routerStaticRouting->SetDefaultRoute(\"192.168.3.1\", 3);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite me a code that simulates a mixed wired and wireless network topology using ns-3. The network should consist of multiple backbone routers connected by an ad hoc WiFi network, with each backbone router having a local 802.11 infrastructure network and being connected to a local LAN. The nodes should use TCP/IP stacks, with OLSR routing on the backbone network. There should be a UDP flow from a wired LAN node to a wireless STA in the last infrastructure network. Ensure the simulation parameters like number of backbone routers, LAN nodes, and wireless nodes can be configured via command line arguments. Additionally, set up mobility for the nodes, and configure options to generate packet traces and enable course change callbacks for the mobility models."}, {"role": "assistant", "content": "//\n// This ns-3 example demonstrates the use of helper functions to ease\n// the construction of simulation scenarios.\n//\n// The simulation topology consists of a mixed wired and wireless\n// scenario in which a hierarchical mobility model is used.\n//\n// The simulation layout consists of N backbone routers interconnected\n// by an ad hoc wifi network.\n// Each backbone router also has a local 802.11 network and is connected\n// to a local LAN.  An additional set of (K-1) nodes are connected to\n// this backbone.  Finally, a local LAN is connected to each router\n// on the backbone, with L-1 additional hosts.\n//\n// The nodes are populated with TCP/IP stacks, and OLSR unicast routing\n// on the backbone.  An example UDP transfer is shown.  The simulator\n// be configured to output tcpdumps or traces from different nodes.\n//\n//\n//          +--------------------------------------------------------+\n//          |                                                        |\n//          |              802.11 ad hoc, ns-2 mobility              |\n//          |                                                        |\n//          +--------------------------------------------------------+\n//                   |       o o o (N backbone routers)       |\n//               +--------+                               +--------+\n//     wired LAN | mobile |                     wired LAN | mobile |\n//    -----------| router |                    -----------| router |\n//               ---------                                ---------\n//                   |                                        |\n//          +----------------+                       +----------------+\n//          |     802.11     |                       |     802.11     |\n//          |   infra net    |                       |   infra net    |\n//          |   K-1 hosts    |                       |   K-1 hosts    |\n//          +----------------+                       +----------------+\n//\n// We'll send data from the first wired LAN node on the first wired LAN\n// to the last wireless STA on the last infrastructure net, thereby\n// causing packets to traverse CSMA to adhoc to infrastructure links\n//\n// Note that certain mobility patterns may cause packet forwarding\n// to fail (if nodes become disconnected)\n\n#include \"ns3/animation-interface.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/csma-helper.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/olsr-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/qos-txop.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\n//\n// Define logging keyword for this file\n//\nNS_LOG_COMPONENT_DEFINE(\"MixedWireless\");\n\n/**\n * This function will be used below as a trace sink, if the command-line\n * argument or default value \"useCourseChangeCallback\" is set to true\n *\n * \\param path The callback path.\n * \\param model The mobility model.\n */\nstatic void\nCourseChangeCallback(std::string path, Ptr<const MobilityModel> model)\n{\n    Vector position = model->GetPosition();\n    std::cout << \"CourseChange \" << path << \" x=\" << position.x << \", y=\" << position.y\n              << \", z=\" << position.z << std::endl;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    //\n    // First, we declare and initialize a few local variables that control some\n    // simulation parameters.\n    //\n    uint32_t backboneNodes = 10;\n    uint32_t infraNodes = 2;\n    uint32_t lanNodes = 2;\n    uint32_t stopTime = 20;\n    bool useCourseChangeCallback = false;\n\n    //\n    // Simulation defaults are typically set next, before command line\n    // arguments are parsed.\n    //\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", StringValue(\"1472\"));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(\"100kb/s\"));\n\n    //\n    // For convenience, we add the local variables to the command line argument\n    // system so that they can be overridden with flags such as\n    // \"--backboneNodes=20\"\n    //\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"backboneNodes\", \"number of backbone nodes\", backboneNodes);\n    cmd.AddValue(\"infraNodes\", \"number of leaf nodes\", infraNodes);\n    cmd.AddValue(\"lanNodes\", \"number of LAN nodes\", lanNodes);\n    cmd.AddValue(\"stopTime\", \"simulation stop time (seconds)\", stopTime);\n    cmd.AddValue(\"useCourseChangeCallback\",\n                 \"whether to enable course change tracing\",\n                 useCourseChangeCallback);\n\n    //\n    // The system global variables and the local values added to the argument\n    // system can be overridden by command line arguments by using this call.\n    //\n    cmd.Parse(argc, argv);\n\n    if (stopTime < 10)\n    {\n        std::cout << \"Use a simulation stop time >= 10 seconds\" << std::endl;\n        exit(1);\n    }\n    ///////////////////////////////////////////////////////////////////////////\n    //                                                                       //\n    // Construct the backbone                                                //\n    //                                                                       //\n    ///////////////////////////////////////////////////////////////////////////\n\n    //\n    // Create a container to manage the nodes of the adhoc (backbone) network.\n    // Later we'll create the rest of the nodes we'll need.\n    //\n    NodeContainer backbone;\n    backbone.Create(backboneNodes);\n    //\n    // Create the backbone wifi net devices and install them into the nodes in\n    // our container\n    //\n    WifiHelper wifi;\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate54Mbps\"));\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n    NetDeviceContainer backboneDevices = wifi.Install(wifiPhy, mac, backbone);\n\n    // We enable OLSR (which will be consulted at a higher priority than\n    // the global routing) on the backbone ad hoc nodes\n    NS_LOG_INFO(\"Enabling OLSR routing on all backbone nodes\");\n    OlsrHelper olsr;\n    //\n    // Add the IPv4 protocol stack to the nodes in our container\n    //\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(olsr); // has effect on the next Install ()\n    internet.Install(backbone);\n\n    //\n    // Assign IPv4 addresses to the device drivers (actually to the associated\n    // IPv4 interfaces) we just created.\n    //\n    Ipv4AddressHelper ipAddrs;\n    ipAddrs.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n    ipAddrs.Assign(backboneDevices);\n\n    //\n    // The ad-hoc network nodes need a mobility model so we aggregate one to\n    // each of the nodes we just finished building.\n    //\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\",\n                                  DoubleValue(20.0),\n                                  \"MinY\",\n                                  DoubleValue(20.0),\n                                  \"DeltaX\",\n                                  DoubleValue(20.0),\n                                  \"DeltaY\",\n                                  DoubleValue(20.0),\n                                  \"GridWidth\",\n                                  UintegerValue(5),\n                                  \"LayoutType\",\n                                  StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomDirection2dMobilityModel\",\n                              \"Bounds\",\n                              RectangleValue(Rectangle(-500, 500, -500, 500)),\n                              \"Speed\",\n                              StringValue(\"ns3::ConstantRandomVariable[Constant=2]\"),\n                              \"Pause\",\n                              StringValue(\"ns3::ConstantRandomVariable[Constant=0.2]\"));\n    mobility.Install(backbone);\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                                                                       //\n    // Construct the LANs                                                    //\n    //                                                                       //\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Reset the address base-- all of the CSMA networks will be in\n    // the \"172.16 address space\n    ipAddrs.SetBase(\"172.16.0.0\", \"255.255.255.0\");\n\n    for (uint32_t i = 0; i < backboneNodes; ++i)\n    {\n        NS_LOG_INFO(\"Configuring local area network for backbone node \" << i);\n        //\n        // Create a container to manage the nodes of the LAN.  We need\n        // two containers here; one with all of the new nodes, and one\n        // with all of the nodes including new and existing nodes\n        //\n        NodeContainer newLanNodes;\n        newLanNodes.Create(lanNodes - 1);\n        // Now, create the container with all nodes on this link\n        NodeContainer lan(backbone.Get(i), newLanNodes);\n        //\n        // Create the CSMA net devices and install them into the nodes in our\n        // collection.\n        //\n        CsmaHelper csma;\n        csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n        csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n        NetDeviceContainer lanDevices = csma.Install(lan);\n        //\n        // Add the IPv4 protocol stack to the new LAN nodes\n        //\n        internet.Install(newLanNodes);\n        //\n        // Assign IPv4 addresses to the device drivers (actually to the\n        // associated IPv4 interfaces) we just created.\n        //\n        ipAddrs.Assign(lanDevices);\n        //\n        // Assign a new network prefix for the next LAN, according to the\n        // network mask initialized above\n        //\n        ipAddrs.NewNetwork();\n        //\n        // The new LAN nodes need a mobility model so we aggregate one\n        // to each of the nodes we just finished building.\n        //\n        MobilityHelper mobilityLan;\n        Ptr<ListPositionAllocator> subnetAlloc = CreateObject<ListPositionAllocator>();\n        for (uint32_t j = 0; j < newLanNodes.GetN(); ++j)\n        {\n            subnetAlloc->Add(Vector(0.0, j * 10 + 10, 0.0));\n        }\n        mobilityLan.PushReferenceMobilityModel(backbone.Get(i));\n        mobilityLan.SetPositionAllocator(subnetAlloc);\n        mobilityLan.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n        mobilityLan.Install(newLanNodes);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                                                                       //\n    // Construct the mobile networks                                         //\n    //                                                                       //\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Reset the address base-- all of the 802.11 networks will be in\n    // the \"10.0\" address space\n    ipAddrs.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n\n    for (uint32_t i = 0; i < backboneNodes; ++i)\n    {\n        NS_LOG_INFO(\"Configuring wireless network for backbone node \" << i);\n        //\n        // Create a container to manage the nodes of the LAN.  We need\n        // two containers here; one with all of the new nodes, and one\n        // with all of the nodes including new and existing nodes\n        //\n        NodeContainer stas;\n        stas.Create(infraNodes - 1);\n        // Now, create the container with all nodes on this link\n        NodeContainer infra(backbone.Get(i), stas);\n        //\n        // Create an infrastructure network\n        //\n        WifiHelper wifiInfra;\n        WifiMacHelper macInfra;\n        wifiPhy.SetChannel(wifiChannel.Create());\n        // Create unique ssids for these networks\n        std::string ssidString(\"wifi-infra\");\n        std::stringstream ss;\n        ss << i;\n        ssidString += ss.str();\n        Ssid ssid = Ssid(ssidString);\n        // setup stas\n        macInfra.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n        NetDeviceContainer staDevices = wifiInfra.Install(wifiPhy, macInfra, stas);\n        // setup ap.\n        macInfra.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n        NetDeviceContainer apDevices = wifiInfra.Install(wifiPhy, macInfra, backbone.Get(i));\n        // Collect all of these new devices\n        NetDeviceContainer infraDevices(apDevices, staDevices);\n\n        // Add the IPv4 protocol stack to the nodes in our container\n        //\n        internet.Install(stas);\n        //\n        // Assign IPv4 addresses to the device drivers (actually to the associated\n        // IPv4 interfaces) we just created.\n        //\n        ipAddrs.Assign(infraDevices);\n        //\n        // Assign a new network prefix for each mobile network, according to\n        // the network mask initialized above\n        //\n        ipAddrs.NewNetwork();\n        //\n        // The new wireless nodes need a mobility model so we aggregate one\n        // to each of the nodes we just finished building.\n        //\n        Ptr<ListPositionAllocator> subnetAlloc = CreateObject<ListPositionAllocator>();\n        for (uint32_t j = 0; j < infra.GetN(); ++j)\n        {\n            subnetAlloc->Add(Vector(0.0, j, 0.0));\n        }\n        mobility.PushReferenceMobilityModel(backbone.Get(i));\n        mobility.SetPositionAllocator(subnetAlloc);\n        mobility.SetMobilityModel(\"ns3::RandomDirection2dMobilityModel\",\n                                  \"Bounds\",\n                                  RectangleValue(Rectangle(-10, 10, -10, 10)),\n                                  \"Speed\",\n                                  StringValue(\"ns3::ConstantRandomVariable[Constant=3]\"),\n                                  \"Pause\",\n                                  StringValue(\"ns3::ConstantRandomVariable[Constant=0.4]\"));\n        mobility.Install(stas);\n    }\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                                                                       //\n    // Application configuration                                             //\n    //                                                                       //\n    ///////////////////////////////////////////////////////////////////////////\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 10 Kb/s, between two nodes\n    // We'll send data from the first wired LAN node on the first wired LAN\n    // to the last wireless STA on the last infrastructure net, thereby\n    // causing packets to traverse CSMA to adhoc to infrastructure links\n\n    NS_LOG_INFO(\"Create Applications.\");\n    uint16_t port = 9; // Discard port (RFC 863)\n\n    // Let's make sure that the user does not define too few nodes\n    // to make this example work.  We need lanNodes > 1  and infraNodes > 1\n    NS_ASSERT(lanNodes > 1 && infraNodes > 1);\n    // We want the source to be the first node created outside of the backbone\n    // Conveniently, the variable \"backboneNodes\" holds this node index value\n    Ptr<Node> appSource = NodeList::GetNode(backboneNodes);\n    // We want the sink to be the last node created in the topology.\n    uint32_t lastNodeIndex =\n        backboneNodes + backboneNodes * (lanNodes - 1) + backboneNodes * (infraNodes - 1) - 1;\n    Ptr<Node> appSink = NodeList::GetNode(lastNodeIndex);\n    // Let's fetch the IP address of the last node, which is on Ipv4Interface 1\n    Ipv4Address remoteAddr = appSink->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal();\n\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", Address(InetSocketAddress(remoteAddr, port)));\n\n    ApplicationContainer apps = onoff.Install(appSource);\n    apps.Start(Seconds(3));\n    apps.Stop(Seconds(stopTime - 1));\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    apps = sink.Install(appSink);\n    apps.Start(Seconds(3));\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                                                                       //\n    // Tracing configuration                                                 //\n    //                                                                       //\n    ///////////////////////////////////////////////////////////////////////////\n\n    NS_LOG_INFO(\"Configure Tracing.\");\n    CsmaHelper csma;\n\n    //\n    // Let's set up some ns-2-like ascii traces, using another helper class\n    //\n    AsciiTraceHelper ascii;\n    Ptr<OutputStreamWrapper> stream = ascii.CreateFileStream(\"mixed-wireless.tr\");\n    wifiPhy.EnableAsciiAll(stream);\n    csma.EnableAsciiAll(stream);\n    internet.EnableAsciiIpv4All(stream);\n\n    // Csma captures in non-promiscuous mode\n    csma.EnablePcapAll(\"mixed-wireless\", false);\n    // pcap captures on the backbone wifi devices\n    wifiPhy.EnablePcap(\"mixed-wireless\", backboneDevices, false);\n    // pcap trace on the application data sink\n    wifiPhy.EnablePcap(\"mixed-wireless\", appSink->GetId(), 0);\n\n    if (useCourseChangeCallback)\n    {\n        Config::Connect(\"/NodeList/*/$ns3::MobilityModel/CourseChange\",\n                        MakeCallback(&CourseChangeCallback));\n    }\n\n    AnimationInterface anim(\"mixed-wireless.xml\");\n\n    ///////////////////////////////////////////////////////////////////////////\n    //                                                                       //\n    // Run simulation                                                        //\n    //                                                                       //\n    ///////////////////////////////////////////////////////////////////////////\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Stop(Seconds(stopTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a private network using Network Address Translation (NAT) in NS-3. The private network contains two hosts using private IP addresses. A NAT router connects this private network to a public network, where an external server is located. The hosts in the private network send UDP packets to the public server, and the NAT router translates their private IP addresses to a public IP for outbound traffic. Capture and verify that the public server responds to the NAT router's public IP, and the NAT router translates the responses back to the correct private IP addresses."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/nat-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"NatExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer natRouter, privateHosts, publicServer;\n    natRouter.Create(1);         // NAT router\n    privateHosts.Create(2);      // Two hosts behind the NAT\n    publicServer.Create(1);      // Public server\n\n    // Create point-to-point links\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Link between the private network and the NAT router\n    NetDeviceContainer privateDevices;\n    privateDevices = p2p.Install(NodeContainer(privateHosts, natRouter));\n\n    // Link between the NAT router and the public server\n    NetDeviceContainer publicDevices;\n    publicDevices = p2p.Install(NodeContainer(natRouter, publicServer));\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(privateHosts);\n    internet.Install(natRouter);\n    internet.Install(publicServer);\n\n    // Assign IP addresses\n    Ipv4AddressHelper privateNetwork;\n    privateNetwork.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer privateInterfaces = privateNetwork.Assign(privateDevices.Get(0));\n\n    Ipv4AddressHelper publicNetwork;\n    publicNetwork.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer publicInterfaces = publicNetwork.Assign(publicDevices.Get(1));\n\n    // Assign public IP to the NAT router's public interface\n    publicNetwork.Assign(publicDevices.Get(0));\n\n    // Configure NAT\n    NatHelper natHelper;\n    natHelper.Install(natRouter.Get(0), publicDevices.Get(0));\n\n    // Install UDP Echo server on the public server\n    UdpEchoServerHelper echoServer(9);  // Listening on port 9\n    ApplicationContainer serverApp = echoServer.Install(publicServer.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Install UDP Echo client on the private network hosts\n    UdpEchoClientHelper echoClient(publicInterfaces.GetAddress(1), 9);  // Destination: public server\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp1 = echoClient.Install(privateHosts.Get(0));\n    clientApp1.Start(Seconds(2.0));\n    clientApp1.Stop(Seconds(10.0));\n\n    ApplicationContainer clientApp2 = echoClient.Install(privateHosts.Get(1));\n    clientApp2.Start(Seconds(2.0));\n    clientApp2.Stop(Seconds(10.0));\n\n    // Enable pcap tracing\n    p2p.EnablePcapAll(\"nat-example\");\n\n    // Start simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate the \"count to infinity\" problem in a small network using Distance Vector (DV) routing in NS-3. The network consists of three routers (A, B, and C) connected in a triangle. Router A connects to router B, and router B connects to router C. Initially, all routers exchange routing information and establish routes. After a few seconds, the link between router B and router C is intentionally broken. Observe how routers A and C incorrectly continue to believe they can reach each other through the failed link and increment their hop counts until they reach the maximum hop count, simulating the \"count to infinity\" problem."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/distance-vector-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CountToInfinityDVExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create nodes: A, B, C\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Create point-to-point links\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create links between A-B, B-C, and A-C (triangle)\n    NetDeviceContainer ab = p2p.Install(NodeContainer(nodes.Get(0), nodes.Get(1))); // A-B\n    NetDeviceContainer bc = p2p.Install(NodeContainer(nodes.Get(1), nodes.Get(2))); // B-C\n    NetDeviceContainer ac = p2p.Install(NodeContainer(nodes.Get(0), nodes.Get(2))); // A-C\n\n    // Install the Internet stack on nodes\n    InternetStackHelper internet;\n    DistanceVectorHelper dvRouting;  // Use DV routing (simulating RIP)\n    internet.SetRoutingHelper(dvRouting);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer abIf = ipv4.Assign(ab);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer bcIf = ipv4.Assign(bc);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer acIf = ipv4.Assign(ac);\n\n    // Create UDP echo server on node C (destination)\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(2)); // C as server\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Create UDP echo client on node A (source)\n    UdpEchoClientHelper echoClient(bcIf.GetAddress(1), 9);  // Sending to C via B\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0)); // A as client\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Simulate link failure between B and C at t = 5s\n    Simulator::Schedule(Seconds(5.0), &NetDevice::SetLinkDown, bc.Get(1));\n    Simulator::Schedule(Seconds(5.0), &NetDevice::SetLinkDown, bc.Get(0));\n\n    // Enable pcap tracing\n    p2p.EnablePcapAll(\"count-to-infinity\");\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate the two-node loop problem in a network using Distance Vector (DV) routing in NS-3. The network consists of two nodes (A and B) connected to each other. Initially, the routing tables converge, and A and B can forward traffic to a common destination. After a few seconds, the network is altered to simulate a failure, and A and B begin to incorrectly forward packets to each other, creating a loop. Observe how packets circulate between A and B, demonstrating the two-node loop problem in Distance Vector routing."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/distance-vector-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TwoNodeLoopDVExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create nodes: A, B\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Create point-to-point link between A and B\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer ab = p2p.Install(nodes);\n\n    // Install the Internet stack on nodes\n    InternetStackHelper internet;\n    DistanceVectorHelper dvRouting;  // Use DV routing (simulating RIP)\n    internet.SetRoutingHelper(dvRouting);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer abIf = ipv4.Assign(ab);\n\n    // Create UDP echo server on node B\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(1)); // B as server\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Create UDP echo client on node A\n    UdpEchoClientHelper echoClient(abIf.GetAddress(1), 9);  // Sending to B\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0)); // A as client\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Simulate link failure between A and B at t = 5s\n    Simulator::Schedule(Seconds(5.0), &NetDevice::SetLinkDown, ab.Get(1));\n    Simulator::Schedule(Seconds(5.0), &NetDevice::SetLinkDown, ab.Get(0));\n\n    // Re-enable link after 8s to simulate routing loop\n    Simulator::Schedule(Seconds(8.0), &NetDevice::SetLinkUp, ab.Get(1));\n    Simulator::Schedule(Seconds(8.0), &NetDevice::SetLinkUp, ab.Get(0));\n\n    // Enable pcap tracing\n    p2p.EnablePcapAll(\"two-node-loop\");\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate Split Horizon in a simple network using Distance Vector (DV) routing in NS-3. The network consists of three nodes arranged in a linear topology, where Node A is connected to Node B, and Node B is connected to Node C. Use Distance Vector routing to allow traffic to flow between the nodes. Demonstrate that the Split Horizon rule is preventing routing loops by ensuring that routes are not advertised back to the node from which they were learned."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/distance-vector-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SplitHorizonSimulation\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for the components involved\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes: A, B, C\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Create point-to-point links between A-B and B-C\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install links\n    NetDeviceContainer ab = p2p.Install(nodes.Get(0), nodes.Get(1)); // Link A-B\n    NetDeviceContainer bc = p2p.Install(nodes.Get(1), nodes.Get(2)); // Link B-C\n\n    // Install Internet stack (with Distance Vector and Split Horizon)\n    InternetStackHelper internet;\n    DistanceVectorHelper dvRouting;\n    dvRouting.Set(\"SplitHorizon\", BooleanValue(true)); // Enabling Split Horizon\n    internet.SetRoutingHelper(dvRouting);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer abIf = ipv4.Assign(ab); // A-B\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer bcIf = ipv4.Assign(bc); // B-C\n\n    // Create UDP echo server on node C\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(2)); // C as server\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Create UDP echo client on node A\n    UdpEchoClientHelper echoClient(bcIf.GetAddress(1), 9); // Sending to C\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0)); // A as client\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable pcap tracing to observe packet flow\n    p2p.EnablePcapAll(\"split-horizon\");\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 to simulate a simple Poisson Reverse setup. The program should create a point-to-point network between two nodes and utilize the Poisson Reverse method for dynamic routing. Implement a minimal routing protocol that periodically updates route costs based on the inverse of the distance to the destination. The program should also include logging of route updates and simulation statistics. Ensure that traffic flows between the nodes and that the Poisson Reverse logic is applied to adjust routes dynamically."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PoissonReverseExample\");\n\nvoid\nLogRouteTable(Ptr<Ipv4> ipv4)\n{\n    Ptr<Ipv4RoutingTableEntry> route;\n    uint32_t numRoutes = ipv4->GetRoutingTableEntryCount();\n    for (uint32_t i = 0; i < numRoutes; ++i)\n    {\n        route = ipv4->GetRoutingTableEntry(i);\n        std::cout << \"Destination: \" << route->GetDestNetwork() << \", Gateway: \" \n                  << route->GetGateway() << \", Interface: \" << route->GetInterface() \n                  << std::endl;\n    }\n}\n\nvoid\nUpdateRoutes(Ptr<Ipv4StaticRouting> staticRouting, Ipv4Address dst, Ipv4Address nextHop, uint32_t cost)\n{\n    // Update the route using Poisson Reverse logic\n    uint32_t reverseCost = 1 / cost; // Poisson reverse logic: invert cost\n\n    staticRouting->SetDefaultRoute(nextHop, reverseCost);\n    NS_LOG_UNCOND(\"Updated route with Poisson Reverse cost: \" << reverseCost);\n}\n\nint\nmain(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"PoissonReverseExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Create point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install network stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Enable static routing\n    Ipv4StaticRoutingHelper staticRoutingHelper;\n    Ptr<Ipv4> ipv4_0 = nodes.Get(0)->GetObject<Ipv4>();\n    Ptr<Ipv4StaticRouting> staticRouting_0 = staticRoutingHelper.GetStaticRouting(ipv4_0);\n    \n    Ptr<Ipv4> ipv4_1 = nodes.Get(1)->GetObject<Ipv4>();\n    Ptr<Ipv4StaticRouting> staticRouting_1 = staticRoutingHelper.GetStaticRouting(ipv4_1);\n\n    // Set initial routes\n    staticRouting_0->AddHostRouteTo(Ipv4Address(\"10.1.1.2\"), Ipv4Address(\"10.1.1.1\"), 1);\n    staticRouting_1->AddHostRouteTo(Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.1.1.2\"), 1);\n\n    // Log initial routing table\n    LogRouteTable(ipv4_0);\n    LogRouteTable(ipv4_1);\n\n    // Update routes based on Poisson Reverse logic periodically\n    Simulator::Schedule(Seconds(5), &UpdateRoutes, staticRouting_0, Ipv4Address(\"10.1.1.2\"), Ipv4Address(\"10.1.1.1\"), 1);\n    Simulator::Schedule(Seconds(5), &UpdateRoutes, staticRouting_1, Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.1.1.2\"), 1);\n\n    // Create a simple TCP flow from node 0 to node 1\n    uint16_t port = 9;\n    Address sinkAddress(InetSocketAddress(interfaces.GetAddress(1), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientHelper.SetAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    clientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = clientHelper.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 to simulate a simple UDP Echo Client with one node. The program should configure a point-to-point connection, set up an echo server, and have a client on the same node send packets to the server using the UDP protocol. The simulation should log packet transmissions and reception. Set a simple scenario with a 5Mbps link, 2ms delay, and include packet size and interval configuration"}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UDPEchoExample\");\n\nint \nmain(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"UDPEchoExample\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create a node\n    NodeContainer nodes;\n    nodes.Create(1); // One node for both client and server\n\n    // Point-to-point link configuration (though it's only one node)\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install the network stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n\n    // Create a loopback network device (since only one node is involved)\n    Ipv4InterfaceContainer interfaces;\n    interfaces = address.Assign(pointToPoint.Install(nodes));\n\n    // Create and set up UDP Echo Server\n    uint16_t port = 9; // Echo server port number\n    UdpEchoServerHelper echoServer(port);\n\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create and set up UDP Echo Client\n    uint32_t packetSize = 1024; // Packet size\n    uint32_t nPackets = 10;     // Number of packets to send\n    double interval = 1.0;      // Time between packets (1 second)\n    \n    UdpEchoClientHelper echoClient(interfaces.GetAddress(0), port);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(nPackets));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(interval)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 to simulate a UDP Echo Client and Server between two nodes. Set up a point-to-point connection between the nodes with a link of 5Mbps data rate and 2ms delay. The client on one node should send UDP packets to the server on the other node, and the simulation should log packet transmission and reception. Include packet size, interval, and the number of packets to be transmitted in the configuration."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpEchoExample\");\n\nint \nmain(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"UdpEchoExample\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2); // Two nodes, one for client and one for server\n\n    // Configure point-to-point link between the nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on the nodes and the link between them\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack (TCP/IP stack) on the nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create and set up UDP Echo Server on node 1 (server)\n    uint16_t port = 9; // Echo server port number\n    UdpEchoServerHelper echoServer(port);\n\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(1)); // Server is node 1\n    serverApp.Start(Seconds(1.0)); // Start server at time = 1 second\n    serverApp.Stop(Seconds(10.0)); // Stop server at time = 10 seconds\n\n    // Create and set up UDP Echo Client on node 0 (client)\n    uint32_t packetSize = 1024;   // Packet size\n    uint32_t nPackets = 10;       // Number of packets to send\n    double interval = 1.0;        // Interval between packets (1 second)\n    \n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1), port); // Server's IP (node 1)\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(nPackets));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(interval)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0)); // Client is node 0\n    clientApp.Start(Seconds(2.0)); // Start client at time = 2 seconds\n    clientApp.Stop(Seconds(10.0)); // Stop client at time = 10 seconds\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 to simulate a UDP Echo Client and Server between three nodes. Set up two point-to-point connections: one between the first and second nodes, and another between the second and third nodes. Both links should have a data rate of 5Mbps and a delay of 2ms. The client on the first node should send UDP packets to the server on the third node, with the second node acting as a router. The simulation should log packet transmission and reception, and the IP address configuration should reflect proper routing between the nodes."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpEchoThreeNodesExample\");\n\nint \nmain(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"UdpEchoThreeNodesExample\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create three nodes\n    NodeContainer nodes;\n    nodes.Create(3); // Three nodes: n0 -> n1 -> n2\n\n    // Configure point-to-point link between nodes n0 and n1\n    PointToPointHelper pointToPoint1;\n    pointToPoint1.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint1.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Configure point-to-point link between nodes n1 and n2\n    PointToPointHelper pointToPoint2;\n    pointToPoint2.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint2.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on the nodes and the links between them\n    NetDeviceContainer devices1, devices2;\n    devices1 = pointToPoint1.Install(nodes.Get(0), nodes.Get(1)); // Link n0 -> n1\n    devices2 = pointToPoint2.Install(nodes.Get(1), nodes.Get(2)); // Link n1 -> n2\n\n    // Install Internet stack (TCP/IP stack) on the nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes' links\n    Ipv4AddressHelper address;\n    \n    // IP address for the link between n0 and n1\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces1 = address.Assign(devices1);\n\n    // IP address for the link between n1 and n2\n    address.SetBase(\"10.2.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces2 = address.Assign(devices2);\n\n    // Enable routing on node n1 (the router)\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create and set up UDP Echo Server on node n2 (server)\n    uint16_t port = 9; // Echo server port number\n    UdpEchoServerHelper echoServer(port);\n\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(2)); // Server is node n2\n    serverApp.Start(Seconds(1.0)); // Start server at time = 1 second\n    serverApp.Stop(Seconds(10.0)); // Stop server at time = 10 seconds\n\n    // Create and set up UDP Echo Client on node n0 (client)\n    uint32_t packetSize = 1024;   // Packet size\n    uint32_t nPackets = 10;       // Number of packets to send\n    double interval = 1.0;        // Interval between packets (1 second)\n    \n    UdpEchoClientHelper echoClient(interfaces2.GetAddress(1), port); // Server's IP (n2)\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(nPackets));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(interval)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0)); // Client is node n0\n    clientApp.Start(Seconds(2.0)); // Start client at time = 2 seconds\n    clientApp.Stop(Seconds(10.0)); // Stop client at time = 10 seconds\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 to simulate a UDP Echo Client and Server for four nodes. Set up three point-to-point links: one between node 0 and node 1, another between node 1 and node 2, and a third between node 2 and node 3. All links should have a data rate of 5Mbps and a delay of 2ms. The client on node 0 should send UDP packets to the server on node 3, with nodes 1 and 2 acting as routers. Ensure proper routing and log packet transmission and reception during the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpEchoFourNodesExample\");\n\nint \nmain(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"UdpEchoFourNodesExample\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create four nodes\n    NodeContainer nodes;\n    nodes.Create(4); // Four nodes: n0 -> n1 -> n2 -> n3\n\n    // Configure point-to-point link between nodes n0 and n1\n    PointToPointHelper pointToPoint1;\n    pointToPoint1.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint1.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Configure point-to-point link between nodes n1 and n2\n    PointToPointHelper pointToPoint2;\n    pointToPoint2.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint2.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Configure point-to-point link between nodes n2 and n3\n    PointToPointHelper pointToPoint3;\n    pointToPoint3.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint3.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on the nodes and the links between them\n    NetDeviceContainer devices1, devices2, devices3;\n    devices1 = pointToPoint1.Install(nodes.Get(0), nodes.Get(1)); // Link n0 -> n1\n    devices2 = pointToPoint2.Install(nodes.Get(1), nodes.Get(2)); // Link n1 -> n2\n    devices3 = pointToPoint3.Install(nodes.Get(2), nodes.Get(3)); // Link n2 -> n3\n\n    // Install Internet stack (TCP/IP stack) on the nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes' links\n    Ipv4AddressHelper address;\n    \n    // IP address for the link between n0 and n1\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces1 = address.Assign(devices1);\n\n    // IP address for the link between n1 and n2\n    address.SetBase(\"10.2.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces2 = address.Assign(devices2);\n\n    // IP address for the link between n2 and n3\n    address.SetBase(\"10.3.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces3 = address.Assign(devices3);\n\n    // Enable routing on nodes n1 and n2 (routers)\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create and set up UDP Echo Server on node n3 (server)\n    uint16_t port = 9; // Echo server port number\n    UdpEchoServerHelper echoServer(port);\n\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(3)); // Server is node n3\n    serverApp.Start(Seconds(1.0)); // Start server at time = 1 second\n    serverApp.Stop(Seconds(10.0)); // Stop server at time = 10 seconds\n\n    // Create and set up UDP Echo Client on node n0 (client)\n    uint32_t packetSize = 1024;   // Packet size\n    uint32_t nPackets = 10;       // Number of packets to send\n    double interval = 1.0;        // Interval between packets (1 second)\n    \n    UdpEchoClientHelper echoClient(interfaces3.GetAddress(1), port); // Server's IP (n3)\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(nPackets));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(interval)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0)); // Client is node n0\n    clientApp.Start(Seconds(2.0)); // Start client at time = 2 seconds\n    clientApp.Stop(Seconds(10.0)); // Stop client at time = 10 seconds\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 to simulate a UDP Echo Client and Server for six nodes. Set up five point-to-point links: one between node 0 and node 1, another between node 1 and node 2, one between node 2 and node 3, one between node 3 and node 4, and the last one between node 4 and node 5. All links should have a data rate of 5Mbps and a delay of 2ms. The client on node 0 should send UDP packets to the server on node 5, with nodes 1, 2, 3, and 4 acting as routers. Ensure proper routing and log packet transmission and reception during the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpEchoSixNodesExample\");\n\nint \nmain(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"UdpEchoSixNodesExample\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create six nodes\n    NodeContainer nodes;\n    nodes.Create(6); // Six nodes: n0 -> n1 -> n2 -> n3 -> n4 -> n5\n\n    // Configure point-to-point link between nodes n0 and n1\n    PointToPointHelper pointToPoint1;\n    pointToPoint1.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint1.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Configure point-to-point link between nodes n1 and n2\n    PointToPointHelper pointToPoint2;\n    pointToPoint2.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint2.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Configure point-to-point link between nodes n2 and n3\n    PointToPointHelper pointToPoint3;\n    pointToPoint3.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint3.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Configure point-to-point link between nodes n3 and n4\n    PointToPointHelper pointToPoint4;\n    pointToPoint4.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint4.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Configure point-to-point link between nodes n4 and n5\n    PointToPointHelper pointToPoint5;\n    pointToPoint5.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint5.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on the nodes and the links between them\n    NetDeviceContainer devices1, devices2, devices3, devices4, devices5;\n    devices1 = pointToPoint1.Install(nodes.Get(0), nodes.Get(1)); // Link n0 -> n1\n    devices2 = pointToPoint2.Install(nodes.Get(1), nodes.Get(2)); // Link n1 -> n2\n    devices3 = pointToPoint3.Install(nodes.Get(2), nodes.Get(3)); // Link n2 -> n3\n    devices4 = pointToPoint4.Install(nodes.Get(3), nodes.Get(4)); // Link n3 -> n4\n    devices5 = pointToPoint5.Install(nodes.Get(4), nodes.Get(5)); // Link n4 -> n5\n\n    // Install Internet stack (TCP/IP stack) on the nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes' links\n    Ipv4AddressHelper address;\n\n    // IP address for the link between n0 and n1\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces1 = address.Assign(devices1);\n\n    // IP address for the link between n1 and n2\n    address.SetBase(\"10.2.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces2 = address.Assign(devices2);\n\n    // IP address for the link between n2 and n3\n    address.SetBase(\"10.3.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces3 = address.Assign(devices3);\n\n    // IP address for the link between n3 and n4\n    address.SetBase(\"10.4.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces4 = address.Assign(devices4);\n\n    // IP address for the link between n4 and n5\n    address.SetBase(\"10.5.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces5 = address.Assign(devices5);\n\n    // Enable routing on nodes n1, n2, n3, and n4 (routers)\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create and set up UDP Echo Server on node n5 (server)\n    uint16_t port = 9; // Echo server port number\n    UdpEchoServerHelper echoServer(port);\n\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(5)); // Server is node n5\n    serverApp.Start(Seconds(1.0)); // Start server at time = 1 second\n    serverApp.Stop(Seconds(10.0)); // Stop server at time = 10 seconds\n\n    // Create and set up UDP Echo Client on node n0 (client)\n    uint32_t packetSize = 1024;   // Packet size\n    uint32_t nPackets = 10;       // Number of packets to send\n    double interval = 1.0;        // Interval between packets (1 second)\n\n    UdpEchoClientHelper echoClient(interfaces5.GetAddress(1), port); // Server's IP (n5)\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(nPackets));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(interval)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0)); // Client is node n0\n    clientApp.Start(Seconds(2.0)); // Start client at time = 2 seconds\n    clientApp.Stop(Seconds(10.0)); // Stop client at time = 10 seconds\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate C++ code using ns-3 that demonstrates the setup of a Wi-Fi network with QoS for different access categories (AC). The code should define 4 independent Wi-Fi networks, each consisting of one access point (AP) and one station (STA), operating on different logical channels of the same physical medium. Each STA sends data packets to its respective AP using different QoS settings for AC_BE and AC_VI. The user should be able to configure parameters such as payload size, distance between nodes, RTS/CTS settings, and simulation time. The code should trace the TXOP duration for each QoS configuration and output the measured throughput. Include application setup using UdpServer and OnOffHelper for traffic generation, mobility models for positioning nodes, and the InternetStackHelper for IP addressing. Add command-line support to customize parameters and allow enabling or disabling of pcap file generation. The simulation should stop after the configured time, and the throughput and TXOP duration results should be printed."}, {"role": "assistant", "content": "#include \"ns3/command-line.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/pointer.h\"\n#include \"ns3/qos-txop.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/wifi-mac.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This is an example that illustrates 802.11 QoS for different Access Categories.\n// It defines 4 independent Wi-Fi networks (working on different logical channels\n// on the same \"ns3::YansWifiPhy\" channel object).\n// Each network contains one access point and one station. Each station continuously\n// transmits data packets to its respective AP.\n//\n// Network topology (numbers in parentheses are channel numbers):\n//\n//  BSS A (36)        BSS B (40)       BSS C (44)        BSS D (48)\n//   *      *          *      *         *      *          *      *\n//   |      |          |      |         |      |          |      |\n//  AP A   STA A      AP B   STA B     AP C   STA C      AP D   STA D\n//\n// The configuration is the following on the 4 networks:\n// - STA A sends AC_BE traffic to AP A with default AC_BE TXOP value of 0 (1 MSDU);\n// - STA B sends AC_BE traffic to AP B with non-default AC_BE TXOP of 4096 us;\n// - STA C sends AC_VI traffic to AP C with default AC_VI TXOP of 4096 us;\n// - STA D sends AC_VI traffic to AP D with non-default AC_VI TXOP value of 0 (1 MSDU);\n//\n// The user can select the distance between the stations and the APs, can enable/disable the RTS/CTS\n// mechanism and can choose the payload size and the simulation duration. Example: ./ns3 run\n// \"wifi-80211e-txop --distance=10 --simulationTime=20s --payloadSize=1000\"\n//\n// The output prints the throughput measured for the 4 cases/networks described above. When TXOP is\n// enabled, results show increased throughput since the channel is granted for a longer duration.\n// TXOP is enabled by default for AC_VI and AC_VO, so that they can use the channel for a longer\n// duration than AC_BE and AC_BK.\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"80211eTxop\");\n\n/**\n * Keeps the maximum duration among all TXOPs\n */\nstruct TxopDurationTracer\n{\n    /**\n     * Callback connected to TXOP duration trace source.\n     *\n     * \\param startTime TXOP start time\n     * \\param duration TXOP duration\n     * \\param linkId the ID of the link\n     */\n    void Trace(Time startTime, Time duration, uint8_t linkId);\n    Time m_max{Seconds(0)}; //!< maximum TXOP duration\n};\n\nvoid\nTxopDurationTracer::Trace(Time startTime, Time duration, uint8_t linkId)\n{\n    if (duration > m_max)\n    {\n        m_max = duration;\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t payloadSize{1472}; // bytes\n    Time simulationTime{\"10s\"};\n    meter_u distance{5};\n    bool enablePcap{false};\n    bool verifyResults{false}; // used for regression\n    Time txopLimit{\"4096us\"};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"payloadSize\", \"Payload size in bytes\", payloadSize);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the station and the access point\",\n                 distance);\n    cmd.AddValue(\"enablePcap\", \"Enable/disable pcap file generation\", enablePcap);\n    cmd.AddValue(\"verifyResults\",\n                 \"Enable/disable results verification at the end of the simulation\",\n                 verifyResults);\n    cmd.Parse(argc, argv);\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(4);\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(4);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n    wifi.SetRemoteStationManager(\"ns3::IdealWifiManager\");\n    WifiMacHelper mac;\n\n    NetDeviceContainer staDeviceA;\n    NetDeviceContainer staDeviceB;\n    NetDeviceContainer staDeviceC;\n    NetDeviceContainer staDeviceD;\n    NetDeviceContainer apDeviceA;\n    NetDeviceContainer apDeviceB;\n    NetDeviceContainer apDeviceC;\n    NetDeviceContainer apDeviceD;\n    Ssid ssid;\n\n    // Network A\n    ssid = Ssid(\"network-A\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{36, 20, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"QosSupported\", BooleanValue(true), \"Ssid\", SsidValue(ssid));\n    staDeviceA = wifi.Install(phy, mac, wifiStaNodes.Get(0));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"QosSupported\",\n                BooleanValue(true),\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceA = wifi.Install(phy, mac, wifiApNodes.Get(0));\n\n    // Network B\n    ssid = Ssid(\"network-B\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{40, 20, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"QosSupported\", BooleanValue(true), \"Ssid\", SsidValue(ssid));\n\n    staDeviceB = wifi.Install(phy, mac, wifiStaNodes.Get(1));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"QosSupported\",\n                BooleanValue(true),\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceB = wifi.Install(phy, mac, wifiApNodes.Get(1));\n\n    // Modify EDCA configuration (TXOP limit) for AC_BE\n    Ptr<NetDevice> dev = wifiApNodes.Get(1)->GetDevice(0);\n    Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    Ptr<WifiMac> wifi_mac = wifi_dev->GetMac();\n    PointerValue ptr;\n    Ptr<QosTxop> edca;\n    wifi_mac->GetAttribute(\"BE_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n    edca->SetTxopLimit(txopLimit);\n\n    // Trace TXOP duration for BE on STA1\n    dev = wifiStaNodes.Get(1)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_mac = wifi_dev->GetMac();\n    wifi_mac->GetAttribute(\"BE_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n    TxopDurationTracer beTxopTracer;\n    edca->TraceConnectWithoutContext(\"TxopTrace\",\n                                     MakeCallback(&TxopDurationTracer::Trace, &beTxopTracer));\n\n    // Network C\n    ssid = Ssid(\"network-C\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{44, 20, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"QosSupported\", BooleanValue(true), \"Ssid\", SsidValue(ssid));\n\n    staDeviceC = wifi.Install(phy, mac, wifiStaNodes.Get(2));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"QosSupported\",\n                BooleanValue(true),\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceC = wifi.Install(phy, mac, wifiApNodes.Get(2));\n\n    // Trace TXOP duration for VI on STA2\n    dev = wifiStaNodes.Get(2)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_mac = wifi_dev->GetMac();\n    wifi_mac->GetAttribute(\"VI_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n    TxopDurationTracer viTxopTracer;\n    edca->TraceConnectWithoutContext(\"TxopTrace\",\n                                     MakeCallback(&TxopDurationTracer::Trace, &viTxopTracer));\n\n    // Network D\n    ssid = Ssid(\"network-D\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{48, 20, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"QosSupported\", BooleanValue(true), \"Ssid\", SsidValue(ssid));\n\n    staDeviceD = wifi.Install(phy, mac, wifiStaNodes.Get(3));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"QosSupported\",\n                BooleanValue(true),\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceD = wifi.Install(phy, mac, wifiApNodes.Get(3));\n\n    // Modify EDCA configuration (TXOP limit) for AC_VO\n    dev = wifiApNodes.Get(3)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_mac = wifi_dev->GetMac();\n    wifi_mac->GetAttribute(\"VI_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n    edca->SetTxopLimit(MicroSeconds(0));\n\n    /* Setting mobility model */\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    // Set position for APs\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(10.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(20.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(30.0, 0.0, 0.0));\n    // Set position for STAs\n    positionAlloc->Add(Vector(distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(10 + distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(20 + distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(30 + distance, 0.0, 0.0));\n    // Remark: while we set these positions 10 meters apart, the networks do not interact\n    // and the only variable that affects transmission performance is the distance.\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(wifiApNodes);\n    mobility.Install(wifiStaNodes);\n\n    /* Internet stack */\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceA;\n    StaInterfaceA = address.Assign(staDeviceA);\n    Ipv4InterfaceContainer ApInterfaceA;\n    ApInterfaceA = address.Assign(apDeviceA);\n\n    address.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceB;\n    StaInterfaceB = address.Assign(staDeviceB);\n    Ipv4InterfaceContainer ApInterfaceB;\n    ApInterfaceB = address.Assign(apDeviceB);\n\n    address.SetBase(\"192.168.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceC;\n    StaInterfaceC = address.Assign(staDeviceC);\n    Ipv4InterfaceContainer ApInterfaceC;\n    ApInterfaceC = address.Assign(apDeviceC);\n\n    address.SetBase(\"192.168.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceD;\n    StaInterfaceD = address.Assign(staDeviceD);\n    Ipv4InterfaceContainer ApInterfaceD;\n    ApInterfaceD = address.Assign(apDeviceD);\n\n    /* Setting applications */\n    uint16_t port = 5001;\n    UdpServerHelper serverA(port);\n    ApplicationContainer serverAppA = serverA.Install(wifiApNodes.Get(0));\n    serverAppA.Start(Seconds(0.0));\n    serverAppA.Stop(simulationTime + Seconds(1.0));\n\n    InetSocketAddress destA(ApInterfaceA.GetAddress(0), port);\n\n    OnOffHelper clientA(\"ns3::UdpSocketFactory\", destA);\n    clientA.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientA.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientA.SetAttribute(\"DataRate\", StringValue(\"100000kb/s\"));\n    clientA.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n    clientA.SetAttribute(\"Tos\", UintegerValue(0x70)); // AC_BE\n\n    ApplicationContainer clientAppA = clientA.Install(wifiStaNodes.Get(0));\n    clientAppA.Start(Seconds(1.0));\n    clientAppA.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverB(port);\n    ApplicationContainer serverAppB = serverB.Install(wifiApNodes.Get(1));\n    serverAppB.Start(Seconds(0.0));\n    serverAppB.Stop(simulationTime + Seconds(1.0));\n\n    InetSocketAddress destB(ApInterfaceB.GetAddress(0), port);\n\n    OnOffHelper clientB(\"ns3::UdpSocketFactory\", destB);\n    clientB.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientB.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientB.SetAttribute(\"DataRate\", StringValue(\"100000kb/s\"));\n    clientB.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n    clientB.SetAttribute(\"Tos\", UintegerValue(0x70)); // AC_BE\n\n    ApplicationContainer clientAppB = clientB.Install(wifiStaNodes.Get(1));\n    clientAppB.Start(Seconds(1.0));\n    clientAppB.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverC(port);\n    ApplicationContainer serverAppC = serverC.Install(wifiApNodes.Get(2));\n    serverAppC.Start(Seconds(0.0));\n    serverAppC.Stop(simulationTime + Seconds(1.0));\n\n    InetSocketAddress destC(ApInterfaceC.GetAddress(0), port);\n\n    OnOffHelper clientC(\"ns3::UdpSocketFactory\", destC);\n    clientC.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientC.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientC.SetAttribute(\"DataRate\", StringValue(\"100000kb/s\"));\n    clientC.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n    clientC.SetAttribute(\"Tos\", UintegerValue(0xb8)); // AC_VI\n\n    ApplicationContainer clientAppC = clientC.Install(wifiStaNodes.Get(2));\n    clientAppC.Start(Seconds(1.0));\n    clientAppC.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverD(port);\n    ApplicationContainer serverAppD = serverD.Install(wifiApNodes.Get(3));\n    serverAppD.Start(Seconds(0.0));\n    serverAppD.Stop(simulationTime + Seconds(1.0));\n\n    InetSocketAddress destD(ApInterfaceD.GetAddress(0), port);\n\n    OnOffHelper clientD(\"ns3::UdpSocketFactory\", destD);\n    clientD.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientD.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientD.SetAttribute(\"DataRate\", StringValue(\"100000kb/s\"));\n    clientD.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n    clientD.SetAttribute(\"Tos\", UintegerValue(0xb8)); // AC_VI\n\n    ApplicationContainer clientAppD = clientD.Install(wifiStaNodes.Get(3));\n    clientAppD.Start(Seconds(1.0));\n    clientAppD.Stop(simulationTime + Seconds(1.0));\n\n    if (enablePcap)\n    {\n        phy.EnablePcap(\"AP_A\", apDeviceA.Get(0));\n        phy.EnablePcap(\"STA_A\", staDeviceA.Get(0));\n        phy.EnablePcap(\"AP_B\", apDeviceB.Get(0));\n        phy.EnablePcap(\"STA_B\", staDeviceB.Get(0));\n        phy.EnablePcap(\"AP_C\", apDeviceC.Get(0));\n        phy.EnablePcap(\"STA_C\", staDeviceC.Get(0));\n        phy.EnablePcap(\"AP_D\", apDeviceD.Get(0));\n        phy.EnablePcap(\"STA_D\", staDeviceD.Get(0));\n    }\n\n    Simulator::Stop(simulationTime + Seconds(1.0));\n    Simulator::Run();\n\n    /* Show results */\n    double totalPacketsThroughA = DynamicCast<UdpServer>(serverAppA.Get(0))->GetReceived();\n    double totalPacketsThroughB = DynamicCast<UdpServer>(serverAppB.Get(0))->GetReceived();\n    double totalPacketsThroughC = DynamicCast<UdpServer>(serverAppC.Get(0))->GetReceived();\n    double totalPacketsThroughD = DynamicCast<UdpServer>(serverAppD.Get(0))->GetReceived();\n\n    Simulator::Destroy();\n\n    auto throughput = totalPacketsThroughA * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"AC_BE with default TXOP limit (0ms): \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 28 || throughput > 29))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    throughput = totalPacketsThroughB * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"AC_BE with non-default TXOP limit (4.096ms): \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 36.5 || throughput > 37))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"  Maximum TXOP duration = \" << beTxopTracer.m_max.GetMicroSeconds() << \" us\"\n              << '\\n';\n    if (verifyResults &&\n        (beTxopTracer.m_max < MicroSeconds(3008) || beTxopTracer.m_max > txopLimit))\n    {\n        NS_LOG_ERROR(\"Maximum TXOP duration \" << beTxopTracer.m_max\n                                              << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    throughput = totalPacketsThroughC * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"AC_VI with default TXOP limit (4.096ms): \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 36.5 || throughput > 37.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"  Maximum TXOP duration = \" << viTxopTracer.m_max.GetMicroSeconds() << \" us\"\n              << '\\n';\n    if (verifyResults &&\n        (viTxopTracer.m_max < MicroSeconds(3008) || viTxopTracer.m_max > txopLimit))\n    {\n        NS_LOG_ERROR(\"Maximum TXOP duration \" << viTxopTracer.m_max\n                                              << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    throughput = totalPacketsThroughD * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"AC_VI with non-default TXOP limit (0ms): \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 31.5 || throughput > 32.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 to simulate a basic TCP Socket communication between two nodes. Set up a point-to-point link between the nodes with a data rate of 5Mbps and a delay of 2ms. Use a custom TCP socket on one node to send data to another node, acting as a server, using the socket API. Log the data transmission and reception events during the simulation"}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/socket.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpSocketExample\");\n\n// Callback function to log when a packet is received at the server\nvoid ReceivePacket(Ptr<Socket> socket)\n{\n    Ptr<Packet> packet;\n    while ((packet = socket->Recv()))\n    {\n        NS_LOG_INFO(\"Received packet of size \" << packet->GetSize());\n    }\n}\n\n// Function to simulate a client sending data via a TCP socket\nvoid SendPacket(Ptr<Socket> socket, uint32_t size, Time sendInterval)\n{\n    Ptr<Packet> packet = Create<Packet>(size); // Create a packet of given size\n    socket->Send(packet); // Send the packet\n    NS_LOG_INFO(\"Sent packet of size \" << size);\n    Simulator::Schedule(sendInterval, &SendPacket, socket, size, sendInterval); // Schedule the next send\n}\n\nint \nmain(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"TcpSocketExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2); // Two nodes: n0 (client) -> n1 (server)\n\n    // Set up a point-to-point link between the two nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install the devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack (TCP/IP) on both nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP socket on the server (node 1)\n    Ptr<Socket> serverSocket = Socket::CreateSocket(nodes.Get(1), TcpSocketFactory::GetTypeId());\n    InetSocketAddress localAddress = InetSocketAddress(Ipv4Address::GetAny(), 8080); // Listening on port 8080\n    serverSocket->Bind(localAddress); // Bind the socket to the address\n    serverSocket->Listen(); // Set the socket to listen mode\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket)); // Set callback to handle received packets\n\n    // Create a TCP socket on the client (node 0)\n    Ptr<Socket> clientSocket = Socket::CreateSocket(nodes.Get(0), TcpSocketFactory::GetTypeId());\n    InetSocketAddress remoteAddress = InetSocketAddress(interfaces.GetAddress(1), 8080); // Server address (node 1)\n    clientSocket->Connect(remoteAddress); // Connect the client socket to the server\n\n    // Schedule the first packet transmission at 2 seconds\n    Simulator::Schedule(Seconds(2.0), &SendPacket, clientSocket, 1024, Seconds(1.0)); // 1024 bytes, every 1 second\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ simulation using ns-3 to simulate a ring topology with 3 nodes. The nodes are interconnected in a ring, and point-to-point links are used between adjacent nodes. Set the link data rate to 10Mbps and delay to 2ms. Install basic Internet stack, assign IP addresses, and simulate packet transmission between the nodes in the ring. Use logging to track packet transmissions."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RingTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"RingTopologyExample\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Set up point-to-point links between the nodes to form a ring\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install the devices on the nodes (Node 0 <-> Node 1, Node 1 <-> Node 2, Node 2 <-> Node 0)\n    NetDeviceContainer devices01, devices12, devices20;\n    devices01 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));\n    devices12 = pointToPoint.Install(nodes.Get(1), nodes.Get(2));\n    devices20 = pointToPoint.Install(nodes.Get(2), nodes.Get(0));\n\n    // Install the Internet stack (TCP/IP) on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to each pair of point-to-point links\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfaces01, interfaces12, interfaces20;\n\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    interfaces01 = address.Assign(devices01);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    interfaces12 = address.Assign(devices12);\n\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    interfaces20 = address.Assign(devices20);\n\n    // Create an application (OnOff Application) to send packets from node 0 to node 1\n    uint16_t port = 9; // Port for communication\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(interfaces01.GetAddress(1), port));\n    onoff.SetConstantRate(DataRate(\"1Mbps\"), 1024); // 1Mbps data rate, 1024-byte packets\n    ApplicationContainer app = onoff.Install(nodes.Get(0)); // Install on node 0\n    app.Start(Seconds(1.0)); // Start at 1 second\n    app.Stop(Seconds(10.0)); // Stop at 10 seconds\n\n    // Set up a PacketSink on node 1 to receive packets from node 0\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sink.Install(nodes.Get(1)); // Install sink on node 1\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Enable routing between the nodes in the ring\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ simulation using ns-3 to simulate a star topology with 3 nodes. There should be a central node connected to 2 other nodes with point-to-point links. Set the link data rate to 5Mbps and delay to 1ms. Install the Internet stack, assign IP addresses, and simulate packet transmission between the peripheral nodes via the central node. Use logging to track packet transmissions."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"StarTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"StarTopologyExample\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes: centralNode and two peripheral nodes\n    NodeContainer centralNode;\n    centralNode.Create(1);\n    \n    NodeContainer peripheralNodes;\n    peripheralNodes.Create(2);\n\n    // Create a point-to-point link helper\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    // Install devices and set up point-to-point links\n    NetDeviceContainer devicesCentralToNode1, devicesCentralToNode2;\n    devicesCentralToNode1 = pointToPoint.Install(centralNode.Get(0), peripheralNodes.Get(0)); // Central to Node 1\n    devicesCentralToNode2 = pointToPoint.Install(centralNode.Get(0), peripheralNodes.Get(1)); // Central to Node 2\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(centralNode);\n    stack.Install(peripheralNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfacesCentralToNode1, interfacesCentralToNode2;\n\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    interfacesCentralToNode1 = address.Assign(devicesCentralToNode1);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    interfacesCentralToNode2 = address.Assign(devicesCentralToNode2);\n\n    // Application: Sending packets from Node 1 to Node 2 via the central node\n    uint16_t port = 9; // Port for communication\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(interfacesCentralToNode2.GetAddress(1), port));\n    onoff.SetConstantRate(DataRate(\"2Mbps\"), 1024); // 2Mbps data rate, 1024-byte packets\n    ApplicationContainer app = onoff.Install(peripheralNodes.Get(0)); // Install on Node 1\n    app.Start(Seconds(1.0)); // Start at 1 second\n    app.Stop(Seconds(10.0)); // Stop at 10 seconds\n\n    // Set up a PacketSink on Node 2 to receive packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sink.Install(peripheralNodes.Get(1)); // Install sink on Node 2\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Enable routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ simulation using ns-3 to simulate a tree topology with 4 nodes. In this configuration, one root node connects to two child nodes, and one of the child nodes connects to a leaf node. Use point-to-point links with a data rate of 5Mbps and a delay of 2ms. Install the Internet stack, assign IP addresses, and simulate packet transmission from the leaf node to the root node. Use logging to track packet transmissions."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TreeTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"TreeTopologyExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer rootNode;\n    rootNode.Create(1);\n    \n    NodeContainer childNodes;\n    childNodes.Create(2);\n\n    NodeContainer leafNode;\n    leafNode.Create(1);\n\n    // Create a point-to-point link helper\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices and set up point-to-point links\n    NetDeviceContainer devicesRootToChild1, devicesRootToChild2, devicesChildToLeaf;\n\n    // Link from root to child 1\n    devicesRootToChild1 = pointToPoint.Install(rootNode.Get(0), childNodes.Get(0));\n\n    // Link from root to child 2\n    devicesRootToChild2 = pointToPoint.Install(rootNode.Get(0), childNodes.Get(1));\n\n    // Link from child 1 to leaf node\n    devicesChildToLeaf = pointToPoint.Install(childNodes.Get(0), leafNode.Get(0));\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(rootNode);\n    stack.Install(childNodes);\n    stack.Install(leafNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfacesRootToChild1, interfacesRootToChild2, interfacesChildToLeaf;\n\n    // IP addresses for the root to child 1 link\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    interfacesRootToChild1 = address.Assign(devicesRootToChild1);\n\n    // IP addresses for the root to child 2 link\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    interfacesRootToChild2 = address.Assign(devicesRootToChild2);\n\n    // IP addresses for the child 1 to leaf link\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    interfacesChildToLeaf = address.Assign(devicesChildToLeaf);\n\n    // Application: Sending packets from the leaf node to the root node\n    uint16_t port = 9; // Port for communication\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(interfacesRootToChild1.GetAddress(0), port));\n    onoff.SetConstantRate(DataRate(\"1Mbps\"), 1024); // 1Mbps data rate, 1024-byte packets\n    ApplicationContainer app = onoff.Install(leafNode.Get(0)); // Install on the leaf node\n    app.Start(Seconds(1.0)); // Start at 1 second\n    app.Stop(Seconds(10.0)); // Stop at 10 seconds\n\n    // Set up a PacketSink on the root node to receive packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sink.Install(rootNode.Get(0)); // Install sink on the root node\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Enable routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ simulation using ns-3 to simulate a ring topology with 4 nodes. In this configuration, each node is connected to two other nodes, forming a closed loop. Use point-to-point links with a data rate of 5Mbps and a delay of 1ms. Install the Internet stack, assign IP addresses, and simulate packet transmission in a circular fashion, where each node sends packets to its neighbor. Log the packet transmissions to observe the behavior of the network."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RingTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n    // Log settings\n    LogComponentEnable(\"RingTopologyExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(4); // Create 4 nodes\n\n    // Create a point-to-point link helper\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    // Install devices and set up point-to-point links in a ring topology\n    NetDeviceContainer devices;\n\n    for (uint32_t i = 0; i < nodes.GetN(); ++i)\n    {\n        // Connect each node to the next, and wrap around for the last node\n        NetDeviceContainer temp = pointToPoint.Install(nodes.Get(i), nodes.Get((i + 1) % nodes.GetN()));\n        devices.Add(temp);\n    }\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses in the 10.1.x.0/24 subnet\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfaces;\n\n    for (uint32_t i = 0; i < nodes.GetN(); ++i)\n    {\n        address.SetBase(\"10.1.\" + std::to_string(i + 1) + \".0\", \"255.255.255.0\");\n        interfaces.Add(address.Assign(devices.Get(i)));\n    }\n\n    // Application: Sending packets from each node to its clockwise neighbor\n    uint16_t port = 9; // Port for communication\n    for (uint32_t i = 0; i < nodes.GetN(); ++i)\n    {\n        // Each node sends packets to its clockwise neighbor\n        OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(interfaces.GetAddress((i + 1) % nodes.GetN()), port));\n        onoff.SetConstantRate(DataRate(\"1Mbps\"), 1024); // 1Mbps data rate, 1024-byte packets\n        ApplicationContainer app = onoff.Install(nodes.Get(i)); // Install on each node\n        app.Start(Seconds(1.0 + i)); // Stagger start times\n        app.Stop(Seconds(10.0)); // Stop at 10 seconds\n    }\n\n    // Set up a PacketSink on each node to receive packets\n    for (uint32_t i = 0; i < nodes.GetN(); ++i)\n    {\n        PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n        ApplicationContainer sinkApp = sink.Install(nodes.Get(i)); // Install sink on each node\n        sinkApp.Start(Seconds(1.0));\n        sinkApp.Stop(Seconds(10.0));\n    }\n\n    // Enable routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a simple C++ program using the ns-3 simulation library to set up a mesh topology with three nodes. Configure the nodes to communicate using a Wi-Fi mesh network and assign them static positions. Use UDP traffic to generate communication between the nodes. The simulation should run for 10 seconds, and it should output basic statistics such as packet transmission and reception. Additionally, enable PCAP tracing to capture the packet flow for analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"MeshTopologyExample\");\n\nint main (int argc, char *argv[])\n{\n    LogComponentEnable (\"MeshTopologyExample\", LOG_LEVEL_INFO);\n    \n    // Create 3 nodes\n    NodeContainer nodes;\n    nodes.Create (3);\n    \n    // Set up Wi-Fi mesh\n    WifiHelper wifi;\n    MeshHelper mesh;\n    mesh.SetStackInstaller (\"ns3::Dot11sStack\");  // 802.11s for mesh\n    mesh.SetSpreadInterfaceChannels (MeshHelper::SPREAD_CHANNELS);\n    mesh.SetMacType (\"RandomStart\", TimeValue (Seconds (0.1)));\n    NetDeviceContainer meshDevices = mesh.Install (wifi, nodes);\n    \n    // Position nodes in a simple line (static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                   \"MinX\", DoubleValue (0.0),\n                                   \"MinY\", DoubleValue (0.0),\n                                   \"DeltaX\", DoubleValue (100.0),\n                                   \"DeltaY\", DoubleValue (0.0),\n                                   \"GridWidth\", UintegerValue (3),\n                                   \"LayoutType\", StringValue (\"RowFirst\"));\n    mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install (nodes);\n    \n    // Install internet stack\n    InternetStackHelper internet;\n    internet.Install (nodes);\n    \n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase (\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign (meshDevices);\n    \n    // Create UDP Echo server on node 1\n    UdpEchoServerHelper echoServer (9);  // port number\n    ApplicationContainer serverApps = echoServer.Install (nodes.Get (0));\n    serverApps.Start (Seconds (1.0));\n    serverApps.Stop (Seconds (10.0));\n    \n    // Create UDP Echo client on node 2 to send data to node 1\n    UdpEchoClientHelper echoClient (interfaces.GetAddress (0), 9);\n    echoClient.SetAttribute (\"MaxPackets\", UintegerValue (10));\n    echoClient.SetAttribute (\"Interval\", TimeValue (Seconds (1.0)));\n    echoClient.SetAttribute (\"PacketSize\", UintegerValue (1024));\n    ApplicationContainer clientApps = echoClient.Install (nodes.Get (1));\n    clientApps.Start (Seconds (2.0));\n    clientApps.Stop (Seconds (10.0));\n    \n    // Enable PCAP tracing to capture packet flow\n    wifi.EnablePcapAll (\"mesh-topology\");\n\n    // Run the simulation\n    Simulator::Run ();\n    \n    // Print statistics (transmissions and receptions)\n    std::cout << \"Mesh simulation finished.\" << std::endl;\n\n    Simulator::Destroy ();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a simple C++ program using the ns-3 simulation library to set up a mesh topology with four nodes. Configure the nodes to communicate using a Wi-Fi mesh network, assign them static positions in a 2x2 grid layout, and use UDP traffic to generate communication between the nodes. The simulation should run for 15 seconds, and basic statistics such as packet transmission and reception should be recorded. Additionally, enable PCAP tracing to capture the packet flow for analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"MeshTopology4Nodes\");\n\nint main (int argc, char *argv[])\n{\n    LogComponentEnable (\"MeshTopology4Nodes\", LOG_LEVEL_INFO);\n    \n    // Create 4 nodes\n    NodeContainer nodes;\n    nodes.Create (4);\n    \n    // Set up Wi-Fi mesh\n    WifiHelper wifi;\n    MeshHelper mesh;\n    mesh.SetStackInstaller (\"ns3::Dot11sStack\");  // 802.11s for mesh\n    mesh.SetSpreadInterfaceChannels (MeshHelper::SPREAD_CHANNELS);\n    mesh.SetMacType (\"RandomStart\", TimeValue (Seconds (0.1)));\n    NetDeviceContainer meshDevices = mesh.Install (wifi, nodes);\n    \n    // Position nodes in a 2x2 grid layout\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                   \"MinX\", DoubleValue (0.0),\n                                   \"MinY\", DoubleValue (0.0),\n                                   \"DeltaX\", DoubleValue (50.0),   // X distance between nodes\n                                   \"DeltaY\", DoubleValue (50.0),   // Y distance between nodes\n                                   \"GridWidth\", UintegerValue (2), // Two columns for 2x2 grid\n                                   \"LayoutType\", StringValue (\"RowFirst\"));\n    mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install (nodes);\n    \n    // Install internet stack\n    InternetStackHelper internet;\n    internet.Install (nodes);\n    \n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase (\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign (meshDevices);\n    \n    // Create UDP Echo server on node 0\n    UdpEchoServerHelper echoServer (9);  // Port number\n    ApplicationContainer serverApps = echoServer.Install (nodes.Get (0));\n    serverApps.Start (Seconds (1.0));\n    serverApps.Stop (Seconds (15.0));\n    \n    // Create UDP Echo client on node 1 to send data to node 0\n    UdpEchoClientHelper echoClient (interfaces.GetAddress (0), 9);\n    echoClient.SetAttribute (\"MaxPackets\", UintegerValue (20));\n    echoClient.SetAttribute (\"Interval\", TimeValue (Seconds (1.0)));\n    echoClient.SetAttribute (\"PacketSize\", UintegerValue (1024));\n    ApplicationContainer clientApps = echoClient.Install (nodes.Get (1));\n    clientApps.Start (Seconds (2.0));\n    clientApps.Stop (Seconds (15.0));\n    \n    // Create another UDP Echo client on node 2 to send data to node 3\n    UdpEchoClientHelper echoClient2 (interfaces.GetAddress (3), 9);\n    echoClient2.SetAttribute (\"MaxPackets\", UintegerValue (20));\n    echoClient2.SetAttribute (\"Interval\", TimeValue (Seconds (1.0)));\n    echoClient2.SetAttribute (\"PacketSize\", UintegerValue (1024));\n    ApplicationContainer clientApps2 = echoClient2.Install (nodes.Get (2));\n    clientApps2.Start (Seconds (3.0));\n    clientApps2.Stop (Seconds (15.0));\n    \n    // Enable PCAP tracing to capture packet flow\n    wifi.EnablePcapAll (\"mesh-topology-4-nodes\");\n\n    // Run the simulation\n    Simulator::Run ();\n    \n    // Print basic statistics\n    std::cout << \"Mesh simulation with 4 nodes finished.\" << std::endl;\n\n    Simulator::Destroy ();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a simple C++ program using the ns-3 simulation library to set up a branch topology with three nodes. Configure the nodes to communicate using a point-to-point network where node 0 acts as the central node connected to nodes 1 and 2 via separate links. Use UDP traffic to generate communication between the nodes, and assign IP addresses accordingly. The simulation should run for 10 seconds, and PCAP tracing should be enabled for traffic analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BranchTopology3Nodes\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"BranchTopology3Nodes\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Set up point-to-point links\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install point-to-point links between node 0 and node 1, and between node 0 and node 2\n    NetDeviceContainer device01, device02;\n    device01 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));  // Link between node 0 and node 1\n    device02 = pointToPoint.Install(nodes.Get(0), nodes.Get(2));  // Link between node 0 and node 2\n\n    // Install internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces01 = address.Assign(device01);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces02 = address.Assign(device02);\n\n    // Set up a UDP Echo server on node 0\n    UdpEchoServerHelper echoServer(9);  // Port number\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 1 to send packets to node 0\n    UdpEchoClientHelper echoClient(interfaces01.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(1));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Set up another UDP Echo client on node 2 to send packets to node 0\n    UdpEchoClientHelper echoClient2(interfaces02.GetAddress(0), 9);\n    echoClient2.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient2.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient2.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApps2 = echoClient2.Install(nodes.Get(2));\n    clientApps2.Start(Seconds(3.0));\n    clientApps2.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing to capture the packet flow\n    pointToPoint.EnablePcapAll(\"branch-topology-3-nodes\");\n\n    // Run the simulation\n    Simulator::Run();\n\n    // End the simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to set up a branch topology with four nodes. Node 0 acts as the central node, with point-to-point links connecting it to nodes 1, 2, and 3. Configure UDP traffic so that nodes 1, 2, and 3 send traffic to node 0, and assign unique IP addresses to each network segment. Enable PCAP tracing to capture the traffic, and run the simulation for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BranchTopology4Nodes\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"BranchTopology4Nodes\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes: node 0 as central, nodes 1, 2, and 3 as branches\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Set up point-to-point links\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install point-to-point links between node 0 and the other nodes (1, 2, and 3)\n    NetDeviceContainer device01, device02, device03;\n    device01 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));  // Link between node 0 and node 1\n    device02 = pointToPoint.Install(nodes.Get(0), nodes.Get(2));  // Link between node 0 and node 2\n    device03 = pointToPoint.Install(nodes.Get(0), nodes.Get(3));  // Link between node 0 and node 3\n\n    // Install internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces01 = address.Assign(device01);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces02 = address.Assign(device02);\n\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces03 = address.Assign(device03);\n\n    // Set up a UDP Echo server on node 0\n    UdpEchoServerHelper echoServer(9);  // Port number\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 1 to send packets to node 0\n    UdpEchoClientHelper echoClient1(interfaces01.GetAddress(0), 9);\n    echoClient1.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient1.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient1.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApps1 = echoClient1.Install(nodes.Get(1));\n    clientApps1.Start(Seconds(2.0));\n    clientApps1.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 2 to send packets to node 0\n    UdpEchoClientHelper echoClient2(interfaces02.GetAddress(0), 9);\n    echoClient2.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient2.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient2.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApps2 = echoClient2.Install(nodes.Get(2));\n    clientApps2.Start(Seconds(2.5));\n    clientApps2.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 3 to send packets to node 0\n    UdpEchoClientHelper echoClient3(interfaces03.GetAddress(0), 9);\n    echoClient3.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient3.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient3.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApps3 = echoClient3.Install(nodes.Get(3));\n    clientApps3.Start(Seconds(3.0));\n    clientApps3.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing to capture packet transmissions\n    pointToPoint.EnablePcapAll(\"branch-topology-4-nodes\");\n\n    // Run the simulation\n    Simulator::Run();\n\n    // End the simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 to simulate a line topology with 3 nodes. Node 0 connects to node 1, and node 1 connects to node 2 via point-to-point links. Configure UDP traffic where node 0 sends traffic to node 2 through node 1. Assign IP addresses to each network segment, and enable PCAP tracing to capture traffic. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LineTopology3Nodes\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"LineTopology3Nodes\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes: node 0, node 1, and node 2\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Set up point-to-point links\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install point-to-point links between node 0 to node 1 and node 1 to node 2\n    NetDeviceContainer device01, device12;\n    device01 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));  // Link between node 0 and node 1\n    device12 = pointToPoint.Install(nodes.Get(1), nodes.Get(2));  // Link between node 1 and node 2\n\n    // Install internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces01 = address.Assign(device01);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces12 = address.Assign(device12);\n\n    // Set up a UDP Echo server on node 2\n    UdpEchoServerHelper echoServer(9);  // Port number\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(2));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 0 to send packets to node 2\n    UdpEchoClientHelper echoClient(interfaces12.GetAddress(1), 9);  // Address of node 2\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));  // Client on node 0\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing to capture packet transmissions\n    pointToPoint.EnablePcapAll(\"line-topology-3-nodes\");\n\n    // Run the simulation\n    Simulator::Run();\n\n    // End the simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a detailed C++ program using the ns-3 library to simulate the performance of 802.11n MIMO networks. The program should output a plot of throughput versus distance for every HT MCS value, ranging from 1 to 4 MIMO streams. It should allow configuration of parameters such as UDP or TCP traffic, frequency band (2.4 or 5.0 GHz), channel width, short guard interval, and preamble detection. The program must simulate a network with a single station and an access point, where the distance between them is varied. For each MIMO stream and MCS mode, simulate data transfer between the nodes and measure throughput. Use Gnuplot to plot the results, with appropriate axis labels and legends. The simulation should allow the user to configure step size, simulation time, and channel bonding, and use either UDP or TCP traffic. Include code to set up the Wi-Fi channel, PHY, MAC, mobility, and network stack, as well as data flow using UDP or TCP applications, and ensure that throughput is calculated and plotted."}, {"role": "assistant", "content": "// This example is used to validate 802.11n MIMO.\n//\n// It outputs plots of the throughput versus the distance\n// for every HT MCS value and from 1 to 4 MIMO streams.\n//\n// The simulation assumes a single station in an infrastructure network:\n//\n//  STA     AP\n//    *     *\n//    |     |\n//   n1     n2\n//\n// The user can choose whether UDP or TCP should be used and can configure\n// some 802.11n parameters (frequency, channel width and guard interval).\n//\n// An important configuration parameter is preamble detection.  It is enabled\n// by default (to match the default ns-3 configuration) but will dominate\n// performance at low SNRs, causing the different MCS to appear to have\n// the same range (because regardless of the MCS, the preamble detection\n// thresholds do not change).\n\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/ht-phy.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    std::ofstream file(\"80211n-mimo-throughput.plt\");\n\n    std::vector<std::string> modes = {\n        \"HtMcs0\",  \"HtMcs1\",  \"HtMcs2\",  \"HtMcs3\",  \"HtMcs4\",  \"HtMcs5\",  \"HtMcs6\",  \"HtMcs7\",\n        \"HtMcs8\",  \"HtMcs9\",  \"HtMcs10\", \"HtMcs11\", \"HtMcs12\", \"HtMcs13\", \"HtMcs14\", \"HtMcs15\",\n        \"HtMcs16\", \"HtMcs17\", \"HtMcs18\", \"HtMcs19\", \"HtMcs20\", \"HtMcs21\", \"HtMcs22\", \"HtMcs23\",\n        \"HtMcs24\", \"HtMcs25\", \"HtMcs26\", \"HtMcs27\", \"HtMcs28\", \"HtMcs29\", \"HtMcs30\", \"HtMcs31\",\n    };\n\n    bool udp{true};\n    Time simulationTime{\"5s\"};\n    double frequency{5.0}; // whether 2.4 or 5.0 GHz\n    double step{5};        // meters\n    bool shortGuardInterval{false};\n    bool channelBonding{false};\n    bool preambleDetection{true};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"step\", \"Granularity of the results to be plotted in meters\", step);\n    cmd.AddValue(\"simulationTime\", \"Simulation time per step\", simulationTime);\n    cmd.AddValue(\"channelBonding\",\n                 \"Enable/disable channel bonding (channel width = 20 MHz if false, channel width = \"\n                 \"40 MHz if true)\",\n                 channelBonding);\n    cmd.AddValue(\"preambleDetection\", \"Enable/disable preamble detection model\", preambleDetection);\n    cmd.AddValue(\"shortGuardInterval\", \"Enable/disable short guard interval\", shortGuardInterval);\n    cmd.AddValue(\"frequency\",\n                 \"Whether working in the 2.4 or 5.0 GHz band (other values gets rejected)\",\n                 frequency);\n    cmd.AddValue(\"udp\", \"UDP if set to 1, TCP otherwise\", udp);\n    cmd.Parse(argc, argv);\n\n    Gnuplot plot = Gnuplot(\"80211n-mimo-throughput.eps\");\n\n    for (uint32_t i = 0; i < modes.size(); i++) // MCS\n    {\n        std::cout << modes[i] << std::endl;\n        Gnuplot2dDataset dataset(modes[i]);\n        for (double d = 0; d <= 100;) // distance\n        {\n            std::cout << \"Distance = \" << d << \"m: \" << std::endl;\n            uint32_t payloadSize; // 1500 byte IP packet\n            if (udp)\n            {\n                payloadSize = 1472; // bytes\n            }\n            else\n            {\n                payloadSize = 1448; // bytes\n                Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n            }\n\n            uint8_t nStreams = 1 + (i / 8); // number of MIMO streams\n\n            NodeContainer wifiStaNode;\n            wifiStaNode.Create(1);\n            NodeContainer wifiApNode;\n            wifiApNode.Create(1);\n\n            YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n            YansWifiPhyHelper phy;\n            phy.SetChannel(channel.Create());\n            if (!preambleDetection)\n            {\n                phy.DisablePreambleDetectionModel();\n            }\n\n            // Set MIMO capabilities\n            phy.Set(\"Antennas\", UintegerValue(nStreams));\n            phy.Set(\"MaxSupportedTxSpatialStreams\", UintegerValue(nStreams));\n            phy.Set(\"MaxSupportedRxSpatialStreams\", UintegerValue(nStreams));\n            phy.Set(\"ChannelSettings\",\n                    StringValue(std::string(\"{0, \") + (channelBonding ? \"40, \" : \"20, \") +\n                                (frequency == 2.4 ? \"BAND_2_4GHZ\" : \"BAND_5GHZ\") + \", 0}\"));\n\n            WifiMacHelper mac;\n            WifiHelper wifi;\n            if (frequency == 5.0)\n            {\n                wifi.SetStandard(WIFI_STANDARD_80211n);\n            }\n            else if (frequency == 2.4)\n            {\n                wifi.SetStandard(WIFI_STANDARD_80211n);\n                Config::SetDefault(\"ns3::LogDistancePropagationLossModel::ReferenceLoss\",\n                                   DoubleValue(40.046));\n            }\n            else\n            {\n                std::cout << \"Wrong frequency value!\" << std::endl;\n                return 0;\n            }\n\n            StringValue ctrlRate;\n            if (frequency == 2.4)\n            {\n                ctrlRate = StringValue(\"ErpOfdmRate24Mbps\");\n            }\n            else\n            {\n                ctrlRate = StringValue(\"OfdmRate24Mbps\");\n            }\n            wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                         \"DataMode\",\n                                         StringValue(modes[i]),\n                                         \"ControlMode\",\n                                         ctrlRate);\n\n            Ssid ssid = Ssid(\"ns3-80211n\");\n\n            mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n            NetDeviceContainer staDevice;\n            staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n            mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n            NetDeviceContainer apDevice;\n            apDevice = wifi.Install(phy, mac, wifiApNode);\n\n            // Set guard interval\n            Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/\"\n                        \"ShortGuardIntervalSupported\",\n                        BooleanValue(shortGuardInterval));\n\n            // mobility.\n            MobilityHelper mobility;\n            Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n            positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n            positionAlloc->Add(Vector(d, 0.0, 0.0));\n            mobility.SetPositionAllocator(positionAlloc);\n\n            mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n            mobility.Install(wifiApNode);\n            mobility.Install(wifiStaNode);\n\n            /* Internet stack*/\n            InternetStackHelper stack;\n            stack.Install(wifiApNode);\n            stack.Install(wifiStaNode);\n\n            Ipv4AddressHelper address;\n            address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n            Ipv4InterfaceContainer staNodeInterface;\n            Ipv4InterfaceContainer apNodeInterface;\n\n            staNodeInterface = address.Assign(staDevice);\n            apNodeInterface = address.Assign(apDevice);\n\n            /* Setting applications */\n            const auto maxLoad = HtPhy::GetDataRate(i,\n                                                    channelBonding ? 40 : 20,\n                                                    NanoSeconds(shortGuardInterval ? 400 : 800),\n                                                    nStreams);\n            ApplicationContainer serverApp;\n            if (udp)\n            {\n                // UDP flow\n                uint16_t port = 9;\n                UdpServerHelper server(port);\n                serverApp = server.Install(wifiStaNode.Get(0));\n                serverApp.Start(Seconds(0.0));\n                serverApp.Stop(simulationTime + Seconds(1.0));\n                const auto packetInterval = payloadSize * 8.0 / maxLoad;\n\n                UdpClientHelper client(staNodeInterface.GetAddress(0), port);\n                client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n                client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n                client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n                clientApp.Start(Seconds(1.0));\n                clientApp.Stop(simulationTime + Seconds(1.0));\n            }\n            else\n            {\n                // TCP flow\n                uint16_t port = 50000;\n                Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n                PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n                serverApp = packetSinkHelper.Install(wifiStaNode.Get(0));\n                serverApp.Start(Seconds(0.0));\n                serverApp.Stop(simulationTime + Seconds(1.0));\n\n                OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n                onoff.SetAttribute(\"OnTime\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n                onoff.SetAttribute(\"OffTime\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n                onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                onoff.SetAttribute(\"DataRate\", DataRateValue(maxLoad));\n                AddressValue remoteAddress(InetSocketAddress(staNodeInterface.GetAddress(0), port));\n                onoff.SetAttribute(\"Remote\", remoteAddress);\n                ApplicationContainer clientApp = onoff.Install(wifiApNode.Get(0));\n                clientApp.Start(Seconds(1.0));\n                clientApp.Stop(simulationTime + Seconds(1.0));\n            }\n\n            Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n            Simulator::Stop(simulationTime + Seconds(1.0));\n            Simulator::Run();\n\n            double throughput = 0;\n            if (udp)\n            {\n                // UDP\n                double totalPacketsThrough =\n                    DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n                throughput = totalPacketsThrough * payloadSize * 8 /\n                             simulationTime.GetMicroSeconds(); // Mbit/s\n            }\n            else\n            {\n                // TCP\n                double totalPacketsThrough =\n                    DynamicCast<PacketSink>(serverApp.Get(0))->GetTotalRx();\n                throughput = totalPacketsThrough * 8 / simulationTime.GetMicroSeconds(); // Mbit/s\n            }\n            dataset.Add(d, throughput);\n            std::cout << throughput << \" Mbit/s\" << std::endl;\n            d += step;\n            Simulator::Destroy();\n        }\n        plot.AddDataset(dataset);\n    }\n\n    plot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    plot.SetLegend(\"Distance (Meters)\", \"Throughput (Mbit/s)\");\n    plot.SetExtra(\"set xrange [0:100]\\n\\\nset yrange [0:600]\\n\\\nset ytics 0,50,600\\n\\\nset style line 1 dashtype 1 linewidth 5\\n\\\nset style line 2 dashtype 1 linewidth 5\\n\\\nset style line 3 dashtype 1 linewidth 5\\n\\\nset style line 4 dashtype 1 linewidth 5\\n\\\nset style line 5 dashtype 1 linewidth 5\\n\\\nset style line 6 dashtype 1 linewidth 5\\n\\\nset style line 7 dashtype 1 linewidth 5\\n\\\nset style line 8 dashtype 1 linewidth 5\\n\\\nset style line 9 dashtype 2 linewidth 5\\n\\\nset style line 10 dashtype 2 linewidth 5\\n\\\nset style line 11 dashtype 2 linewidth 5\\n\\\nset style line 12 dashtype 2 linewidth 5\\n\\\nset style line 13 dashtype 2 linewidth 5\\n\\\nset style line 14 dashtype 2 linewidth 5\\n\\\nset style line 15 dashtype 2 linewidth 5\\n\\\nset style line 16 dashtype 2 linewidth 5\\n\\\nset style line 17 dashtype 3 linewidth 5\\n\\\nset style line 18 dashtype 3 linewidth 5\\n\\\nset style line 19 dashtype 3 linewidth 5\\n\\\nset style line 20 dashtype 3 linewidth 5\\n\\\nset style line 21 dashtype 3 linewidth 5\\n\\\nset style line 22 dashtype 3 linewidth 5\\n\\\nset style line 23 dashtype 3 linewidth 5\\n\\\nset style line 24 dashtype 3 linewidth 5\\n\\\nset style line 25 dashtype 4 linewidth 5\\n\\\nset style line 26 dashtype 4 linewidth 5\\n\\\nset style line 27 dashtype 4 linewidth 5\\n\\\nset style line 28 dashtype 4 linewidth 5\\n\\\nset style line 29 dashtype 4 linewidth 5\\n\\\nset style line 30 dashtype 4 linewidth 5\\n\\\nset style line 31 dashtype 4 linewidth 5\\n\\\nset style line 32 dashtype 4 linewidth 5\\n\\\nset style increment user\");\n    plot.GenerateOutput(file);\n    file.close();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 to simulate a line topology with 4 nodes. Node 0 connects to node 1, node 1 connects to node 2, and node 2 connects to node 3 via point-to-point links. Configure UDP traffic where node 0 sends traffic to node 3 through nodes 1 and 2. Assign IP addresses to each network segment, and enable PCAP tracing to capture traffic. The simulation should run for 10 seconds"}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LineTopology4Nodes\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"LineTopology4Nodes\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes: node 0, node 1, node 2, and node 3\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Set up point-to-point links between consecutive nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install point-to-point links between the nodes\n    NetDeviceContainer device01, device12, device23;\n    device01 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));  // Link between node 0 and node 1\n    device12 = pointToPoint.Install(nodes.Get(1), nodes.Get(2));  // Link between node 1 and node 2\n    device23 = pointToPoint.Install(nodes.Get(2), nodes.Get(3));  // Link between node 2 and node 3\n\n    // Install internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces01 = address.Assign(device01);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces12 = address.Assign(device12);\n\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces23 = address.Assign(device23);\n\n    // Set up a UDP Echo server on node 3\n    UdpEchoServerHelper echoServer(9);  // Port number\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(3));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 0 to send packets to node 3\n    UdpEchoClientHelper echoClient(interfaces23.GetAddress(1), 9);  // Address of node 3\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));  // Client on node 0\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing to capture packet transmissions\n    pointToPoint.EnablePcapAll(\"line-topology-4-nodes\");\n\n    // Run the simulation\n    Simulator::Run();\n\n    // End the simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 to simulate a bus topology with 3 nodes. All nodes are connected to a shared bus network using a CSMA (Carrier Sense Multiple Access) channel. Set up a UDP Echo server on node 2 and configure node 0 to send traffic to node 2 via the shared bus. Assign IP addresses and enable PCAP tracing to capture traffic. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BusTopology3Nodes\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"BusTopology3Nodes\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes: node 0, node 1, and node 2\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Set up CSMA (bus) channel between nodes\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install CSMA devices on the nodes\n    NetDeviceContainer devices = csma.Install(nodes);\n\n    // Install the internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a UDP Echo server on node 2\n    UdpEchoServerHelper echoServer(9);  // Port number\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(2));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 0 to send packets to node 2\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(2), 9);  // Address of node 2\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));  // Client on node 0\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing to capture packet transmissions\n    csma.EnablePcapAll(\"bus-topology-3-nodes\");\n\n    // Run the simulation\n    Simulator::Run();\n\n    // End the simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 to simulate a bus topology with 4 nodes. All nodes are connected to a shared bus network using a CSMA (Carrier Sense Multiple Access) channel. Set up a UDP Echo server on node 3 and configure node 0 to send traffic to node 3 via the shared bus. Assign IP addresses and enable PCAP tracing to capture traffic. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BusTopology4Nodes\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"BusTopology4Nodes\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes: node 0, node 1, node 2, and node 3\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Set up CSMA (bus) channel between nodes\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install CSMA devices on the nodes\n    NetDeviceContainer devices = csma.Install(nodes);\n\n    // Install the internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a UDP Echo server on node 3\n    UdpEchoServerHelper echoServer(9);  // Port number\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(3));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 0 to send packets to node 3\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(3), 9);  // Address of node 3\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));  // Client on node 0\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing to capture packet transmissions\n    csma.EnablePcapAll(\"bus-topology-4-nodes\");\n\n    // Run the simulation\n    Simulator::Run();\n\n    // End the simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 to simulate a simple network topology with 4 nodes using the AODV (Ad-hoc On-Demand Distance Vector) routing protocol instead of OSPF. Configure the nodes to form an ad-hoc wireless network, assign IP addresses, and set up a UDP Echo server on node 3. Node 0 should send traffic to node 3 via the AODV protocol. Enable PCAP tracing to capture the traffic and run the simulation for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/aodv-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AodvRoutingExample\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"AodvRoutingExample\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes: node 0, node 1, node 2, and node 3\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Configure WiFi channel and physical layer\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up the WiFi MAC and install on nodes\n    WifiHelper wifi;\n    WifiMacHelper mac;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n    mac.SetType(\"ns3::AdhocWifiMac\");  // Ad-hoc network\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set up mobility model to arrange nodes in a random 100x100 area\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the AODV routing protocol using the InternetStackHelper\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);  // Set AODV as the routing protocol\n    internet.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a UDP Echo server on node 3\n    UdpEchoServerHelper echoServer(9);  // Port 9\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(3));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on node 0 to send traffic to node 3\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(3), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing to capture the traffic\n    phy.EnablePcapAll(\"aodv-routing-4-nodes\");\n\n    // Run the simulation for 10 seconds\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // End the simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 that generates a dataset of packet transmissions between nodes in a network. The program should simulate a wireless network with 5 nodes, where each node sends UDP traffic to a central server (node 4). The dataset should record the source node, destination node, packet size, transmission time, and reception time for each packet, and write this information into a CSV file."}, {"role": "assistant", "content": "I\n#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"DatasetExample\");\n\nvoid RecordPacketData(Ptr<FlowMonitor> flowMonitor, std::string filename)\n{\n    std::ofstream outFile;\n    outFile.open(filename, std::ios::out | std::ios::app);\n    outFile << \"FlowID,SrcAddr,DestAddr,PacketSize,TxTime,RxTime\\n\";  // CSV headers\n\n    // Retrieve statistics from flow monitor\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n    for (auto &flow : stats)\n    {\n        FlowId id = flow.first;\n        FlowMonitor::FlowStats flowStats = flow.second;\n        Ipv4FlowClassifier::FiveTuple t = flowMonitor->GetClassifier()->FindFlow(id);\n\n        for (uint32_t i = 0; i < flowStats.txPackets; i++)\n        {\n            outFile << id << \",\"\n                    << t.sourceAddress << \",\"\n                    << t.destinationAddress << \",\"\n                    << flowStats.txBytes << \",\"\n                    << flowStats.timeFirstTxPacket.GetSeconds() << \",\"\n                    << flowStats.timeLastRxPacket.GetSeconds() << \"\\n\";\n        }\n    }\n    outFile.close();\n}\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"DatasetExample\", LOG_LEVEL_INFO);\n\n    // Create 5 nodes\n    NodeContainer nodes;\n    nodes.Create(5);\n\n    // Configure WiFi channel and physical layer\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up the WiFi MAC layer for Ad-hoc networking\n    WifiHelper wifi;\n    WifiMacHelper mac;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the internet stack and assign IP addresses\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Setup UDP Echo server on node 4 (central server)\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(4));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup UDP Echo client on nodes 0, 1, 2, and 3 to send traffic to node 4\n    for (int i = 0; i < 4; i++)\n    {\n        UdpEchoClientHelper echoClient(interfaces.GetAddress(4), 9);\n        echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n        echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n        echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n        ApplicationContainer clientApp = echoClient.Install(nodes.Get(i));\n        clientApp.Start(Seconds(2.0));\n        clientApp.Stop(Seconds(10.0));\n    }\n\n    // Enable PCAP tracing\n    phy.EnablePcapAll(\"dataset-example\");\n\n    // Flow monitor to capture packet statistics\n    Ptr<FlowMonitor> flowMonitor;\n    FlowMonitorHelper flowHelper;\n    flowMonitor = flowHelper.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Record the dataset to a CSV file\n    RecordPacketData(flowMonitor, \"packet_dataset.csv\");\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that generates a dataset for a simple star topology network with 5 nodes, where one central node (node 0) communicates with four peripheral nodes (nodes 1 to 4) using TCP. The dataset should capture the source node, destination node, packet size, transmission time, and reception time for each packet. Save the information to a CSV file."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"StarTopologyDataset\");\n\nvoid RecordTcpData(Ptr<FlowMonitor> flowMonitor, std::string filename)\n{\n    std::ofstream outFile;\n    outFile.open(filename, std::ios::out | std::ios::app);\n    outFile << \"FlowID,SrcAddr,DestAddr,PacketSize,TxTime,RxTime\\n\"; // CSV headers\n\n    // Retrieve statistics from flow monitor\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n    for (auto &flow : stats)\n    {\n        FlowId id = flow.first;\n        FlowMonitor::FlowStats flowStats = flow.second;\n        Ipv4FlowClassifier::FiveTuple t = flowMonitor->GetClassifier()->FindFlow(id);\n\n        for (uint32_t i = 0; i < flowStats.txPackets; i++)\n        {\n            outFile << id << \",\"\n                    << t.sourceAddress << \",\"\n                    << t.destinationAddress << \",\"\n                    << flowStats.txBytes << \",\"\n                    << flowStats.timeFirstTxPacket.GetSeconds() << \",\"\n                    << flowStats.timeLastRxPacket.GetSeconds() << \"\\n\";\n        }\n    }\n    outFile.close();\n}\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"StarTopologyDataset\", LOG_LEVEL_INFO);\n\n    // Create 5 nodes (1 central node and 4 peripheral nodes)\n    NodeContainer centralNode;\n    centralNode.Create(1);\n\n    NodeContainer peripheralNodes;\n    peripheralNodes.Create(4);\n\n    NodeContainer allNodes;\n    allNodes.Add(centralNode);\n    allNodes.Add(peripheralNodes);\n\n    // Set up point-to-point links between central node and peripheral nodes\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    for (uint32_t i = 0; i < peripheralNodes.GetN(); ++i)\n    {\n        devices.Add(p2p.Install(centralNode.Get(0), peripheralNodes.Get(i)));\n    }\n\n    // Install Internet stack on nodes\n    InternetStackHelper internet;\n    internet.Install(allNodes);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Setup TCP server on central node (node 0)\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(interfaces.GetAddress(0), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = packetSinkHelper.Install(centralNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup TCP clients on peripheral nodes (nodes 1-4)\n    OnOffHelper onOffHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    onOffHelper.SetAttribute(\"DataRate\", StringValue(\"500kbps\"));\n    onOffHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    onOffHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < peripheralNodes.GetN(); ++i)\n    {\n        onOffHelper.SetAttribute(\"Remote\", AddressValue(InetSocketAddress(interfaces.GetAddress(0), port)));\n        clientApps.Add(onOffHelper.Install(peripheralNodes.Get(i)));\n    }\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(9.0));\n\n    // Enable flow monitor\n    FlowMonitorHelper flowHelper;\n    Ptr<FlowMonitor> flowMonitor = flowHelper.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Record TCP data to a CSV file\n    RecordTcpData(flowMonitor, \"tcp_dataset.csv\");\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that generates a dataset for a simple star topology network with 5 nodes, where one central node (node 0) communicates with four peripheral nodes (nodes 1 to 4) using TCP. The dataset should capture the source node, destination node, packet size, transmission time, and reception time for each packet. Save the information to a CSV file."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"StarTopologyDataset\");\n\nvoid RecordTcpData(Ptr<FlowMonitor> flowMonitor, std::string filename)\n{\n    std::ofstream outFile;\n    outFile.open(filename, std::ios::out | std::ios::app);\n    outFile << \"FlowID,SrcAddr,DestAddr,PacketSize,TxTime,RxTime\\n\"; // CSV headers\n\n    // Retrieve statistics from flow monitor\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n    for (auto &flow : stats)\n    {\n        FlowId id = flow.first;\n        FlowMonitor::FlowStats flowStats = flow.second;\n        Ipv4FlowClassifier::FiveTuple t = flowMonitor->GetClassifier()->FindFlow(id);\n\n        for (uint32_t i = 0; i < flowStats.txPackets; i++)\n        {\n            outFile << id << \",\"\n                    << t.sourceAddress << \",\"\n                    << t.destinationAddress << \",\"\n                    << flowStats.txBytes << \",\"\n                    << flowStats.timeFirstTxPacket.GetSeconds() << \",\"\n                    << flowStats.timeLastRxPacket.GetSeconds() << \"\\n\";\n        }\n    }\n    outFile.close();\n}\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"StarTopologyDataset\", LOG_LEVEL_INFO);\n\n    // Create 5 nodes (1 central node and 4 peripheral nodes)\n    NodeContainer centralNode;\n    centralNode.Create(1);\n\n    NodeContainer peripheralNodes;\n    peripheralNodes.Create(4);\n\n    NodeContainer allNodes;\n    allNodes.Add(centralNode);\n    allNodes.Add(peripheralNodes);\n\n    // Set up point-to-point links between central node and peripheral nodes\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    for (uint32_t i = 0; i < peripheralNodes.GetN(); ++i)\n    {\n        devices.Add(p2p.Install(centralNode.Get(0), peripheralNodes.Get(i)));\n    }\n\n    // Install Internet stack on nodes\n    InternetStackHelper internet;\n    internet.Install(allNodes);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Setup TCP server on central node (node 0)\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(interfaces.GetAddress(0), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = packetSinkHelper.Install(centralNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup TCP clients on peripheral nodes (nodes 1-4)\n    OnOffHelper onOffHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    onOffHelper.SetAttribute(\"DataRate\", StringValue(\"500kbps\"));\n    onOffHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    onOffHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < peripheralNodes.GetN(); ++i)\n    {\n        onOffHelper.SetAttribute(\"Remote\", AddressValue(InetSocketAddress(interfaces.GetAddress(0), port)));\n        clientApps.Add(onOffHelper.Install(peripheralNodes.Get(i)));\n    }\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(9.0));\n\n    // Enable flow monitor\n    FlowMonitorHelper flowHelper;\n    Ptr<FlowMonitor> flowMonitor = flowHelper.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Record TCP data to a CSV file\n    RecordTcpData(flowMonitor, \"tcp_dataset.csv\");\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that generates a dataset for a simple ring topology with 4 nodes, where each node communicates with its neighbor using UDP. The dataset should capture the source node, destination node, packet size, transmission time, and reception time for each packet. Save the information to a CSV file."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RingTopologyDataset\");\n\nvoid RecordUdpData(Ptr<FlowMonitor> flowMonitor, std::string filename)\n{\n    std::ofstream outFile;\n    outFile.open(filename, std::ios::out | std::ios::app);\n    outFile << \"FlowID,SrcAddr,DestAddr,PacketSize,TxTime,RxTime\\n\"; // CSV headers\n\n    // Retrieve statistics from flow monitor\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n    for (auto &flow : stats)\n    {\n        FlowId id = flow.first;\n        FlowMonitor::FlowStats flowStats = flow.second;\n        Ipv4FlowClassifier::FiveTuple t = flowMonitor->GetClassifier()->FindFlow(id);\n\n        for (uint32_t i = 0; i < flowStats.txPackets; i++)\n        {\n            outFile << id << \",\"\n                    << t.sourceAddress << \",\"\n                    << t.destinationAddress << \",\"\n                    << flowStats.txBytes << \",\"\n                    << flowStats.timeFirstTxPacket.GetSeconds() << \",\"\n                    << flowStats.timeLastRxPacket.GetSeconds() << \"\\n\";\n        }\n    }\n    outFile.close();\n}\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"RingTopologyDataset\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes in a ring topology\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Set up point-to-point links between nodes in a ring\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices.Add(p2p.Install(nodes.Get(0), nodes.Get(1)));\n    devices.Add(p2p.Install(nodes.Get(1), nodes.Get(2)));\n    devices.Add(p2p.Install(nodes.Get(2), nodes.Get(3)));\n    devices.Add(p2p.Install(nodes.Get(3), nodes.Get(0))); // Connect back to node 0 to form a ring\n\n    // Install Internet stack on nodes\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Setup UDP server on node 0\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup UDP clients on nodes 1-3 to send data to node 0\n    UdpClientHelper udpClient(interfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 1; i < nodes.GetN(); ++i)\n    {\n        clientApps.Add(udpClient.Install(nodes.Get(i)));\n    }\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(9.0));\n\n    // Enable flow monitor\n    FlowMonitorHelper flowHelper;\n    Ptr<FlowMonitor> flowMonitor = flowHelper.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Record UDP data to a CSV file\n    RecordUdpData(flowMonitor, \"udp_dataset_ring.csv\");\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an ns-3 simulation that sets up a simple network with two nodes connected via a point-to-point link. Install the TCP/IP stack on both nodes, and assign IP addresses to the devices. On one node, configure a TCP server that listens on port 8080. On the other node, configure a TCP client that sends packets to the server using the OnOffApplication with a constant data rate of 5Mbps and a packet size of 1024 bytes. Set the client to start transmitting after 2 seconds and stop at 10 seconds. Enable the FlowMonitor to collect network performance statistics like transmitted and received packets, and throughput. Run the simulation for 10 seconds and print out the flow statistics at the end."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"TcpExample\");\n\nint main (int argc, char *argv[])\n{\n    // Set up default simulation parameters\n    CommandLine cmd;\n    cmd.Parse (argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create (2);\n\n    // Set up a point-to-point link between the nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute (\"DataRate\", StringValue (\"5Mbps\"));\n    pointToPoint.SetChannelAttribute (\"Delay\", StringValue (\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install (nodes);\n\n    // Install the Internet stack (TCP/IP) on both nodes\n    InternetStackHelper stack;\n    stack.Install (nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n    // Set up a TCP server on node 1\n    uint16_t port = 8080; // Port number\n    Address serverAddress (InetSocketAddress (interfaces.GetAddress (1), port));\n    PacketSinkHelper tcpServerHelper (\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = tcpServerHelper.Install (nodes.Get (1));\n    serverApp.Start (Seconds (1.0));\n    serverApp.Stop (Seconds (10.0));\n\n    // Set up a TCP client on node 0 to send data to node 1\n    OnOffHelper tcpClientHelper (\"ns3::TcpSocketFactory\", serverAddress);\n    tcpClientHelper.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=1]\"));\n    tcpClientHelper.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0]\"));\n    tcpClientHelper.SetAttribute (\"DataRate\", DataRateValue (DataRate (\"5Mbps\")));\n    tcpClientHelper.SetAttribute (\"PacketSize\", UintegerValue (1024)); // Packet size: 1024 bytes\n\n    ApplicationContainer clientApp = tcpClientHelper.Install (nodes.Get (0));\n    clientApp.Start (Seconds (2.0)); // Start client after 2 seconds\n    clientApp.Stop (Seconds (10.0)); // Stop after 10 seconds\n\n    // Enable flow monitor to track performance statistics\n    FlowMonitorHelper flowMonitor;\n    Ptr<FlowMonitor> monitor = flowMonitor.InstallAll ();\n\n    // Run the simulation\n    Simulator::Stop (Seconds (10.0));\n    Simulator::Run ();\n\n    // Print flow statistics (e.g., throughput, delay)\n    monitor->CheckForLostPackets ();\n    monitor->SerializeToXmlFile (\"tcp-flow-monitor.xml\", true, true);\n\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats ();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n    {\n        NS_LOG_UNCOND (\"Flow \" << i->first << \" (\" << serverAddress << \"):\");\n        NS_LOG_UNCOND (\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND (\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND (\"  Throughput: \" << i->second.rxBytes * 8.0 / 9.0 / 1024 / 1024 << \" Mbps\");\n    }\n\n    // Cleanup and exit\n    Simulator::Destroy ();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that models a hybrid topology combining a **star topology** and a **bus topology**. In the star topology, a central node (Node 0) is connected to three peripheral nodes (Nodes 1, 2, and 3) using point-to-point links. In the bus topology, three nodes (Nodes 4, 5, and 6) are connected sequentially with point-to-point links. Install the **Internet stack** on all nodes and assign appropriate **IP addresses**. Deploy a **UDP echo server** on Node 0 (central node in the star topology) and **UDP echo clients** on Nodes 4 and 5 from the bus topology. Use **FlowMonitor** to track performance metrics such as packet loss and delay, and run the simulation for 20 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"HybridTopologyExample\");\n\nint main (int argc, char *argv[])\n{\n    // Enable logging for simulation\n    LogComponentEnable(\"HybridTopologyExample\", LOG_LEVEL_INFO);\n\n    // Node containers for star topology and bus topology\n    NodeContainer starNodes;\n    starNodes.Create(4); // Star: 1 central node + 3 peripheral nodes\n\n    NodeContainer busNodes;\n    busNodes.Create(3);  // Bus: 3 nodes in bus topology\n\n    // Point-to-Point helper for both star and bus\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Central node connected to 3 peripheral nodes in star topology\n    NetDeviceContainer starDevices;\n    for (uint32_t i = 1; i < starNodes.GetN(); i++)\n    {\n        starDevices.Add(p2p.Install(starNodes.Get(0), starNodes.Get(i)));\n    }\n\n    // Bus topology connecting 3 nodes in sequence\n    NetDeviceContainer busDevices;\n    busDevices.Add(p2p.Install(busNodes.Get(0), busNodes.Get(1)));\n    busDevices.Add(p2p.Install(busNodes.Get(1), busNodes.Get(2)));\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper internet;\n    internet.Install(starNodes);\n    internet.Install(busNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(starDevices);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    ipv4.Assign(busDevices);\n\n    // Set up UDP echo server on node 0 (central node in star)\n    UdpEchoServerHelper echoServer(9); // Port 9\n    ApplicationContainer serverApp = echoServer.Install(starNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Set up UDP echo clients on nodes 4 and 5 (from bus topology)\n    UdpEchoClientHelper echoClient(starNodes.Get(0)->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal(), 9); // Talk to the server\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps;\n    clientApps.Add(echoClient.Install(busNodes.Get(0))); // Client on bus node 4\n    clientApps.Add(echoClient.Install(busNodes.Get(1))); // Client on bus node 5\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(20.0));\n\n    // Enable routing tables\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Enable FlowMonitor to collect statistics\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(20.0));\n    Simulator::Run();\n\n    // Print flow monitor statistics\n    monitor->CheckForLostPackets();\n    monitor->SerializeToXmlFile(\"hybrid-topology.flowmon\", true, true);\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program that simulates an ad-hoc WiFi network using NS-3. The program should include the necessary NS-3 libraries like command-line parsing, logging, gnuplot generation, mobility models, packet sockets, and WiFi helpers. Define a class `Experiment` that handles the creation and running of the experiment, with methods to set and get the position of nodes, move them, receive packets, and set up packet reception sockets. In the `Run` method, configure two nodes with WiFi devices, assign constant mobility, and configure an `OnOffHelper` to send packets. For each experiment, the nodes should move and log throughput data in a 2D dataset to generate gnuplot graphs. The main function should simulate the experiment for different WiFi rates and managers, generating output graphs for each experiment run."}, {"role": "assistant", "content": "#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-socket-address.h\"\n#include \"ns3/packet-socket-helper.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Wifi-Adhoc\");\n\n/**\n * WiFi adhoc experiment class.\n *\n * It handles the creation and run of an experiment.\n */\nclass Experiment\n{\n  public:\n    Experiment();\n    /**\n     * Constructor.\n     * \\param name The name of the experiment.\n     */\n    Experiment(std::string name);\n\n    /**\n     * Run an experiment.\n     * \\param wifi      //!< The WifiHelper class.\n     * \\param wifiPhy   //!< The YansWifiPhyHelper class.\n     * \\param wifiMac   //!< The WifiMacHelper class.\n     * \\param wifiChannel //!< The YansWifiChannelHelper class.\n     * \\return a 2D dataset of the experiment data.\n     */\n    Gnuplot2dDataset Run(const WifiHelper& wifi,\n                         const YansWifiPhyHelper& wifiPhy,\n                         const WifiMacHelper& wifiMac,\n                         const YansWifiChannelHelper& wifiChannel);\n\n  private:\n    /**\n     * Receive a packet.\n     * \\param socket The receiving socket.\n     */\n    void ReceivePacket(Ptr<Socket> socket);\n    /**\n     * Set the position of a node.\n     * \\param node The node.\n     * \\param position The position of the node.\n     */\n    void SetPosition(Ptr<Node> node, Vector position);\n    /**\n     * Get the position of a node.\n     * \\param node The node.\n     * \\return the position of the node.\n     */\n    Vector GetPosition(Ptr<Node> node);\n    /**\n     * Move a node by 1m on the x axis, stops at 210m.\n     * \\param node The node.\n     */\n    void AdvancePosition(Ptr<Node> node);\n    /**\n     * Setup the receiving socket.\n     * \\param node The receiving node.\n     * \\return the socket.\n     */\n    Ptr<Socket> SetupPacketReceive(Ptr<Node> node);\n\n    uint32_t m_bytesTotal;     //!< The number of received bytes.\n    Gnuplot2dDataset m_output; //!< The output dataset.\n};\n\nExperiment::Experiment()\n{\n}\n\nExperiment::Experiment(std::string name)\n    : m_output(name)\n{\n    m_output.SetStyle(Gnuplot2dDataset::LINES);\n}\n\nvoid\nExperiment::SetPosition(Ptr<Node> node, Vector position)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    mobility->SetPosition(position);\n}\n\nVector\nExperiment::GetPosition(Ptr<Node> node)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    return mobility->GetPosition();\n}\n\nvoid\nExperiment::AdvancePosition(Ptr<Node> node)\n{\n    Vector pos = GetPosition(node);\n    double mbs = ((m_bytesTotal * 8.0) / 1000000);\n    m_bytesTotal = 0;\n    m_output.Add(pos.x, mbs);\n    pos.x += 1.0;\n    if (pos.x >= 210.0)\n    {\n        return;\n    }\n    SetPosition(node, pos);\n    Simulator::Schedule(Seconds(1.0), &Experiment::AdvancePosition, this, node);\n}\n\nvoid\nExperiment::ReceivePacket(Ptr<Socket> socket)\n{\n    Ptr<Packet> packet;\n    while ((packet = socket->Recv()))\n    {\n        m_bytesTotal += packet->GetSize();\n    }\n}\n\nPtr<Socket>\nExperiment::SetupPacketReceive(Ptr<Node> node)\n{\n    TypeId tid = TypeId::LookupByName(\"ns3::PacketSocketFactory\");\n    Ptr<Socket> sink = Socket::CreateSocket(node, tid);\n    sink->Bind();\n    sink->SetRecvCallback(MakeCallback(&Experiment::ReceivePacket, this));\n    return sink;\n}\n\nGnuplot2dDataset\nExperiment::Run(const WifiHelper& wifi,\n                const YansWifiPhyHelper& wifiPhy,\n                const WifiMacHelper& wifiMac,\n                const YansWifiChannelHelper& wifiChannel)\n{\n    m_bytesTotal = 0;\n\n    NodeContainer c;\n    c.Create(2);\n\n    PacketSocketHelper packetSocket;\n    packetSocket.Install(c);\n\n    YansWifiPhyHelper phy = wifiPhy;\n    phy.SetChannel(wifiChannel.Create());\n\n    NetDeviceContainer devices = wifi.Install(phy, wifiMac, c);\n\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(c);\n\n    PacketSocketAddress socket;\n    socket.SetSingleDevice(devices.Get(0)->GetIfIndex());\n    socket.SetPhysicalAddress(devices.Get(1)->GetAddress());\n    socket.SetProtocol(1);\n\n    OnOffHelper onoff(\"ns3::PacketSocketFactory\", Address(socket));\n    onoff.SetConstantRate(DataRate(60000000));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(2000));\n\n    ApplicationContainer apps = onoff.Install(c.Get(0));\n    apps.Start(Seconds(0.5));\n    apps.Stop(Seconds(250.0));\n\n    Simulator::Schedule(Seconds(1.5), &Experiment::AdvancePosition, this, c.Get(1));\n    Ptr<Socket> recvSink = SetupPacketReceive(c.Get(1));\n\n    Simulator::Run();\n\n    Simulator::Destroy();\n\n    return m_output;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Gnuplot gnuplot = Gnuplot(\"reference-rates.png\");\n\n    Experiment experiment;\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n    WifiMacHelper wifiMac;\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    Gnuplot2dDataset dataset;\n\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NS_LOG_DEBUG(\"54\");\n    experiment = Experiment(\"54mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate54Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"48\");\n    experiment = Experiment(\"48mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate48Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"36\");\n    experiment = Experiment(\"36mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate36Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"24\");\n    experiment = Experiment(\"24mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate24Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"18\");\n    experiment = Experiment(\"18mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate18Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"12\");\n    experiment = Experiment(\"12mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate12Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"9\");\n    experiment = Experiment(\"9mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate9Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"6\");\n    experiment = Experiment(\"6mb\");\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"OfdmRate6Mbps\"));\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    gnuplot.GenerateOutput(std::cout);\n\n    gnuplot = Gnuplot(\"rate-control.png\");\n\n    NS_LOG_DEBUG(\"arf\");\n    experiment = Experiment(\"arf\");\n    wifi.SetRemoteStationManager(\"ns3::ArfWifiManager\");\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"aarf\");\n    experiment = Experiment(\"aarf\");\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"aarf-cd\");\n    experiment = Experiment(\"aarf-cd\");\n    wifi.SetRemoteStationManager(\"ns3::AarfcdWifiManager\");\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"cara\");\n    experiment = Experiment(\"cara\");\n    wifi.SetRemoteStationManager(\"ns3::CaraWifiManager\");\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"rraa\");\n    experiment = Experiment(\"rraa\");\n    wifi.SetRemoteStationManager(\"ns3::RraaWifiManager\");\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    NS_LOG_DEBUG(\"ideal\");\n    experiment = Experiment(\"ideal\");\n    wifi.SetRemoteStationManager(\"ns3::IdealWifiManager\");\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n    gnuplot.AddDataset(dataset);\n\n    gnuplot.GenerateOutput(std::cout);\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a simulation code in ns-3 to compare the performance of mesh and tree topologies. In the simulation, create a mesh network with 4 nodes and a tree network with 4 nodes. Use UDP traffic applications for both topologies, and measure key performance metrics such as throughput, latency, and packet delivery ratio. Use FlowMonitor to capture statistics and visualize the topologies with NetAnim. Ensure the simulation runs for 20 seconds, and output the final results comparing the two topologies. Animate the node movements and traffic using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MeshVsTreeComparison\");\n\nint main(int argc, char *argv[])\n{\n    // Simulation time\n    double simTime = 20.0;\n\n    // Create nodes\n    NodeContainer meshNodes;\n    meshNodes.Create(4);\n\n    NodeContainer treeNodes;\n    treeNodes.Create(4);\n\n    // Install Internet Stack\n    InternetStackHelper internet;\n    internet.Install(meshNodes);\n    internet.Install(treeNodes);\n\n    // Configure mesh topology\n    MeshHelper mesh;\n    mesh.SetStackInstaller(\"ns3::Dot11sStack\");\n    mesh.SetSpreadInterfaceChannels(MeshHelper::SPREAD_CHANNELS);\n    mesh.SetStandard(WIFI_PHY_STANDARD_80211s);\n    \n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    MeshPointDeviceContainer meshDevices = mesh.Install(wifiPhy, meshNodes);\n    Ipv4AddressHelper addressMesh;\n    addressMesh.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer meshInterfaces = addressMesh.Assign(meshDevices);\n\n    // Configure tree topology\n    Ipv4AddressHelper addressTree;\n    addressTree.SetBase(\"10.2.2.0\", \"255.255.255.0\");\n\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer treeDevices1 = p2p.Install(treeNodes.Get(0), treeNodes.Get(1));\n    NetDeviceContainer treeDevices2 = p2p.Install(treeNodes.Get(0), treeNodes.Get(2));\n    NetDeviceContainer treeDevices3 = p2p.Install(treeNodes.Get(1), treeNodes.Get(3));\n\n    Ipv4InterfaceContainer treeInterfaces1 = addressTree.Assign(treeDevices1);\n    Ipv4InterfaceContainer treeInterfaces2 = addressTree.Assign(treeDevices2);\n    Ipv4InterfaceContainer treeInterfaces3 = addressTree.Assign(treeDevices3);\n\n    // Set mobility models\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(meshNodes);\n    mobility.Install(treeNodes);\n\n    // UDP traffic configuration\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverAppsMesh = udpServer.Install(meshNodes.Get(0));\n    serverAppsMesh.Start(Seconds(1.0));\n    serverAppsMesh.Stop(Seconds(simTime));\n\n    UdpServerHelper udpServerTree(port);\n    ApplicationContainer serverAppsTree = udpServerTree.Install(treeNodes.Get(0));\n    serverAppsTree.Start(Seconds(1.0));\n    serverAppsTree.Stop(Seconds(simTime));\n\n    UdpClientHelper udpClientMesh(meshInterfaces.GetAddress(0), port);\n    udpClientMesh.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClientMesh.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClientMesh.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientAppsMesh = udpClientMesh.Install(meshNodes.Get(1));\n    clientAppsMesh.Start(Seconds(2.0));\n    clientAppsMesh.Stop(Seconds(simTime));\n\n    UdpClientHelper udpClientTree(treeInterfaces1.GetAddress(0), port);\n    udpClientTree.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClientTree.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClientTree.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientAppsTree = udpClientTree.Install(treeNodes.Get(1));\n    clientAppsTree.Start(Seconds(2.0));\n    clientAppsTree.Stop(Seconds(simTime));\n\n    // Set up FlowMonitor to gather statistics\n    FlowMonitorHelper flowMonitorHelper;\n    Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n    // NetAnim setup\n    AnimationInterface anim(\"mesh_vs_tree.xml\");\n    anim.SetConstantPosition(meshNodes.Get(0), 10, 20);\n    anim.SetConstantPosition(meshNodes.Get(1), 20, 30);\n    anim.SetConstantPosition(meshNodes.Get(2), 30, 40);\n    anim.SetConstantPosition(meshNodes.Get(3), 40, 50);\n\n    anim.SetConstantPosition(treeNodes.Get(0), 50, 20);\n    anim.SetConstantPosition(treeNodes.Get(1), 60, 30);\n    anim.SetConstantPosition(treeNodes.Get(2), 70, 40);\n    anim.SetConstantPosition(treeNodes.Get(3), 80, 50);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n\n    // Flow monitor statistics\n    flowMonitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitorHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n\n    for (auto it = stats.begin(); it != stats.end(); ++it)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(it->first);\n        std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n        std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n        std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n        std::cout << \"  Throughput: \" << it->second.rxBytes * 8.0 / simTime / 1000 / 1000 << \" Mbps\" << std::endl;\n        std::cout << \"  Packet Delivery Ratio: \" << (double)it->second.rxPackets / it->second.txPackets * 100 << \"%\" << std::endl;\n    }\n\n    // Clean up\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simulation in ns-3 to compare the performance of TCP and UDP traffic in a simple network topology. Use a point-to-point topology with two nodes. Install both TCP and UDP applications on the network, transmitting data between the nodes. Measure and compare the key performance metrics, including throughput, latency, and packet delivery ratio for each protocol. Use FlowMonitor to capture and analyze these metrics, and visualize the traffic and node movements using NetAnim. Ensure that the simulation runs for 10 seconds, and print out the performance results for comparison between TCP and UDP."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpVsUdpComparison\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time\n    double simTime = 10.0;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Create point-to-point channel\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a UDP server on node 1\n    uint16_t udpPort = 9;\n    UdpServerHelper udpServer(udpPort);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simTime));\n\n    // Create a UDP client on node 0\n    UdpClientHelper udpClient(interfaces.GetAddress(1), udpPort);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simTime));\n\n    // Create a TCP server (Packet Sink) on node 1\n    uint16_t tcpPort = 8080;\n    PacketSinkHelper tcpSink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), tcpPort));\n    ApplicationContainer sinkApp = tcpSink.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(simTime));\n\n    // Create a TCP client on node 0\n    OnOffHelper tcpClient(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), tcpPort));\n    tcpClient.SetAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    tcpClient.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    tcpClient.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    ApplicationContainer clientAppTcp = tcpClient.Install(nodes.Get(0));\n    clientAppTcp.Start(Seconds(3.0));\n    clientAppTcp.Stop(Seconds(simTime));\n\n    // Set up FlowMonitor\n    FlowMonitorHelper flowMonitorHelper;\n    Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n    // NetAnim configuration\n    AnimationInterface anim(\"tcp_vs_udp.xml\");\n    anim.SetConstantPosition(nodes.Get(0), 10.0, 20.0);\n    anim.SetConstantPosition(nodes.Get(1), 30.0, 20.0);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n\n    // Flow monitor statistics\n    flowMonitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitorHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n\n    for (auto it = stats.begin(); it != stats.end(); ++it)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(it->first);\n        std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n        std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n        std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n        std::cout << \"  Throughput: \" << it->second.rxBytes * 8.0 / simTime / 1000 / 1000 << \" Mbps\" << std::endl;\n        std::cout << \"  Packet Delivery Ratio: \" << (double)it->second.rxPackets / it->second.txPackets * 100 << \"%\" << std::endl;\n        std::cout << \"  Delay: \" << it->second.delaySum.GetSeconds() << \" seconds\" << std::endl;\n    }\n\n    // Cleanup\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that involves a ring topology with 4 nodes and establishes a persistent TCP connection. Visualize the topology and packet exchanges using NetAnim. The simulation should use point-to-point links with a data rate of 5Mbps and a delay of 1ms. One node should act as the TCP client, while another node acts as the TCP server, maintaining a persistent connection. The other nodes should simply forward the traffic. Log the packet transmissions and set up NetAnim to animate the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PersistentTcpConnectionWithNetAnim\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"PersistentTcpConnectionWithNetAnim\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes for the ring topology\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Create a point-to-point link helper\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    // Create and install point-to-point links in a ring topology\n    NetDeviceContainer devices;\n    for (uint32_t i = 0; i < nodes.GetN(); ++i)\n    {\n        NetDeviceContainer temp = pointToPoint.Install(nodes.Get(i), nodes.Get((i + 1) % nodes.GetN()));\n        devices.Add(temp);\n    }\n\n    // Install Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfaces;\n    for (uint32_t i = 0; i < nodes.GetN(); ++i)\n    {\n        std::ostringstream subnet;\n        subnet << \"10.1.\" << i + 1 << \".0\";\n        address.SetBase(subnet.str().c_str(), \"255.255.255.0\");\n        interfaces.Add(address.Assign(devices.Get(i)));\n    }\n\n    // Create TCP server on node 0\n    uint16_t port = 50000;\n    Address serverAddress(InetSocketAddress(interfaces.GetAddress(0), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(0));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Create TCP client on node 2\n    OnOffHelper client(\"ns3::TcpSocketFactory\", serverAddress);\n    client.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    client.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    client.SetAttribute(\"DataRate\", StringValue(\"2Mbps\"));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = client.Install(nodes.Get(2));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Populate routing tables\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Set up NetAnim\n    AnimationInterface anim(\"tcp_ring_topology.xml\");\n\n    // Set positions for the nodes for visualization in NetAnim\n    anim.SetConstantPosition(nodes.Get(0), 10.0, 30.0); // Node 0\n    anim.SetConstantPosition(nodes.Get(1), 30.0, 50.0); // Node 1\n    anim.SetConstantPosition(nodes.Get(2), 50.0, 30.0); // Node 2\n    anim.SetConstantPosition(nodes.Get(3), 30.0, 10.0); // Node 3\n\n    // Enable packet tracing in NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that establishes a non-persistent TCP connection in a simple topology using NetAnim. Set up a point-to-point link between a client and a server, and ensure that after completing a single data transfer, the TCP connection terminates. Visualize the packet flow using NetAnim, and configure the connection to have a bandwidth of 5Mbps and a delay of 1ms."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"NonPersistentTcpWithNetAnim\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"NonPersistentTcpWithNetAnim\", LOG_LEVEL_INFO);\n\n    // Create 2 nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Create a point-to-point link with 5Mbps bandwidth and 1ms delay\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    // Install the link between the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack on the nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP server on node 0\n    uint16_t port = 50000;\n    Address serverAddress(InetSocketAddress(interfaces.GetAddress(0), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(0));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(5.0));  // Stop after 5 seconds\n\n    // Create a TCP client on node 1 for a non-persistent connection\n    OnOffHelper client(\"ns3::TcpSocketFactory\", serverAddress);\n    client.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    client.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\")); // Non-persistent connection\n    client.SetAttribute(\"DataRate\", StringValue(\"2Mbps\"));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = client.Install(nodes.Get(1));\n    clientApp.Start(Seconds(2.0));  // Start client 1 second after the server\n    clientApp.Stop(Seconds(4.0));   // Stop client after the connection finishes\n\n    // Populate routing tables\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Set up NetAnim\n    AnimationInterface anim(\"non_persistent_tcp_netanim.xml\");\n\n    // Set node positions for visualization\n    anim.SetConstantPosition(nodes.Get(0), 10.0, 20.0); // Server (Node 0)\n    anim.SetConstantPosition(nodes.Get(1), 30.0, 20.0); // Client (Node 1)\n\n    // Enable packet metadata for NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that demonstrates OSPF (Open Shortest Path First) routing protocol between multiple nodes using NetAnim. Set up a basic network topology where multiple nodes are interconnected using point-to-point links. OSPF will dynamically compute the shortest path between nodes, and packet flows should be visualized using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ospf-helper.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OspfWithNetAnimExample\");\n\nint main(int argc, char *argv[])\n{\n    // Log level\n    LogComponentEnable(\"OspfWithNetAnimExample\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Set up point-to-point link properties\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install links between nodes in a square topology\n    NetDeviceContainer d1d2, d2d3, d3d4, d4d1;\n    d1d2 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));\n    d2d3 = pointToPoint.Install(nodes.Get(1), nodes.Get(2));\n    d3d4 = pointToPoint.Install(nodes.Get(2), nodes.Get(3));\n    d4d1 = pointToPoint.Install(nodes.Get(3), nodes.Get(0));\n\n    // Install internet stack on nodes with OSPF routing\n    OspfHelper ospfRouting;\n    Ipv4ListRoutingHelper listRouting;\n    listRouting.Add(ospfRouting, 10); // OSPF priority 10\n    InternetStackHelper stack;\n    stack.SetRoutingHelper(listRouting);\n    stack.Install(nodes);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfaces;\n    \n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(d1d2));\n    \n    address.SetBase(\"10.2.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(d2d3));\n    \n    address.SetBase(\"10.3.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(d3d4));\n    \n    address.SetBase(\"10.4.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(d4d1));\n\n    // Enable OSPF to populate routing tables\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create TCP traffic from node 1 to node 3\n    uint16_t port = 50000;\n    OnOffHelper onOffHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(2), port));\n    onOffHelper.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    onOffHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = onOffHelper.Install(nodes.Get(0)); // TCP traffic from node 1 to node 3\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Install a sink on node 3\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sinkHelper.Install(nodes.Get(2));\n    sinkApp.Start(Seconds(0.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Set up NetAnim\n    AnimationInterface anim(\"ospf_with_netanim.xml\");\n\n    // Set node positions for better visualization\n    anim.SetConstantPosition(nodes.Get(0), 10, 10);\n    anim.SetConstantPosition(nodes.Get(1), 30, 10);\n    anim.SetConstantPosition(nodes.Get(2), 30, 30);\n    anim.SetConstantPosition(nodes.Get(3), 10, 30);\n\n    // Enable packet metadata for visualization\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(12.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a network using OSPF as the routing protocol in NS-3. The network consists of four nodes arranged in a square topology. OSPF should be used to dynamically generate routing tables at each node. Monitor the routing tables to verify that the correct routes are chosen based on the shortest path."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ospf-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OspfRoutingExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for OSPF and other components\n    LogComponentEnable(\"OspfRoutingExample\", LOG_LEVEL_INFO);\n\n    // Create 4 nodes\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Create Point-to-Point links between the nodes to form a square topology\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install links: Node 0-1, Node 1-2, Node 2-3, Node 3-0 (square)\n    NetDeviceContainer devices01 = p2p.Install(nodes.Get(0), nodes.Get(1));\n    NetDeviceContainer devices12 = p2p.Install(nodes.Get(1), nodes.Get(2));\n    NetDeviceContainer devices23 = p2p.Install(nodes.Get(2), nodes.Get(3));\n    NetDeviceContainer devices30 = p2p.Install(nodes.Get(3), nodes.Get(0));\n\n    // Install Internet stack with OSPF routing on all nodes\n    InternetStackHelper internet;\n    \n    // Enable OSPF routing\n    Ipv4ListRoutingHelper listRouting;\n    OspfHelper ospfRouting;\n    listRouting.Add(ospfRouting, 0);\n    internet.SetRoutingHelper(listRouting);  // Use OSPF as the routing protocol\n    internet.Install(nodes);\n\n    // Assign IP addresses to the network interfaces\n    Ipv4AddressHelper ipv4;\n    \n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ifaces01 = ipv4.Assign(devices01);  // Link 0-1\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ifaces12 = ipv4.Assign(devices12);  // Link 1-2\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ifaces23 = ipv4.Assign(devices23);  // Link 2-3\n\n    ipv4.SetBase(\"10.1.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ifaces30 = ipv4.Assign(devices30);  // Link 3-0\n\n    // Set up a simple application: Echo server on node 3\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(3));  // Server on node 3\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a client on node 0 to send packets to node 3\n    UdpEchoClientHelper echoClient(ifaces23.GetAddress(1), 9);  // Node 0 sends to node 3\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));  // Client on node 0\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable routing table printing on all nodes for OSPF\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n    Simulator::Schedule(Seconds(2.0), &Ipv4GlobalRoutingHelper::PrintRoutingTableAllAt, Seconds(2.0), Create<OutputStreamWrapper>(&std::cout));\n\n    // Enable pcap tracing to observe packet transmission\n    p2p.EnablePcapAll(\"ospf-routing\");\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate an ad-hoc wireless network with five nodes using the AODV routing protocol in NS-3. The nodes are randomly placed in a 100x100 meter area and communicate wirelessly. One node acts as a server, while another node acts as a client, sending UDP packets to the server. Track the dynamic creation of routes using AODV and enable packet tracing to observe the packet flow."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/aodv-helper.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AodvAdhocExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for AODV and related components\n    LogComponentEnable(\"AodvAdhocExample\", LOG_LEVEL_INFO);\n\n    // Number of nodes\n    uint32_t numNodes = 5;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(numNodes);\n\n    // Set up wireless devices using the Wi-Fi standard\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Assign mobility to nodes, randomly placing them in a 100x100 meter area\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install AODV as the routing protocol\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ifaces = ipv4.Assign(devices);\n\n    // Set up a UDP server on node 4\n    uint16_t port = 9;\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(4));  // Server on node 4\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP client on node 0 to communicate with node 4 (server)\n    UdpEchoClientHelper echoClient(ifaces.GetAddress(4), port);  // Node 0 communicates with node 4\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));  // Client on node 0\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable pcap tracing to observe packet transmission\n    wifiPhy.EnablePcapAll(\"aodv-adhoc\");\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a point-to-point network in NS-3 where Node A acts as a TCP server and Node B acts as a TCP client. Node A and Node B are connected via a point-to-point link. Enable pcap and ASCII tracing to monitor the packet exchanges. Measure the throughput and ensure that the TCP traffic flows over the link without errors. Configure a delay of 2ms and a data rate of 5 Mbps for the point-to-point link."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpPointToPointExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set default parameters for simulation\n    Time::SetResolution(Time::NS);\n\n    // Create 2 nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point connection between the nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack (TCP/IP protocols)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP server (Packet Sink) on Node 1 (server)\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(interfaces.GetAddress(1), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = packetSinkHelper.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client (OnOff application) on Node 0 (client)\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientHelper.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"5Mbps\")));\n    clientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = clientHelper.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable packet tracing\n    pointToPoint.EnablePcapAll(\"tcp-point-to-point\");\n    AsciiTraceHelper ascii;\n    pointToPoint.EnableAsciiAll(ascii.CreateFileStream(\"tcp-point-to-point.tr\"));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network in ns-3 with multiple stations (clients) connected to an access point (AP) in infrastructure mode. One client will act as a UDP server, while another will act as a UDP client sending traffic to the server. Configure a Wi-Fi channel with a data rate of 54 Mbps and a delay of 2ms. Enable pcap and ASCII tracing to analyze packet transmission and reception. Ensure the simulation runs for 10 seconds, and measure the throughput at the server."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for the simulation\n    LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n\n    // Create nodes for Wi-Fi stations (clients) and an access point (AP)\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2); // 2 stations (clients)\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1); // 1 AP node\n\n    // Set up the Wi-Fi physical layer and channel properties\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up the Wi-Fi MAC layer in infrastructure mode (AP + stations)\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n    WifiMacHelper mac;\n\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n\n    // Install Wi-Fi devices on the stations (clients)\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\", SsidValue(ssid));\n\n    // Install Wi-Fi device on the AP\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set up mobility models for the stations and AP\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Install the Internet stack (TCP/IP) on the nodes\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses to the Wi-Fi devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces;\n    staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface;\n    apInterface = address.Assign(apDevice);\n\n    // Set up a UDP server on one of the stations\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up a UDP client on another station\n    UdpClientHelper udpClient(staInterfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable packet tracing (pcap and ASCII)\n    phy.EnablePcap(\"wifi-udp\", apDevice.Get(0));\n    AsciiTraceHelper ascii;\n    phy.EnableAsciiAll(ascii.CreateFileStream(\"wifi-udp.tr\"));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple point-to-point (P2P) network in ns-3 where a TCP client communicates with a TCP server. The link should have a data rate of 5 Mbps and a delay of 2 milliseconds. The TCP client should send data to the server using a bulk send application, and the server should use a packet sink to receive data. Enable pcap tracing to log packet transmissions and receptions. Run the simulation for 10 seconds and observe the throughput at the server."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for bulk send and packet sink\n    LogComponentEnable(\"BulkSendApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"PacketSink\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);  // Two nodes\n\n    // Set up point-to-point channel properties\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install the point-to-point devices and channels on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the TCP/IP stack on both nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP server (packet sink) on one node\n    uint16_t port = 9;  // Well-known port for TCP\n    Address sinkAddress(InetSocketAddress(interfaces.GetAddress(1), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Create a TCP client (bulk sender) on the other node\n    BulkSendHelper bulkSend(\"ns3::TcpSocketFactory\", sinkAddress);\n    bulkSend.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data\n    ApplicationContainer clientApp = bulkSend.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable packet tracing\n    pointToPoint.EnablePcapAll(\"p2p-tcp\");\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate NS-3 code that sets up a Wi-Fi network simulation with four independent networks, each consisting of one access point and one station working on different channels (36, 40, 44, 48). Configure each station to continuously transmit data packets to its respective AP with varying aggregation settings: station A should use default aggregation with A-MSDU disabled and A-MPDU enabled at 65 KB, station B should have both A-MPDU and A-MSDU disabled, station C should enable A-MSDU with 8 KB and disable A-MPDU, and station D should use two-level aggregation with A-MPDU at 32 KB and A-MSDU at 4 KB. Include command line options to modify payload size, simulation time, distance between stations and APs, and enable or disable RTS/CTS."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/wifi-mac.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This is an example that illustrates how 802.11n aggregation is configured.\n// It defines 4 independent Wi-Fi networks (working on different channels).\n// Each network contains one access point and one station. Each station\n// continuously transmits data packets to its respective AP.\n//\n// Network topology (numbers in parentheses are channel numbers):\n//\n//  Network A (36)   Network B (40)   Network C (44)   Network D (48)\n//   *      *          *      *         *      *          *      *\n//   |      |          |      |         |      |          |      |\n//  AP A   STA A      AP B   STA B     AP C   STA C      AP D   STA D\n//\n// The aggregation parameters are configured differently on the 4 stations:\n// - station A uses default aggregation parameter values (A-MSDU disabled, A-MPDU enabled with\n// maximum size of 65 kB);\n// - station B doesn't use aggregation (both A-MPDU and A-MSDU are disabled);\n// - station C enables A-MSDU (with maximum size of 8 kB) but disables A-MPDU;\n// - station D uses two-level aggregation (A-MPDU with maximum size of 32 kB and A-MSDU with maximum\n// size of 4 kB).\n//\n// Packets in this simulation belong to BestEffort Access Class (AC_BE).\n//\n// The user can select the distance between the stations and the APs and can enable/disable the\n// RTS/CTS mechanism. Example: ./ns3 run \"wifi-aggregation --distance=10 --enableRts=0\n// --simulationTime=20s\"\n//\n// The output prints the throughput measured for the 4 cases/networks described above. When default\n// aggregation parameters are enabled, the maximum A-MPDU size is 65 kB and the throughput is\n// maximal. When aggregation is disabled, the throughput is about the half of the physical bitrate.\n// When only A-MSDU is enabled, the throughput is increased but is not maximal, since the maximum\n// A-MSDU size is limited to 7935 bytes (whereas the maximum A-MPDU size is limited to 65535 bytes).\n// When A-MSDU and A-MPDU are both enabled (= two-level aggregation), the throughput is slightly\n// smaller than the first scenario since we set a smaller maximum A-MPDU size.\n//\n// When the distance is increased, the frame error rate gets higher, and the output shows how it\n// affects the throughput for the 4 networks. Even through A-MSDU has less overheads than A-MPDU,\n// A-MSDU is less robust against transmission errors than A-MPDU. When the distance is augmented,\n// the throughput for the third scenario is more affected than the throughput obtained in other\n// networks.\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleMpduAggregation\");\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t payloadSize{1472}; // bytes\n    Time simulationTime{\"10s\"};\n    meter_u distance{5};\n    bool enableRts{false};\n    bool enablePcap{false};\n    bool verifyResults{false}; // used for regression\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"payloadSize\", \"Payload size in bytes\", payloadSize);\n    cmd.AddValue(\"enableRts\", \"Enable or disable RTS/CTS\", enableRts);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the station and the access point\",\n                 distance);\n    cmd.AddValue(\"enablePcap\", \"Enable/disable pcap file generation\", enablePcap);\n    cmd.AddValue(\"verifyResults\",\n                 \"Enable/disable results verification at the end of the simulation\",\n                 verifyResults);\n    cmd.Parse(argc, argv);\n\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\",\n                       enableRts ? StringValue(\"0\") : StringValue(\"999999\"));\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(4);\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(4);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"HtMcs7\"),\n                                 \"ControlMode\",\n                                 StringValue(\"HtMcs0\"));\n    WifiMacHelper mac;\n\n    NetDeviceContainer staDeviceA;\n    NetDeviceContainer staDeviceB;\n    NetDeviceContainer staDeviceC;\n    NetDeviceContainer staDeviceD;\n    NetDeviceContainer apDeviceA;\n    NetDeviceContainer apDeviceB;\n    NetDeviceContainer apDeviceC;\n    NetDeviceContainer apDeviceD;\n    Ssid ssid;\n\n    // Network A\n    ssid = Ssid(\"network-A\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{36, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    staDeviceA = wifi.Install(phy, mac, wifiStaNodes.Get(0));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceA = wifi.Install(phy, mac, wifiApNodes.Get(0));\n\n    // Network B\n    ssid = Ssid(\"network-B\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{40, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    staDeviceB = wifi.Install(phy, mac, wifiStaNodes.Get(1));\n\n    // Disable A-MPDU\n    Ptr<NetDevice> dev = wifiStaNodes.Get(1)->GetDevice(0);\n    Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceB = wifi.Install(phy, mac, wifiApNodes.Get(1));\n\n    // Disable A-MPDU\n    dev = wifiApNodes.Get(1)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n\n    // Network C\n    ssid = Ssid(\"network-C\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{44, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    staDeviceC = wifi.Install(phy, mac, wifiStaNodes.Get(2));\n\n    // Disable A-MPDU and enable A-MSDU with the highest maximum size allowed by the standard (7935\n    // bytes)\n    dev = wifiStaNodes.Get(2)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(7935));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceC = wifi.Install(phy, mac, wifiApNodes.Get(2));\n\n    // Disable A-MPDU and enable A-MSDU with the highest maximum size allowed by the standard (7935\n    // bytes)\n    dev = wifiApNodes.Get(2)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(7935));\n\n    // Network D\n    ssid = Ssid(\"network-D\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{48, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    staDeviceD = wifi.Install(phy, mac, wifiStaNodes.Get(3));\n\n    // Enable A-MPDU with a smaller size than the default one and\n    // enable A-MSDU with the smallest maximum size allowed by the standard (3839 bytes)\n    dev = wifiStaNodes.Get(3)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(32768));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(3839));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    apDeviceD = wifi.Install(phy, mac, wifiApNodes.Get(3));\n\n    // Enable A-MPDU with a smaller size than the default one and\n    // enable A-MSDU with the smallest maximum size allowed by the standard (3839 bytes)\n    dev = wifiApNodes.Get(3)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(32768));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(3839));\n\n    // Setting mobility model\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    // Set position for APs\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(10.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(20.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(30.0, 0.0, 0.0));\n    // Set position for STAs\n    positionAlloc->Add(Vector(distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(10 + distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(20 + distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(30 + distance, 0.0, 0.0));\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(wifiApNodes);\n    mobility.Install(wifiStaNodes);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceA;\n    StaInterfaceA = address.Assign(staDeviceA);\n    Ipv4InterfaceContainer ApInterfaceA;\n    ApInterfaceA = address.Assign(apDeviceA);\n\n    address.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceB;\n    StaInterfaceB = address.Assign(staDeviceB);\n    Ipv4InterfaceContainer ApInterfaceB;\n    ApInterfaceB = address.Assign(apDeviceB);\n\n    address.SetBase(\"192.168.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceC;\n    StaInterfaceC = address.Assign(staDeviceC);\n    Ipv4InterfaceContainer ApInterfaceC;\n    ApInterfaceC = address.Assign(apDeviceC);\n\n    address.SetBase(\"192.168.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceD;\n    StaInterfaceD = address.Assign(staDeviceD);\n    Ipv4InterfaceContainer ApInterfaceD;\n    ApInterfaceD = address.Assign(apDeviceD);\n\n    // Setting applications\n    uint16_t port = 9;\n    UdpServerHelper serverA(port);\n    ApplicationContainer serverAppA = serverA.Install(wifiStaNodes.Get(0));\n    serverAppA.Start(Seconds(0.0));\n    serverAppA.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientA(StaInterfaceA.GetAddress(0), port);\n    clientA.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientA.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientA.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppA = clientA.Install(wifiApNodes.Get(0));\n    clientAppA.Start(Seconds(1.0));\n    clientAppA.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverB(port);\n    ApplicationContainer serverAppB = serverB.Install(wifiStaNodes.Get(1));\n    serverAppB.Start(Seconds(0.0));\n    serverAppB.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientB(StaInterfaceB.GetAddress(0), port);\n    clientB.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientB.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientB.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppB = clientB.Install(wifiApNodes.Get(1));\n    clientAppB.Start(Seconds(1.0));\n    clientAppB.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverC(port);\n    ApplicationContainer serverAppC = serverC.Install(wifiStaNodes.Get(2));\n    serverAppC.Start(Seconds(0.0));\n    serverAppC.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientC(StaInterfaceC.GetAddress(0), port);\n    clientC.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientC.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientC.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppC = clientC.Install(wifiApNodes.Get(2));\n    clientAppC.Start(Seconds(1.0));\n    clientAppC.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverD(port);\n    ApplicationContainer serverAppD = serverD.Install(wifiStaNodes.Get(3));\n    serverAppD.Start(Seconds(0.0));\n    serverAppD.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientD(StaInterfaceD.GetAddress(0), port);\n    clientD.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientD.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientD.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppD = clientD.Install(wifiApNodes.Get(3));\n    clientAppD.Start(Seconds(1.0));\n    clientAppD.Stop(simulationTime + Seconds(1.0));\n\n    if (enablePcap)\n    {\n        phy.EnablePcap(\"AP_A\", apDeviceA.Get(0));\n        phy.EnablePcap(\"STA_A\", staDeviceA.Get(0));\n        phy.EnablePcap(\"AP_B\", apDeviceB.Get(0));\n        phy.EnablePcap(\"STA_B\", staDeviceB.Get(0));\n        phy.EnablePcap(\"AP_C\", apDeviceC.Get(0));\n        phy.EnablePcap(\"STA_C\", staDeviceC.Get(0));\n        phy.EnablePcap(\"AP_D\", apDeviceD.Get(0));\n        phy.EnablePcap(\"STA_D\", staDeviceD.Get(0));\n    }\n\n    Simulator::Stop(simulationTime + Seconds(1.0));\n    Simulator::Run();\n\n    // Show results\n    double totalPacketsThroughA = DynamicCast<UdpServer>(serverAppA.Get(0))->GetReceived();\n    double totalPacketsThroughB = DynamicCast<UdpServer>(serverAppB.Get(0))->GetReceived();\n    double totalPacketsThroughC = DynamicCast<UdpServer>(serverAppC.Get(0))->GetReceived();\n    double totalPacketsThroughD = DynamicCast<UdpServer>(serverAppD.Get(0))->GetReceived();\n\n    Simulator::Destroy();\n\n    auto throughput = totalPacketsThroughA * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Throughput with default configuration (A-MPDU aggregation enabled, 65kB): \"\n              << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 59.0 || throughput > 60.0))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    throughput = totalPacketsThroughB * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Throughput with aggregation disabled: \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 30 || throughput > 31))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    throughput = totalPacketsThroughC * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Throughput with A-MPDU disabled and A-MSDU enabled (8kB): \" << throughput\n              << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 51 || throughput > 52))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    throughput = totalPacketsThroughD * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Throughput with A-MPDU enabled (32kB) and A-MSDU enabled (4kB): \" << throughput\n              << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 58 || throughput > 59))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless LAN network using ns-3 where a single access point (AP) communicates with two wireless stations (STAs). Configure TCP traffic where one station acts as a server and another as a client. The Wi-Fi standard should be 802.11b with a data rate of 11 Mbps. Run the simulation for 10 seconds and use pcap tracing to capture packet transmissions. Measure the throughput at the server side and display packet counts at the end of the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation parameters\n    double simulationTime = 10.0; // seconds\n\n    // Enable logging for BulkSend and PacketSink applications\n    LogComponentEnable(\"BulkSendApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"PacketSink\", LOG_LEVEL_INFO);\n\n    // Create AP and STA nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2); // Two stations (STA)\n\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1); // One access point (AP)\n\n    // Set up Wi-Fi network\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n\n    // Configure STA devices\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure AP device\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set up mobility for stations and AP\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Install TCP/IP stack on both AP and STA nodes\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Create a TCP server (packet sink) on one STA\n    uint16_t port = 9;  // TCP port\n    Address sinkAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(wifiStaNodes.Get(1)); // Server on STA2\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(simulationTime + 1));\n\n    // Create a TCP client (bulk sender) on another STA\n    BulkSendHelper bulkSend(\"ns3::TcpSocketFactory\",\n                            InetSocketAddress(staInterfaces.GetAddress(1), port));\n    bulkSend.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data\n    ApplicationContainer clientApp = bulkSend.Install(wifiStaNodes.Get(0)); // Client on STA1\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime + 1));\n\n    // Enable packet capture tracing\n    phy.EnablePcap(\"wifi-tcp\", apDevice.Get(0));\n\n    // FlowMonitor to monitor traffic\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime + 1));\n    Simulator::Run();\n\n    // Output flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Bytes: \" << i->second.txBytes);\n        NS_LOG_UNCOND(\"  Rx Bytes: \" << i->second.rxBytes);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 / simulationTime / 1000 / 1000 << \" Mbps\");\n    }\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate an ad-hoc wireless network using ns-3 with the AODV routing protocol. Create 10 mobile nodes that move randomly within a 500m x 500m area. Simulate UDP traffic between nodes, starting at random times, and run the simulation for 30 seconds. Use pcap tracing to capture the packet transmissions. Measure and display the packet delivery ratio (PDR) and average end-to-end delay at the end of the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocAodvExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation parameters\n    double simulationTime = 30.0; // seconds\n    uint32_t numNodes = 10;\n    double txPower = 16.0; // dBm\n    double nodeSpeed = 20.0; // m/s (random speed for mobility)\n\n    // Create nodes\n    NodeContainer adhocNodes;\n    adhocNodes.Create(numNodes);\n\n    // Set up Wi-Fi for ad-hoc network\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.Set(\"TxPowerStart\", DoubleValue(txPower));\n    phy.Set(\"TxPowerEnd\", DoubleValue(txPower));\n\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::RangePropagationLossModel\", \"MaxRange\", DoubleValue(100.0));\n    phy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, adhocNodes);\n\n    // Set up mobility\n    MobilityHelper mobility;\n    Ptr<UniformRandomVariable> speed = CreateObject<UniformRandomVariable>();\n    speed->SetAttribute(\"Min\", DoubleValue(0.0));\n    speed->SetAttribute(\"Max\", DoubleValue(nodeSpeed));\n\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", PointerValue(speed),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=2.0]\"),\n                              \"PositionAllocator\", StringValue(\"ns3::RandomRectanglePositionAllocator\"),\n                              \"X\", DoubleValue(500.0), // Area of 500x500 meters\n                              \"Y\", DoubleValue(500.0));\n\n    mobility.Install(adhocNodes);\n\n    // Install internet stack and AODV routing protocol\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv); // AODV as the routing protocol\n    internet.Install(adhocNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP traffic: a UdpEchoServer on one node and a UdpEchoClient on another\n    uint16_t port = 9;\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApp = echoServer.Install(adhocNodes.Get(0)); // Server on node 0\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(0), port); // Client to node 0\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(adhocNodes.Get(numNodes - 1)); // Client on last node\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Enable pcap tracing\n    phy.EnablePcapAll(\"aodv-adhoc\");\n\n    // Install FlowMonitor for traffic statistics\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n\n    // Output flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    uint32_t sentPackets = 0;\n    uint32_t receivedPackets = 0;\n    double delaySum = 0.0;\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        sentPackets += i->second.txPackets;\n        receivedPackets += i->second.rxPackets;\n        delaySum += i->second.delaySum.GetSeconds();\n    }\n\n    double pdr = double(receivedPackets) / sentPackets * 100;\n    double averageDelay = delaySum / receivedPackets;\n\n    NS_LOG_UNCOND(\"Packet Delivery Ratio: \" << pdr << \"%\");\n    NS_LOG_UNCOND(\"Average End-to-End Delay: \" << averageDelay << \" s\");\n\n    // Clean up\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate an ad-hoc wireless network using ns-3 with the AODV routing protocol. Create 10 mobile nodes that move randomly within a 500m x 500m area. Simulate UDP traffic between nodes, starting at random times, and run the simulation for 30 seconds. Use pcap tracing to capture the packet transmissions. Measure and display the packet delivery ratio (PDR) and average end-to-end delay at the end of the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocAodvExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation parameters\n    double simulationTime = 30.0; // seconds\n    uint32_t numNodes = 10;\n    double txPower = 16.0; // dBm\n    double nodeSpeed = 20.0; // m/s (random speed for mobility)\n\n    // Create nodes\n    NodeContainer adhocNodes;\n    adhocNodes.Create(numNodes);\n\n    // Set up Wi-Fi for ad-hoc network\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.Set(\"TxPowerStart\", DoubleValue(txPower));\n    phy.Set(\"TxPowerEnd\", DoubleValue(txPower));\n\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::RangePropagationLossModel\", \"MaxRange\", DoubleValue(100.0));\n    phy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, adhocNodes);\n\n    // Set up mobility\n    MobilityHelper mobility;\n    Ptr<UniformRandomVariable> speed = CreateObject<UniformRandomVariable>();\n    speed->SetAttribute(\"Min\", DoubleValue(0.0));\n    speed->SetAttribute(\"Max\", DoubleValue(nodeSpeed));\n\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", PointerValue(speed),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=2.0]\"),\n                              \"PositionAllocator\", StringValue(\"ns3::RandomRectanglePositionAllocator\"),\n                              \"X\", DoubleValue(500.0), // Area of 500x500 meters\n                              \"Y\", DoubleValue(500.0));\n\n    mobility.Install(adhocNodes);\n\n    // Install internet stack and AODV routing protocol\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv); // AODV as the routing protocol\n    internet.Install(adhocNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP traffic: a UdpEchoServer on one node and a UdpEchoClient on another\n    uint16_t port = 9;\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApp = echoServer.Install(adhocNodes.Get(0)); // Server on node 0\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(0), port); // Client to node 0\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(adhocNodes.Get(numNodes - 1)); // Client on last node\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Enable pcap tracing\n    phy.EnablePcapAll(\"aodv-adhoc\");\n\n    // Install FlowMonitor for traffic statistics\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n\n    // Output flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    uint32_t sentPackets = 0;\n    uint32_t receivedPackets = 0;\n    double delaySum = 0.0;\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        sentPackets += i->second.txPackets;\n        receivedPackets += i->second.rxPackets;\n        delaySum += i->second.delaySum.GetSeconds();\n    }\n\n    double pdr = double(receivedPackets) / sentPackets * 100;\n    double averageDelay = delaySum / receivedPackets;\n\n    NS_LOG_UNCOND(\"Packet Delivery Ratio: \" << pdr << \"%\");\n    NS_LOG_UNCOND(\"Average End-to-End Delay: \" << averageDelay << \" s\");\n\n    // Clean up\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a hybrid network topology in ns-3 with 4 wired nodes and 3 wireless nodes. The wired nodes will be connected in a chain using point-to-point links. The wireless nodes will be connected via Wi-Fi, and one of the wired nodes will act as a gateway for the wireless network. Generate TCP traffic from the wireless nodes to the wired nodes, and enable pcap tracing to capture packet transmissions. At the end of the simulation, output the average throughput of the TCP flow."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"HybridNetworkTopology\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation parameters\n    double simulationTime = 10.0; // seconds\n\n    // Create wired nodes\n    NodeContainer wiredNodes;\n    wiredNodes.Create(4); // 4 wired nodes\n\n    // Create wireless nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(3); // 3 wireless nodes\n\n    NodeContainer wifiApNode = wiredNodes.Get(3); // Use one wired node as AP\n\n    // Create point-to-point connections between wired nodes\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer p2pDevices;\n    for (uint32_t i = 0; i < wiredNodes.GetN() - 1; ++i)\n    {\n        NetDeviceContainer link = p2p.Install(wiredNodes.Get(i), wiredNodes.Get(i + 1));\n        p2pDevices.Add(link);\n    }\n\n    // Set up Wi-Fi for wireless nodes\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    phy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(wiredNodes);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses to the wired network\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer wiredInterfaces = address.Assign(p2pDevices);\n\n    // Assign IP addresses to the wireless network\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer wifiInterfaces = address.Assign(staDevices);\n    address.Assign(apDevice);\n\n    // Set up mobility for wireless nodes\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Enable global routing to route between wired and wireless sections\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create TCP traffic from wireless nodes to wired nodes\n    uint16_t port = 9;\n    OnOffHelper onOffHelper(\"ns3::TcpSocketFactory\", Address());\n    onOffHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    onOffHelper.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"1Mbps\")));\n    onOffHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < wifiStaNodes.GetN(); ++i)\n    {\n        AddressValue remoteAddress(InetSocketAddress(wiredInterfaces.GetAddress(3), port));\n        onOffHelper.SetAttribute(\"Remote\", remoteAddress);\n        clientApps.Add(onOffHelper.Install(wifiStaNodes.Get(i)));\n    }\n\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(simulationTime));\n\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = packetSinkHelper.Install(wiredNodes.Get(3)); // Sink on last wired node\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Enable pcap tracing\n    p2p.EnablePcapAll(\"hybrid-topology\");\n    phy.EnablePcap(\"wifi-ap\", apDevice.Get(0));\n    phy.EnablePcap(\"wifi-sta\", staDevices.Get(0));\n\n    // Flow monitor to calculate throughput\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n\n    // Output the throughput\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    double totalThroughput = 0;\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        totalThroughput += i->second.rxBytes * 8.0 / simulationTime / 1000 / 1000; // in Mbps\n    }\n\n    NS_LOG_UNCOND(\"Average Throughput: \" << totalThroughput << \" Mbps\");\n\n    // Clean up\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that demonstrates a hybrid topology combining a ring, mesh, bus, line, star, and tree topology. This simulation will show the interconnection of nodes in different topology types within a single network. Use point-to-point links for connections, install Internet stacks on the nodes, and enable dynamic routing using OSPF for efficient routing between nodes. Additionally, enable tracing and NetAnim visualization to capture the network behavior"}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ospf-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"HybridTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"HybridTopologyExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for different topologies\n    NodeContainer ringNodes, meshNodes, busNodes, lineNodes, starNodes, treeNodes;\n    \n    ringNodes.Create(4);  // Ring topology (4 nodes)\n    meshNodes.Create(4);  // Mesh topology (4 nodes)\n    busNodes.Create(3);   // Bus topology (3 nodes)\n    lineNodes.Create(2);  // Line topology (2 nodes)\n    starNodes.Create(4);  // Star topology (1 central node + 3 leaf nodes)\n    treeNodes.Create(7);  // Tree topology (7 nodes)\n\n    // Create point-to-point helper for links\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install Internet stack with OSPF routing\n    OspfHelper ospfRouting;\n    Ipv4ListRoutingHelper listRouting;\n    listRouting.Add(ospfRouting, 10);\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(listRouting);\n\n    // Install on all nodes\n    internet.Install(ringNodes);\n    internet.Install(meshNodes);\n    internet.Install(busNodes);\n    internet.Install(lineNodes);\n    internet.Install(starNodes);\n    internet.Install(treeNodes);\n\n    // Set up IP addressing\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfaces;\n\n    // --------- Ring Topology ---------\n    NetDeviceContainer ringDevices;\n    for (uint32_t i = 0; i < ringNodes.GetN(); ++i)\n    {\n        ringDevices = p2p.Install(ringNodes.Get(i), ringNodes.Get((i + 1) % ringNodes.GetN()));\n        address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n        interfaces.Add(address.Assign(ringDevices));\n    }\n\n    // --------- Mesh Topology ---------\n    for (uint32_t i = 0; i < meshNodes.GetN(); ++i)\n    {\n        for (uint32_t j = i + 1; j < meshNodes.GetN(); ++j)\n        {\n            NetDeviceContainer meshDevices = p2p.Install(meshNodes.Get(i), meshNodes.Get(j));\n            address.SetBase(\"10.2.1.0\", \"255.255.255.0\");\n            interfaces.Add(address.Assign(meshDevices));\n        }\n    }\n\n    // --------- Bus Topology ---------\n    NetDeviceContainer busDevices;\n    for (uint32_t i = 0; i < busNodes.GetN() - 1; ++i)\n    {\n        busDevices = p2p.Install(busNodes.Get(i), busNodes.Get(i + 1));\n        address.SetBase(\"10.3.1.0\", \"255.255.255.0\");\n        interfaces.Add(address.Assign(busDevices));\n    }\n\n    // --------- Line Topology ---------\n    NetDeviceContainer lineDevices = p2p.Install(lineNodes.Get(0), lineNodes.Get(1));\n    address.SetBase(\"10.4.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(lineDevices));\n\n    // --------- Star Topology ---------\n    NetDeviceContainer starDevices;\n    for (uint32_t i = 1; i < starNodes.GetN(); ++i)\n    {\n        starDevices = p2p.Install(starNodes.Get(0), starNodes.Get(i));  // Central node is starNodes.Get(0)\n        address.SetBase(\"10.5.1.0\", \"255.255.255.0\");\n        interfaces.Add(address.Assign(starDevices));\n    }\n\n    // --------- Tree Topology ---------\n    // Connecting nodes in a basic binary tree fashion\n    NetDeviceContainer treeDevices;\n    treeDevices = p2p.Install(treeNodes.Get(0), treeNodes.Get(1));  // Root to left child\n    address.SetBase(\"10.6.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(treeDevices));\n\n    treeDevices = p2p.Install(treeNodes.Get(0), treeNodes.Get(2));  // Root to right child\n    address.SetBase(\"10.7.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(treeDevices));\n\n    treeDevices = p2p.Install(treeNodes.Get(1), treeNodes.Get(3));  // Left child to left grandchild\n    address.SetBase(\"10.8.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(treeDevices));\n\n    treeDevices = p2p.Install(treeNodes.Get(1), treeNodes.Get(4));  // Left child to right grandchild\n    address.SetBase(\"10.9.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(treeDevices));\n\n    treeDevices = p2p.Install(treeNodes.Get(2), treeNodes.Get(5));  // Right child to left grandchild\n    address.SetBase(\"10.10.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(treeDevices));\n\n    treeDevices = p2p.Install(treeNodes.Get(2), treeNodes.Get(6));  // Right child to right grandchild\n    address.SetBase(\"10.11.1.0\", \"255.255.255.0\");\n    interfaces.Add(address.Assign(treeDevices));\n\n    // Populate routing tables using OSPF\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Set up traffic flow\n    uint16_t port = 50000;\n    OnOffHelper onOffHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(2), port));\n    onOffHelper.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    onOffHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = onOffHelper.Install(ringNodes.Get(0)); // Traffic from ringNode 0 to meshNode\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sinkHelper.Install(meshNodes.Get(0));\n    sinkApp.Start(Seconds(0.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Set up NetAnim\n    AnimationInterface anim(\"hybrid_topology_with_netanim.xml\");\n\n    // Set constant positions for better visualization in NetAnim\n    anim.SetConstantPosition(ringNodes.Get(0), 10, 10);\n    anim.SetConstantPosition(ringNodes.Get(1), 30, 10);\n    anim.SetConstantPosition(ringNodes.Get(2), 50, 10);\n    anim.SetConstantPosition(ringNodes.Get(3), 70, 10);\n\n    anim.SetConstantPosition(meshNodes.Get(0), 10, 30);\n    anim.SetConstantPosition(meshNodes.Get(1), 30, 30);\n    anim.SetConstantPosition(meshNodes.Get(2), 50, 30);\n    anim.SetConstantPosition(meshNodes.Get(3), 70, 30);\n\n    anim.SetConstantPosition(busNodes.Get(0), 10, 50);\n    anim.SetConstantPosition(busNodes.Get(1), 30, 50);\n    anim.SetConstantPosition(busNodes.Get(2), 50, 50);\n\n    anim.SetConstantPosition(lineNodes.Get(0), 10, 70);\n    anim.SetConstantPosition(lineNodes.Get(1), 30, 70);\n\n    anim.SetConstantPosition(starNodes.Get(0), 50, 70);  // Central node of star\n    anim.SetConstantPosition(starNodes.Get(1), 70, 70);\n    anim.SetConstantPosition(starNodes.Get(2), 70, 90);\n    anim.SetConstantPosition(starNodes.Get(3), 50, 90);\n\n    anim.SetConstantPosition(treeNodes.Get(0), 50, 50);  // Root of tree\n    anim.SetConstantPosition(treeNodes.Get(1), 70, 50);\n    anim.SetConstantPosition(treeNodes.Get(2), 50, 30);\n    anim.SetConstantPosition(treeNodes.Get(3), 70, 30);\n    anim.SetConstantPosition(treeNodes.Get(4), 50, 10);\n    anim.SetConstantPosition(treeNodes.Get(5), 70, 10);\n    anim.SetConstantPosition(treeNodes.Get(6), 90, 10);\n\n    anim.EnablePacketMetadata(true);\n\n    // Run simulation\n    Simulator::Stop(Seconds(12.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that demonstrates a wireless network with Wi-Fi communication between three nodes. One node acts as a Wi-Fi access point (AP), while the other two are Wi-Fi stations (STA) communicating through the AP. The simulation will include the setup of Wi-Fi standards, Internet stack installation, and enable NetAnim visualization to capture the network behavior and packet exchanges."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiNetAnimExample\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"WifiNetAnimExample\", LOG_LEVEL_INFO);\n\n    // Configure the default Wi-Fi standard\n    std::string phyMode(\"DsssRate1Mbps\");\n    double simulationTime = 10.0; // Simulation time in seconds\n\n    // Create 3 nodes: 1 Access Point (AP) and 2 Stations (STAs)\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Set up the Wi-Fi PHY and MAC layers\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\", \"DataMode\", StringValue(phyMode), \"ControlMode\", StringValue(phyMode));\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Set up STA MAC and devices\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Set up AP MAC and devices\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Configure mobility for the nodes\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Set up UDP echo server on the AP node\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Set up UDP echo client on one STA node\n    UdpEchoClientHelper echoClient(apInterface.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(wifiStaNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Set up NetAnim for visualization\n    AnimationInterface anim(\"wifi_netanim.xml\");\n\n    // Set constant positions for NetAnim visualization\n    anim.SetConstantPosition(wifiStaNodes.Get(0), 0, 0);  // STA 1\n    anim.SetConstantPosition(wifiStaNodes.Get(1), 5, 0);  // STA 2\n    anim.SetConstantPosition(wifiApNode.Get(0), 2.5, 5);  // AP\n\n    // Enable packet metadata in NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that demonstrates packet loss in a simple wired network with two nodes connected via a point-to-point link. The simulation should send packets using a UDP application, where packet loss occurs due to a rate-limiting queue. The example should also include NetAnim for visualizing packet transmissions and losses in the network."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/traffic-control-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PacketLossExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set up logging\n    LogComponentEnable(\"PacketLossExample\", LOG_LEVEL_INFO);\n\n    // Simulation time\n    double simulationTime = 5.0; // seconds\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Create a point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"2Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    // Install net devices on both nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the internet stack on both nodes\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a traffic control helper with a queue to simulate packet loss\n    TrafficControlHelper tch;\n    tch.SetRootQueueDisc(\"ns3::RedQueueDisc\"); // Use Random Early Detection (RED) queue for packet loss\n    tch.Install(devices);\n\n    // Create a UDP server application on Node 1\n    uint16_t port = 9; // Port number\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Create a UDP client application on Node 0\n    UdpClientHelper client(interfaces.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    client.SetAttribute(\"Interval\", TimeValue(Seconds(0.05))); // 50 ms interval between packets\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));    // 1024 bytes per packet\n\n    ApplicationContainer clientApp = client.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Set up NetAnim for visualization\n    AnimationInterface anim(\"packet_loss_netanim.xml\");\n\n    // Set constant positions for NetAnim visualization\n    anim.SetConstantPosition(nodes.Get(0), 0, 0); // Node 0 (Sender)\n    anim.SetConstantPosition(nodes.Get(1), 5, 0); // Node 1 (Receiver)\n\n    // Enable packet metadata in NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation that demonstrates network congestion control using TCP with Reno and Cubic variants in a bottleneck network. The simulation should include three nodes connected in a dumbbell topology, where two TCP flows share a bottleneck link, causing congestion. It should also generate a NetAnim visualization to show packet transmissions and congestion points."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpCongestionControlExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set up logging\n    LogComponentEnable(\"TcpCongestionControlExample\", LOG_LEVEL_INFO);\n\n    // Simulation time\n    double simulationTime = 10.0; // seconds\n\n    // Create nodes for the dumbbell topology\n    NodeContainer leftNodes, rightNodes, routerNodes;\n    leftNodes.Create(2);   // Two TCP sources\n    rightNodes.Create(2);  // Two TCP sinks\n    routerNodes.Create(2); // Routers (bottleneck)\n\n    // Create point-to-point link helpers\n    PointToPointHelper pointToPointLeft, pointToPointRight, pointToPointRouter;\n    pointToPointLeft.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPointLeft.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    pointToPointRight.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPointRight.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    pointToPointRouter.SetDeviceAttribute(\"DataRate\", StringValue(\"2Mbps\")); // Bottleneck link\n    pointToPointRouter.SetChannelAttribute(\"Delay\", StringValue(\"20ms\"));\n\n    // Install devices on the nodes\n    NetDeviceContainer leftDevices1 = pointToPointLeft.Install(leftNodes.Get(0), routerNodes.Get(0));\n    NetDeviceContainer leftDevices2 = pointToPointLeft.Install(leftNodes.Get(1), routerNodes.Get(0));\n\n    NetDeviceContainer rightDevices1 = pointToPointRight.Install(rightNodes.Get(0), routerNodes.Get(1));\n    NetDeviceContainer rightDevices2 = pointToPointRight.Install(rightNodes.Get(1), routerNodes.Get(1));\n\n    NetDeviceContainer routerDevices = pointToPointRouter.Install(routerNodes);\n\n    // Install internet stack on all nodes\n    InternetStackHelper internet;\n    internet.Install(leftNodes);\n    internet.Install(rightNodes);\n    internet.Install(routerNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer leftInterfaces1 = ipv4.Assign(leftDevices1);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer leftInterfaces2 = ipv4.Assign(leftDevices2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer rightInterfaces1 = ipv4.Assign(rightDevices1);\n\n    ipv4.SetBase(\"10.1.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer rightInterfaces2 = ipv4.Assign(rightDevices2);\n\n    ipv4.SetBase(\"10.1.5.0\", \"255.255.255.0\");\n    ipv4.Assign(routerDevices);\n\n    // Set up TCP applications\n    uint16_t port = 8080;\n    Address sinkAddress1(InetSocketAddress(rightInterfaces1.GetAddress(0), port));\n    PacketSinkHelper sinkHelper1(\"ns3::TcpSocketFactory\", sinkAddress1);\n    ApplicationContainer sinkApp1 = sinkHelper1.Install(rightNodes.Get(0));\n\n    Address sinkAddress2(InetSocketAddress(rightInterfaces2.GetAddress(0), port));\n    PacketSinkHelper sinkHelper2(\"ns3::TcpSocketFactory\", sinkAddress2);\n    ApplicationContainer sinkApp2 = sinkHelper2.Install(rightNodes.Get(1));\n\n    sinkApp1.Start(Seconds(0.0));\n    sinkApp1.Stop(Seconds(simulationTime));\n    sinkApp2.Start(Seconds(0.0));\n    sinkApp2.Stop(Seconds(simulationTime));\n\n    // Set TCP socket types for the flows\n    TypeId tcpRenoTypeId = TypeId::LookupByName(\"ns3::TcpReno\");\n    TypeId tcpCubicTypeId = TypeId::LookupByName(\"ns3::TcpCubic\");\n\n    // Create TCP flow 1 using TCP Reno\n    Ptr<Socket> tcpRenoSocket = Socket::CreateSocket(leftNodes.Get(0), tcpRenoTypeId);\n    Ptr<TcpSocketBase> tcpReno = DynamicCast<TcpSocketBase>(tcpRenoSocket);\n    tcpReno->Bind();\n    tcpReno->Connect(sinkAddress1);\n\n    // Create TCP flow 2 using TCP Cubic\n    Ptr<Socket> tcpCubicSocket = Socket::CreateSocket(leftNodes.Get(1), tcpCubicTypeId);\n    Ptr<TcpSocketBase> tcpCubic = DynamicCast<TcpSocketBase>(tcpCubicSocket);\n    tcpCubic->Bind();\n    tcpCubic->Connect(sinkAddress2);\n\n    // Set up the on-off application to simulate traffic generation\n    OnOffHelper onOffTcpReno(\"ns3::TcpSocketFactory\", sinkAddress1);\n    onOffTcpReno.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffTcpReno.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    onOffTcpReno.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    onOffTcpReno.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer tcpRenoApp = onOffTcpReno.Install(leftNodes.Get(0));\n    tcpRenoApp.Start(Seconds(1.0));\n    tcpRenoApp.Stop(Seconds(simulationTime));\n\n    OnOffHelper onOffTcpCubic(\"ns3::TcpSocketFactory\", sinkAddress2);\n    onOffTcpCubic.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffTcpCubic.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    onOffTcpCubic.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    onOffTcpCubic.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer tcpCubicApp = onOffTcpCubic.Install(leftNodes.Get(1));\n    tcpCubicApp.Start(Seconds(1.0));\n    tcpCubicApp.Stop(Seconds(simulationTime));\n\n    // Set up NetAnim for visualization\n    AnimationInterface anim(\"tcp_congestion_control_netanim.xml\");\n\n    // Set constant positions for NetAnim visualization\n    anim.SetConstantPosition(leftNodes.Get(0), 1.0, 2.0);  // TCP Reno source\n    anim.SetConstantPosition(leftNodes.Get(1), 1.0, 3.0);  // TCP Cubic source\n    anim.SetConstantPosition(rightNodes.Get(0), 3.0, 2.0); // TCP Reno sink\n    anim.SetConstantPosition(rightNodes.Get(1), 3.0, 3.0); // TCP Cubic sink\n    anim.SetConstantPosition(routerNodes.Get(0), 2.0, 2.5); // Router 1\n    anim.SetConstantPosition(routerNodes.Get(1), 2.0, 3.5); // Router 2\n\n    // Enable packet metadata in NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation demonstrating Wi-Fi communication between two nodes using the 802.11n standard in Ad-hoc mode. The simulation should include a UDP client-server application for testing data transmission, and it should generate a NetAnim visualization to display packet exchanges between the nodes."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiAdhocExample\");\n\nint main(int argc, char *argv[])\n{\n    // Simulation time\n    double simulationTime = 10.0; // seconds\n\n    // Create two nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Set up Wi-Fi and PHY layers for the nodes\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);  // Use the 802.11n standard (5 GHz)\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Use Ad-hoc mode (no infrastructure like APs)\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, wifiNodes);\n\n    // Install internet stack on the nodes\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set mobility model for the nodes (placing them in fixed positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Set up UDP server on Node 1\n    uint16_t port = 9;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Set up UDP client on Node 0 to send packets to Node 1\n    UdpClientHelper client(interfaces.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    client.SetAttribute(\"Interval\", TimeValue(Seconds(0.05))); // 20 packets per second\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024)); // 1024 bytes per packet\n\n    ApplicationContainer clientApp = client.Install(wifiNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Set up NetAnim for visualization\n    AnimationInterface anim(\"wifi_adhoc_netanim.xml\");\n\n    // Set constant positions for NetAnim visualization\n    anim.SetConstantPosition(wifiNodes.Get(0), 1.0, 1.0);  // Client node\n    anim.SetConstantPosition(wifiNodes.Get(1), 5.0, 1.0);  // Server node\n\n    // Enable packet metadata in NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation of a wired network using a Point-to-Point (P2P) connection between two nodes. The simulation should involve the TCP NewReno congestion control algorithm and use a BulkSendApplication to generate large data transfers. Visualize the traffic using NetAnim and display packet exchanges between the nodes."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpNewRenoExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set TCP NewReno as the default congestion control algorithm\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\", StringValue(\"ns3::TcpNewReno\"));\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP sink at node 1 (server)\n    uint16_t port = 9;\n    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", localAddress);\n    ApplicationContainer sinkApp = sink.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(0.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Create a BulkSendApplication at node 0 (client) to send large amounts of data\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    source.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n    ApplicationContainer sourceApp = source.Install(nodes.Get(0));\n    sourceApp.Start(Seconds(1.0));\n    sourceApp.Stop(Seconds(10.0));\n\n    // Set up NetAnim for visualization\n    AnimationInterface anim(\"tcp_newreno_netanim.xml\");\n\n    // Assign positions to the nodes in NetAnim\n    anim.SetConstantPosition(nodes.Get(0), 1.0, 2.0);  // Node 0 (client)\n    anim.SetConstantPosition(nodes.Get(1), 5.0, 2.0);  // Node 1 (server)\n\n    // Enable packet metadata in NetAnim for visualization\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a code in NS-3 that simulates a wireless network using WifiHelper and MobilityHelper where two stations (stas) communicate with an access point (ap). Install packet socket capabilities on the nodes, configure the wifi settings with StaWifiMac for stations and ApWifiMac for the access point using the same SSID, and set up mobility for both stations and the access point. Include tracing for MAC and PHY-level events such as TX, RX, PHY RX OK, PHY RX error, and state transitions, and use a helper function to move the access point along the x-axis by 5 meters every second. The stations should communicate with a data rate of 500kbps, and the simulation should run for 44 seconds, starting the communication after 0.5 seconds."}, {"role": "assistant", "content": "#include \"ns3/athstats-helper.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-socket-address.h\"\n#include \"ns3/packet-socket-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\n/// True for verbose output.\nstatic bool g_verbose = true;\n\n/**\n * MAC-level TX trace.\n *\n * \\param context The context.\n * \\param p The packet.\n */\nvoid\nDevTxTrace(std::string context, Ptr<const Packet> p)\n{\n    if (g_verbose)\n    {\n        std::cout << \" TX p: \" << *p << std::endl;\n    }\n}\n\n/**\n * MAC-level RX trace.\n *\n * \\param context The context.\n * \\param p The packet.\n */\nvoid\nDevRxTrace(std::string context, Ptr<const Packet> p)\n{\n    if (g_verbose)\n    {\n        std::cout << \" RX p: \" << *p << std::endl;\n    }\n}\n\n/**\n * PHY-level RX OK trace\n *\n * \\param context The context.\n * \\param packet The packet.\n * \\param snr The SNR.\n * \\param mode The wifi mode.\n * \\param preamble The preamble.\n */\nvoid\nPhyRxOkTrace(std::string context,\n             Ptr<const Packet> packet,\n             double snr,\n             WifiMode mode,\n             WifiPreamble preamble)\n{\n    if (g_verbose)\n    {\n        std::cout << \"PHYRXOK mode=\" << mode << \" snr=\" << snr << \" \" << *packet << std::endl;\n    }\n}\n\n/**\n * PHY-level RX error trace\n *\n * \\param context The context.\n * \\param packet The packet.\n * \\param snr The SNR.\n */\nvoid\nPhyRxErrorTrace(std::string context, Ptr<const Packet> packet, double snr)\n{\n    if (g_verbose)\n    {\n        std::cout << \"PHYRXERROR snr=\" << snr << \" \" << *packet << std::endl;\n    }\n}\n\n/**\n * PHY-level TX trace.\n *\n * \\param context The context.\n * \\param packet The packet.\n * \\param mode The wifi mode.\n * \\param preamble The preamble.\n * \\param txPower The TX power.\n */\nvoid\nPhyTxTrace(std::string context,\n           Ptr<const Packet> packet,\n           WifiMode mode,\n           WifiPreamble preamble,\n           uint8_t txPower)\n{\n    if (g_verbose)\n    {\n        std::cout << \"PHYTX mode=\" << mode << \" \" << *packet << std::endl;\n    }\n}\n\n/**\n * PHY state trace.\n *\n * \\param context The context.\n * \\param start Start time of the state.\n * \\param duration Duration of the state.\n * \\param state The state.\n */\nvoid\nPhyStateTrace(std::string context, Time start, Time duration, WifiPhyState state)\n{\n    if (g_verbose)\n    {\n        std::cout << \" state=\" << state << \" start=\" << start << \" duration=\" << duration\n                  << std::endl;\n    }\n}\n\n/**\n * Move a node position by 5m on the x axis every second, up to 210m.\n *\n * \\param node The node.\n */\nstatic void\nAdvancePosition(Ptr<Node> node)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    Vector pos = mobility->GetPosition();\n    pos.x += 5.0;\n    if (pos.x >= 210.0)\n    {\n        return;\n    }\n    mobility->SetPosition(pos);\n\n    Simulator::Schedule(Seconds(1.0), &AdvancePosition, node);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"Print trace information if true\", g_verbose);\n    cmd.Parse(argc, argv);\n\n    Packet::EnablePrinting();\n\n    WifiHelper wifi;\n    MobilityHelper mobility;\n    NodeContainer stas;\n    NodeContainer ap;\n    NetDeviceContainer staDevs;\n    PacketSocketHelper packetSocket;\n\n    stas.Create(2);\n    ap.Create(1);\n\n    // give packet socket powers to nodes.\n    packetSocket.Install(stas);\n    packetSocket.Install(ap);\n\n    WifiMacHelper wifiMac;\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n    Ssid ssid = Ssid(\"wifi-default\");\n    // setup stas.\n    wifiMac.SetType(\"ns3::StaWifiMac\",\n                    \"ActiveProbing\",\n                    BooleanValue(true),\n                    \"Ssid\",\n                    SsidValue(ssid));\n    staDevs = wifi.Install(wifiPhy, wifiMac, stas);\n    // setup ap.\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    wifi.Install(wifiPhy, wifiMac, ap);\n\n    // mobility.\n    mobility.Install(stas);\n    mobility.Install(ap);\n\n    Simulator::Schedule(Seconds(1.0), &AdvancePosition, ap.Get(0));\n\n    PacketSocketAddress socket;\n    socket.SetSingleDevice(staDevs.Get(0)->GetIfIndex());\n    socket.SetPhysicalAddress(staDevs.Get(1)->GetAddress());\n    socket.SetProtocol(1);\n\n    OnOffHelper onoff(\"ns3::PacketSocketFactory\", Address(socket));\n    onoff.SetConstantRate(DataRate(\"500kb/s\"));\n\n    ApplicationContainer apps = onoff.Install(stas.Get(0));\n    apps.Start(Seconds(0.5));\n    apps.Stop(Seconds(43.0));\n\n    Simulator::Stop(Seconds(44.0));\n\n    Config::Connect(\"/NodeList/*/DeviceList/*/Mac/MacTx\", MakeCallback(&DevTxTrace));\n    Config::Connect(\"/NodeList/*/DeviceList/*/Mac/MacRx\", MakeCallback(&DevRxTrace));\n    Config::Connect(\"/NodeList/*/DeviceList/*/Phy/State/RxOk\", MakeCallback(&PhyRxOkTrace));\n    Config::Connect(\"/NodeList/*/DeviceList/*/Phy/State/RxError\", MakeCallback(&PhyRxErrorTrace));\n    Config::Connect(\"/NodeList/*/DeviceList/*/Phy/State/Tx\", MakeCallback(&PhyTxTrace));\n    Config::Connect(\"/NodeList/*/DeviceList/*/Phy/State/State\", MakeCallback(&PhyStateTrace));\n\n    AthstatsHelper athstats;\n    athstats.EnableAthstats(\"athstats-sta\", stas);\n    athstats.EnableAthstats(\"athstats-ap\", ap);\n\n    Simulator::Run();\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation of a wireless ad-hoc network with 3 nodes using the AODV routing protocol. Set up UDP communication between two nodes while the third node relays packets. Visualize the packet transmission and network topology using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/aodv-helper.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocAodvExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Set up Wi-Fi channel and physical layer\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Configure Wi-Fi with Ad-hoc mode\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Set up the AODV routing protocol\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install UDP server on node 1\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Install UDP client on node 0, sending packets to node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up NetAnim\n    AnimationInterface anim(\"aodv_netanim.xml\");\n\n    // Set positions for nodes in NetAnim\n    anim.SetConstantPosition(nodes.Get(0), 0.0, 0.0); // Node 0 (Client)\n    anim.SetConstantPosition(nodes.Get(1), 5.0, 5.0); // Node 1 (Server)\n    anim.SetConstantPosition(nodes.Get(2), 2.5, 2.5); // Node 2 (Relay)\n\n    // Enable packet metadata for detailed visualization in NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a VANET (Vehicular Ad-hoc Network) scenario using ns-3 with two vehicles communicating using DSRC/WAVE (Dedicated Short-Range Communication). Configure the vehicles to move along a straight path with constant speeds, exchange packets over UDP, and visualize the simulation using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/wave-helper.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"VANETExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time in seconds\n    double simulationTime = 10.0;\n    \n    // Create 2 nodes representing vehicles\n    NodeContainer vehicles;\n    vehicles.Create(2);\n\n    // Set up WAVE (802.11p) PHY and MAC for VANET\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    NqosWaveMacHelper wifiMac = NqosWaveMacHelper::Default();\n    Wifi80211pHelper waveHelper = Wifi80211pHelper::Default();\n    NetDeviceContainer devices = waveHelper.Install(wifiPhy, wifiMac, vehicles);\n\n    // Set mobility model for the vehicles\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(vehicles);\n\n    // Set initial positions and constant speeds for vehicles\n    Ptr<ConstantVelocityMobilityModel> mobility1 = vehicles.Get(0)->GetObject<ConstantVelocityMobilityModel>();\n    mobility1->SetPosition(Vector(0.0, 0.0, 0.0));\n    mobility1->SetVelocity(Vector(20.0, 0.0, 0.0)); // Vehicle 1 moves at 20 m/s\n\n    Ptr<ConstantVelocityMobilityModel> mobility2 = vehicles.Get(1)->GetObject<ConstantVelocityMobilityModel>();\n    mobility2->SetPosition(Vector(100.0, 0.0, 0.0));\n    mobility2->SetVelocity(Vector(20.0, 0.0, 0.0)); // Vehicle 2 moves at 20 m/s\n\n    // Install Internet stack on vehicles\n    InternetStackHelper internet;\n    internet.Install(vehicles);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Install UDP server on vehicle 1\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(vehicles.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Install UDP client on vehicle 2, sending packets to vehicle 1\n    UdpClientHelper udpClient(interfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(vehicles.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Set up NetAnim\n    AnimationInterface anim(\"vanet_netanim.xml\");\n\n    // Set positions for visualization in NetAnim\n    anim.SetConstantPosition(vehicles.Get(0), 0.0, 0.0);  // Vehicle 1\n    anim.SetConstantPosition(vehicles.Get(1), 100.0, 0.0); // Vehicle 2\n\n    // Enable packet metadata for NetAnim\n    anim.EnablePacketMetadata(true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a basic LTE network using ns-3 where two User Equipment (UE) nodes communicate through a single eNodeB (Base Station) using the LTE EPC (Evolved Packet Core). Configure the UEs to exchange data over TCP and visualize the results using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteSimulationExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set the simulation time\n    double simulationTime = 10.0;\n\n    // Create LTE nodes: 1 eNodeB (base station) and 2 UEs (User Equipments)\n    NodeContainer ueNodes;\n    ueNodes.Create(2);\n    NodeContainer enbNodes;\n    enbNodes.Create(1);\n\n    // Set up the LTE modules\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    // Create a remote host to act as the internet backbone\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // Set up a point-to-point link between the PGW and the remote host\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2p.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.01)));\n    NetDeviceContainer internetDevices = p2p.Install(pgw, remoteHost);\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetInterfaces = ipv4.Assign(internetDevices);\n\n    // Assign IP addresses to the remote host\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting = ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n\n    // Install LTE devices to UEs and eNodeB\n    NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueLteDevs = lteHelper->InstallUeDevice(ueNodes);\n\n    // Install IP stack on the UEs\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpInterfaces = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLteDevs));\n\n    // Attach UEs to the eNodeB\n    lteHelper->Attach(ueLteDevs, enbLteDevs.Get(0));\n\n    // Set mobility for UEs and eNodeB\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(enbNodes);\n    mobility.Install(ueNodes);\n\n    // Set positions for eNodeB and UEs\n    Ptr<ConstantPositionMobilityModel> enbMobility = enbNodes.Get(0)->GetObject<ConstantPositionMobilityModel>();\n    enbMobility->SetPosition(Vector(0.0, 0.0, 0.0)); // eNodeB at origin\n\n    Ptr<ConstantPositionMobilityModel> ueMobility1 = ueNodes.Get(0)->GetObject<ConstantPositionMobilityModel>();\n    ueMobility1->SetPosition(Vector(10.0, 0.0, 0.0)); // UE 1 at 10 meters away from eNodeB\n\n    Ptr<ConstantPositionMobilityModel> ueMobility2 = ueNodes.Get(1)->GetObject<ConstantPositionMobilityModel>();\n    ueMobility2->SetPosition(Vector(20.0, 0.0, 0.0)); // UE 2 at 20 meters away from eNodeB\n\n    // Set up applications to send and receive data\n    uint16_t dlPort = 1234;\n    OnOffHelper onoff(\"ns3::TcpSocketFactory\", Address(InetSocketAddress(ueIpInterfaces.GetAddress(1), dlPort)));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    onoff.SetAttribute(\"DataRate\", StringValue(\"50Mbps\"));\n    ApplicationContainer clientApps = onoff.Install(remoteHost);\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(simulationTime));\n\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", Address(InetSocketAddress(Ipv4Address::GetAny(), dlPort)));\n    ApplicationContainer serverApps = sink.Install(ueNodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(simulationTime));\n\n    // Enable NetAnim\n    AnimationInterface anim(\"lte_netanim.xml\");\n\n    // Set positions in NetAnim\n    anim.SetConstantPosition(enbNodes.Get(0), 0.0, 0.0);   // eNodeB at origin\n    anim.SetConstantPosition(ueNodes.Get(0), 10.0, 0.0);   // UE 1 at 10m\n    anim.SetConstantPosition(ueNodes.Get(1), 20.0, 0.0);   // UE 2 at 20m\n\n    anim.EnablePacketMetadata(true);  // Enable packet tracking in NetAnim\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network with 2 access points (APs) and 4 stations (STA) using ns-3. Configure the stations to connect to the nearest access point and exchange UDP traffic. Visualize the network and traffic flow using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimulationExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time\n    double simulationTime = 10.0;\n\n    // Create 2 access points and 4 stations (STAs)\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(4);\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(2);\n\n    // Configure the Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up Wi-Fi helper and configure for 802.11n standard\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n\n    WifiMacHelper mac;\n    Ssid ssid1 = Ssid(\"AP1\");\n    Ssid ssid2 = Ssid(\"AP2\");\n\n    // Install Wi-Fi devices on AP nodes (Access Points)\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid1));\n    NetDeviceContainer ap1Devices = wifi.Install(phy, mac, wifiApNodes.Get(0));\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid2));\n    NetDeviceContainer ap2Devices = wifi.Install(phy, mac, wifiApNodes.Get(1));\n\n    // Install Wi-Fi devices on STA nodes (Stations)\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid1));\n    NetDeviceContainer staDevices1 = wifi.Install(phy, mac, wifiStaNodes.Get(0));\n    staDevices1.Add(wifi.Install(phy, mac, wifiStaNodes.Get(1)));\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid2));\n    NetDeviceContainer staDevices2 = wifi.Install(phy, mac, wifiStaNodes.Get(2));\n    staDevices2.Add(wifi.Install(phy, mac, wifiStaNodes.Get(3)));\n\n    // Set up mobility model for APs (fixed)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNodes);\n\n    // Set up mobility for STAs (random)\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(wifiStaNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ap1Interfaces = address.Assign(ap1Devices);\n    Ipv4InterfaceContainer sta1Interfaces = address.Assign(staDevices1);\n\n    address.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ap2Interfaces = address.Assign(ap2Devices);\n    Ipv4InterfaceContainer sta2Interfaces = address.Assign(staDevices2);\n\n    // Create UDP traffic application\n    uint16_t port = 9; // Discard port\n    UdpEchoServerHelper echoServer(port);\n\n    // Install server on STA 1 and STA 3\n    ApplicationContainer serverApps = echoServer.Install(wifiStaNodes.Get(0));\n    serverApps.Add(echoServer.Install(wifiStaNodes.Get(2)));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(simulationTime));\n\n    // Install clients on STA 2 and STA 4 to send packets to STA 1 and STA 3\n    UdpEchoClientHelper echoClient(sta1Interfaces.GetAddress(0), port);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(wifiStaNodes.Get(1));\n    echoClient.SetAttribute(\"RemoteAddress\", AddressValue(sta2Interfaces.GetAddress(0)));\n    clientApps.Add(echoClient.Install(wifiStaNodes.Get(3)));\n\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(simulationTime));\n\n    // Enable NetAnim\n    AnimationInterface anim(\"wifi_netanim.xml\");\n\n    // Set positions for visualization\n    anim.SetConstantPosition(wifiApNodes.Get(0), 0, 0);    // AP1 at origin\n    anim.SetConstantPosition(wifiApNodes.Get(1), 10, 0);   // AP2 at (10,0)\n    anim.SetConstantPosition(wifiStaNodes.Get(0), -5, -5); // STA 1\n    anim.SetConstantPosition(wifiStaNodes.Get(1), 5, -5);  // STA 2\n    anim.SetConstantPosition(wifiStaNodes.Get(2), -5, 5);  // STA 3\n    anim.SetConstantPosition(wifiStaNodes.Get(3), 5, 5);   // STA 4\n\n    anim.EnablePacketMetadata(true); // Enable packet metadata for tracking\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple LTE network with one eNodeB and two UEs (User Equipment) using ns-3. Configure the UEs to send UDP traffic to a remote host via the LTE core network (PGW). Visualize the packet flow and network configuration using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteSimulationExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time\n    double simulationTime = 10.0;\n\n    // Create LTE Helper and EPC Helper for LTE core\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    // Create nodes: 1 eNodeB, 2 UEs (User Equipments), and 1 Remote Host\n    NodeContainer ueNodes;\n    ueNodes.Create(2);\n    NodeContainer enbNodes;\n    enbNodes.Create(1);\n\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n\n    // Create a remote host\n    NodeContainer remoteHostContainer;\n    remoteHostContainer.Create(1);\n    Ptr<Node> remoteHost = remoteHostContainer.Get(0);\n    InternetStackHelper internet;\n    internet.Install(remoteHostContainer);\n\n    // Configure the remote host to use a point-to-point link with the PGW (Packet Gateway)\n    PointToPointHelper p2ph;\n    p2ph.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"100Gb/s\")));\n    p2ph.SetChannelAttribute(\"Delay\", TimeValue(Seconds(0.01)));\n    NetDeviceContainer internetDevices = p2ph.Install(pgw, remoteHost);\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"1.0.0.0\", \"255.0.0.0\");\n    Ipv4InterfaceContainer internetIpIfaces = ipv4h.Assign(internetDevices);\n\n    Ipv4Address remoteHostAddr = internetIpIfaces.GetAddress(1);\n\n    // Set up the routing between UEs and the remote host\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> remoteHostStaticRouting = ipv4RoutingHelper.GetStaticRouting(remoteHost->GetObject<Ipv4>());\n    remoteHostStaticRouting->AddNetworkRouteTo(Ipv4Address(\"7.0.0.0\"), Ipv4Mask(\"255.0.0.0\"), 1);\n\n    // Install the LTE stack on UEs and eNodeB\n    NetDeviceContainer enbLteDevs = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueLteDevs = lteHelper->InstallUeDevice(ueNodes);\n\n    // Set up mobility model for eNodeB and UEs\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(enbNodes);\n    mobility.Install(ueNodes);\n\n    // Install the IP stack on UEs\n    internet.Install(ueNodes);\n    Ipv4InterfaceContainer ueIpIfaces = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLteDevs));\n\n    // Set up default gateways for UEs\n    for (uint32_t i = 0; i < ueNodes.GetN(); ++i)\n    {\n        Ptr<Ipv4StaticRouting> ueStaticRouting = ipv4RoutingHelper.GetStaticRouting(ueNodes.Get(i)->GetObject<Ipv4>());\n        ueStaticRouting->SetDefaultRoute(epcHelper->GetUeDefaultGatewayAddress(), 1);\n    }\n\n    // Attach UEs to the eNodeB\n    lteHelper->Attach(ueLteDevs, enbLteDevs.Get(0));\n\n    // Install UDP traffic applications on UEs\n    uint16_t dlPort = 1234;\n    uint16_t ulPort = 2000;\n\n    UdpClientHelper dlClient(remoteHostAddr, dlPort);\n    dlClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    dlClient.SetAttribute(\"MaxPackets\", UintegerValue(1000000));\n    dlClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps;\n    clientApps.Add(dlClient.Install(ueNodes.Get(0)));\n    clientApps.Add(dlClient.Install(ueNodes.Get(1)));\n\n    UdpServerHelper ulServer(ulPort);\n    ApplicationContainer serverApps = ulServer.Install(remoteHost);\n\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(simulationTime));\n\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(simulationTime));\n\n    // Enable NetAnim for visualization\n    AnimationInterface anim(\"lte_netanim.xml\");\n    anim.SetConstantPosition(enbNodes.Get(0), 50.0, 50.0); // eNodeB\n    anim.SetConstantPosition(ueNodes.Get(0), 60.0, 50.0);  // UE 1\n    anim.SetConstantPosition(ueNodes.Get(1), 70.0, 50.0);  // UE 2\n    anim.EnablePacketMetadata(true);                       // Enable packet tracking\n\n    // Run simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network with three Access Points (APs) and six stations (STA) using the ns-3 simulator. Distribute the stations across the APs and set up UDP traffic flows between the stations and a remote server. Visualize the network in NetAnim and include mobility for the stations to simulate movement between the access points."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimulationExample\");\n\nint main(int argc, char *argv[])\n{\n    double simulationTime = 10.0;\n\n    // Create nodes for Access Points (AP) and Stations (STA)\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(3); // 3 Access Points\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(6); // 6 Stations\n\n    // Create Wi-Fi Helper and configure the PHY and MAC layers\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n\n    YansWifiPhyHelper phyHelper = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channelHelper = YansWifiChannelHelper::Default();\n    phyHelper.SetChannel(channelHelper.Create());\n\n    WifiMacHelper macHelper;\n    Ssid ssid1 = Ssid(\"AP1-SSID\");\n    Ssid ssid2 = Ssid(\"AP2-SSID\");\n    Ssid ssid3 = Ssid(\"AP3-SSID\");\n\n    // Install Wi-Fi devices on the APs\n    NetDeviceContainer apDevices1, apDevices2, apDevices3;\n    macHelper.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid1));\n    apDevices1 = wifiHelper.Install(phyHelper, macHelper, wifiApNodes.Get(0));\n    \n    macHelper.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid2));\n    apDevices2 = wifiHelper.Install(phyHelper, macHelper, wifiApNodes.Get(1));\n    \n    macHelper.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid3));\n    apDevices3 = wifiHelper.Install(phyHelper, macHelper, wifiApNodes.Get(2));\n\n    // Install Wi-Fi devices on the STAs\n    NetDeviceContainer staDevices1, staDevices2, staDevices3;\n    macHelper.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid1));\n    staDevices1 = wifiHelper.Install(phyHelper, macHelper, wifiStaNodes.Get(0));\n    staDevices1.Add(wifiHelper.Install(phyHelper, macHelper, wifiStaNodes.Get(1)));\n\n    macHelper.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid2));\n    staDevices2 = wifiHelper.Install(phyHelper, macHelper, wifiStaNodes.Get(2));\n    staDevices2.Add(wifiHelper.Install(phyHelper, macHelper, wifiStaNodes.Get(3)));\n\n    macHelper.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid3));\n    staDevices3 = wifiHelper.Install(phyHelper, macHelper, wifiStaNodes.Get(4));\n    staDevices3.Add(wifiHelper.Install(phyHelper, macHelper, wifiStaNodes.Get(5)));\n\n    // Install mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNodes);\n    \n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(wifiStaNodes);\n\n    // Install Internet stack on all nodes\n    InternetStackHelper internet;\n    internet.Install(wifiApNodes);\n    internet.Install(wifiStaNodes);\n\n    // Assign IP addresses to all devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apInterfaces1 = ipv4.Assign(apDevices1);\n    Ipv4InterfaceContainer staInterfaces1 = ipv4.Assign(staDevices1);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apInterfaces2 = ipv4.Assign(apDevices2);\n    Ipv4InterfaceContainer staInterfaces2 = ipv4.Assign(staDevices2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apInterfaces3 = ipv4.Assign(apDevices3);\n    Ipv4InterfaceContainer staInterfaces3 = ipv4.Assign(staDevices3);\n\n    // Set up UDP server on one of the stations\n    uint16_t port = 9; // Discard port (just for testing)\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Set up UDP client to send traffic to the server\n    UdpClientHelper client(staInterfaces1.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    client.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = client.Install(wifiStaNodes.Get(5)); // Another station sends traffic\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Enable NetAnim tracing\n    AnimationInterface anim(\"wifi_netanim.xml\");\n    anim.SetConstantPosition(wifiApNodes.Get(0), 0.0, 0.0);\n    anim.SetConstantPosition(wifiApNodes.Get(1), 10.0, 0.0);\n    anim.SetConstantPosition(wifiApNodes.Get(2), 20.0, 0.0);\n    \n    // Run simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Vehicular Ad-Hoc Network (VANET) in ns-3 with 5 moving vehicles. Use the 802.11p (WAVE) standard for wireless communication between vehicles. Set up a scenario where vehicles exchange periodic messages (Basic Safety Messages - BSM) to simulate vehicle-to-vehicle (V2V) communication. Visualize the simulation using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wave-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"VANETExample\");\n\nclass BsmApplication : public Application\n{\npublic:\n    BsmApplication() {}\n    virtual ~BsmApplication() {}\n\nprotected:\n    virtual void StartApplication()\n    {\n        m_sendEvent = Simulator::Schedule(Seconds(1.0), &BsmApplication::SendBsm, this);\n    }\n\n    virtual void StopApplication()\n    {\n        Simulator::Cancel(m_sendEvent);\n    }\n\n    void SendBsm()\n    {\n        NS_LOG_INFO(\"Sending BSM (Basic Safety Message)\");\n        // Here we could add code to actually send a packet, but for now, it's just a log message\n        m_sendEvent = Simulator::Schedule(Seconds(1.0), &BsmApplication::SendBsm, this);\n    }\n\nprivate:\n    EventId m_sendEvent;\n};\n\nint main(int argc, char *argv[])\n{\n    // Create nodes for the vehicles\n    NodeContainer vehicleNodes;\n    vehicleNodes.Create(5); // 5 vehicles\n\n    // Set up the mobility model for vehicle movement\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n\n    // Position vehicles along a straight road\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(50.0),\n                                  \"GridWidth\", UintegerValue(5),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.Install(vehicleNodes);\n\n    // Set constant velocity for vehicles (50 m/s)\n    for (uint32_t i = 0; i < vehicleNodes.GetN(); ++i)\n    {\n        Ptr<ConstantVelocityMobilityModel> mobilityModel = vehicleNodes.Get(i)->GetObject<ConstantVelocityMobilityModel>();\n        mobilityModel->SetVelocity(Vector(50.0, 0.0, 0.0));\n    }\n\n    // Install Wave (802.11p) devices on vehicles\n    YansWifiPhyHelper wavePhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper waveChannel = YansWifiChannelHelper::Default();\n    wavePhy.SetChannel(waveChannel.Create());\n\n    NqosWaveMacHelper waveMac = NqosWaveMacHelper::Default();\n    Wifi80211pHelper waveHelper = Wifi80211pHelper::Default();\n\n    NetDeviceContainer vehicleDevices;\n    vehicleDevices = waveHelper.Install(wavePhy, waveMac, vehicleNodes);\n\n    // Install Internet stack on all vehicles\n    InternetStackHelper internet;\n    internet.Install(vehicleNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vehicleInterfaces = ipv4.Assign(vehicleDevices);\n\n    // Install BSM application on vehicles\n    for (uint32_t i = 0; i < vehicleNodes.GetN(); ++i)\n    {\n        Ptr<BsmApplication> app = CreateObject<BsmApplication>();\n        vehicleNodes.Get(i)->AddApplication(app);\n        app->SetStartTime(Seconds(1.0));\n        app->SetStopTime(Seconds(10.0));\n    }\n\n    // Enable NetAnim tracing\n    AnimationInterface anim(\"vanet_netanim.xml\");\n    anim.SetConstantPosition(vehicleNodes.Get(0), 0.0, 0.0);\n    anim.SetConstantPosition(vehicleNodes.Get(1), 50.0, 0.0);\n    anim.SetConstantPosition(vehicleNodes.Get(2), 100.0, 0.0);\n    anim.SetConstantPosition(vehicleNodes.Get(3), 150.0, 0.0);\n    anim.SetConstantPosition(vehicleNodes.Get(4), 200.0, 0.0);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a data center network in ns-3 using Fat-Tree topology. Create a scenario where servers send data to each other across the network using TCP connections. Simulate the transmission of traffic and observe the packet flow across different layers of the topology. Use NetAnim for visualization."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"FatTreeDataCenter\");\n\nint main(int argc, char *argv[])\n{\n    // Simulation parameters\n    uint32_t numServers = 4;\n    double simulationTime = 10.0; // seconds\n\n    // Create nodes\n    NodeContainer coreSwitch;\n    coreSwitch.Create(1); // Single core switch\n\n    NodeContainer aggregationSwitches;\n    aggregationSwitches.Create(2); // Two aggregation switches\n\n    NodeContainer edgeSwitches;\n    edgeSwitches.Create(2); // Two edge switches\n\n    NodeContainer servers;\n    servers.Create(numServers); // Four servers\n\n    // Point-to-Point link attributes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Gbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Connect core to aggregation switches\n    NetDeviceContainer coreToAggDevices;\n    coreToAggDevices.Add(pointToPoint.Install(coreSwitch.Get(0), aggregationSwitches.Get(0)));\n    coreToAggDevices.Add(pointToPoint.Install(coreSwitch.Get(0), aggregationSwitches.Get(1)));\n\n    // Connect aggregation switches to edge switches\n    NetDeviceContainer aggToEdgeDevices;\n    aggToEdgeDevices.Add(pointToPoint.Install(aggregationSwitches.Get(0), edgeSwitches.Get(0)));\n    aggToEdgeDevices.Add(pointToPoint.Install(aggregationSwitches.Get(0), edgeSwitches.Get(1)));\n    aggToEdgeDevices.Add(pointToPoint.Install(aggregationSwitches.Get(1), edgeSwitches.Get(0)));\n    aggToEdgeDevices.Add(pointToPoint.Install(aggregationSwitches.Get(1), edgeSwitches.Get(1)));\n\n    // Connect edge switches to servers\n    NetDeviceContainer edgeToServerDevices;\n    for (uint32_t i = 0; i < numServers / 2; ++i)\n    {\n        edgeToServerDevices.Add(pointToPoint.Install(edgeSwitches.Get(0), servers.Get(i)));\n        edgeToServerDevices.Add(pointToPoint.Install(edgeSwitches.Get(1), servers.Get(i + 2)));\n    }\n\n    // Install Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(coreSwitch);\n    stack.Install(aggregationSwitches);\n    stack.Install(edgeSwitches);\n    stack.Install(servers);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces;\n    interfaces.Add(ipv4.Assign(coreToAggDevices));\n    interfaces.Add(ipv4.Assign(aggToEdgeDevices));\n    interfaces.Add(ipv4.Assign(edgeToServerDevices));\n\n    // Install applications (TCP traffic)\n    uint16_t port = 9; // TCP port\n\n    // Create server applications\n    ApplicationContainer serverApps;\n    for (uint32_t i = 0; i < numServers; ++i)\n    {\n        Address serverAddress(InetSocketAddress(interfaces.GetAddress(i + 6), port));\n        PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n        serverApps.Add(packetSinkHelper.Install(servers.Get(i)));\n    }\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(simulationTime));\n\n    // Create client applications to generate TCP traffic\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < numServers; ++i)\n    {\n        OnOffHelper onoff(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(i + 6), port));\n        onoff.SetAttribute(\"DataRate\", StringValue(\"1Gbps\"));\n        onoff.SetAttribute(\"PacketSize\", UintegerValue(1024));\n        onoff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        onoff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n        clientApps.Add(onoff.Install(servers.Get((i + 1) % numServers)));\n    }\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(simulationTime));\n\n    // Enable NetAnim visualization\n    AnimationInterface anim(\"fat_tree_datacenter.xml\");\n    anim.SetConstantPosition(coreSwitch.Get(0), 50.0, 50.0);\n    anim.SetConstantPosition(aggregationSwitches.Get(0), 30.0, 30.0);\n    anim.SetConstantPosition(aggregationSwitches.Get(1), 70.0, 30.0);\n    anim.SetConstantPosition(edgeSwitches.Get(0), 20.0, 10.0);\n    anim.SetConstantPosition(edgeSwitches.Get(1), 80.0, 10.0);\n    anim.SetConstantPosition(servers.Get(0), 10.0, 0.0);\n    anim.SetConstantPosition(servers.Get(1), 30.0, 0.0);\n    anim.SetConstantPosition(servers.Get(2), 70.0, 0.0);\n    anim.SetConstantPosition(servers.Get(3), 90.0, 0.0);\n\n    // Run simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network in ns-3 where two stations (STA) are connected to an access point (AP). One station sends UDP packets to the other via the AP, and the performance metrics such as throughput and packet loss are measured. Use NetAnim to visualize the communication."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation parameters\n    double simulationTime = 10.0; // seconds\n\n    // Create nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2); // Two stations\n\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1); // One access point\n\n    // Setup Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Install UDP application\n    uint16_t port = 9; // UDP port\n\n    // Create UDP server on one of the stations\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiStaNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Create UDP client on the other station\n    UdpClientHelper udpClient(staInterfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05))); // 20 packets per second\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024)); // 1024 bytes per packet\n\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Enable NetAnim\n    AnimationInterface anim(\"wifi_network.xml\");\n    anim.SetConstantPosition(wifiApNode.Get(0), 50.0, 50.0); // AP position\n    anim.SetConstantPosition(wifiStaNodes.Get(0), 30.0, 30.0); // STA 1 position\n    anim.SetConstantPosition(wifiStaNodes.Get(1), 70.0, 30.0); // STA 2 position\n\n    // Run simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a CSMA (Carrier Sense Multiple Access) network in ns-3 with 4 nodes. The nodes will communicate over a shared medium with each node sending TCP traffic to a central server. Include packet loss, delay, and throughput metrics in the simulation, and visualize the communication using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CsmaNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation parameters\n    double simulationTime = 10.0; // seconds\n\n    // Create nodes\n    NodeContainer csmaNodes;\n    csmaNodes.Create(4); // 4 CSMA nodes\n\n    // Create the CSMA channel\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install the CSMA devices\n    NetDeviceContainer csmaDevices;\n    csmaDevices = csma.Install(csmaNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(csmaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer csmaInterfaces = address.Assign(csmaDevices);\n\n    // Install TCP application on each node to communicate with node 0 (central server)\n    uint16_t port = 9; // TCP port\n\n    // Create a packet sink on the first node (server)\n    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(csmaNodes.Get(0));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(simulationTime));\n\n    // Create TCP clients on the other nodes\n    for (uint32_t i = 1; i < csmaNodes.GetN(); ++i)\n    {\n        OnOffHelper onoff(\"ns3::TcpSocketFactory\", InetSocketAddress(csmaInterfaces.GetAddress(0), port));\n        onoff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        onoff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n        onoff.SetAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n        onoff.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n        ApplicationContainer clientApp = onoff.Install(csmaNodes.Get(i));\n        clientApp.Start(Seconds(2.0));\n        clientApp.Stop(Seconds(simulationTime));\n    }\n\n    // Enable NetAnim\n    AnimationInterface anim(\"csma_network.xml\");\n    anim.SetConstantPosition(csmaNodes.Get(0), 10.0, 20.0); // Server\n    anim.SetConstantPosition(csmaNodes.Get(1), 20.0, 40.0); // Client 1\n    anim.SetConstantPosition(csmaNodes.Get(2), 30.0, 40.0); // Client 2\n    anim.SetConstantPosition(csmaNodes.Get(3), 40.0, 40.0); // Client 3\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 code that simulates a Wi-Fi network with backward compatibility between different 802.11 versions, where the access point (AP) and station (STA) use different Wi-Fi standards. Include a function that converts Wi-Fi version strings like \"80211a\" or \"80211ac\" into a corresponding Wi-Fi standard and physical band. Configure the AP and STA to use separate Wi-Fi standards, assign rate adaptation algorithms, and set up traffic generation from either the AP, STA, or both. The simulation should output the throughput and include node mobility, IP addressing, UDP server and client setup, and global routing table population."}, {"role": "assistant", "content": "#include \"ns3/attribute-container.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/tuple.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This is an example to show how to configure an IEEE 802.11 Wi-Fi\n// network where the AP and the station use different 802.11 standards.\n//\n// It outputs the throughput for a given configuration: user can specify\n// the 802.11 versions for the AP and the station as well as their rate\n// adaptation algorithms. It also allows to decide whether the station,\n// the AP or both has/have traffic to send.\n//\n// Example for an IEEE 802.11ac station sending traffic to an 802.11a AP using Ideal rate adaptation\n// algorithm:\n// ./ns3 run \"wifi-backward-compatibility --apVersion=80211a --staVersion=80211ac --staRaa=Ideal\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"wifi-backward-compatibility\");\n\n/**\n * Convert a string (e.g., \"80211a\") to a pair {WifiStandard, WifiPhyBand}\n *\n * \\param version The WiFi standard version.\n * \\return a pair of WifiStandard, WifiPhyBand\n */\nstd::pair<WifiStandard, WifiPhyBand>\nConvertStringToStandardAndBand(std::string version)\n{\n    WifiStandard standard = WIFI_STANDARD_80211a;\n    WifiPhyBand band = WIFI_PHY_BAND_5GHZ;\n    if (version == \"80211a\")\n    {\n        standard = WIFI_STANDARD_80211a;\n        band = WIFI_PHY_BAND_5GHZ;\n    }\n    else if (version == \"80211b\")\n    {\n        standard = WIFI_STANDARD_80211b;\n        band = WIFI_PHY_BAND_2_4GHZ;\n    }\n    else if (version == \"80211g\")\n    {\n        standard = WIFI_STANDARD_80211g;\n        band = WIFI_PHY_BAND_2_4GHZ;\n    }\n    else if (version == \"80211p\")\n    {\n        standard = WIFI_STANDARD_80211p;\n        band = WIFI_PHY_BAND_5GHZ;\n    }\n    else if (version == \"80211n_2_4GHZ\")\n    {\n        standard = WIFI_STANDARD_80211n;\n        band = WIFI_PHY_BAND_2_4GHZ;\n    }\n    else if (version == \"80211n_5GHZ\")\n    {\n        standard = WIFI_STANDARD_80211n;\n        band = WIFI_PHY_BAND_5GHZ;\n    }\n    else if (version == \"80211ac\")\n    {\n        standard = WIFI_STANDARD_80211ac;\n        band = WIFI_PHY_BAND_5GHZ;\n    }\n    else if (version == \"80211ax_2_4GHZ\")\n    {\n        standard = WIFI_STANDARD_80211ax;\n        band = WIFI_PHY_BAND_2_4GHZ;\n    }\n    else if (version == \"80211ax_5GHZ\")\n    {\n        standard = WIFI_STANDARD_80211ax;\n        band = WIFI_PHY_BAND_5GHZ;\n    }\n    return {standard, band};\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t payloadSize{1472}; // bytes\n    Time simulationTime{\"10s\"};\n    std::string apVersion{\"80211a\"};\n    std::string staVersion{\"80211n_5GHZ\"};\n    std::string apRaa{\"Minstrel\"};\n    std::string staRaa{\"MinstrelHt\"};\n    bool apHasTraffic{false};\n    bool staHasTraffic{true};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"apVersion\",\n                 \"The standard version used by the AP: 80211a, 80211b, 80211g, 80211p, \"\n                 \"80211n_2_4GHZ, 80211n_5GHZ, 80211ac, 80211ax_2_4GHZ or 80211ax_5GHZ\",\n                 apVersion);\n    cmd.AddValue(\"staVersion\",\n                 \"The standard version used by the station: 80211a, 80211b, 80211g, 80211_10MHZ, \"\n                 \"80211_5MHZ, 80211n_2_4GHZ, 80211n_5GHZ, 80211ac, 80211ax_2_4GHZ or 80211ax_5GHZ\",\n                 staVersion);\n    cmd.AddValue(\"apRaa\", \"Rate adaptation algorithm used by the AP\", apRaa);\n    cmd.AddValue(\"staRaa\", \"Rate adaptation algorithm used by the station\", staRaa);\n    cmd.AddValue(\"apHasTraffic\", \"Enable/disable traffic on the AP\", apHasTraffic);\n    cmd.AddValue(\"staHasTraffic\", \"Enable/disable traffic on the station\", staHasTraffic);\n    cmd.Parse(argc, argv);\n\n    NodeContainer wifiStaNode;\n    wifiStaNode.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    WifiHelper wifi;\n    Ssid ssid = Ssid(\"ns3\");\n    AttributeContainerValue<\n        TupleValue<UintegerValue, UintegerValue, EnumValue<WifiPhyBand>, UintegerValue>,\n        ';'>\n        channelValue;\n\n    const auto& [staStandard, staBand] = ConvertStringToStandardAndBand(staVersion);\n    wifi.SetStandard(staStandard);\n    wifi.SetRemoteStationManager(\"ns3::\" + staRaa + \"WifiManager\");\n\n    mac.SetType(\"ns3::StaWifiMac\", \"QosSupported\", BooleanValue(true), \"Ssid\", SsidValue(ssid));\n\n    // Workaround needed as long as we do not fully support channel bonding\n    uint16_t width = (staVersion == \"80211ac\" ? 20 : 0);\n    channelValue.Set(WifiPhy::ChannelSegments{{0, width, staBand, 0}});\n    phy.Set(\"ChannelSettings\", channelValue);\n\n    NetDeviceContainer staDevice;\n    staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n    const auto& [apStandard, apBand] = ConvertStringToStandardAndBand(apVersion);\n    wifi.SetStandard(apStandard);\n    wifi.SetRemoteStationManager(\"ns3::\" + apRaa + \"WifiManager\");\n\n    mac.SetType(\"ns3::ApWifiMac\", \"QosSupported\", BooleanValue(true), \"Ssid\", SsidValue(ssid));\n\n    // Workaround needed as long as we do not fully support channel bonding\n    width = (apVersion == \"80211ac\" ? 20 : 0);\n    channelValue.Set(WifiPhy::ChannelSegments{{0, width, apBand, 0}});\n    phy.Set(\"ChannelSettings\", channelValue);\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNode);\n\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNode);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staNodeInterface;\n    Ipv4InterfaceContainer apNodeInterface;\n\n    staNodeInterface = address.Assign(staDevice);\n    apNodeInterface = address.Assign(apDevice);\n\n    UdpServerHelper apServer(9);\n    ApplicationContainer apServerApp = apServer.Install(wifiApNode.Get(0));\n    apServerApp.Start(Seconds(0.0));\n    apServerApp.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper staServer(5001);\n    ApplicationContainer staServerApp = staServer.Install(wifiStaNode.Get(0));\n    staServerApp.Start(Seconds(0.0));\n    staServerApp.Stop(simulationTime + Seconds(1.0));\n\n    if (apHasTraffic)\n    {\n        UdpClientHelper apClient(staNodeInterface.GetAddress(0), 5001);\n        apClient.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n        apClient.SetAttribute(\"Interval\", TimeValue(Time(\"0.00001\")));   // packets/s\n        apClient.SetAttribute(\"PacketSize\", UintegerValue(payloadSize)); // bytes\n        ApplicationContainer apClientApp = apClient.Install(wifiApNode.Get(0));\n        apClientApp.Start(Seconds(1.0));\n        apClientApp.Stop(simulationTime + Seconds(1.0));\n    }\n\n    if (staHasTraffic)\n    {\n        UdpClientHelper staClient(apNodeInterface.GetAddress(0), 9);\n        staClient.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n        staClient.SetAttribute(\"Interval\", TimeValue(Time(\"0.00001\")));   // packets/s\n        staClient.SetAttribute(\"PacketSize\", UintegerValue(payloadSize)); // bytes\n        ApplicationContainer staClientApp = staClient.Install(wifiStaNode.Get(0));\n        staClientApp.Start(Seconds(1.0));\n        staClientApp.Stop(simulationTime + Seconds(1.0));\n    }\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    Simulator::Stop(simulationTime + Seconds(1.0));\n    Simulator::Run();\n\n    double rxBytes;\n    double throughput;\n    bool error = false;\n    if (apHasTraffic)\n    {\n        rxBytes = payloadSize * DynamicCast<UdpServer>(staServerApp.Get(0))->GetReceived();\n        throughput = (rxBytes * 8) / simulationTime.GetMicroSeconds(); // Mbit/s\n        std::cout << \"AP Throughput: \" << throughput << \" Mbit/s\" << std::endl;\n        if (throughput == 0)\n        {\n            error = true;\n        }\n    }\n    if (staHasTraffic)\n    {\n        rxBytes = payloadSize * DynamicCast<UdpServer>(apServerApp.Get(0))->GetReceived();\n        throughput = (rxBytes * 8) / simulationTime.GetMicroSeconds(); // Mbit/s\n        std::cout << \"STA Throughput: \" << throughput << \" Mbit/s\" << std::endl;\n        if (throughput == 0)\n        {\n            error = true;\n        }\n    }\n\n    Simulator::Destroy();\n\n    if (error)\n    {\n        NS_LOG_ERROR(\"No traffic received!\");\n        exit(1);\n    }\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Mobile Ad Hoc Network (MANET) in ns-3 with 3 mobile nodes moving in a random direction. The nodes should communicate using UDP traffic, and the simulation should track the movement of nodes and packet transmission. Include metrics like packet delivery ratio and latency, and use NetAnim to visualize the node mobility and communication."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/udp-echo-helper.h\"\n#include \"ns3/animation-interface.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ManetExample\");\n\nint main(int argc, char *argv[])\n{\n    double simulationTime = 10.0; // seconds\n\n    // Create 3 mobile nodes\n    NodeContainer manetNodes;\n    manetNodes.Create(3);\n\n    // Configure WiFi settings\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"manet-ssid\");\n    mac.SetType(\"ns3::AdhocWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, manetNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(manetNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP Echo Server on node 0\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(manetNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Set up UDP Echo Client on node 2 to communicate with node 0\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(manetNodes.Get(2));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Configure mobility for the nodes\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(manetNodes);\n\n    // Enable NetAnim for visualization\n    AnimationInterface anim(\"manet.xml\");\n    anim.SetConstantPosition(manetNodes.Get(0), 0.0, 0.0);\n    anim.SetConstantPosition(manetNodes.Get(1), 10.0, 20.0);\n    anim.SetConstantPosition(manetNodes.Get(2), 20.0, 40.0);\n\n    // Enable FlowMonitor to capture packet delivery and delay metrics\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n\n    // Output FlowMonitor results\n    monitor->SerializeToXmlFile(\"manet-flowmon.xml\", true, true);\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a simulation in ns-3 that demonstrates a wireless sensor network (WSN) with energy constraints. The network should consist of sensor nodes arranged in a grid. Each sensor node generates data packets that are sent to a central sink node. Energy depletion should be simulated, and the network should stop once all nodes run out of energy."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/energy-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"WirelessSensorNetwork\");\n\nvoid RemainingEnergy(Ptr<BasicEnergySource> source)\n{\n    NS_LOG_UNCOND(\"Remaining energy: \" << source->GetRemainingEnergy() << \" J\");\n    if (source->GetRemainingEnergy() <= 0)\n    {\n        NS_LOG_UNCOND(\"Node has run out of energy\");\n    }\n}\n\nint main (int argc, char *argv[])\n{\n    uint32_t gridSize = 3; // 3x3 grid of nodes\n    double totalEnergy = 100.0; // Initial energy in Joules\n    double simulationTime = 50.0; // seconds\n    double dataRate = 1.0; // packets per second\n\n    // 1. Create nodes\n    NodeContainer sensorNodes;\n    sensorNodes.Create (gridSize * gridSize);\n\n    // 2. Configure Wifi PHY and MAC\n    WifiHelper wifi;\n    wifi.SetStandard (WIFI_PHY_STANDARD_80211b);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();\n    phy.SetChannel (channel.Create ());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid (\"wsn-grid\");\n    mac.SetType (\"ns3::AdhocWifiMac\", \"Ssid\", SsidValue (ssid));\n\n    NetDeviceContainer devices = wifi.Install (phy, mac, sensorNodes);\n\n    // 3. Set up mobility model (grid)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                    \"MinX\", DoubleValue (0.0),\n                                    \"MinY\", DoubleValue (0.0),\n                                    \"DeltaX\", DoubleValue (50.0),\n                                    \"DeltaY\", DoubleValue (50.0),\n                                    \"GridWidth\", UintegerValue (gridSize),\n                                    \"LayoutType\", StringValue (\"RowFirst\"));\n    mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install (sensorNodes);\n\n    // 4. Install energy model\n    BasicEnergySourceHelper energySourceHelper;\n    energySourceHelper.Set (\"BasicEnergySourceInitialEnergyJ\", DoubleValue (totalEnergy));\n    EnergySourceContainer sources = energySourceHelper.Install (sensorNodes);\n\n    WifiRadioEnergyModelHelper radioEnergyHelper;\n    DeviceEnergyModelContainer deviceModels = radioEnergyHelper.Install (devices, sources);\n\n    // 5. Set up the Internet stack\n    InternetStackHelper internet;\n    internet.Install (sensorNodes);\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);\n\n    // 6. Install applications\n    uint16_t sinkPort = 9;\n    Address sinkAddress (InetSocketAddress (interfaces.GetAddress (0), sinkPort)); // First node is the sink\n\n    PacketSinkHelper sinkHelper (\"ns3::UdpSocketFactory\", sinkAddress);\n    ApplicationContainer sinkApp = sinkHelper.Install (sensorNodes.Get (0)); // Sink installed on node 0\n    sinkApp.Start (Seconds (0.0));\n    sinkApp.Stop (Seconds (simulationTime));\n\n    OnOffHelper clientHelper (\"ns3::UdpSocketFactory\", sinkAddress);\n    clientHelper.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientHelper.SetAttribute (\"DataRate\", DataRateValue (DataRate (\"1kbps\")));\n    clientHelper.SetAttribute (\"PacketSize\", UintegerValue (50));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 1; i < sensorNodes.GetN (); ++i) // All nodes except the sink send data\n    {\n        clientApps.Add (clientHelper.Install (sensorNodes.Get (i)));\n    }\n    clientApps.Start (Seconds (1.0));\n    clientApps.Stop (Seconds (simulationTime));\n\n    // 7. Trace remaining energy\n    for (uint32_t i = 0; i < sources.GetN (); ++i)\n    {\n        Ptr<BasicEnergySource> basicSource = DynamicCast<BasicEnergySource> (sources.Get (i));\n        basicSource->TraceConnectWithoutContext (\"RemainingEnergy\", MakeCallback (&RemainingEnergy));\n    }\n\n    // 8. Enable pcap tracing\n    phy.EnablePcapAll (\"wsn-grid\");\n\n    // 9. Run simulation\n    Simulator::Stop (Seconds (simulationTime));\n    Simulator::Run ();\n    Simulator::Destroy ();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple wireless network using ns-3, comprising three nodes arranged in a line topology. Configure the middle node as a router that forwards packets between the two end nodes. Implement a Constant Bit Rate (CBR) traffic source on one end node and a packet sink on the other to measure end-to-end throughput. Enable tracing to capture packet transmissions and receptions, and output the results to a file for analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWirelessNetwork\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"SimpleWirelessNetwork\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Configure Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    // Configure PHY and MAC\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n    NqosWifiMacHelper mac = NqosWifiMacHelper::Default();\n\n    // Install Wi-Fi devices\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Configure routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create applications\n    uint16_t port = 9; // Well-known echo port number\n\n    // CBR traffic source on node 0\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(interfaces.GetAddress(2), port));\n    onoff.SetAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer sourceApps = onoff.Install(nodes.Get(0));\n    sourceApps.Start(Seconds(1.0));\n    sourceApps.Stop(Seconds(10.0));\n\n    // Packet sink on node 2\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApps = sink.Install(nodes.Get(2));\n    sinkApps.Start(Seconds(1.0));\n    sinkApps.Stop(Seconds(10.0));\n\n    // Enable tracing\n    AsciiTraceHelper ascii;\n    phy.EnableAsciiAll(ascii.CreateFileStream(\"simple-wireless-network.tr\"));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple point-to-point network with two nodes using ns-3. Configure the first node to act as a sender and the second node as a receiver. Use TCP as the transport protocol, and set up a bulk data transfer application on the sender to continuously send data to the receiver. Enable packet tracing to generate pcap files for traffic analysis, and log the total amount of data received at the end of the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"PointToPointTcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link with specific data rate and delay\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the internet stack on both nodes\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up a BulkSendApplication on the sender (node 0)\n    uint16_t port = 9; // TCP well-known port number\n    BulkSendHelper bulkSend(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    bulkSend.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n    ApplicationContainer senderApp = bulkSend.Install(nodes.Get(0));\n    senderApp.Start(Seconds(1.0));\n    senderApp.Stop(Seconds(10.0));\n\n    // Set up a PacketSinkApplication on the receiver (node 1)\n    PacketSinkHelper packetSink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer receiverApp = packetSink.Install(nodes.Get(1));\n    receiverApp.Start(Seconds(1.0));\n    receiverApp.Stop(Seconds(10.0));\n\n    // Enable packet tracing (pcap file generation)\n    pointToPoint.EnablePcapAll(\"tcp-p2p-example\");\n\n    // Run the simulation\n    Simulator::Run();\n\n    // Log the total bytes received by the receiver node\n    Ptr<PacketSink> sink = DynamicCast<PacketSink>(receiverApp.Get(0));\n    NS_LOG_INFO(\"Total Bytes Received: \" << sink->GetTotalRx());\n\n    // Destroy the simulation\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network in ns-3 with two access points (APs) and multiple stations (STA). Each AP supports a group of stations, and the stations are configured to communicate with their respective APs. Use UDP as the transport protocol, and set up a UDP client-server application where the stations send continuous data to a server. Enable pcap and ASCII tracing for traffic analysis, and print the total data sent by each station."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ssid.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    uint32_t nStas = 4; // Number of stations per AP\n    double simulationTime = 10.0; // Simulation time in seconds\n\n    // Create two access points and multiple stations\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(2);\n    NodeContainer wifiStaNodes1;\n    wifiStaNodes1.Create(nStas);\n    NodeContainer wifiStaNodes2;\n    wifiStaNodes2.Create(nStas);\n\n    // Set up the Wi-Fi channel and PHY\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up Wi-Fi MAC layer (non-QoS)\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper mac;\n    Ssid ssid1 = Ssid(\"network-1\");\n    Ssid ssid2 = Ssid(\"network-2\");\n\n    // Configure the APs\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid1));\n    NetDeviceContainer apDevices1 = wifi.Install(phy, mac, wifiApNodes.Get(0));\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid2));\n    NetDeviceContainer apDevices2 = wifi.Install(phy, mac, wifiApNodes.Get(1));\n\n    // Configure the stations for AP 1\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid1));\n    NetDeviceContainer staDevices1 = wifi.Install(phy, mac, wifiStaNodes1);\n\n    // Configure the stations for AP 2\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid2));\n    NetDeviceContainer staDevices2 = wifi.Install(phy, mac, wifiStaNodes2);\n\n    // Set up mobility models\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNodes);\n    mobility.Install(wifiStaNodes1);\n    mobility.Install(wifiStaNodes2);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes1);\n    stack.Install(wifiStaNodes2);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer ap1Interface, ap2Interface, sta1Interface, sta2Interface;\n\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ap1Interface = address.Assign(apDevices1);\n    sta1Interface = address.Assign(staDevices1);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    ap2Interface = address.Assign(apDevices2);\n    sta2Interface = address.Assign(staDevices2);\n\n    // Set up UDP server on the access points\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp1 = udpServer.Install(wifiApNodes.Get(0));\n    ApplicationContainer serverApp2 = udpServer.Install(wifiApNodes.Get(1));\n    serverApp1.Start(Seconds(1.0));\n    serverApp2.Start(Seconds(1.0));\n    serverApp1.Stop(Seconds(simulationTime));\n    serverApp2.Stop(Seconds(simulationTime));\n\n    // Set up UDP clients on the stations\n    UdpClientHelper udpClient1(ap1Interface.GetAddress(0), 9);\n    udpClient1.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient1.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    udpClient1.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    UdpClientHelper udpClient2(ap2Interface.GetAddress(0), 9);\n    udpClient2.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient2.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    udpClient2.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps1, clientApps2;\n    clientApps1.Add(udpClient1.Install(wifiStaNodes1));\n    clientApps2.Add(udpClient2.Install(wifiStaNodes2));\n\n    clientApps1.Start(Seconds(2.0));\n    clientApps2.Start(Seconds(2.0));\n    clientApps1.Stop(Seconds(simulationTime));\n    clientApps2.Stop(Seconds(simulationTime));\n\n    // Enable packet tracing (ASCII and pcap files)\n    phy.EnablePcap(\"wifi-network-ap1\", apDevices1.Get(0));\n    phy.EnablePcap(\"wifi-network-ap2\", apDevices2.Get(0));\n    phy.EnableAsciiAll(CreateObject<OutputStreamWrapper>(\"wifi-network.tr\", std::ios::out));\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n\n    // Log the total packets received by each AP\n    Ptr<UdpServer> server1 = DynamicCast<UdpServer>(serverApp1.Get(0));\n    Ptr<UdpServer> server2 = DynamicCast<UdpServer>(serverApp2.Get(0));\n    NS_LOG_INFO(\"Total Packets Received by AP 1: \" << server1->GetReceived());\n    NS_LOG_INFO(\"Total Packets Received by AP 2: \" << server2->GetReceived());\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wired network with a TCP bulk transfer between two nodes in ns-3. Create a point-to-point link between the nodes with configurable data rate and delay. Implement a TCP bulk send application that sends data from the client to the server. Track and log the number of bytes transmitted and the throughput during the simulation. Enable pcap tracing to capture packets transmitted over the link for detailed analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpBulkTransferExample\");\n\nint main(int argc, char *argv[])\n{\n    double simulationTime = 10.0; // Simulation time in seconds\n    std::string dataRate = \"5Mbps\"; // Link data rate\n    std::string delay = \"2ms\";      // Link delay\n\n    // Enable logging\n    LogComponentEnable(\"TcpBulkTransferExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes (client and server)\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up a point-to-point link with the specified data rate and delay\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(dataRate));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(delay));\n\n    // Install devices and create the point-to-point link\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a TCP bulk send application on the client node\n    uint16_t port = 9; // Port number for the TCP connection\n    BulkSendHelper bulkSend(\"ns3::TcpSocketFactory\",\n                            InetSocketAddress(interfaces.GetAddress(1), port));\n    bulkSend.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data\n    ApplicationContainer clientApp = bulkSend.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(simulationTime));\n\n    // Set up a packet sink on the server node to receive the data\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\",\n                                      InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = packetSinkHelper.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Enable pcap tracing\n    pointToPoint.EnablePcap(\"tcp-bulk-transfer\", devices.Get(0), true);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n\n    // Log the total number of bytes received by the server\n    Ptr<PacketSink> sink = DynamicCast<PacketSink>(serverApp.Get(0));\n    NS_LOG_INFO(\"Total Bytes Received by Server: \" << sink->GetTotalRx());\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless network using the IEEE 802.11 WiFi standard in ns-3. Create a network with one Access Point (AP) and two WiFi stations (STA). Configure the stations to communicate with the AP using UDP traffic. Track the number of packets transmitted, the total received bytes, and the throughput for each station. Enable pcap tracing to capture the wireless traffic."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/packet-sink-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    double simulationTime = 10.0; // Simulation time in seconds\n    std::string dataRate = \"10Mbps\"; // UDP application data rate\n\n    // Enable logging\n    LogComponentEnable(\"WifiNetworkExample\", LOG_LEVEL_INFO);\n\n    // Create a WiFi network with one AP and two stations\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Configure the WiFi PHY and MAC\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Configure STA nodes\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure AP node\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Configure mobility for the stations and AP\n    MobilityHelper mobility;\n\n    // Set up station mobility\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n\n    // Set up AP mobility (static)\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n\n    // Set up UDP applications on STA nodes to send data to the AP\n    uint16_t port = 9;\n    UdpClientHelper udpClient(apInterface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05))); // Packet interval\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));    // Packet size\n\n    ApplicationContainer clientApps = udpClient.Install(wifiStaNodes);\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(simulationTime));\n\n    // Set up a packet sink on the AP to receive the UDP traffic\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simulationTime));\n\n    // Enable pcap tracing\n    phy.EnablePcap(\"wifi-network\", apDevice.Get(0));\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simulationTime));\n    Simulator::Run();\n\n    // Log the total number of packets received by the AP\n    Ptr<UdpServer> server = DynamicCast<UdpServer>(serverApp.Get(0));\n    NS_LOG_INFO(\"Total Packets Received by AP: \" << server->GetReceived());\n    NS_LOG_INFO(\"Total Bytes Received by AP: \" << server->GetReceivedBytes());\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a basic wired network using ns-3, where three nodes are connected in a simple point-to-point (P2P) topology. The first node sends TCP traffic to the third node, while the second node acts as a router forwarding packets between them. Implement packet tracing to log the number of transmitted and received packets on each node. Capture and analyze the packets in a pcap file for deeper analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"P2PNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Log level settings\n    LogComponentEnable(\"P2PNetworkExample\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Create point-to-point links between nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install the P2P devices and channels between node0-node1 and node1-node2\n    NetDeviceContainer devices0 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));\n    NetDeviceContainer devices1 = pointToPoint.Install(nodes.Get(1), nodes.Get(2));\n\n    // Install the internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces0 = address.Assign(devices0);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces1 = address.Assign(devices1);\n\n    // Enable routing on the middle node (node1)\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create a TCP server on node2 to receive traffic\n    uint16_t port = 9;\n    Address serverAddress(InetSocketAddress(interfaces1.GetAddress(1), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(2));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Create a TCP client on node0 to send traffic to node2\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", Address());\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientHelper.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    clientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps;\n    clientHelper.SetAttribute(\"Remote\", AddressValue(serverAddress));\n    clientApps.Add(clientHelper.Install(nodes.Get(0)));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable packet tracing (pcap)\n    pointToPoint.EnablePcapAll(\"p2p-network\");\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Output received packets\n    Ptr<PacketSink> sink1 = DynamicCast<PacketSink>(sinkApp.Get(0));\n    NS_LOG_INFO(\"Total Packets Received by Node 2: \" << sink1->GetTotalRx());\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple vehicle-to-vehicle (V2V) communication scenario using the ns-3 Wave module. There are two vehicles communicating via the Wave protocol (802.11p), and a UDP application is used to send messages from one vehicle to another. The simulation should track packet transmissions and receptions and provide statistics on the messages sent and received."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wave-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"V2VCommunicationExample\");\n\nint main (int argc, char *argv[])\n{\n    // Set simulation parameters\n    double simTime = 10.0; // seconds\n    double distance = 50.0; // meters between vehicles\n\n    // Enable logging\n    LogComponentEnable (\"UdpClient\", LOG_LEVEL_INFO);\n    LogComponentEnable (\"UdpServer\", LOG_LEVEL_INFO);\n\n    // Create two vehicle nodes\n    NodeContainer vehicles;\n    vehicles.Create (2);\n\n    // Set up Wi-Fi for vehicular communication using Wave (802.11p)\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default ();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default ();\n    wifiPhy.SetChannel (wifiChannel.Create ());\n\n    QosWaveMacHelper wifiMac = QosWaveMacHelper::Default ();\n    WaveHelper waveHelper = WaveHelper::Default ();\n    NetDeviceContainer devices = waveHelper.Install (wifiPhy, wifiMac, vehicles);\n\n    // Set up mobility model for the vehicles\n    MobilityHelper mobility;\n    mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();\n    positionAlloc->Add (Vector (0.0, 0.0, 0.0));  // Position for vehicle 1\n    positionAlloc->Add (Vector (distance, 0.0, 0.0));  // Position for vehicle 2\n    mobility.SetPositionAllocator (positionAlloc);\n    mobility.Install (vehicles);\n\n    // Install the internet stack on the vehicles\n    InternetStackHelper internet;\n    internet.Install (vehicles);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);\n\n    // Set up UDP server on vehicle 2 (Node 1)\n    uint16_t port = 4000;\n    UdpServerHelper udpServer (port);\n    ApplicationContainer serverApp = udpServer.Install (vehicles.Get (1));\n    serverApp.Start (Seconds (1.0));\n    serverApp.Stop (Seconds (simTime));\n\n    // Set up UDP client on vehicle 1 (Node 0)\n    UdpClientHelper udpClient (interfaces.GetAddress (1), port);\n    udpClient.SetAttribute (\"MaxPackets\", UintegerValue (100));\n    udpClient.SetAttribute (\"Interval\", TimeValue (Seconds (1.0))); // 1 packet per second\n    udpClient.SetAttribute (\"PacketSize\", UintegerValue (1024));\n\n    ApplicationContainer clientApp = udpClient.Install (vehicles.Get (0));\n    clientApp.Start (Seconds (2.0));\n    clientApp.Stop (Seconds (simTime));\n\n    // Set up Flow Monitor to track statistics\n    FlowMonitorHelper flowHelper;\n    Ptr<FlowMonitor> monitor = flowHelper.InstallAll ();\n\n    // Run the simulation\n    Simulator::Stop (Seconds (simTime));\n    Simulator::Run ();\n\n    // Print Flow Monitor statistics\n    monitor->CheckForLostPackets ();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowHelper.GetClassifier ());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats ();\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);\n        NS_LOG_UNCOND (\"Flow ID: \" << i->first << \" Src Addr \" << t.sourceAddress << \" Dst Addr \" << t.destinationAddress);\n        NS_LOG_UNCOND (\"Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND (\"Rx Packets: \" << i->second.rxPackets);\n    }\n\n    // Clean up\n    Simulator::Destroy ();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a network with two point-to-point links connecting three routers (R1, R2, R3) and a LAN connected to one of the routers (R2). The simulation uses the TCP protocol to send traffic from a node in the LAN to a node connected to Router R3, passing through Router R2. The simulation collects data on packet transmission, reception, and throughput, and saves this information into an output file."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointAndLanExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n\n    // Create 3 routers and 2 nodes in a LAN\n    NodeContainer routers;\n    routers.Create(3);\n\n    NodeContainer lanNodes;\n    lanNodes.Add(routers.Get(1)); // Connect R2 to the LAN\n    lanNodes.Create(2);           // Add 2 LAN nodes\n\n    // Create point-to-point links between routers\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devicesR1R2, devicesR2R3;\n    devicesR1R2 = pointToPoint.Install(routers.Get(0), routers.Get(1)); // R1-R2 link\n    devicesR2R3 = pointToPoint.Install(routers.Get(1), routers.Get(2)); // R2-R3 link\n\n    // Create CSMA (LAN) link\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    NetDeviceContainer lanDevices;\n    lanDevices = csma.Install(lanNodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(routers);\n    stack.Install(lanNodes.Get(1)); // Install on LAN nodes\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfacesR1R2 = address.Assign(devicesR1R2);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfacesR2R3 = address.Assign(devicesR2R3);\n\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer lanInterfaces = address.Assign(lanDevices);\n\n    // Enable routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Install UDP server on R3 (node 2)\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(routers.Get(2)); // R3\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Install UDP client on one of the LAN nodes\n    UdpClientHelper udpClient(interfacesR2R3.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(lanNodes.Get(1)); // LAN Node\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up FlowMonitor to track traffic\n    FlowMonitorHelper flowmonHelper;\n    Ptr<FlowMonitor> monitor = flowmonHelper.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Print FlowMonitor statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow ID: \" << i->first << \" Src Addr \" << t.sourceAddress << \" Dst Addr \" << t.destinationAddress);\n        NS_LOG_UNCOND(\"Tx Packets = \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"Rx Packets = \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"Throughput: \" << i->second.rxBytes * 8.0 / (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) / 1024 / 1024 << \" Mbps\");\n    }\n\n    // Clean up and exit\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an NS-3 simulation in C++ that models a basic network with two nodes. Connect these nodes using a point-to-point link with a data transmission rate of 5 Mbps and a propagation delay of 2 milliseconds. Do not configure any IP addresses or communication protocols for the nodes; the focus is only on setting up the link between them. Once the point-to-point link has been established between the two nodes, the simulation should verify the setup and conclude."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BasicNodeAndLinkSetup\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link between the two nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a complete NS-3 simulation example that demonstrates the use of the 802.11n compressed block acknowledgment mechanism. Create a network topology with an access point and two stations, where a QoS station sends UDP packets to the access point, which replies with ICMP frames. Configure the block acknowledgment parameters, including setting a block acknowledgment threshold and a timeout for block acknowledgment inactivity. Implement the necessary NS-3 classes, such as YansWifiChannelHelper, YansWifiPhyHelper, WifiHelper, and others, to create nodes, install devices, and set up mobility models. Also, set up the Internet stack and routing tables, and define applications for packet transmission with specified data rates and timing attributes. Finally, enable packet capture for the access point and run the simulation."}, {"role": "assistant", "content": "/**\n * This is a simple example in order to show how 802.11n compressed block ack mechanism could be\n * used.\n *\n * Network topology:\n *\n *  Wifi 192.168.1.0\n *\n *        AP\n *   *    *\n *   |    |\n *   n1   n2\n *\n * In this example a QoS sta sends UDP datagram packets to access point. On the access point\n * there is no application installed so it replies to every packet with an ICMP frame. However\n * our attention is on originator sta n1. We have set blockAckThreshold (minimum number of packets\n * to use block ack) to 2 so if there are in the BestEffort queue more than 2 packets a block ack\n * will be negotiated. We also set a timeout for block ack inactivity to 3 blocks of 1024\n * microseconds. This timer is reset when:\n *    - the originator receives a block ack frame.\n *    - the recipient receives a block ack request or a MPDU with ack policy Block Ack.\n */\n\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/rectangle.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Test-block-ack\");\n\nint\nmain(int argc, char* argv[])\n{\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    LogComponentEnable(\"QosTxop\", LOG_LEVEL_DEBUG);\n    LogComponentEnable(\"BlockAckManager\", LOG_LEVEL_INFO);\n\n    Ptr<Node> sta = CreateObject<Node>();\n    Ptr<Node> ap = CreateObject<Node>();\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    WifiMacHelper mac;\n    /* disable fragmentation */\n    wifi.SetRemoteStationManager(\"ns3::IdealWifiManager\",\n                                 \"FragmentationThreshold\",\n                                 UintegerValue(2500));\n\n    Ssid ssid(\"My-network\");\n\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"QosSupported\",\n                BooleanValue(true),\n                \"Ssid\",\n                SsidValue(ssid),\n                /* setting blockack threshold for sta's BE queue */\n                \"BE_BlockAckThreshold\",\n                UintegerValue(2),\n                /* setting block inactivity timeout to 3*1024 = 3072 microseconds */\n                \"BE_BlockAckInactivityTimeout\",\n                UintegerValue(3));\n    NetDeviceContainer staDevice = wifi.Install(phy, mac, sta);\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"QosSupported\",\n                BooleanValue(true),\n                \"Ssid\",\n                SsidValue(ssid),\n                \"BE_BlockAckThreshold\",\n                UintegerValue(0));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, ap);\n\n    /* Setting mobility model */\n    MobilityHelper mobility;\n\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\",\n                                  DoubleValue(0.0),\n                                  \"MinY\",\n                                  DoubleValue(0.0),\n                                  \"DeltaX\",\n                                  DoubleValue(5.0),\n                                  \"DeltaY\",\n                                  DoubleValue(10.0),\n                                  \"GridWidth\",\n                                  UintegerValue(3),\n                                  \"LayoutType\",\n                                  StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\",\n                              RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(sta);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(ap);\n\n    /* Internet stack*/\n    InternetStackHelper stack;\n    stack.Install(sta);\n    stack.Install(ap);\n\n    Ipv4AddressHelper address;\n\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staIf;\n    Ipv4InterfaceContainer apIf;\n    staIf = address.Assign(staDevice);\n    apIf = address.Assign(apDevice);\n\n    /* Setting applications */\n\n    uint16_t port = 9;\n    DataRate dataRate(\"1Mb/s\");\n    OnOffHelper onOff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(apIf.GetAddress(0), port)));\n    onOff.SetAttribute(\"DataRate\", DataRateValue(dataRate));\n    onOff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0.01]\"));\n    onOff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=8]\"));\n    onOff.SetAttribute(\"PacketSize\", UintegerValue(50));\n\n    ApplicationContainer staApps = onOff.Install(sta);\n\n    staApps.Start(Seconds(1.0));\n    staApps.Stop(Seconds(10.0));\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    Simulator::Stop(Seconds(10.0));\n\n    phy.EnablePcap(\"test-blockack\", ap->GetId(), 0);\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation for a wireless network where four mobile nodes are connected via an Ad-Hoc network. Use the AODV (Ad hoc On-Demand Distance Vector) routing protocol to manage routing in the network. The nodes should move randomly within a predefined area during the simulation, and UDP traffic is generated between the nodes. Track the movement and interactions of the nodes using NetAnim. Measure and analyze packet delivery ratio, throughput, and average end-to-end delay using FlowMonitor, and visualize the nodes' mobility and communication using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"AdhocNetworkSimulation\");\n\nint main (int argc, char *argv[])\n{\n    // Set simulation time\n    double simTime = 20.0;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Set up WiFi for Ad-Hoc network\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, nodes);\n\n    // Install Internet stack with AODV routing\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Mobility model for random movement\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", StringValue(\"ns3::ConstantRandomVariable[Constant=20.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=2.0]\"),\n                              \"PositionAllocator\", StringValue(\"ns3::RandomRectanglePositionAllocator\"));\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(50.0),\n                                  \"DeltaY\", DoubleValue(50.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.Install(nodes);\n\n    // Set up UDP traffic\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(3));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(simTime));\n\n    UdpClientHelper udpClient(interfaces.GetAddress(3), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(simTime));\n\n    // Set up FlowMonitor\n    FlowMonitorHelper flowMonitorHelper;\n    Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n    // NetAnim setup\n    AnimationInterface anim(\"adhoc_network.xml\");\n    anim.SetConstantPosition(nodes.Get(0), 10.0, 10.0);\n    anim.SetConstantPosition(nodes.Get(1), 30.0, 10.0);\n    anim.SetConstantPosition(nodes.Get(2), 10.0, 30.0);\n    anim.SetConstantPosition(nodes.Get(3), 30.0, 30.0);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n\n    // Flow monitor statistics\n    flowMonitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitorHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n\n    for (auto it = stats.begin(); it != stats.end(); ++it)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(it->first);\n        std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n        std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n        std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n        std::cout << \"  Throughput: \" << it->second.rxBytes * 8.0 / simTime / 1000 / 1000 << \" Mbps\" << std::endl;\n        std::cout << \"  Packet Delivery Ratio: \" << (double)it->second.rxPackets / it->second.txPackets * 100 << \"%\" << std::endl;\n        std::cout << \"  Delay: \" << it->second.delaySum.GetSeconds() << \" seconds\" << std::endl;\n    }\n\n    // Clean up and destroy simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an ns-3 simulation with a star topology consisting of five nodes. The central node acts as a hub that connects to four peripheral nodes through point-to-point links, each with a data rate of 10 Mbps and a delay of 1 ms. Install a UDP echo server on the central node and configure UDP echo clients on each of the peripheral nodes to send packets to the central node. Collect metrics using FlowMonitor, including packet delivery ratio, delay, and throughput, and log them. Additionally, enable pcap tracing for analysis and simulate for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"StarTopologyExample\");\n\nint main (int argc, char *argv[])\n{\n    // Set up the nodes\n    NodeContainer centralNode;\n    centralNode.Create(1);\n\n    NodeContainer peripheralNodes;\n    peripheralNodes.Create(4);\n\n    // Install point-to-point links\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    NetDeviceContainer devices[4];\n    for (int i = 0; i < 4; ++i)\n    {\n        devices[i] = pointToPoint.Install(centralNode.Get(0), peripheralNodes.Get(i));\n    }\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(centralNode);\n    stack.Install(peripheralNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    Ipv4InterfaceContainer interfaces[4];\n    for (int i = 0; i < 4; ++i)\n    {\n        std::ostringstream subnet;\n        subnet << \"10.1.\" << i+1 << \".0\";\n        address.SetBase(subnet.str().c_str(), \"255.255.255.0\");\n        interfaces[i] = address.Assign(devices[i]);\n    }\n\n    // UDP Echo Server on the central node\n    uint16_t port = 9; // UDP Echo server port\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApps = echoServer.Install(centralNode.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // UDP Echo Clients on peripheral nodes\n    ApplicationContainer clientApps[4];\n    for (int i = 0; i < 4; ++i)\n    {\n        UdpEchoClientHelper echoClient(interfaces[i].GetAddress(1), port);\n        echoClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n        echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n        echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n        clientApps[i] = echoClient.Install(peripheralNodes.Get(i));\n        clientApps[i].Start(Seconds(2.0));\n        clientApps[i].Stop(Seconds(10.0));\n    }\n\n    // Enable packet tracing\n    pointToPoint.EnablePcapAll(\"star_topology\");\n\n    // Set up FlowMonitor for performance metrics\n    FlowMonitorHelper flowMonitorHelper;\n    Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // FlowMonitor statistics\n    flowMonitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitorHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n\n    for (auto it = stats.begin(); it != stats.end(); ++it)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(it->first);\n        std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n        std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n        std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n        std::cout << \"  Throughput: \" << it->second.rxBytes * 8.0 / 10.0 / 1000 / 1000 << \" Mbps\" << std::endl;\n        std::cout << \"  End-to-End Delay: \" << it->second.delaySum.GetSeconds() << \" seconds\" << std::endl;\n    }\n\n    // Clean up and exit\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless sensor network (WSN) with six nodes arranged in a circular topology using ns-3. Each node uses the IEEE 802.15.4 standard for low-rate wireless communication and operates in the 2.4 GHz frequency band. Set up one of the nodes as a data collector (sink) that receives sensor data from the other five nodes. Implement a simple UDP-based data transfer, where each node sends a packet to the sink node at regular intervals. Collect performance metrics such as packet delivery ratio, end-to-end delay, and throughput, and visualize the packet flows using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/udp-echo-helper.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/lr-wpan-module.h\"\n#include \"ns3/sixlowpan-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WirelessSensorNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create six sensor nodes\n    NodeContainer sensorNodes;\n    sensorNodes.Create(6);\n\n    // Set up the physical layer with LR-WPAN (IEEE 802.15.4)\n    LrWpanHelper lrWpan;\n    NetDeviceContainer sensorDevices = lrWpan.Install(sensorNodes);\n    lrWpan.AssociateToPan(sensorDevices, 0);\n\n    // Set up the 6LoWPAN layer (optional)\n    SixLowPanHelper sixlowpan;\n    NetDeviceContainer sixlowpanDevices = sixlowpan.Install(sensorDevices);\n\n    // Install the internet stack on all nodes\n    InternetStackHelper internet;\n    internet.Install(sensorNodes);\n\n    // Assign IP addresses\n    Ipv6AddressHelper ipv6;\n    ipv6.SetBase(Ipv6Address(\"2001:db8::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer sensorInterfaces = ipv6.Assign(sixlowpanDevices);\n\n    // Set up mobility: Arrange nodes in a circle\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0)); // Sink node (center)\n    double radius = 20.0;\n    for (int i = 1; i < 6; ++i)\n    {\n        double angle = i * (2 * M_PI / 5); // 5 peripheral nodes\n        positionAlloc->Add(Vector(radius * cos(angle), radius * sin(angle), 0.0));\n    }\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(sensorNodes);\n\n    // Set up UDP echo server on the central (sink) node\n    uint16_t port = 9;\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApp = echoServer.Install(sensorNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Set up UDP echo clients on the peripheral sensor nodes\n    UdpEchoClientHelper echoClient(sensorInterfaces.GetAddress(0, 1), port);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(2.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps;\n    for (int i = 1; i < 6; ++i)\n    {\n        clientApps.Add(echoClient.Install(sensorNodes.Get(i)));\n    }\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(20.0));\n\n    // Enable tracing\n    lrWpan.EnablePcapAll(\"wsn-example\");\n\n    // Set up FlowMonitor to gather performance metrics\n    FlowMonitorHelper flowMonitorHelper;\n    Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n    // Set up NetAnim for visualization\n    AnimationInterface anim(\"wsn-animation.xml\");\n\n    // Run the simulation\n    Simulator::Stop(Seconds(20.0));\n    Simulator::Run();\n\n    // FlowMonitor statistics\n    flowMonitor->CheckForLostPackets();\n    Ptr<Ipv6FlowClassifier> classifier = DynamicCast<Ipv6FlowClassifier>(flowMonitorHelper.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n\n    for (auto it = stats.begin(); it != stats.end(); ++it)\n    {\n        Ipv6FlowClassifier::FiveTuple t = classifier->FindFlow(it->first);\n        std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n        std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n        std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n        std::cout << \"  Throughput: \" << it->second.rxBytes * 8.0 / 20.0 / 1000 / 1000 << \" Mbps\" << std::endl;\n        std::cout << \"  End-to-End Delay: \" << it->second.delaySum.GetSeconds() << \" seconds\" << std::endl;\n    }\n\n    // Clean up\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simulation in ns-3 for a vehicular ad-hoc network (VANET) with five vehicles moving along a straight road. Each vehicle is equipped with Wi-Fi and uses the IEEE 802.11p standard for vehicle-to-vehicle (V2V) communication. The vehicles are configured to exchange information using a UDP client-server model, where one vehicle acts as a server and the others send data at regular intervals. The mobility model should ensure that the vehicles move in the same direction with varying speeds. Collect and display metrics such as packet delivery ratio and end-to-end delay, and visualize the vehicle movements and communication with NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"VanetExample\");\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n  LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n  // Create nodes (5 vehicles)\n  NodeContainer vehicles;\n  vehicles.Create(5);\n\n  // Set up 802.11p Wi-Fi (vehicular communication)\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n  YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n  phy.SetChannel(channel.Create());\n\n  WifiHelper wifi;\n  wifi.SetStandard(WIFI_PHY_STANDARD_80211p);\n\n  NqosWaveMacHelper mac = NqosWaveMacHelper::Default();\n  Wifi80211pHelper wifi80211p = Wifi80211pHelper::Default();\n  NetDeviceContainer devices = wifi80211p.Install(phy, mac, vehicles);\n\n  // Install Internet stack\n  InternetStackHelper internet;\n  internet.Install(vehicles);\n\n  // Assign IP addresses\n  Ipv4AddressHelper ipv4;\n  ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer vehicleInterfaces = ipv4.Assign(devices);\n\n  // Set up mobility model for vehicles\n  MobilityHelper mobility;\n  mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n  \n  Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n  positionAlloc->Add(Vector(0.0, 0.0, 0.0));    // First vehicle position\n  positionAlloc->Add(Vector(20.0, 0.0, 0.0));   // Second vehicle\n  positionAlloc->Add(Vector(40.0, 0.0, 0.0));   // Third vehicle\n  positionAlloc->Add(Vector(60.0, 0.0, 0.0));   // Fourth vehicle\n  positionAlloc->Add(Vector(80.0, 0.0, 0.0));   // Fifth vehicle\n  mobility.SetPositionAllocator(positionAlloc);\n  mobility.Install(vehicles);\n\n  // Set different speeds for the vehicles\n  for (uint32_t i = 0; i < vehicles.GetN(); ++i) {\n    Ptr<ConstantVelocityMobilityModel> mob = vehicles.Get(i)->GetObject<ConstantVelocityMobilityModel>();\n    mob->SetVelocity(Vector(10.0 + i, 0.0, 0.0));  // Speed varies slightly for each vehicle\n  }\n\n  // Set up UDP echo server on the first vehicle\n  uint16_t port = 9;\n  UdpEchoServerHelper echoServer(port);\n  ApplicationContainer serverApp = echoServer.Install(vehicles.Get(0));\n  serverApp.Start(Seconds(1.0));\n  serverApp.Stop(Seconds(20.0));\n\n  // Set up UDP echo clients on the other vehicles\n  UdpEchoClientHelper echoClient(vehicleInterfaces.GetAddress(0), port);\n  echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n  echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(2.0)));\n  echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n  ApplicationContainer clientApps;\n  for (uint32_t i = 1; i < vehicles.GetN(); ++i)\n  {\n    clientApps.Add(echoClient.Install(vehicles.Get(i)));\n  }\n  clientApps.Start(Seconds(2.0));\n  clientApps.Stop(Seconds(20.0));\n\n  // Enable tracing for Wi-Fi packets\n  phy.EnablePcapAll(\"vanet-example\");\n\n  // Set up FlowMonitor for performance metrics\n  FlowMonitorHelper flowMonitorHelper;\n  Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n  // Set up NetAnim for visualization\n  AnimationInterface anim(\"vanet-animation.xml\");\n  anim.SetConstantPosition(vehicles.Get(0), 0.0, 0.0);\n  anim.SetConstantPosition(vehicles.Get(1), 20.0, 0.0);\n  anim.SetConstantPosition(vehicles.Get(2), 40.0, 0.0);\n  anim.SetConstantPosition(vehicles.Get(3), 60.0, 0.0);\n  anim.SetConstantPosition(vehicles.Get(4), 80.0, 0.0);\n\n  // Run the simulation\n  Simulator::Stop(Seconds(20.0));\n  Simulator::Run();\n\n  // FlowMonitor statistics\n  flowMonitor->CheckForLostPackets();\n  Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitorHelper.GetClassifier());\n  FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n\n  for (auto it = stats.begin(); it != stats.end(); ++it)\n  {\n    Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(it->first);\n    std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n    std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n    std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n    std::cout << \"  Throughput: \" << it->second.rxBytes * 8.0 / 20.0 / 1000 / 1000 << \" Mbps\" << std::endl;\n    std::cout << \"  End-to-End Delay: \" << it->second.delaySum.GetSeconds() << \" seconds\" << std::endl;\n  }\n\n  // Clean up and exit\n  Simulator::Destroy();\n  return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless sensor network (WSN) in ns-3 with six sensor nodes placed in a grid. The nodes should communicate using a simple CSMA protocol. One of the nodes should act as a base station, receiving data from the other sensor nodes using a UDP protocol. The sensor nodes should periodically send data to the base station. Collect and display metrics such as packet delivery ratio and end-to-end delay, and visualize the communication using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WirelessSensorNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n  LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n  LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n  // Create nodes for WSN (6 sensor nodes)\n  NodeContainer sensorNodes;\n  sensorNodes.Create(6);\n\n  // Set up CSMA (wired communication simulation for sensor network)\n  CsmaHelper csma;\n  csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n  csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n  NetDeviceContainer devices = csma.Install(sensorNodes);\n\n  // Install Internet stack\n  InternetStackHelper stack;\n  stack.Install(sensorNodes);\n\n  // Assign IP addresses\n  Ipv4AddressHelper ipv4;\n  ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer sensorInterfaces = ipv4.Assign(devices);\n\n  // Set up mobility model for sensor nodes (grid placement)\n  MobilityHelper mobility;\n  mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                \"MinX\", DoubleValue(0.0),\n                                \"MinY\", DoubleValue(0.0),\n                                \"DeltaX\", DoubleValue(20.0),\n                                \"DeltaY\", DoubleValue(20.0),\n                                \"GridWidth\", UintegerValue(3),\n                                \"LayoutType\", StringValue(\"RowFirst\"));\n  mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install(sensorNodes);\n\n  // Set up UDP server on the base station (node 0)\n  uint16_t port = 9;\n  UdpEchoServerHelper echoServer(port);\n  ApplicationContainer serverApp = echoServer.Install(sensorNodes.Get(0));\n  serverApp.Start(Seconds(1.0));\n  serverApp.Stop(Seconds(10.0));\n\n  // Set up UDP clients on sensor nodes\n  UdpEchoClientHelper echoClient(sensorInterfaces.GetAddress(0), port);\n  echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n  echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n  echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n  ApplicationContainer clientApps;\n  for (uint32_t i = 1; i < sensorNodes.GetN(); ++i)\n  {\n    clientApps.Add(echoClient.Install(sensorNodes.Get(i)));\n  }\n  clientApps.Start(Seconds(2.0));\n  clientApps.Stop(Seconds(10.0));\n\n  // Enable pcap tracing\n  csma.EnablePcapAll(\"wsn-example\");\n\n  // Set up FlowMonitor for performance analysis\n  FlowMonitorHelper flowMonitorHelper;\n  Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n  // Set up NetAnim for visualization\n  AnimationInterface anim(\"wsn-animation.xml\");\n  anim.SetConstantPosition(sensorNodes.Get(0), 0.0, 0.0);\n  anim.SetConstantPosition(sensorNodes.Get(1), 20.0, 0.0);\n  anim.SetConstantPosition(sensorNodes.Get(2), 40.0, 0.0);\n  anim.SetConstantPosition(sensorNodes.Get(3), 0.0, 20.0);\n  anim.SetConstantPosition(sensorNodes.Get(4), 20.0, 20.0);\n  anim.SetConstantPosition(sensorNodes.Get(5), 40.0, 20.0);\n\n  // Run the simulation\n  Simulator::Stop(Seconds(10.0));\n  Simulator::Run();\n\n  // Analyze FlowMonitor statistics\n  flowMonitor->CheckForLostPackets();\n  Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitorHelper.GetClassifier());\n  FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats();\n\n  for (auto it = stats.begin(); it != stats.end(); ++it)\n  {\n    Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(it->first);\n    std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n    std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n    std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n    std::cout << \"  End-to-End Delay: \" << it->second.delaySum.GetSeconds() << \" seconds\" << std::endl;\n  }\n\n  // Clean up\n  Simulator::Destroy();\n  return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a vehicular network scenario using ns-3, where four vehicles are moving along a straight road. The vehicles should communicate using WiFi in ad-hoc mode. Use a constant velocity mobility model to simulate the movement of the vehicles. The vehicles should send periodic UDP packets to one another to mimic vehicle-to-vehicle communication. Collect metrics such as packet loss and delay, and visualize the simulation using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"VehicularNetworkSimulation\");\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable (\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n  LogComponentEnable (\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n  // Create nodes (vehicles)\n  NodeContainer vehicles;\n  vehicles.Create (4);\n\n  // Set up WiFi for ad-hoc communication\n  WifiHelper wifi;\n  wifi.SetStandard (WIFI_PHY_STANDARD_80211g);\n\n  YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default ();\n  YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default ();\n  wifiPhy.SetChannel (wifiChannel.Create ());\n\n  WifiMacHelper wifiMac;\n  wifiMac.SetType (\"ns3::AdhocWifiMac\");\n\n  NetDeviceContainer devices = wifi.Install (wifiPhy, wifiMac, vehicles);\n\n  // Install Internet stack\n  InternetStackHelper stack;\n  stack.Install (vehicles);\n\n  // Assign IP addresses\n  Ipv4AddressHelper ipv4;\n  ipv4.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer vehicleInterfaces = ipv4.Assign (devices);\n\n  // Set up mobility model for vehicles (straight road with constant velocity)\n  MobilityHelper mobility;\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0),\n                                 \"MinY\", DoubleValue (0.0),\n                                 \"DeltaX\", DoubleValue (50.0),\n                                 \"DeltaY\", DoubleValue (0.0),\n                                 \"GridWidth\", UintegerValue (4),\n                                 \"LayoutType\", StringValue (\"RowFirst\"));\n\n  mobility.SetMobilityModel (\"ns3::ConstantVelocityMobilityModel\");\n  mobility.Install (vehicles);\n\n  for (uint32_t i = 0; i < vehicles.GetN (); ++i)\n    {\n      Ptr<ConstantVelocityMobilityModel> mobility = vehicles.Get (i)->GetObject<ConstantVelocityMobilityModel> ();\n      mobility->SetVelocity (Vector (20.0, 0.0, 0.0)); // 20 m/s constant speed\n    }\n\n  // Set up UDP server on vehicle 0\n  uint16_t port = 9;\n  UdpEchoServerHelper echoServer (port);\n  ApplicationContainer serverApp = echoServer.Install (vehicles.Get (0));\n  serverApp.Start (Seconds (1.0));\n  serverApp.Stop (Seconds (10.0));\n\n  // Set up UDP clients on vehicles 1, 2, and 3\n  UdpEchoClientHelper echoClient (vehicleInterfaces.GetAddress (0), port);\n  echoClient.SetAttribute (\"MaxPackets\", UintegerValue (10));\n  echoClient.SetAttribute (\"Interval\", TimeValue (Seconds (1.0)));\n  echoClient.SetAttribute (\"PacketSize\", UintegerValue (1024));\n\n  ApplicationContainer clientApps;\n  for (uint32_t i = 1; i < vehicles.GetN (); ++i)\n    {\n      clientApps.Add (echoClient.Install (vehicles.Get (i)));\n    }\n  clientApps.Start (Seconds (2.0));\n  clientApps.Stop (Seconds (10.0));\n\n  // Enable pcap tracing\n  wifiPhy.EnablePcap (\"vehicular-network\", devices);\n\n  // FlowMonitor for performance analysis\n  FlowMonitorHelper flowMonitorHelper;\n  Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll ();\n\n  // NetAnim for visualization\n  AnimationInterface anim (\"vehicular-network-animation.xml\");\n  anim.SetConstantPosition (vehicles.Get (0), 0.0, 0.0);\n  anim.SetConstantPosition (vehicles.Get (1), 50.0, 0.0);\n  anim.SetConstantPosition (vehicles.Get (2), 100.0, 0.0);\n  anim.SetConstantPosition (vehicles.Get (3), 150.0, 0.0);\n\n  // Run the simulation\n  Simulator::Stop (Seconds (10.0));\n  Simulator::Run ();\n\n  // Analyze flow statistics\n  flowMonitor->CheckForLostPackets ();\n  Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowMonitorHelper.GetClassifier ());\n  FlowMonitor::FlowStatsContainer stats = flowMonitor->GetFlowStats ();\n\n  for (auto it = stats.begin (); it != stats.end (); ++it)\n    {\n      Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (it->first);\n      std::cout << \"Flow from \" << t.sourceAddress << \" to \" << t.destinationAddress << std::endl;\n      std::cout << \"  Tx Packets: \" << it->second.txPackets << std::endl;\n      std::cout << \"  Rx Packets: \" << it->second.rxPackets << std::endl;\n      std::cout << \"  Delay: \" << it->second.delaySum.GetSeconds () << \" seconds\" << std::endl;\n    }\n\n  Simulator::Destroy ();\n  return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple sensor network in ns-3, where five sensor nodes are deployed in a star topology around a central sink node. The nodes communicate using a low-power wireless communication protocol such as 802.15.4. The sensor nodes periodically send data to the sink node via UDP. Measure packet delivery, latency, and throughput. Visualize the network using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"SimpleSensorNetwork\");\n\nint main (int argc, char *argv[])\n{\n  LogComponentEnable (\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n  LogComponentEnable (\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n  // Create 6 nodes (5 sensors + 1 sink)\n  NodeContainer sensorNodes;\n  sensorNodes.Create (5);\n  \n  NodeContainer sinkNode;\n  sinkNode.Create (1);\n\n  NodeContainer allNodes = NodeContainer (sensorNodes, sinkNode);\n\n  // Set up WiFi 802.15.4\n  WifiHelper wifi;\n  wifi.SetStandard (WIFI_PHY_STANDARD_80211_15_4);\n  \n  YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default ();\n  YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default ();\n  wifiPhy.SetChannel (wifiChannel.Create ());\n  \n  WifiMacHelper wifiMac;\n  wifiMac.SetType (\"ns3::AdhocWifiMac\");\n  \n  NetDeviceContainer devices = wifi.Install (wifiPhy, wifiMac, allNodes);\n\n  // Install Internet stack\n  InternetStackHelper stack;\n  stack.Install (allNodes);\n\n  // Assign IP addresses\n  Ipv4AddressHelper address;\n  address.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign (devices);\n\n  // Set up mobility model for sensor nodes (fixed positions)\n  MobilityHelper mobility;\n  Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator> ();\n\n  // Position the sink node at the center\n  positionAlloc->Add (Vector (50.0, 50.0, 0.0));\n\n  // Position the sensor nodes around the sink in a star topology\n  positionAlloc->Add (Vector (100.0, 50.0, 0.0));  // Sensor 1\n  positionAlloc->Add (Vector (50.0, 100.0, 0.0));  // Sensor 2\n  positionAlloc->Add (Vector (0.0, 50.0, 0.0));    // Sensor 3\n  positionAlloc->Add (Vector (50.0, 0.0, 0.0));    // Sensor 4\n  positionAlloc->Add (Vector (75.0, 75.0, 0.0));   // Sensor 5\n\n  mobility.SetPositionAllocator (positionAlloc);\n  mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install (allNodes);\n\n  // Set up UDP communication between sensors and sink\n  UdpEchoServerHelper echoServer (9);  // Port 9 for sink node\n  ApplicationContainer serverApps = echoServer.Install (sinkNode.Get (0));\n  serverApps.Start (Seconds (1.0));\n  serverApps.Stop (Seconds (10.0));\n\n  UdpEchoClientHelper echoClient (interfaces.GetAddress (5), 9); // Sink address\n  echoClient.SetAttribute (\"MaxPackets\", UintegerValue (1));\n  echoClient.SetAttribute (\"Interval\", TimeValue (Seconds (1.0))); // Periodic data\n  echoClient.SetAttribute (\"PacketSize\", UintegerValue (1024)); // 1 KB data\n\n  // Install client applications on sensor nodes\n  ApplicationContainer clientApps;\n  for (uint32_t i = 0; i < sensorNodes.GetN (); ++i)\n    {\n      clientApps.Add (echoClient.Install (sensorNodes.Get (i)));\n    }\n  clientApps.Start (Seconds (2.0));\n  clientApps.Stop (Seconds (10.0));\n\n  // Set up FlowMonitor for measuring performance\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll ();\n\n  // Set up NetAnim for visualization\n  AnimationInterface anim (\"sensor-network.xml\");\n  anim.SetConstantPosition (sinkNode.Get (0), 50.0, 50.0);  // Sink at center\n  for (uint32_t i = 0; i < sensorNodes.GetN (); ++i)\n    {\n      anim.SetConstantPosition (sensorNodes.Get (i), positionAlloc->GetNext ());\n    }\n\n  Simulator::Stop (Seconds (10.0));\n  Simulator::Run ();\n\n  // FlowMonitor analysis\n  monitor->SerializeToXmlFile (\"sensor-network-flowmon.xml\", true, true);\n\n  Simulator::Destroy ();\n  return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a basic wireless network in ns-3 where two nodes communicate using TCP over Wi-Fi. One node acts as a TCP server, and the other node as a TCP client. Measure and output the throughput of the communication. Use the AODV routing protocol and visualize the network using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/aodv-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE (\"TcpWifiExample\");\n\nint main (int argc, char *argv[])\n{\n  // Set the simulation time\n  double simTime = 10.0;\n\n  // Create two nodes\n  NodeContainer wifiNodes;\n  wifiNodes.Create (2);\n\n  // Setup Wi-Fi physical and MAC layers\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default ();\n  YansWifiPhyHelper phy = YansWifiPhyHelper::Default ();\n  phy.SetChannel (channel.Create ());\n\n  WifiHelper wifi;\n  wifi.SetRemoteStationManager (\"ns3::AarfWifiManager\");\n\n  WifiMacHelper mac;\n  mac.SetType (\"ns3::AdhocWifiMac\");\n\n  NetDeviceContainer devices = wifi.Install (phy, mac, wifiNodes);\n\n  // Set mobility models for the nodes\n  MobilityHelper mobility;\n  mobility.SetPositionAllocator (\"ns3::GridPositionAllocator\",\n                                 \"MinX\", DoubleValue (0.0),\n                                 \"MinY\", DoubleValue (0.0),\n                                 \"DeltaX\", DoubleValue (5.0),\n                                 \"DeltaY\", DoubleValue (10.0),\n                                 \"GridWidth\", UintegerValue (2),\n                                 \"LayoutType\", StringValue (\"RowFirst\"));\n  mobility.SetMobilityModel (\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install (wifiNodes);\n\n  // Install Internet stack with AODV routing protocol\n  AodvHelper aodv;\n  InternetStackHelper internet;\n  internet.SetRoutingHelper (aodv);\n  internet.Install (wifiNodes);\n\n  // Assign IP addresses\n  Ipv4AddressHelper ipv4;\n  ipv4.SetBase (\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer interfaces = ipv4.Assign (devices);\n\n  // Setup TCP server on Node 1\n  uint16_t port = 9;\n  Address serverAddress (InetSocketAddress (interfaces.GetAddress (1), port));\n  PacketSinkHelper sink (\"ns3::TcpSocketFactory\", serverAddress);\n  ApplicationContainer serverApp = sink.Install (wifiNodes.Get (1));\n  serverApp.Start (Seconds (1.0));\n  serverApp.Stop (Seconds (simTime));\n\n  // Setup TCP client on Node 0\n  OnOffHelper client (\"ns3::TcpSocketFactory\", serverAddress);\n  client.SetAttribute (\"OnTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=1]\"));\n  client.SetAttribute (\"OffTime\", StringValue (\"ns3::ConstantRandomVariable[Constant=0]\"));\n  client.SetAttribute (\"DataRate\", DataRateValue (DataRate (\"1Mbps\")));\n  client.SetAttribute (\"PacketSize\", UintegerValue (1024));\n\n  ApplicationContainer clientApp = client.Install (wifiNodes.Get (0));\n  clientApp.Start (Seconds (2.0));\n  clientApp.Stop (Seconds (simTime));\n\n  // Enable NetAnim\n  AnimationInterface anim (\"tcp_wifi_example.xml\");\n\n  // Set up FlowMonitor to calculate throughput\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n  // Run the simulation\n  Simulator::Stop (Seconds (simTime));\n  Simulator::Run ();\n\n  // Calculate throughput\n  monitor->CheckForLostPackets ();\n  Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier> (flowmon.GetClassifier ());\n  std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats ();\n  \n  for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin (); i != stats.end (); ++i)\n    {\n      Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow (i->first);\n      if (t.destinationPort == port)\n        {\n          std::cout << \"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\\n\";\n          std::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n          std::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n          std::cout << \"  Throughput: \" << i->second.rxBytes * 8.0 / simTime / 1000000 << \" Mbps\\n\";\n        }\n    }\n\n  // Destroy the simulation\n  Simulator::Destroy ();\n  return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless network using ns-3 with two Wi-Fi access points (APs) and a group of 6 mobile nodes. The nodes move randomly within a designated area and switch between the two APs based on signal strength. Use the RandomWalk2dMobilityModel to model the movement of nodes and visualize the network in NetAnim. Measure handover events and packet loss as nodes switch between APs."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiHandoverExample\");\n\nint main(int argc, char *argv[])\n{\n  LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n  LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n  // Create 2 AP nodes and 6 mobile nodes\n  NodeContainer wifiApNodes;\n  wifiApNodes.Create(2);\n\n  NodeContainer wifiStaNodes;\n  wifiStaNodes.Create(6);\n\n  // Set up Wi-Fi PHY and channel\n  YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n  YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n  phy.SetChannel(channel.Create());\n\n  // Set up Wi-Fi\n  WifiHelper wifi;\n  wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n  WifiMacHelper mac;\n  Ssid ssid = Ssid(\"HandoverNetwork\");\n\n  // Access Point setup\n  mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n  NetDeviceContainer apDevices = wifi.Install(phy, mac, wifiApNodes);\n\n  // Station (Mobile) setup\n  mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n  NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n  // Install Internet stack\n  InternetStackHelper stack;\n  stack.Install(wifiApNodes);\n  stack.Install(wifiStaNodes);\n\n  // Assign IP addresses\n  Ipv4AddressHelper address;\n  address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer apInterfaces = address.Assign(apDevices);\n  Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n\n  // Mobility model for APs (static)\n  MobilityHelper mobility;\n  mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n  mobility.Install(wifiApNodes);\n\n  // Mobility model for stations (random movement)\n  MobilityHelper mobilitySta;\n  mobilitySta.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                               \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n  mobilitySta.Install(wifiStaNodes);\n\n  // Set up UDP echo server on one of the AP nodes\n  UdpEchoServerHelper echoServer(9);\n  ApplicationContainer serverApps = echoServer.Install(wifiApNodes.Get(0));\n  serverApps.Start(Seconds(1.0));\n  serverApps.Stop(Seconds(20.0));\n\n  // Set up UDP echo clients on the mobile nodes\n  UdpEchoClientHelper echoClient(apInterfaces.GetAddress(0), 9);\n  echoClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n  echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n  echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n  ApplicationContainer clientApps = echoClient.Install(wifiStaNodes);\n  clientApps.Start(Seconds(2.0));\n  clientApps.Stop(Seconds(20.0));\n\n  // Enable Flow Monitor to measure performance\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n  // Set up NetAnim for visualization\n  AnimationInterface anim(\"wifi-handover.xml\");\n  anim.SetMaxPktsPerTraceFile(500000);\n  anim.SetMobilityPollInterval(Seconds(1));\n\n  // Run the simulation\n  Simulator::Stop(Seconds(20.0));\n  Simulator::Run();\n\n  // Print flow monitor statistics\n  monitor->SerializeToXmlFile(\"handover_flowmon.xml\", true, true);\n\n  Simulator::Destroy();\n  return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple star topology network using ns-3, where a central server communicates with multiple client nodes. The communication protocol used is TCP, and each client sends a series of data packets to the server. Measure the throughput, latency, and packet loss, and visualize the simulation using NetAnim. The network consists of one central server and 5 clients connected through point-to-point links."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"StarTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n  LogComponentEnable(\"TcpL4Protocol\", LOG_LEVEL_INFO);\n  LogComponentEnable(\"PacketSink\", LOG_LEVEL_INFO);\n\n  // Create the central node (server) and 5 client nodes\n  NodeContainer centralNode;\n  centralNode.Create(1);\n\n  NodeContainer clientNodes;\n  clientNodes.Create(5);\n\n  // Set up point-to-point links between the central node and each client\n  PointToPointHelper p2p;\n  p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n  p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n  NetDeviceContainer serverDevices, clientDevices;\n  for (uint32_t i = 0; i < clientNodes.GetN(); ++i)\n  {\n    NodeContainer link = NodeContainer(centralNode.Get(0), clientNodes.Get(i));\n    NetDeviceContainer devices = p2p.Install(link);\n    serverDevices.Add(devices.Get(0));\n    clientDevices.Add(devices.Get(1));\n  }\n\n  // Install Internet stack\n  InternetStackHelper stack;\n  stack.Install(centralNode);\n  stack.Install(clientNodes);\n\n  // Assign IP addresses\n  Ipv4AddressHelper address;\n  address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer serverInterfaces;\n  serverInterfaces = address.Assign(serverDevices);\n\n  Ipv4InterfaceContainer clientInterfaces;\n  clientInterfaces = address.Assign(clientDevices);\n\n  // Create a TCP server on the central node\n  uint16_t port = 9; // Well-known port for TCP\n  Address serverAddress(InetSocketAddress(serverInterfaces.GetAddress(0), port));\n  PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n  ApplicationContainer serverApp = sinkHelper.Install(centralNode.Get(0));\n  serverApp.Start(Seconds(1.0));\n  serverApp.Stop(Seconds(10.0));\n\n  // Create TCP client applications on each client node\n  OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", serverAddress);\n  clientHelper.SetAttribute(\"DataRate\", StringValue(\"2Mbps\"));\n  clientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n  ApplicationContainer clientApps;\n  for (uint32_t i = 0; i < clientNodes.GetN(); ++i)\n  {\n    clientHelper.SetAttribute(\"StartTime\", TimeValue(Seconds(2.0 + i)));\n    clientHelper.SetAttribute(\"StopTime\", TimeValue(Seconds(10.0)));\n    clientApps.Add(clientHelper.Install(clientNodes.Get(i)));\n  }\n\n  // Enable Flow Monitor for performance analysis\n  FlowMonitorHelper flowmon;\n  Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n  // Set up NetAnim for visualization\n  AnimationInterface anim(\"star_topology.xml\");\n  anim.SetConstantPosition(centralNode.Get(0), 50, 50);\n  for (uint32_t i = 0; i < clientNodes.GetN(); ++i)\n  {\n    anim.SetConstantPosition(clientNodes.Get(i), 20 + i * 20, 20);\n  }\n\n  // Run the simulation\n  Simulator::Stop(Seconds(10.0));\n  Simulator::Run();\n\n  // Flow Monitor analysis\n  monitor->SerializeToXmlFile(\"star_flowmon.xml\", true, true);\n\n  Simulator::Destroy();\n  return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an NS-3 simulation that conducts an experiment to analyze the performance of WiFi clear channel conditions under different data rates using the 802.11b standard. Implement an `Experiment` class to handle the setup and execution of the experiment, including methods for traffic generation, packet reception, and node positioning. In the `main` function, set up a loop to test various transmission modes, configure the WiFi helper and PHY layer parameters, and simulate the effects of different received signal strengths on packet reception. Finally, collect the results in a Gnuplot dataset and generate a visual output in EPS format, showing the relationship between RSS and the number of packets received."}, {"role": "assistant", "content": "#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/string.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ClearChannelCmu\");\n\n/**\n * WiFi clear channel cmu experiment class.\n *\n * It handles the creation and run of an experiment.\n */\nclass Experiment\n{\n  public:\n    Experiment();\n    /**\n     * Constructor.\n     * \\param name The name of the experiment.\n     */\n    Experiment(std::string name);\n    /**\n     * Run an experiment.\n     * \\param wifi      //!< The WifiHelper class.\n     * \\param wifiPhy   //!< The YansWifiPhyHelper class.\n     * \\param wifiMac   //!< The WifiMacHelper class.\n     * \\param wifiChannel //!< The YansWifiChannelHelper class.\n     * \\return the number of received packets.\n     */\n    uint32_t Run(const WifiHelper& wifi,\n                 const YansWifiPhyHelper& wifiPhy,\n                 const WifiMacHelper& wifiMac,\n                 const YansWifiChannelHelper& wifiChannel);\n\n  private:\n    /**\n     * Receive a packet.\n     * \\param socket The receiving socket.\n     */\n    void ReceivePacket(Ptr<Socket> socket);\n    /**\n     * Set the position of a node.\n     * \\param node The node.\n     * \\param position The position of the node.\n     */\n    void SetPosition(Ptr<Node> node, Vector position);\n    /**\n     * Get the position of a node.\n     * \\param node The node.\n     * \\return the position of the node.\n     */\n    Vector GetPosition(Ptr<Node> node);\n    /**\n     * Setup the receiving socket.\n     * \\param node The receiving node.\n     * \\return the socket.\n     */\n    Ptr<Socket> SetupPacketReceive(Ptr<Node> node);\n    /**\n     * Generate the traffic.\n     * \\param socket The sending socket.\n     * \\param pktSize The packet size.\n     * \\param pktCount The number of packets to send.\n     * \\param pktInterval The time between packets.\n     */\n    void GenerateTraffic(Ptr<Socket> socket, uint32_t pktSize, uint32_t pktCount, Time pktInterval);\n\n    uint32_t m_pktsTotal;      //!< Total number of received packets\n    Gnuplot2dDataset m_output; //!< Output dataset.\n};\n\nExperiment::Experiment()\n{\n}\n\nExperiment::Experiment(std::string name)\n    : m_output(name)\n{\n    m_output.SetStyle(Gnuplot2dDataset::LINES);\n}\n\nvoid\nExperiment::SetPosition(Ptr<Node> node, Vector position)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    mobility->SetPosition(position);\n}\n\nVector\nExperiment::GetPosition(Ptr<Node> node)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    return mobility->GetPosition();\n}\n\nvoid\nExperiment::ReceivePacket(Ptr<Socket> socket)\n{\n    Ptr<Packet> packet;\n    while ((packet = socket->Recv()))\n    {\n        m_pktsTotal++;\n    }\n}\n\nPtr<Socket>\nExperiment::SetupPacketReceive(Ptr<Node> node)\n{\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> sink = Socket::CreateSocket(node, tid);\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 80);\n    sink->Bind(local);\n    sink->SetRecvCallback(MakeCallback(&Experiment::ReceivePacket, this));\n    return sink;\n}\n\nvoid\nExperiment::GenerateTraffic(Ptr<Socket> socket,\n                            uint32_t pktSize,\n                            uint32_t pktCount,\n                            Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval,\n                            &Experiment::GenerateTraffic,\n                            this,\n                            socket,\n                            pktSize,\n                            pktCount - 1,\n                            pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\nuint32_t\nExperiment::Run(const WifiHelper& wifi,\n                const YansWifiPhyHelper& wifiPhy,\n                const WifiMacHelper& wifiMac,\n                const YansWifiChannelHelper& wifiChannel)\n{\n    m_pktsTotal = 0;\n\n    NodeContainer c;\n    c.Create(2);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    YansWifiPhyHelper phy = wifiPhy;\n    phy.SetChannel(wifiChannel.Create());\n\n    NetDeviceContainer devices = wifi.Install(phy, wifiMac, c);\n\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    Ipv4AddressHelper ipv4;\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    Ptr<Socket> recvSink = SetupPacketReceive(c.Get(0));\n\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> source = Socket::CreateSocket(c.Get(1), tid);\n    InetSocketAddress remote = InetSocketAddress(Ipv4Address(\"255.255.255.255\"), 80);\n    source->SetAllowBroadcast(true);\n    source->Connect(remote);\n    uint32_t packetSize = 1014;\n    uint32_t maxPacketCount = 200;\n    Time interPacketInterval = Seconds(1.);\n    Simulator::Schedule(Seconds(1.0),\n                        &Experiment::GenerateTraffic,\n                        this,\n                        source,\n                        packetSize,\n                        maxPacketCount,\n                        interPacketInterval);\n    Simulator::Run();\n\n    Simulator::Destroy();\n\n    return m_pktsTotal;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::ofstream outfile(\"clear-channel.plt\");\n\n    const std::vector<std::string> modes{\n        \"DsssRate1Mbps\",\n        \"DsssRate2Mbps\",\n        \"DsssRate5_5Mbps\",\n        \"DsssRate11Mbps\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Gnuplot gnuplot = Gnuplot(\"clear-channel.eps\");\n\n    for (uint32_t i = 0; i < modes.size(); i++)\n    {\n        std::cout << modes[i] << std::endl;\n        Gnuplot2dDataset dataset(modes[i]);\n\n        for (double rss = -102.0; rss <= -80.0; rss += 0.5)\n        {\n            Experiment experiment;\n            dataset.SetStyle(Gnuplot2dDataset::LINES);\n\n            WifiHelper wifi;\n            wifi.SetStandard(WIFI_STANDARD_80211b);\n            WifiMacHelper wifiMac;\n            Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\",\n                               StringValue(modes[i]));\n            wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                         \"DataMode\",\n                                         StringValue(modes[i]),\n                                         \"ControlMode\",\n                                         StringValue(modes[i]));\n            wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n            YansWifiPhyHelper wifiPhy;\n            YansWifiChannelHelper wifiChannel;\n            wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n            wifiChannel.AddPropagationLoss(\"ns3::FixedRssLossModel\", \"Rss\", DoubleValue(rss));\n\n            NS_LOG_DEBUG(modes[i]);\n            experiment = Experiment(modes[i]);\n            wifiPhy.Set(\"TxPowerStart\", DoubleValue(15.0));\n            wifiPhy.Set(\"TxPowerEnd\", DoubleValue(15.0));\n            wifiPhy.Set(\"RxGain\", DoubleValue(0));\n            wifiPhy.Set(\"RxNoiseFigure\", DoubleValue(7));\n            uint32_t pktsRecvd = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel);\n            dataset.Add(rss, pktsRecvd);\n        }\n\n        gnuplot.AddDataset(dataset);\n    }\n    gnuplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    gnuplot.SetLegend(\"RSS(dBm)\", \"Number of packets received\");\n    gnuplot.SetExtra(\"set xrange [-102:-83]\");\n    gnuplot.GenerateOutput(outfile);\n    outfile.close();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a hybrid topology network using ns-3 with both TCP and UDP protocols. The network consists of two parts: (1) a star topology using TCP where multiple clients communicate with a central server and (2) a mesh topology using UDP where multiple nodes communicate with each other in an ad-hoc manner. Measure the performance of both protocols, including throughput, latency, and packet loss, and visualize the simulation using NetAnim."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"HybridTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n  // Log setup\n  LogComponentEnable(\"TcpL4Protocol\", LOG_LEVEL_INFO);\n  LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n  LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n  \n  // Part 1: Star topology using TCP\n  NodeContainer starNodes;\n  starNodes.Create(6); // Central node + 5 client nodes\n  \n  PointToPointHelper p2p;\n  p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n  p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n  \n  // Install point-to-point devices between central node and client nodes\n  NetDeviceContainer p2pDevices;\n  for (uint32_t i = 1; i < starNodes.GetN(); ++i)\n  {\n    NodeContainer link = NodeContainer(starNodes.Get(0), starNodes.Get(i));\n    NetDeviceContainer devices = p2p.Install(link);\n    p2pDevices.Add(devices);\n  }\n  \n  // Part 2: Mesh topology using UDP\n  NodeContainer meshNodes;\n  meshNodes.Create(4); // 4 mesh nodes\n\n  MeshHelper mesh;\n  mesh.SetStackInstaller(\"ns3::Dot11sStack\");\n  mesh.SetSpreadInterfaceChannels(MeshHelper::SPREAD_CHANNELS);\n  mesh.SetMacType(\"RandomStart\", TimeValue(Seconds(0.1)));\n  mesh.SetNumberOfInterfaces(1);\n\n  NetDeviceContainer meshDevices = mesh.Install(meshNodes);\n\n  // Internet stack\n  InternetStackHelper internet;\n  internet.Install(starNodes);\n  internet.Install(meshNodes);\n\n  // Assign IP addresses\n  Ipv4AddressHelper address;\n  address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n  address.Assign(p2pDevices);\n  \n  address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n  Ipv4InterfaceContainer meshInterfaces = address.Assign(meshDevices);\n\n  // TCP Application (Star topology)\n  uint16_t tcpPort = 9; // Well-known port for TCP\n  Address tcpServerAddress(InetSocketAddress(Ipv4Address::GetAny(), tcpPort));\n  \n  PacketSinkHelper tcpSinkHelper(\"ns3::TcpSocketFactory\", tcpServerAddress);\n  ApplicationContainer tcpServerApp = tcpSinkHelper.Install(starNodes.Get(0)); // Central node as server\n  tcpServerApp.Start(Seconds(1.0));\n  tcpServerApp.Stop(Seconds(20.0));\n  \n  OnOffHelper tcpClientHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(starNodes.Get(0)->GetObject<Ipv4>()->GetAddress(1, 0).GetLocal(), tcpPort));\n  tcpClientHelper.SetAttribute(\"DataRate\", StringValue(\"2Mbps\"));\n  tcpClientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n  \n  ApplicationContainer tcpClientApps;\n  for (uint32_t i = 1; i < starNodes.GetN(); ++i)\n  {\n    tcpClientHelper.SetAttribute(\"StartTime\", TimeValue(Seconds(2.0 + i)));\n    tcpClientHelper.SetAttribute(\"StopTime\", TimeValue(Seconds(20.0)));\n    tcpClientApps.Add(tcpClientHelper.Install(starNodes.Get(i)));\n  }\n\n  // UDP Application (Mesh topology)\n  uint16_t udpPort = 8080; // UDP echo port\n  UdpEchoServerHelper udpServer(udpPort);\n  ApplicationContainer udpServerApp = udpServer.Install(meshNodes.Get(0)); // First node as server\n  udpServerApp.Start(Seconds(1.0));\n  udpServerApp.Stop(Seconds(20.0));\n\n  UdpEchoClientHelper udpClient(meshInterfaces.GetAddress(0), udpPort);\n  udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n  udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n  udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n  ApplicationContainer udpClientApps;\n  for (uint32_t i = 1; i < meshNodes.GetN(); ++i)\n  {\n    udpClient.SetAttribute(\"StartTime\", TimeValue(Seconds(2.0 + i)));\n    udpClient.SetAttribute(\"StopTime\", TimeValue(Seconds(20.0)));\n    udpClientApps.Add(udpClient.Install(meshNodes.Get(i)));\n  }\n\n  // Flow monitor\n  FlowMonitorHelper flowMonitor;\n  Ptr<FlowMonitor> monitor = flowMonitor.InstallAll();\n\n  // Set up NetAnim for visualization\n  AnimationInterface anim(\"hybrid_topology.xml\");\n  anim.SetConstantPosition(starNodes.Get(0), 50, 50); // Central node position\n  for (uint32_t i = 1; i < starNodes.GetN(); ++i)\n  {\n    anim.SetConstantPosition(starNodes.Get(i), 20 + i * 10, 50);\n  }\n  for (uint32_t i = 0; i < meshNodes.GetN(); ++i)\n  {\n    anim.SetConstantPosition(meshNodes.Get(i), 50, 20 + i * 10);\n  }\n\n  Simulator::Stop(Seconds(20.0));\n  Simulator::Run();\n  \n  monitor->SerializeToXmlFile(\"hybrid_flowmon.xml\", true, true);\n  \n  Simulator::Destroy();\n  return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless ad-hoc network using ns-3 with 5 nodes using WiFi. Nodes communicate via peer-to-peer ad-hoc mode, with random mobility applied to the nodes. One of the nodes will generate UDP traffic to be sent to another node, and the simulation will track packet loss and throughput. The output will be saved in a file for further analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocWifiSimulation\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Enable logging for UDP\n    LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n\n    // Create 5 nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(5);\n\n    // Set up Wifi PHY and MAC for ad-hoc mode\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer wifiDevices = wifi.Install(wifiPhy, wifiMac, wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer wifiInterfaces = address.Assign(wifiDevices);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(wifiNodes);\n\n    // Install UDP server on node 1\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Install UDP client on node 0\n    UdpClientHelper udpClient(wifiInterfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up FlowMonitor to track traffic\n    FlowMonitorHelper flowmonHelper;\n    Ptr<FlowMonitor> monitor = flowmonHelper.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Print FlowMonitor statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow ID: \" << i->first << \" Src Addr \" << t.sourceAddress << \" Dst Addr \" << t.destinationAddress);\n        NS_LOG_UNCOND(\"Tx Packets = \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"Rx Packets = \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"Throughput: \" << i->second.rxBytes * 8.0 / (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) / 1024 / 1024 << \" Mbps\");\n    }\n\n    // Clean up and exit\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless ad-hoc network using the AODV (Ad hoc On-Demand Distance Vector) routing protocol in ns-3. The network consists of 5 nodes, all of which are randomly placed in a 100x100 meter area. UDP traffic will be sent from one node to another, and the simulation will track the packet transmission, route discovery, and delivery using the AODV protocol. Pcap traces will also be enabled for further analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/udp-echo-helper.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AODVAdhocNetwork\");\n\nint main(int argc, char *argv[])\n{\n    // Set up logging for AODV\n    LogComponentEnable(\"AodvRoutingProtocol\", LOG_LEVEL_INFO);\n\n    // Create 5 nodes\n    NodeContainer nodes;\n    nodes.Create(5);\n\n    // Set up wireless channel and PHY layer\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Configure WiFi (non-infrastructure mode)\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set mobility model (random placement of nodes)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install internet stack with AODV routing protocol\n    AodvHelper aodv;\n    Ipv4ListRoutingHelper list;\n    list.Add(aodv, 100);\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(list);\n    internet.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP Echo Server on node 1\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP Echo Client on node 0 to send packets to node 1\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable pcap tracing\n    phy.EnablePcap(\"aodv-adhoc\", devices);\n\n    // Set up flow monitor to track network performance\n    FlowMonitorHelper flowmonHelper;\n    Ptr<FlowMonitor> monitor = flowmonHelper.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Print flow monitor statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 /\n                                            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n                                            1024 / 1024 << \" Mbps\");\n    }\n\n    // Clean up and exit\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a simple TCP connection over a point-to-point link between two nodes in ns-3. The simulation will involve two nodes, one acting as a TCP server and the other as a TCP client. The client will send data to the server using TCP, and the simulation will record the number of bytes successfully transmitted and received. Additionally, enable packet tracing to observe the packet-level behavior of TCP during the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for TCP\n    LogComponentEnable(\"TcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Create a point-to-point link between the nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP server on node 1\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = packetSinkHelper.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create a TCP client on node 0\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", Address(InetSocketAddress(interfaces.GetAddress(1), port)));\n    clientHelper.SetAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    clientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = clientHelper.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable packet tracing\n    pointToPoint.EnablePcapAll(\"tcp-point-to-point\");\n\n    // Monitor the flow\n    FlowMonitorHelper flowmonHelper;\n    Ptr<FlowMonitor> monitor = flowmonHelper.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(11.0));\n    Simulator::Run();\n\n    // Print flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 /\n                                            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n                                            1024 / 1024 << \" Mbps\");\n    }\n\n    // Clean up\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a wireless network with four nodes using Wi-Fi in ns-3. One node acts as an Access Point (AP), and the other three act as Wi-Fi stations (STA) connected to the AP. The stations will communicate with each other through the AP. The simulation will capture and display packet traces and measure the performance in terms of throughput and packet loss."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set the default Wi-Fi standard to 802.11g\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(\"DsssRate11Mbps\"));\n\n    // Create 4 nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(3);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Configure the Wi-Fi physical layer and MAC\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-ssid\");\n\n    // Configure Wi-Fi stations (STAs)\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure the Access Point (AP)\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set up mobility model for the stations and AP\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(wifiStaNodes);\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses to the Wi-Fi devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces;\n    staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface;\n    apInterface = address.Assign(apDevice);\n\n    // Set up an application to send UDP traffic from STA 1 to STA 2 through the AP\n    uint16_t port = 9;\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApp = echoServer.Install(wifiStaNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(staInterfaces.GetAddress(1), port);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(wifiStaNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable packet tracing\n    phy.EnablePcap(\"wifi-network\", apDevice.Get(0));\n\n    // Monitor the flow\n    FlowMonitorHelper flowmonHelper;\n    Ptr<FlowMonitor> monitor = flowmonHelper.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(11.0));\n    Simulator::Run();\n\n    // Print flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 /\n                                            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n                                            1024 / 1024 << \" Mbps\");\n    }\n\n    // Clean up\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Mobile Ad Hoc Network (MANET) in ns-3 with four nodes using AODV (Ad hoc On-Demand Distance Vector) routing. The nodes move randomly within a defined boundary, and one node sends UDP packets to another node. Capture packet traces and monitor the performance in terms of throughput and packet loss."}, {"role": "assistant", "content": "#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ManetSimulationExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set default time resolution\n    Time::SetResolution(Time::NS);\n\n    // Create four nodes\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Set up the Wi-Fi network (Ad Hoc mode)\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\", \"DataMode\", StringValue(\"DsssRate2Mbps\"));\n\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer wifiDevices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Install the Internet stack and AODV routing protocol\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);  // Use AODV for routing\n    internet.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(wifiDevices);\n\n    // Set up random mobility for the nodes\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(nodes);\n\n    // Create a UDP server on node 1\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create a UDP client on node 0\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable pcap tracing\n    wifiPhy.EnablePcap(\"manet\", wifiDevices);\n\n    // Set up flow monitoring\n    FlowMonitorHelper flowmonHelper;\n    Ptr<FlowMonitor> monitor = flowmonHelper.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(11.0));\n    Simulator::Run();\n\n    // Print flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmonHelper.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 /\n                                            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n                                            1024 / 1024 << \" Mbps\");\n    }\n\n    // Clean up and exit\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Point-to-Point (P2P) Network with three nodes using TCP protocol in ns-3. Node 0 acts as a TCP client, sending data to Node 2 (TCP server), with Node 1 serving as an intermediate router. Monitor the network's performance by collecting data throughput and packet loss statistics. Enable packet capturing (PCAP) for deeper analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"P2PNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(3); // Node 0 -> Client, Node 1 -> Router, Node 2 -> Server\n\n    // Configure Point-to-Point channels\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on node pairs\n    NetDeviceContainer devices01 = pointToPoint.Install(nodes.Get(0), nodes.Get(1));\n    NetDeviceContainer devices12 = pointToPoint.Install(nodes.Get(1), nodes.Get(2));\n\n    // Install the Internet stack on nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces01 = address.Assign(devices01);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces12 = address.Assign(devices12);\n\n    // Set up routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create a TCP server on node 2\n    uint16_t port = 9;\n    Address serverAddress(InetSocketAddress(interfaces12.GetAddress(1), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = packetSinkHelper.Install(nodes.Get(2));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create a TCP client on node 0\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", Address());\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientHelper.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"1Mbps\")));\n    clientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp;\n    clientHelper.SetAttribute(\"Remote\", AddressValue(serverAddress));\n    clientApp = clientHelper.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing\n    pointToPoint.EnablePcapAll(\"p2p-network\");\n\n    // Set up Flow Monitor to collect throughput and packet loss statistics\n    FlowMonitorHelper flowMonitor;\n    Ptr<FlowMonitor> monitor = flowMonitor.InstallAll();\n\n    // Run simulation\n    Simulator::Stop(Seconds(11.0));\n    Simulator::Run();\n\n    // Collect and print flow monitor statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitor.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"  Lost Packets: \" << i->second.lostPackets);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 /\n                                            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n                                            1024 / 1024 << \" Mbps\");\n    }\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wireless Ad-Hoc Network (MANET) with 5 nodes using the AODV (Ad-hoc On-Demand Distance Vector) routing protocol in ns-3. Nodes are mobile and will move around in a specified area, maintaining communication between nodes even as they move. Collect mobility trace information and analyze the packet delivery using AODV."}, {"role": "assistant", "content": "#include \"ns3/aodv-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/animation-interface.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocAODVExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time and logging\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(5); // Create 5 mobile nodes\n\n    // Setup WiFi physical layer\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n    \n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Setup WiFi MAC layer (Ad-hoc mode)\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Install the AODV routing protocol on the nodes\n    AodvHelper aodv;\n    Ipv4ListRoutingHelper list;\n    list.Add(aodv, 100);\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(list);\n    internet.Install(nodes);\n\n    // Assign IP addresses to nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set mobility for nodes (they will move randomly in a rectangular field)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", StringValue(\"ns3::UniformRandomVariable[Min=1.0|Max=5.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=2.0]\"),\n                              \"PositionAllocator\", StringValue(\"ns3::RandomRectanglePositionAllocator\"));\n    mobility.Install(nodes);\n\n    // Create UDP server on node 4\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(4));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create UDP client on node 0 to send data to node 4\n    UdpClientHelper udpClient(interfaces.GetAddress(4), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable tracing\n    wifiPhy.EnablePcap(\"adhoc-aodv\", devices);\n    AnimationInterface anim(\"adhoc-aodv.xml\");\n\n    // Set up Flow Monitor to collect performance metrics\n    FlowMonitorHelper flowMonitor;\n    Ptr<FlowMonitor> monitor = flowMonitor.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    // Collect and print flow monitor statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitor.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"  Lost Packets: \" << i->second.lostPackets);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 /\n                                            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n                                            1024 / 1024 << \" Mbps\");\n    }\n\n    // End simulation\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Vehicular Ad-hoc Network (VANET) using DSDV (Destination-Sequenced Distance-Vector Routing) in ns-3. The simulation will model vehicles moving along a straight road, with each vehicle acting as a mobile node. These nodes communicate via WiFi and use the DSDV routing protocol to maintain routes between them. The simulation will track packet delivery, node mobility, and the overall network performance using DSDV."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/dsdv-helper.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/animation-interface.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"VanetDsdvExample\");\n\nint main(int argc, char *argv[])\n{\n    // Log configuration\n    LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n\n    // Set up 10 nodes (vehicles)\n    NodeContainer vehicles;\n    vehicles.Create(10);\n\n    // Set up WiFi network with Ad-Hoc mode\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, vehicles);\n\n    // Set mobility for vehicles (moving along a straight road)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(50.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(10),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(vehicles);\n\n    for (uint32_t i = 0; i < vehicles.GetN(); ++i)\n    {\n        Ptr<ConstantVelocityMobilityModel> mob = vehicles.Get(i)->GetObject<ConstantVelocityMobilityModel>();\n        mob->SetVelocity(Vector(20.0, 0.0, 0.0)); // Vehicles move at 20 m/s along the x-axis\n    }\n\n    // Install DSDV routing protocol\n    DsdvHelper dsdv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(dsdv);\n    internet.Install(vehicles);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Create a UDP server on the last vehicle\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(vehicles.Get(9));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Create a UDP client on the first vehicle to send packets to the server\n    UdpClientHelper udpClient(interfaces.GetAddress(9), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(320));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(vehicles.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(20.0));\n\n    // Enable tracing\n    wifiPhy.EnablePcap(\"vanet-dsdv\", devices);\n    AnimationInterface anim(\"vanet-dsdv.xml\");\n\n    // Flow Monitor to track performance\n    FlowMonitorHelper flowMonitor;\n    Ptr<FlowMonitor> monitor = flowMonitor.InstallAll();\n\n    // Run the simulation\n    Simulator::Stop(Seconds(20.0));\n    Simulator::Run();\n\n    // Output flow monitor statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowMonitor.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n\n    for (std::map<FlowId, FlowMonitor::FlowStats>::const_iterator i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        NS_LOG_UNCOND(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \" << t.destinationAddress << \")\");\n        NS_LOG_UNCOND(\"  Tx Packets: \" << i->second.txPackets);\n        NS_LOG_UNCOND(\"  Rx Packets: \" << i->second.rxPackets);\n        NS_LOG_UNCOND(\"  Lost Packets: \" << i->second.lostPackets);\n        NS_LOG_UNCOND(\"  Throughput: \" << i->second.rxBytes * 8.0 /\n                                            (i->second.timeLastRxPacket.GetSeconds() - i->second.timeFirstTxPacket.GetSeconds()) /\n                                            1024 / 1024 << \" Mbps\");\n    }\n\n    // End the simulation\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nDevelop an NS-3 simulation to validate error rate models for DSSS rates by calculating and plotting the Frame Success Rate against the Signal-to-Noise Ratio for various DSSS modes. In the `main` function, set the frame size and configure Gnuplot for output. Create instances of different error rate models, including Yans, Nist, and Table-based models, and loop through the defined DSSS modes. For each mode, compute the success rates based on varying SNR values and validate the results against expected ranges. Collect the data in a Gnuplot dataset and generate a visual output in EPS format, depicting the relationship between SNR and Frame Success Rate."}, {"role": "assistant", "content": "// This example is used to validate error rate models for DSSS rates.\n//\n// It outputs plots of the Frame Success Rate versus the Signal-to-noise ratio\n// for the DSSS error rate models and for every DSSS mode.\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t frameSizeBytes = 1500;\n    std::ofstream file(\"frame-success-rate-dsss.plt\");\n\n    const std::vector<std::string> modes{\n        \"DsssRate1Mbps\",\n        \"DsssRate2Mbps\",\n        \"DsssRate5_5Mbps\",\n        \"DsssRate11Mbps\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"FrameSize\", \"The frame size in bytes\", frameSizeBytes);\n    cmd.Parse(argc, argv);\n\n    Gnuplot plot = Gnuplot(\"frame-success-rate-dsss.eps\");\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n    WifiTxVector txVector;\n\n    uint32_t frameSizeBits = frameSizeBytes * 8;\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset dataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -10.0; snrDb <= 20.0; snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double psYans = yans->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (psYans < 0.0 || psYans > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            double psNist = nist->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (psNist < 0.0 || psNist > 1.0)\n            {\n                std::cout << psNist << std::endl;\n                // error\n                exit(1);\n            }\n            if (psNist != psYans)\n            {\n                exit(1);\n            }\n            double psTable = table->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (psTable < 0.0 || psTable > 1.0)\n            {\n                std::cout << psTable << std::endl;\n                // error\n                exit(1);\n            }\n            if (psTable != psYans)\n            {\n                exit(1);\n            }\n            dataset.Add(snrDb, psYans);\n        }\n\n        plot.AddDataset(dataset);\n    }\n\n    plot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    plot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    plot.SetExtra(\"set xrange [-10:20]\\n\\\nset yrange [0:1.2]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style increment user\");\n    plot.GenerateOutput(file);\n    file.close();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simulation of a Wi-Fi environment using NS-3 to evaluate throughput for different Modulation and Coding Scheme (MCS) values, channel widths, and guard intervals (GI) under the IEEE 802.11be (Wi-Fi 7) standard. The program should accept input parameters such as MCS, operating frequencies (2.4 GHz, 5 GHz, or 6 GHz), uplink OFDMA and BSRP flags, number of stations, traffic type (TCP or UDP), payload size, MPDU buffer size, and auxiliary PHY settings. For each combination of MCS, channel width, and GI, the simulation must create Wi-Fi stations and access points, configure them with the specified frequencies, and evaluate data throughput based on available bandwidth per station. The simulation should test both TCP and UDP traffic, run for a specified time, and print the results. Multiple frequencies (2.4, 5, and 6 GHz) should be configured correctly, ensuring they are unique to prevent collisions. Throughput tests should gather cumulative RX bytes per station and validate results against minimum and maximum expected throughput values, with a tolerance to account for real-world variances. If any throughput result is unexpectedly low or high for any MCS, channel width, or GI combination, an error should be logged, and the simulation should terminate. The output must display a table showing the MCS value, channel width, guard interval, and calculated throughput in Mbps."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/eht-phy.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/wifi-acknowledgment.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <array>\n#include <functional>\n#include <numeric>\n\n// This is a simple example in order to show how to configure an IEEE 802.11be Wi-Fi network.\n//\n// It outputs the UDP or TCP goodput for every EHT MCS value, which depends on the MCS value (0 to\n// 13), the channel width (20, 40, 80 or 160 MHz) and the guard interval (800ns, 1600ns or 3200ns).\n// The PHY bitrate is constant over all the simulation run. The user can also specify the distance\n// between the access point and the station: the larger the distance the smaller the goodput.\n//\n// The simulation assumes a configurable number of stations in an infrastructure network:\n//\n//  STA     AP\n//    *     *\n//    |     |\n//   n1     n2\n//\n// Packets in this simulation belong to BestEffort Access Class (AC_BE).\n// By selecting an acknowledgment sequence for DL MU PPDUs, it is possible to aggregate a\n// Round Robin scheduler to the AP, so that DL MU PPDUs are sent by the AP via DL OFDMA.\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"eht-wifi-network\");\n\n/**\n * \\param udp true if UDP is used, false if TCP is used\n * \\param serverApp a container of server applications\n * \\param payloadSize the size in bytes of the packets\n * \\return the bytes received by each server application\n */\nstd::vector<uint64_t>\nGetRxBytes(bool udp, const ApplicationContainer& serverApp, uint32_t payloadSize)\n{\n    std::vector<uint64_t> rxBytes(serverApp.GetN(), 0);\n    if (udp)\n    {\n        for (uint32_t i = 0; i < serverApp.GetN(); i++)\n        {\n            rxBytes[i] = payloadSize * DynamicCast<UdpServer>(serverApp.Get(i))->GetReceived();\n        }\n    }\n    else\n    {\n        for (uint32_t i = 0; i < serverApp.GetN(); i++)\n        {\n            rxBytes[i] = DynamicCast<PacketSink>(serverApp.Get(i))->GetTotalRx();\n        }\n    }\n    return rxBytes;\n}\n\n/**\n * Print average throughput over an intermediate time interval.\n * \\param rxBytes a vector of the amount of bytes received by each server application\n * \\param udp true if UDP is used, false if TCP is used\n * \\param serverApp a container of server applications\n * \\param payloadSize the size in bytes of the packets\n * \\param tputInterval the duration of an intermediate time interval\n * \\param simulationTime the simulation time in seconds\n */\nvoid\nPrintIntermediateTput(std::vector<uint64_t>& rxBytes,\n                      bool udp,\n                      const ApplicationContainer& serverApp,\n                      uint32_t payloadSize,\n                      Time tputInterval,\n                      Time simulationTime)\n{\n    auto newRxBytes = GetRxBytes(udp, serverApp, payloadSize);\n    Time now = Simulator::Now();\n\n    std::cout << \"[\" << (now - tputInterval).As(Time::S) << \" - \" << now.As(Time::S)\n              << \"] Per-STA Throughput (Mbit/s):\";\n\n    for (std::size_t i = 0; i < newRxBytes.size(); i++)\n    {\n        std::cout << \"\\t\\t(\" << i << \") \"\n                  << (newRxBytes[i] - rxBytes[i]) * 8. / tputInterval.GetMicroSeconds(); // Mbit/s\n    }\n    std::cout << std::endl;\n\n    rxBytes.swap(newRxBytes);\n\n    if (now < (simulationTime - NanoSeconds(1)))\n    {\n        Simulator::Schedule(Min(tputInterval, simulationTime - now - NanoSeconds(1)),\n                            &PrintIntermediateTput,\n                            rxBytes,\n                            udp,\n                            serverApp,\n                            payloadSize,\n                            tputInterval,\n                            simulationTime);\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    bool udp{true};\n    bool downlink{true};\n    bool useRts{false};\n    bool use80Plus80{false};\n    uint16_t mpduBufferSize{512};\n    std::string emlsrLinks;\n    uint16_t paddingDelayUsec{32};\n    uint16_t transitionDelayUsec{128};\n    uint16_t channelSwitchDelayUsec{100};\n    bool switchAuxPhy{true};\n    uint16_t auxPhyChWidth{20};\n    bool auxPhyTxCapable{true};\n    Time simulationTime{\"10s\"};\n    meter_u distance{1.0};\n    double frequency{5};  // whether the first link operates in the 2.4, 5 or 6 GHz\n    double frequency2{0}; // whether the second link operates in the 2.4, 5 or 6 GHz (0 means no\n                          // second link exists)\n    double frequency3{\n        0}; // whether the third link operates in the 2.4, 5 or 6 GHz (0 means no third link exists)\n    std::size_t nStations{1};\n    std::string dlAckSeqType{\"NO-OFDMA\"};\n    bool enableUlOfdma{false};\n    bool enableBsrp{false};\n    int mcs{-1}; // -1 indicates an unset value\n    uint32_t payloadSize =\n        700; // must fit in the max TX duration when transmitting at MCS 0 over an RU of 26 tones\n    Time tputInterval{0}; // interval for detailed throughput measurement\n    double minExpectedThroughput{0};\n    double maxExpectedThroughput{0};\n    Time accessReqInterval{0};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\n        \"frequency\",\n        \"Whether the first link operates in the 2.4, 5 or 6 GHz band (other values gets rejected)\",\n        frequency);\n    cmd.AddValue(\n        \"frequency2\",\n        \"Whether the second link operates in the 2.4, 5 or 6 GHz band (0 means the device has one \"\n        \"link, otherwise the band must be different than first link and third link)\",\n        frequency2);\n    cmd.AddValue(\n        \"frequency3\",\n        \"Whether the third link operates in the 2.4, 5 or 6 GHz band (0 means the device has up to \"\n        \"two links, otherwise the band must be different than first link and second link)\",\n        frequency3);\n    cmd.AddValue(\"emlsrLinks\",\n                 \"The comma separated list of IDs of EMLSR links (for MLDs only)\",\n                 emlsrLinks);\n    cmd.AddValue(\"emlsrPaddingDelay\",\n                 \"The EMLSR padding delay in microseconds (0, 32, 64, 128 or 256)\",\n                 paddingDelayUsec);\n    cmd.AddValue(\"emlsrTransitionDelay\",\n                 \"The EMLSR transition delay in microseconds (0, 16, 32, 64, 128 or 256)\",\n                 transitionDelayUsec);\n    cmd.AddValue(\"emlsrAuxSwitch\",\n                 \"Whether Aux PHY should switch channel to operate on the link on which \"\n                 \"the Main PHY was operating before moving to the link of the Aux PHY. \",\n                 switchAuxPhy);\n    cmd.AddValue(\"emlsrAuxChWidth\",\n                 \"The maximum channel width (MHz) supported by Aux PHYs.\",\n                 auxPhyChWidth);\n    cmd.AddValue(\"emlsrAuxTxCapable\",\n                 \"Whether Aux PHYs are capable of transmitting.\",\n                 auxPhyTxCapable);\n    cmd.AddValue(\"channelSwitchDelay\",\n                 \"The PHY channel switch delay in microseconds\",\n                 channelSwitchDelayUsec);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the station and the access point\",\n                 distance);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"udp\", \"UDP if set to 1, TCP otherwise\", udp);\n    cmd.AddValue(\"downlink\",\n                 \"Generate downlink flows if set to 1, uplink flows otherwise\",\n                 downlink);\n    cmd.AddValue(\"useRts\", \"Enable/disable RTS/CTS\", useRts);\n    cmd.AddValue(\"use80Plus80\", \"Enable/disable use of 80+80 MHz\", use80Plus80);\n    cmd.AddValue(\"mpduBufferSize\",\n                 \"Size (in number of MPDUs) of the BlockAck buffer\",\n                 mpduBufferSize);\n    cmd.AddValue(\"nStations\", \"Number of non-AP EHT stations\", nStations);\n    cmd.AddValue(\"dlAckType\",\n                 \"Ack sequence type for DL OFDMA (NO-OFDMA, ACK-SU-FORMAT, MU-BAR, AGGR-MU-BAR)\",\n                 dlAckSeqType);\n    cmd.AddValue(\"enableUlOfdma\",\n                 \"Enable UL OFDMA (useful if DL OFDMA is enabled and TCP is used)\",\n                 enableUlOfdma);\n    cmd.AddValue(\"enableBsrp\",\n                 \"Enable BSRP (useful if DL and UL OFDMA are enabled and TCP is used)\",\n                 enableBsrp);\n    cmd.AddValue(\n        \"muSchedAccessReqInterval\",\n        \"Duration of the interval between two requests for channel access made by the MU scheduler\",\n        accessReqInterval);\n    cmd.AddValue(\"mcs\", \"if set, limit testing to a specific MCS (0-11)\", mcs);\n    cmd.AddValue(\"payloadSize\", \"The application payload size in bytes\", payloadSize);\n    cmd.AddValue(\"tputInterval\", \"duration of intervals for throughput measurement\", tputInterval);\n    cmd.AddValue(\"minExpectedThroughput\",\n                 \"if set, simulation fails if the lowest throughput is below this value\",\n                 minExpectedThroughput);\n    cmd.AddValue(\"maxExpectedThroughput\",\n                 \"if set, simulation fails if the highest throughput is above this value\",\n                 maxExpectedThroughput);\n    cmd.Parse(argc, argv);\n\n    if (useRts)\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"0\"));\n        Config::SetDefault(\"ns3::WifiDefaultProtectionManager::EnableMuRts\", BooleanValue(true));\n    }\n\n    if (dlAckSeqType == \"ACK-SU-FORMAT\")\n    {\n        Config::SetDefault(\"ns3::WifiDefaultAckManager::DlMuAckSequenceType\",\n                           EnumValue(WifiAcknowledgment::DL_MU_BAR_BA_SEQUENCE));\n    }\n    else if (dlAckSeqType == \"MU-BAR\")\n    {\n        Config::SetDefault(\"ns3::WifiDefaultAckManager::DlMuAckSequenceType\",\n                           EnumValue(WifiAcknowledgment::DL_MU_TF_MU_BAR));\n    }\n    else if (dlAckSeqType == \"AGGR-MU-BAR\")\n    {\n        Config::SetDefault(\"ns3::WifiDefaultAckManager::DlMuAckSequenceType\",\n                           EnumValue(WifiAcknowledgment::DL_MU_AGGREGATE_TF));\n    }\n    else if (dlAckSeqType != \"NO-OFDMA\")\n    {\n        NS_ABORT_MSG(\"Invalid DL ack sequence type (must be NO-OFDMA, ACK-SU-FORMAT, MU-BAR or \"\n                     \"AGGR-MU-BAR)\");\n    }\n\n    double prevThroughput[12] = {0};\n\n    std::cout << \"MCS value\"\n              << \"\\t\\t\"\n              << \"Channel width\"\n              << \"\\t\\t\"\n              << \"GI\"\n              << \"\\t\\t\\t\"\n              << \"Throughput\" << '\\n';\n    int minMcs = 0;\n    int maxMcs = 13;\n    if (mcs >= 0 && mcs <= 13)\n    {\n        minMcs = mcs;\n        maxMcs = mcs;\n    }\n    for (int mcs = minMcs; mcs <= maxMcs; mcs++)\n    {\n        uint8_t index = 0;\n        double previous = 0;\n        uint16_t maxChannelWidth =\n            (frequency != 2.4 && frequency2 != 2.4 && frequency3 != 2.4) ? 160 : 40;\n        int minGi = enableUlOfdma ? 1600 : 800;\n        for (int channelWidth = 20; channelWidth <= maxChannelWidth;) // MHz\n        {\n            const auto is80Plus80 = (use80Plus80 && (channelWidth == 160));\n            const std::string widthStr = is80Plus80 ? \"80+80\" : std::to_string(channelWidth);\n            const auto segmentWidthStr = is80Plus80 ? \"80\" : widthStr;\n            for (int gi = 3200; gi >= minGi;) // Nanoseconds\n            {\n                if (!udp)\n                {\n                    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n                }\n\n                NodeContainer wifiStaNodes;\n                wifiStaNodes.Create(nStations);\n                NodeContainer wifiApNode;\n                wifiApNode.Create(1);\n\n                NetDeviceContainer apDevice;\n                NetDeviceContainer staDevices;\n                WifiMacHelper mac;\n                WifiHelper wifi;\n\n                wifi.SetStandard(WIFI_STANDARD_80211be);\n                std::array<std::string, 3> channelStr;\n                std::array<FrequencyRange, 3> freqRanges;\n                uint8_t nLinks = 0;\n                std::string dataModeStr = \"EhtMcs\" + std::to_string(mcs);\n                std::string ctrlRateStr;\n                uint64_t nonHtRefRateMbps = EhtPhy::GetNonHtReferenceRate(mcs) / 1e6;\n\n                if (frequency2 == frequency || frequency3 == frequency ||\n                    (frequency3 != 0 && frequency3 == frequency2))\n                {\n                    NS_FATAL_ERROR(\"Frequency values must be unique!\");\n                }\n\n                for (auto freq : {frequency, frequency2, frequency3})\n                {\n                    if (nLinks > 0 && freq == 0)\n                    {\n                        break;\n                    }\n                    channelStr[nLinks] = \"{0, \" + segmentWidthStr + \", \";\n                    if (freq == 6)\n                    {\n                        channelStr[nLinks] += \"BAND_6GHZ, 0}\";\n                        freqRanges[nLinks] = WIFI_SPECTRUM_6_GHZ;\n                        Config::SetDefault(\"ns3::LogDistancePropagationLossModel::ReferenceLoss\",\n                                           DoubleValue(48));\n                        wifi.SetRemoteStationManager(nLinks,\n                                                     \"ns3::ConstantRateWifiManager\",\n                                                     \"DataMode\",\n                                                     StringValue(dataModeStr),\n                                                     \"ControlMode\",\n                                                     StringValue(dataModeStr));\n                    }\n                    else if (freq == 5)\n                    {\n                        channelStr[nLinks] += \"BAND_5GHZ, 0}\";\n                        freqRanges[nLinks] = WIFI_SPECTRUM_5_GHZ;\n                        ctrlRateStr = \"OfdmRate\" + std::to_string(nonHtRefRateMbps) + \"Mbps\";\n                        wifi.SetRemoteStationManager(nLinks,\n                                                     \"ns3::ConstantRateWifiManager\",\n                                                     \"DataMode\",\n                                                     StringValue(dataModeStr),\n                                                     \"ControlMode\",\n                                                     StringValue(ctrlRateStr));\n                    }\n                    else if (freq == 2.4)\n                    {\n                        channelStr[nLinks] += \"BAND_2_4GHZ, 0}\";\n                        freqRanges[nLinks] = WIFI_SPECTRUM_2_4_GHZ;\n                        Config::SetDefault(\"ns3::LogDistancePropagationLossModel::ReferenceLoss\",\n                                           DoubleValue(40));\n                        ctrlRateStr = \"ErpOfdmRate\" + std::to_string(nonHtRefRateMbps) + \"Mbps\";\n                        wifi.SetRemoteStationManager(nLinks,\n                                                     \"ns3::ConstantRateWifiManager\",\n                                                     \"DataMode\",\n                                                     StringValue(dataModeStr),\n                                                     \"ControlMode\",\n                                                     StringValue(ctrlRateStr));\n                    }\n                    else\n                    {\n                        NS_FATAL_ERROR(\"Wrong frequency value!\");\n                    }\n\n                    if (is80Plus80)\n                    {\n                        channelStr[nLinks] += std::string(\";\") + channelStr[nLinks];\n                    }\n\n                    nLinks++;\n                }\n\n                if (nLinks > 1 && !emlsrLinks.empty())\n                {\n                    wifi.ConfigEhtOptions(\"EmlsrActivated\", BooleanValue(true));\n                }\n\n                Ssid ssid = Ssid(\"ns3-80211be\");\n\n                SpectrumWifiPhyHelper phy(nLinks);\n                phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n                phy.Set(\"ChannelSwitchDelay\", TimeValue(MicroSeconds(channelSwitchDelayUsec)));\n\n                mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n                mac.SetEmlsrManager(\"ns3::DefaultEmlsrManager\",\n                                    \"EmlsrLinkSet\",\n                                    StringValue(emlsrLinks),\n                                    \"EmlsrPaddingDelay\",\n                                    TimeValue(MicroSeconds(paddingDelayUsec)),\n                                    \"EmlsrTransitionDelay\",\n                                    TimeValue(MicroSeconds(transitionDelayUsec)),\n                                    \"SwitchAuxPhy\",\n                                    BooleanValue(switchAuxPhy),\n                                    \"AuxPhyTxCapable\",\n                                    BooleanValue(auxPhyTxCapable),\n                                    \"AuxPhyChannelWidth\",\n                                    UintegerValue(auxPhyChWidth));\n                for (uint8_t linkId = 0; linkId < nLinks; linkId++)\n                {\n                    phy.Set(linkId, \"ChannelSettings\", StringValue(channelStr[linkId]));\n\n                    auto spectrumChannel = CreateObject<MultiModelSpectrumChannel>();\n                    auto lossModel = CreateObject<LogDistancePropagationLossModel>();\n                    spectrumChannel->AddPropagationLossModel(lossModel);\n                    phy.AddChannel(spectrumChannel, freqRanges[linkId]);\n                }\n                staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n                if (dlAckSeqType != \"NO-OFDMA\")\n                {\n                    mac.SetMultiUserScheduler(\"ns3::RrMultiUserScheduler\",\n                                              \"EnableUlOfdma\",\n                                              BooleanValue(enableUlOfdma),\n                                              \"EnableBsrp\",\n                                              BooleanValue(enableBsrp),\n                                              \"AccessReqInterval\",\n                                              TimeValue(accessReqInterval));\n                }\n                mac.SetType(\"ns3::ApWifiMac\",\n                            \"EnableBeaconJitter\",\n                            BooleanValue(false),\n                            \"Ssid\",\n                            SsidValue(ssid));\n                apDevice = wifi.Install(phy, mac, wifiApNode);\n\n                int64_t streamNumber = 100;\n                streamNumber += WifiHelper::AssignStreams(apDevice, streamNumber);\n                streamNumber += WifiHelper::AssignStreams(staDevices, streamNumber);\n\n                // Set guard interval and MPDU buffer size\n                Config::Set(\n                    \"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HeConfiguration/GuardInterval\",\n                    TimeValue(NanoSeconds(gi)));\n                Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/MpduBufferSize\",\n                            UintegerValue(mpduBufferSize));\n\n                // mobility.\n                MobilityHelper mobility;\n                Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n                positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n                positionAlloc->Add(Vector(distance, 0.0, 0.0));\n                mobility.SetPositionAllocator(positionAlloc);\n\n                mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n                mobility.Install(wifiApNode);\n                mobility.Install(wifiStaNodes);\n\n                /* Internet stack*/\n                InternetStackHelper stack;\n                stack.Install(wifiApNode);\n                stack.Install(wifiStaNodes);\n                streamNumber += stack.AssignStreams(wifiApNode, streamNumber);\n                streamNumber += stack.AssignStreams(wifiStaNodes, streamNumber);\n\n                Ipv4AddressHelper address;\n                address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n                Ipv4InterfaceContainer staNodeInterfaces;\n                Ipv4InterfaceContainer apNodeInterface;\n\n                staNodeInterfaces = address.Assign(staDevices);\n                apNodeInterface = address.Assign(apDevice);\n\n                /* Setting applications */\n                ApplicationContainer serverApp;\n                auto serverNodes = downlink ? std::ref(wifiStaNodes) : std::ref(wifiApNode);\n                Ipv4InterfaceContainer serverInterfaces;\n                NodeContainer clientNodes;\n                for (std::size_t i = 0; i < nStations; i++)\n                {\n                    serverInterfaces.Add(downlink ? staNodeInterfaces.Get(i)\n                                                  : apNodeInterface.Get(0));\n                    clientNodes.Add(downlink ? wifiApNode.Get(0) : wifiStaNodes.Get(i));\n                }\n\n                const auto maxLoad =\n                    nLinks * EhtPhy::GetDataRate(mcs, channelWidth, NanoSeconds(gi), 1) / nStations;\n                if (udp)\n                {\n                    // UDP flow\n                    uint16_t port = 9;\n                    UdpServerHelper server(port);\n                    serverApp = server.Install(serverNodes.get());\n                    streamNumber += server.AssignStreams(serverNodes.get(), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n                    const auto packetInterval = payloadSize * 8.0 / maxLoad;\n\n                    for (std::size_t i = 0; i < nStations; i++)\n                    {\n                        UdpClientHelper client(serverInterfaces.GetAddress(i), port);\n                        client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n                        client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n                        client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                        ApplicationContainer clientApp = client.Install(clientNodes.Get(i));\n                        streamNumber += client.AssignStreams(clientNodes.Get(i), streamNumber);\n\n                        clientApp.Start(Seconds(1.0));\n                        clientApp.Stop(simulationTime + Seconds(1.0));\n                    }\n                }\n                else\n                {\n                    // TCP flow\n                    uint16_t port = 50000;\n                    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n                    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n                    serverApp = packetSinkHelper.Install(serverNodes.get());\n                    streamNumber += packetSinkHelper.AssignStreams(serverNodes.get(), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n\n                    for (std::size_t i = 0; i < nStations; i++)\n                    {\n                        OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n                        onoff.SetAttribute(\"OnTime\",\n                                           StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n                        onoff.SetAttribute(\"OffTime\",\n                                           StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n                        onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                        onoff.SetAttribute(\"DataRate\", DataRateValue(maxLoad));\n                        AddressValue remoteAddress(\n                            InetSocketAddress(serverInterfaces.GetAddress(i), port));\n                        onoff.SetAttribute(\"Remote\", remoteAddress);\n                        ApplicationContainer clientApp = onoff.Install(clientNodes.Get(i));\n                        streamNumber += onoff.AssignStreams(clientNodes.Get(i), streamNumber);\n\n                        clientApp.Start(Seconds(1.0));\n                        clientApp.Stop(simulationTime + Seconds(1.0));\n                    }\n                }\n\n                // cumulative number of bytes received by each server application\n                std::vector<uint64_t> cumulRxBytes(nStations, 0);\n\n                if (tputInterval.IsStrictlyPositive())\n                {\n                    Simulator::Schedule(Seconds(1) + tputInterval,\n                                        &PrintIntermediateTput,\n                                        cumulRxBytes,\n                                        udp,\n                                        serverApp,\n                                        payloadSize,\n                                        tputInterval,\n                                        simulationTime + Seconds(1.0));\n                }\n\n                Simulator::Stop(simulationTime + Seconds(1.0));\n                Simulator::Run();\n\n                // When multiple stations are used, there are chances that association requests\n                // collide and hence the throughput may be lower than expected. Therefore, we relax\n                // the check that the throughput cannot decrease by introducing a scaling factor (or\n                // tolerance)\n                auto tolerance = 0.10;\n                cumulRxBytes = GetRxBytes(udp, serverApp, payloadSize);\n                auto rxBytes = std::accumulate(cumulRxBytes.cbegin(), cumulRxBytes.cend(), 0.0);\n                auto throughput = (rxBytes * 8) / simulationTime.GetMicroSeconds(); // Mbit/s\n\n                Simulator::Destroy();\n\n                std::cout << +mcs << \"\\t\\t\\t\" << widthStr << \" MHz\\t\\t\"\n                          << (widthStr.size() > 3 ? \"\" : \"\\t\") << gi << \" ns\\t\\t\\t\" << throughput\n                          << \" Mbit/s\" << std::endl;\n\n                // test first element\n                if (mcs == minMcs && channelWidth == 20 && gi == 3200)\n                {\n                    if (throughput * (1 + tolerance) < minExpectedThroughput)\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                }\n                // test last element\n                if (mcs == maxMcs && channelWidth == maxChannelWidth && gi == 800)\n                {\n                    if (maxExpectedThroughput > 0 &&\n                        throughput > maxExpectedThroughput * (1 + tolerance))\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                }\n                // test previous throughput is smaller (for the same mcs)\n                if (throughput * (1 + tolerance) > previous)\n                {\n                    previous = throughput;\n                }\n                else if (throughput > 0)\n                {\n                    NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                    exit(1);\n                }\n                // test previous throughput is smaller (for the same channel width and GI)\n                if (throughput * (1 + tolerance) > prevThroughput[index])\n                {\n                    prevThroughput[index] = throughput;\n                }\n                else if (throughput > 0)\n                {\n                    NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                    exit(1);\n                }\n                index++;\n                gi /= 2;\n            }\n            channelWidth *= 2;\n        }\n    }\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nYou will create a simulation in NS-3 to demonstrate the differences between the Nist, Yans, and Table-based error rate models. This program will generate plots comparing the Frame Error Rate (FER) to the Signal-to-Noise Ratio (SNR) for MCS values 0, 4, and 7. You will use the `Gnuplot` library to visualize the data. The simulation accepts command-line parameters such as frame size, MCS range, step values, and error model flags. You will configure and test different MCS values across a range of SNR values and calculate the FER for each error model. The results will be plotted, with Nist, Yans, and Table-based error rate models differentiated by color. After running the simulation, you will output a plot in `.eps` format showing the performance of each error model across the tested MCS values and SNR range."}, {"role": "assistant", "content": "// This example is to show difference among Nist, Yans and Table-based error rate models.\n//\n// It outputs plots of the Frame Error Rate versus the Signal-to-noise ratio for\n// Nist, Yans and Table-based error rate models and for MCS 0, 4 and 7 value.\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t size = 1500 * 8; // bits\n    bool tableErrorModelEnabled = true;\n    bool yansErrorModelEnabled = true;\n    bool nistErrorModelEnabled = true;\n    uint8_t beginMcs = 0;\n    uint8_t endMcs = 7;\n    uint8_t stepMcs = 4;\n    std::string format(\"Ht\");\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"size\", \"The size in bits\", size);\n    cmd.AddValue(\"frameFormat\", \"The frame format to use: Ht, Vht or He\", format);\n    cmd.AddValue(\"beginMcs\", \"The first MCS to test\", beginMcs);\n    cmd.AddValue(\"endMcs\", \"The last MCS to test\", endMcs);\n    cmd.AddValue(\"stepMcs\", \"The step between two MCSs to test\", stepMcs);\n    cmd.AddValue(\"includeTableErrorModel\",\n                 \"Flag to include/exclude Table-based error model\",\n                 tableErrorModelEnabled);\n    cmd.AddValue(\"includeYansErrorModel\",\n                 \"Flag to include/exclude Yans error model\",\n                 yansErrorModelEnabled);\n    cmd.AddValue(\"includeNistErrorModel\",\n                 \"Flag to include/exclude Nist error model\",\n                 nistErrorModelEnabled);\n    cmd.Parse(argc, argv);\n\n    std::ofstream errormodelfile(\"wifi-error-rate-models.plt\");\n    Gnuplot plot = Gnuplot(\"wifi-error-rate-models.eps\");\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n    WifiTxVector txVector;\n    std::vector<std::string> modes;\n\n    std::stringstream mode;\n    mode << format << \"Mcs\" << +beginMcs;\n    modes.push_back(mode.str());\n    for (uint8_t mcs = (beginMcs + stepMcs); mcs < endMcs; mcs += stepMcs)\n    {\n        mode.str(\"\");\n        mode << format << \"Mcs\" << +mcs;\n        modes.push_back(mode.str());\n    }\n    mode.str(\"\");\n    mode << format << \"Mcs\" << +endMcs;\n    modes.push_back(mode.str());\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset yansdataset(mode);\n        Gnuplot2dDataset nistdataset(mode);\n        Gnuplot2dDataset tabledataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -5.0; snrDb <= (endMcs * 5); snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double ps = yans->GetChunkSuccessRate(wifiMode, txVector, snr, size);\n            if (ps < 0 || ps > 1)\n            {\n                // error\n                exit(1);\n            }\n            yansdataset.Add(snrDb, 1 - ps);\n            ps = nist->GetChunkSuccessRate(wifiMode, txVector, snr, size);\n            if (ps < 0 || ps > 1)\n            {\n                // error\n                exit(1);\n            }\n            nistdataset.Add(snrDb, 1 - ps);\n            ps = table->GetChunkSuccessRate(wifiMode, txVector, snr, size);\n            if (ps < 0 || ps > 1)\n            {\n                // error\n                exit(1);\n            }\n            tabledataset.Add(snrDb, 1 - ps);\n        }\n\n        if (tableErrorModelEnabled)\n        {\n            std::stringstream ss;\n            ss << \"Table-\" << mode;\n            tabledataset.SetTitle(ss.str());\n            plot.AddDataset(tabledataset);\n        }\n        if (yansErrorModelEnabled)\n        {\n            std::stringstream ss;\n            ss << \"Yans-\" << mode;\n            yansdataset.SetTitle(ss.str());\n            plot.AddDataset(yansdataset);\n        }\n        if (nistErrorModelEnabled)\n        {\n            std::stringstream ss;\n            ss << \"Nist-\" << mode;\n            nistdataset.SetTitle(ss.str());\n            plot.AddDataset(nistdataset);\n        }\n    }\n\n    plot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    plot.SetLegend(\"SNR(dB)\", \"Frame Error Rate\");\n\n    std::stringstream plotExtra;\n    plotExtra << \"set xrange [-5:\" << endMcs * 5 << \"]\\n\\\nset log y\\n\\\nset yrange [0.0001:1]\\n\";\n\n    uint8_t lineNumber = 1;\n    for (uint32_t i = 0; i < modes.size(); i++)\n    {\n        if (tableErrorModelEnabled)\n        {\n            plotExtra << \"set style line \" << +lineNumber++\n                      << \" linewidth 5 linecolor rgb \\\"red\\\" \\n\";\n        }\n        if (yansErrorModelEnabled)\n        {\n            plotExtra << \"set style line \" << +lineNumber++\n                      << \" linewidth 5 linecolor rgb \\\"green\\\" \\n\";\n        }\n        if (nistErrorModelEnabled)\n        {\n            plotExtra << \"set style line \" << +lineNumber++\n                      << \" linewidth 5 linecolor rgb \\\"blue\\\" \\n\";\n        }\n    }\n\n    plotExtra << \"set style increment user\";\n    plot.SetExtra(plotExtra.str());\n\n    plot.GenerateOutput(errormodelfile);\n    errormodelfile.close();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a code that configures and simulates an IEEE 802.11ax Wi-Fi network using the NS-3 simulator to analyze UDP or TCP traffic performance under varying Modulation and Coding Scheme (MCS) values, channel widths, and guard intervals. It sets up an access point (AP) and one or more stations, allowing you to customize parameters such as the distance between the AP and stations, the acknowledgment sequence for downlink (DL) MU PPDUs, and options like enabling RTS/CTS, 80+80 MHz channels, extended block acknowledgment, or UL OFDMA. You can simulate 2.4, 5, or 6 GHz bands with Yans or Spectrum PHY models. The code lets you adjust the number of stations, packet payload size, and target throughput. Depending on your choice, it initializes UDP or TCP flows and produces throughput results for different MCS values and channel widths. You can also schedule channel access and assess network performance across various configurations and topologies."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/he-phy.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/wifi-acknowledgment.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <functional>\n\n// This is a simple example in order to show how to configure an IEEE 802.11ax Wi-Fi network.\n//\n// It outputs the UDP or TCP goodput for every HE MCS value, which depends on the MCS value (0 to\n// 11), the channel width (20, 40, 80 or 160 MHz) and the guard interval (800ns, 1600ns or 3200ns).\n// The PHY bitrate is constant over all the simulation run. The user can also specify the distance\n// between the access point and the station: the larger the distance the smaller the goodput.\n//\n// The simulation assumes a configurable number of stations in an infrastructure network:\n//\n//  STA     AP\n//    *     *\n//    |     |\n//   n1     n2\n//\n// Packets in this simulation belong to BestEffort Access Class (AC_BE).\n// By selecting an acknowledgment sequence for DL MU PPDUs, it is possible to aggregate a\n// Round Robin scheduler to the AP, so that DL MU PPDUs are sent by the AP via DL OFDMA.\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"he-wifi-network\");\n\nint\nmain(int argc, char* argv[])\n{\n    bool udp{true};\n    bool downlink{true};\n    bool useRts{false};\n    bool use80Plus80{false};\n    bool useExtendedBlockAck{false};\n    Time simulationTime{\"10s\"};\n    meter_u distance{1.0};\n    double frequency{5}; // whether 2.4, 5 or 6 GHz\n    std::size_t nStations{1};\n    std::string dlAckSeqType{\"NO-OFDMA\"};\n    bool enableUlOfdma{false};\n    bool enableBsrp{false};\n    int mcs{-1}; // -1 indicates an unset value\n    uint32_t payloadSize =\n        700; // must fit in the max TX duration when transmitting at MCS 0 over an RU of 26 tones\n    std::string phyModel{\"Yans\"};\n    double minExpectedThroughput{0};\n    double maxExpectedThroughput{0};\n    Time accessReqInterval{0};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"frequency\",\n                 \"Whether working in the 2.4, 5 or 6 GHz band (other values gets rejected)\",\n                 frequency);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the station and the access point\",\n                 distance);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"udp\", \"UDP if set to 1, TCP otherwise\", udp);\n    cmd.AddValue(\"downlink\",\n                 \"Generate downlink flows if set to 1, uplink flows otherwise\",\n                 downlink);\n    cmd.AddValue(\"useRts\", \"Enable/disable RTS/CTS\", useRts);\n    cmd.AddValue(\"use80Plus80\", \"Enable/disable use of 80+80 MHz\", use80Plus80);\n    cmd.AddValue(\"useExtendedBlockAck\", \"Enable/disable use of extended BACK\", useExtendedBlockAck);\n    cmd.AddValue(\"nStations\", \"Number of non-AP HE stations\", nStations);\n    cmd.AddValue(\"dlAckType\",\n                 \"Ack sequence type for DL OFDMA (NO-OFDMA, ACK-SU-FORMAT, MU-BAR, AGGR-MU-BAR)\",\n                 dlAckSeqType);\n    cmd.AddValue(\"enableUlOfdma\",\n                 \"Enable UL OFDMA (useful if DL OFDMA is enabled and TCP is used)\",\n                 enableUlOfdma);\n    cmd.AddValue(\"enableBsrp\",\n                 \"Enable BSRP (useful if DL and UL OFDMA are enabled and TCP is used)\",\n                 enableBsrp);\n    cmd.AddValue(\n        \"muSchedAccessReqInterval\",\n        \"Duration of the interval between two requests for channel access made by the MU scheduler\",\n        accessReqInterval);\n    cmd.AddValue(\"mcs\", \"if set, limit testing to a specific MCS (0-11)\", mcs);\n    cmd.AddValue(\"payloadSize\", \"The application payload size in bytes\", payloadSize);\n    cmd.AddValue(\"phyModel\",\n                 \"PHY model to use when OFDMA is disabled (Yans or Spectrum). If 80+80 MHz or \"\n                 \"OFDMA is enabled \"\n                 \"then Spectrum is automatically selected\",\n                 phyModel);\n    cmd.AddValue(\"minExpectedThroughput\",\n                 \"if set, simulation fails if the lowest throughput is below this value\",\n                 minExpectedThroughput);\n    cmd.AddValue(\"maxExpectedThroughput\",\n                 \"if set, simulation fails if the highest throughput is above this value\",\n                 maxExpectedThroughput);\n    cmd.Parse(argc, argv);\n\n    if (useRts)\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"0\"));\n        Config::SetDefault(\"ns3::WifiDefaultProtectionManager::EnableMuRts\", BooleanValue(true));\n    }\n\n    if (dlAckSeqType == \"ACK-SU-FORMAT\")\n    {\n        Config::SetDefault(\"ns3::WifiDefaultAckManager::DlMuAckSequenceType\",\n                           EnumValue(WifiAcknowledgment::DL_MU_BAR_BA_SEQUENCE));\n    }\n    else if (dlAckSeqType == \"MU-BAR\")\n    {\n        Config::SetDefault(\"ns3::WifiDefaultAckManager::DlMuAckSequenceType\",\n                           EnumValue(WifiAcknowledgment::DL_MU_TF_MU_BAR));\n    }\n    else if (dlAckSeqType == \"AGGR-MU-BAR\")\n    {\n        Config::SetDefault(\"ns3::WifiDefaultAckManager::DlMuAckSequenceType\",\n                           EnumValue(WifiAcknowledgment::DL_MU_AGGREGATE_TF));\n    }\n    else if (dlAckSeqType != \"NO-OFDMA\")\n    {\n        NS_ABORT_MSG(\"Invalid DL ack sequence type (must be NO-OFDMA, ACK-SU-FORMAT, MU-BAR or \"\n                     \"AGGR-MU-BAR)\");\n    }\n\n    if (phyModel != \"Yans\" && phyModel != \"Spectrum\")\n    {\n        NS_ABORT_MSG(\"Invalid PHY model (must be Yans or Spectrum)\");\n    }\n    if (use80Plus80 || (dlAckSeqType != \"NO-OFDMA\"))\n    {\n        // SpectrumWifiPhy is required for 80+80 MHz and OFDMA\n        phyModel = \"Spectrum\";\n    }\n\n    double prevThroughput[12] = {0};\n\n    std::cout << \"MCS value\"\n              << \"\\t\\t\"\n              << \"Channel width\"\n              << \"\\t\\t\"\n              << \"GI\"\n              << \"\\t\\t\\t\"\n              << \"Throughput\" << '\\n';\n    int minMcs = 0;\n    int maxMcs = 11;\n    if (mcs >= 0 && mcs <= 11)\n    {\n        minMcs = mcs;\n        maxMcs = mcs;\n    }\n    for (int mcs = minMcs; mcs <= maxMcs; mcs++)\n    {\n        uint8_t index = 0;\n        double previous = 0;\n        uint8_t maxChannelWidth = frequency == 2.4 ? 40 : 160;\n        int minGi = enableUlOfdma ? 1600 : 800;\n        for (int channelWidth = 20; channelWidth <= maxChannelWidth;) // MHz\n        {\n            const auto is80Plus80 = (use80Plus80 && (channelWidth == 160));\n            const std::string widthStr = is80Plus80 ? \"80+80\" : std::to_string(channelWidth);\n            const auto segmentWidthStr = is80Plus80 ? \"80\" : widthStr;\n            for (int gi = 3200; gi >= minGi;) // Nanoseconds\n            {\n                if (!udp)\n                {\n                    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n                }\n\n                NodeContainer wifiStaNodes;\n                wifiStaNodes.Create(nStations);\n                NodeContainer wifiApNode;\n                wifiApNode.Create(1);\n\n                NetDeviceContainer apDevice;\n                NetDeviceContainer staDevices;\n                WifiMacHelper mac;\n                WifiHelper wifi;\n                std::string channelStr(\"{0, \" + segmentWidthStr + \", \");\n                StringValue ctrlRate;\n                auto nonHtRefRateMbps = HePhy::GetNonHtReferenceRate(mcs) / 1e6;\n\n                std::ostringstream ossDataMode;\n                ossDataMode << \"HeMcs\" << mcs;\n\n                if (frequency == 6)\n                {\n                    ctrlRate = StringValue(ossDataMode.str());\n                    channelStr += \"BAND_6GHZ, 0}\";\n                    Config::SetDefault(\"ns3::LogDistancePropagationLossModel::ReferenceLoss\",\n                                       DoubleValue(48));\n                }\n                else if (frequency == 5)\n                {\n                    std::ostringstream ossControlMode;\n                    ossControlMode << \"OfdmRate\" << nonHtRefRateMbps << \"Mbps\";\n                    ctrlRate = StringValue(ossControlMode.str());\n                    channelStr += \"BAND_5GHZ, 0}\";\n                }\n                else if (frequency == 2.4)\n                {\n                    std::ostringstream ossControlMode;\n                    ossControlMode << \"ErpOfdmRate\" << nonHtRefRateMbps << \"Mbps\";\n                    ctrlRate = StringValue(ossControlMode.str());\n                    channelStr += \"BAND_2_4GHZ, 0}\";\n                    Config::SetDefault(\"ns3::LogDistancePropagationLossModel::ReferenceLoss\",\n                                       DoubleValue(40));\n                }\n                else\n                {\n                    NS_FATAL_ERROR(\"Wrong frequency value!\");\n                }\n\n                if (is80Plus80)\n                {\n                    channelStr += std::string(\";\") + channelStr;\n                }\n\n                wifi.SetStandard(WIFI_STANDARD_80211ax);\n                wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                             \"DataMode\",\n                                             StringValue(ossDataMode.str()),\n                                             \"ControlMode\",\n                                             ctrlRate);\n                // Set guard interval\n                wifi.ConfigHeOptions(\"GuardInterval\", TimeValue(NanoSeconds(gi)));\n\n                Ssid ssid = Ssid(\"ns3-80211ax\");\n\n                if (phyModel == \"Spectrum\")\n                {\n                    auto spectrumChannel = CreateObject<MultiModelSpectrumChannel>();\n\n                    auto lossModel = CreateObject<LogDistancePropagationLossModel>();\n                    spectrumChannel->AddPropagationLossModel(lossModel);\n\n                    SpectrumWifiPhyHelper phy;\n                    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n                    phy.SetChannel(spectrumChannel);\n\n                    mac.SetType(\"ns3::StaWifiMac\",\n                                \"Ssid\",\n                                SsidValue(ssid),\n                                \"MpduBufferSize\",\n                                UintegerValue(useExtendedBlockAck ? 256 : 64));\n                    phy.Set(\"ChannelSettings\", StringValue(channelStr));\n                    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n                    if (dlAckSeqType != \"NO-OFDMA\")\n                    {\n                        mac.SetMultiUserScheduler(\"ns3::RrMultiUserScheduler\",\n                                                  \"EnableUlOfdma\",\n                                                  BooleanValue(enableUlOfdma),\n                                                  \"EnableBsrp\",\n                                                  BooleanValue(enableBsrp),\n                                                  \"AccessReqInterval\",\n                                                  TimeValue(accessReqInterval));\n                    }\n                    mac.SetType(\"ns3::ApWifiMac\",\n                                \"EnableBeaconJitter\",\n                                BooleanValue(false),\n                                \"Ssid\",\n                                SsidValue(ssid));\n                    apDevice = wifi.Install(phy, mac, wifiApNode);\n                }\n                else\n                {\n                    auto channel = YansWifiChannelHelper::Default();\n                    YansWifiPhyHelper phy;\n                    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n                    phy.SetChannel(channel.Create());\n\n                    mac.SetType(\"ns3::StaWifiMac\",\n                                \"Ssid\",\n                                SsidValue(ssid),\n                                \"MpduBufferSize\",\n                                UintegerValue(useExtendedBlockAck ? 256 : 64));\n                    phy.Set(\"ChannelSettings\", StringValue(channelStr));\n                    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n                    mac.SetType(\"ns3::ApWifiMac\",\n                                \"EnableBeaconJitter\",\n                                BooleanValue(false),\n                                \"Ssid\",\n                                SsidValue(ssid));\n                    apDevice = wifi.Install(phy, mac, wifiApNode);\n                }\n\n                int64_t streamNumber = 150;\n                streamNumber += WifiHelper::AssignStreams(apDevice, streamNumber);\n                streamNumber += WifiHelper::AssignStreams(staDevices, streamNumber);\n\n                // mobility.\n                MobilityHelper mobility;\n                Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n                positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n                positionAlloc->Add(Vector(distance, 0.0, 0.0));\n                mobility.SetPositionAllocator(positionAlloc);\n\n                mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n                mobility.Install(wifiApNode);\n                mobility.Install(wifiStaNodes);\n\n                /* Internet stack*/\n                InternetStackHelper stack;\n                stack.Install(wifiApNode);\n                stack.Install(wifiStaNodes);\n                streamNumber += stack.AssignStreams(wifiApNode, streamNumber);\n                streamNumber += stack.AssignStreams(wifiStaNodes, streamNumber);\n\n                Ipv4AddressHelper address;\n                address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n                Ipv4InterfaceContainer staNodeInterfaces;\n                Ipv4InterfaceContainer apNodeInterface;\n\n                staNodeInterfaces = address.Assign(staDevices);\n                apNodeInterface = address.Assign(apDevice);\n\n                /* Setting applications */\n                ApplicationContainer serverApp;\n                auto serverNodes = downlink ? std::ref(wifiStaNodes) : std::ref(wifiApNode);\n                Ipv4InterfaceContainer serverInterfaces;\n                NodeContainer clientNodes;\n                for (std::size_t i = 0; i < nStations; i++)\n                {\n                    serverInterfaces.Add(downlink ? staNodeInterfaces.Get(i)\n                                                  : apNodeInterface.Get(0));\n                    clientNodes.Add(downlink ? wifiApNode.Get(0) : wifiStaNodes.Get(i));\n                }\n\n                const auto maxLoad =\n                    HePhy::GetDataRate(mcs, channelWidth, NanoSeconds(gi), 1) / nStations;\n                if (udp)\n                {\n                    // UDP flow\n                    uint16_t port = 9;\n                    UdpServerHelper server(port);\n                    serverApp = server.Install(serverNodes.get());\n                    streamNumber += server.AssignStreams(serverNodes.get(), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n                    const auto packetInterval = payloadSize * 8.0 / maxLoad;\n\n                    for (std::size_t i = 0; i < nStations; i++)\n                    {\n                        UdpClientHelper client(serverInterfaces.GetAddress(i), port);\n                        client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n                        client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n                        client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                        ApplicationContainer clientApp = client.Install(clientNodes.Get(i));\n                        streamNumber += client.AssignStreams(clientNodes.Get(i), streamNumber);\n\n                        clientApp.Start(Seconds(1.0));\n                        clientApp.Stop(simulationTime + Seconds(1.0));\n                    }\n                }\n                else\n                {\n                    // TCP flow\n                    uint16_t port = 50000;\n                    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n                    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n                    serverApp = packetSinkHelper.Install(serverNodes.get());\n                    streamNumber += packetSinkHelper.AssignStreams(serverNodes.get(), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n\n                    for (std::size_t i = 0; i < nStations; i++)\n                    {\n                        OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n                        onoff.SetAttribute(\"OnTime\",\n                                           StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n                        onoff.SetAttribute(\"OffTime\",\n                                           StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n                        onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                        onoff.SetAttribute(\"DataRate\", DataRateValue(maxLoad));\n                        AddressValue remoteAddress(\n                            InetSocketAddress(serverInterfaces.GetAddress(i), port));\n                        onoff.SetAttribute(\"Remote\", remoteAddress);\n                        ApplicationContainer clientApp = onoff.Install(clientNodes.Get(i));\n                        streamNumber += onoff.AssignStreams(clientNodes.Get(i), streamNumber);\n\n                        clientApp.Start(Seconds(1.0));\n                        clientApp.Stop(simulationTime + Seconds(1.0));\n                    }\n                }\n\n                Simulator::Schedule(Seconds(0), &Ipv4GlobalRoutingHelper::PopulateRoutingTables);\n\n                Simulator::Stop(simulationTime + Seconds(1.0));\n                Simulator::Run();\n\n                // When multiple stations are used, there are chances that association requests\n                // collide and hence the throughput may be lower than expected. Therefore, we relax\n                // the check that the throughput cannot decrease by introducing a scaling factor (or\n                // tolerance)\n                auto tolerance = 0.10;\n                auto rxBytes = 0.0;\n                if (udp)\n                {\n                    for (uint32_t i = 0; i < serverApp.GetN(); i++)\n                    {\n                        rxBytes +=\n                            payloadSize * DynamicCast<UdpServer>(serverApp.Get(i))->GetReceived();\n                    }\n                }\n                else\n                {\n                    for (uint32_t i = 0; i < serverApp.GetN(); i++)\n                    {\n                        rxBytes += DynamicCast<PacketSink>(serverApp.Get(i))->GetTotalRx();\n                    }\n                }\n                auto throughput = (rxBytes * 8) / simulationTime.GetMicroSeconds(); // Mbit/s\n\n                Simulator::Destroy();\n\n                std::cout << +mcs << \"\\t\\t\\t\" << widthStr << \" MHz\\t\\t\"\n                          << (widthStr.size() > 3 ? \"\" : \"\\t\") << gi << \" ns\\t\\t\\t\" << throughput\n                          << \" Mbit/s\" << std::endl;\n\n                // test first element\n                if (mcs == minMcs && channelWidth == 20 && gi == 3200)\n                {\n                    if (throughput * (1 + tolerance) < minExpectedThroughput)\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                }\n                // test last element\n                if (mcs == maxMcs && channelWidth == maxChannelWidth && gi == 800)\n                {\n                    if (maxExpectedThroughput > 0 &&\n                        throughput > maxExpectedThroughput * (1 + tolerance))\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                }\n                // Skip comparisons with previous cases if more than one stations are present\n                // because, e.g., random collisions in the establishment of Block Ack agreements\n                // have an impact on throughput\n                if (nStations == 1)\n                {\n                    // test previous throughput is smaller (for the same mcs)\n                    if (throughput * (1 + tolerance) > previous)\n                    {\n                        previous = throughput;\n                    }\n                    else if (throughput > 0)\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                    // test previous throughput is smaller (for the same channel width and GI)\n                    if (throughput * (1 + tolerance) > prevThroughput[index])\n                    {\n                        prevThroughput[index] = throughput;\n                    }\n                    else if (throughput > 0)\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                }\n                index++;\n                gi /= 2;\n            }\n            channelWidth *= 2;\n        }\n    }\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simulation in NS-3 that demonstrates the classical hidden terminal problem and its solution using RTS/CTS in an ad-hoc Wi-Fi network. Set up a topology with three nodes, where node 0 and node 2 are hidden from each other, and both communicate with node 1. Use the MatrixPropagationLossModel to simulate a 50 dB loss between adjacent nodes. Configure the simulation to use 802.11b Wi-Fi in ad-hoc mode, and install the Internet stack and IP addresses. Generate two CBR streams using the OnOffApplication, where node 0 sends to node 1, and node 2 sends to node 1, with each flow slightly staggered to avoid NS-3 bugs. Enable flow monitoring and simulate for 10 seconds, capturing performance statistics like throughput and packet loss. Run the simulation twice—once with RTS/CTS disabled and once with it enabled for packets larger than 100 bytes. Print out the flow statistics after each run."}, {"role": "assistant", "content": "/* Classical hidden terminal problem and its RTS/CTS solution.\n *\n * Topology: [node 0] <-- -50 dB --> [node 1] <-- -50 dB --> [node 2]\n *\n * This example illustrates the use of\n *  - Wifi in ad-hoc mode\n *  - Matrix propagation loss model\n *  - Use of OnOffApplication to generate CBR stream\n *  - IP flow monitor\n */\n\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/constant-position-mobility-model.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-flow-classifier.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/propagation-delay-model.h\"\n#include \"ns3/propagation-loss-model.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-echo-helper.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\n/**\n * Run single 10 seconds experiment\n *\n * \\param enableCtsRts if true, enable RTS/CTS for packets larger than 100 bytes.\n * \\param wifiManager WiFi manager to use.\n */\nvoid\nexperiment(bool enableCtsRts, std::string wifiManager)\n{\n    // 0. Enable or disable CTS/RTS\n    UintegerValue ctsThr = (enableCtsRts ? UintegerValue(100) : UintegerValue(2200));\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", ctsThr);\n\n    // 1. Create 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // 2. Place nodes somehow, this is required by every wireless simulation\n    for (uint8_t i = 0; i < 3; ++i)\n    {\n        nodes.Get(i)->AggregateObject(CreateObject<ConstantPositionMobilityModel>());\n    }\n\n    // 3. Create propagation loss matrix\n    Ptr<MatrixPropagationLossModel> lossModel = CreateObject<MatrixPropagationLossModel>();\n    lossModel->SetDefaultLoss(200); // set default loss to 200 dB (no link)\n    lossModel->SetLoss(nodes.Get(0)->GetObject<MobilityModel>(),\n                       nodes.Get(1)->GetObject<MobilityModel>(),\n                       50); // set symmetric loss 0 <-> 1 to 50 dB\n    lossModel->SetLoss(nodes.Get(2)->GetObject<MobilityModel>(),\n                       nodes.Get(1)->GetObject<MobilityModel>(),\n                       50); // set symmetric loss 2 <-> 1 to 50 dB\n\n    // 4. Create & setup wifi channel\n    Ptr<YansWifiChannel> wifiChannel = CreateObject<YansWifiChannel>();\n    wifiChannel->SetPropagationLossModel(lossModel);\n    wifiChannel->SetPropagationDelayModel(CreateObject<ConstantSpeedPropagationDelayModel>());\n\n    // 5. Install wireless devices\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n    wifi.SetRemoteStationManager(\"ns3::\" + wifiManager + \"WifiManager\");\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.SetChannel(wifiChannel);\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\"); // use ad-hoc MAC\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // uncomment the following to have athstats output\n    // AthstatsHelper athstats;\n    // athstats.EnableAthstats(enableCtsRts ? \"rtscts-athstats-node\" : \"basic-athstats-node\" ,\n    // nodes);\n\n    // uncomment the following to have pcap output\n    // wifiPhy.SetPcapDataLinkType (WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    // wifiPhy.EnablePcap (enableCtsRts ? \"rtscts-pcap-node\" : \"basic-pcap-node\" , nodes);\n\n    // 6. Install TCP/IP stack & assign IP addresses\n    InternetStackHelper internet;\n    internet.Install(nodes);\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.0.0.0\");\n    ipv4.Assign(devices);\n\n    // 7. Install applications: two CBR streams each saturating the channel\n    ApplicationContainer cbrApps;\n    uint16_t cbrPort = 12345;\n    OnOffHelper onOffHelper(\"ns3::UdpSocketFactory\",\n                            InetSocketAddress(Ipv4Address(\"10.0.0.2\"), cbrPort));\n    onOffHelper.SetAttribute(\"PacketSize\", UintegerValue(1400));\n    onOffHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    // flow 1:  node 0 -> node 1\n    onOffHelper.SetAttribute(\"DataRate\", StringValue(\"3000000bps\"));\n    onOffHelper.SetAttribute(\"StartTime\", TimeValue(Seconds(1.000000)));\n    cbrApps.Add(onOffHelper.Install(nodes.Get(0)));\n\n    // flow 2:  node 2 -> node 1\n    /**\n     * \\internal\n     * The slightly different start times and data rates are a workaround\n     * for \\bugid{388} and \\bugid{912}\n     */\n    onOffHelper.SetAttribute(\"DataRate\", StringValue(\"3001100bps\"));\n    onOffHelper.SetAttribute(\"StartTime\", TimeValue(Seconds(1.001)));\n    cbrApps.Add(onOffHelper.Install(nodes.Get(2)));\n\n    /**\n     * \\internal\n     * We also use separate UDP applications that will send a single\n     * packet before the CBR flows start.\n     * This is a workaround for the lack of perfect ARP, see \\bugid{187}\n     */\n    uint16_t echoPort = 9;\n    UdpEchoClientHelper echoClientHelper(Ipv4Address(\"10.0.0.2\"), echoPort);\n    echoClientHelper.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClientHelper.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    echoClientHelper.SetAttribute(\"PacketSize\", UintegerValue(10));\n    ApplicationContainer pingApps;\n\n    // again using different start times to workaround Bug 388 and Bug 912\n    echoClientHelper.SetAttribute(\"StartTime\", TimeValue(Seconds(0.001)));\n    pingApps.Add(echoClientHelper.Install(nodes.Get(0)));\n    echoClientHelper.SetAttribute(\"StartTime\", TimeValue(Seconds(0.006)));\n    pingApps.Add(echoClientHelper.Install(nodes.Get(2)));\n\n    // 8. Install FlowMonitor on all nodes\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // 9. Run simulation for 10 seconds\n    Simulator::Stop(Seconds(10));\n    Simulator::Run();\n\n    // 10. Print per flow statistics\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n    for (auto i = stats.begin(); i != stats.end(); ++i)\n    {\n        // first 2 FlowIds are for ECHO apps, we don't want to display them\n        //\n        // Duration for throughput measurement is 9.0 seconds, since\n        //   StartTime of the OnOffApplication is at about \"second 1\"\n        // and\n        //   Simulator::Stops at \"second 10\".\n        if (i->first > 2)\n        {\n            Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n            std::cout << \"Flow \" << i->first - 2 << \" (\" << t.sourceAddress << \" -> \"\n                      << t.destinationAddress << \")\\n\";\n            std::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n            std::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n            std::cout << \"  TxOffered:  \" << i->second.txBytes * 8.0 / 9.0 / 1000 / 1000\n                      << \" Mbps\\n\";\n            std::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n            std::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n            std::cout << \"  Throughput: \" << i->second.rxBytes * 8.0 / 9.0 / 1000 / 1000\n                      << \" Mbps\\n\";\n        }\n    }\n\n    // 11. Cleanup\n    Simulator::Destroy();\n}\n\nint\nmain(int argc, char** argv)\n{\n    std::string wifiManager(\"Arf\");\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\n        \"wifiManager\",\n        \"Set wifi rate manager (Aarf, Aarfcd, Amrr, Arf, Cara, Ideal, Minstrel, Onoe, Rraa)\",\n        wifiManager);\n    cmd.Parse(argc, argv);\n\n    std::cout << \"Hidden station experiment with RTS/CTS disabled:\\n\" << std::flush;\n    experiment(false, wifiManager);\n    std::cout << \"------------------------------------------------\\n\";\n    std::cout << \"Hidden station experiment with RTS/CTS enabled:\\n\";\n    experiment(true, wifiManager);\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate simple simulation of an IEEE 802.11n Wi-Fi network using the NS-3 simulator. The program should configure the network to evaluate the goodput for different Modulation and Coding Scheme (MCS) values (from 0 to 7), varying channel widths (20 or 40 MHz), and guard intervals (short or long). It should allow the user to configure parameters like the simulation time, UDP or TCP mode, RTS/CTS, distance between the station and access point, and expected throughput."}, {"role": "assistant", "content": "#include \"ns3/attribute-container.h\"\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/ht-phy.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/tuple.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This is a simple example in order to show how to configure an IEEE 802.11n Wi-Fi network.\n//\n// It outputs the UDP or TCP goodput for every HT MCS value, which depends on the MCS value (0 to\n// 7), the channel width (20 or 40 MHz) and the guard interval (long or short). The PHY bitrate is\n// constant over all the simulation run. The user can also specify the distance between the access\n// point and the station: the larger the distance the smaller the goodput.\n//\n// The simulation assumes a single station in an infrastructure network:\n//\n//  STA     AP\n//    *     *\n//    |     |\n//   n1     n2\n//\n// Packets in this simulation belong to BestEffort Access Class (AC_BE).\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ht-wifi-network\");\n\nint\nmain(int argc, char* argv[])\n{\n    bool udp{true};\n    bool useRts{false};\n    Time simulationTime{\"10s\"};\n    meter_u distance{1.0};\n    double frequency{5}; // whether 2.4 or 5 GHz\n    int mcs{-1};         // -1 indicates an unset value\n    double minExpectedThroughput{0.0};\n    double maxExpectedThroughput{0.0};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"frequency\",\n                 \"Whether working in the 2.4 or 5.0 GHz band (other values gets rejected)\",\n                 frequency);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the station and the access point\",\n                 distance);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"udp\", \"UDP if set to 1, TCP otherwise\", udp);\n    cmd.AddValue(\"useRts\", \"Enable/disable RTS/CTS\", useRts);\n    cmd.AddValue(\"mcs\", \"if set, limit testing to a specific MCS (0-7)\", mcs);\n    cmd.AddValue(\"minExpectedThroughput\",\n                 \"if set, simulation fails if the lowest throughput is below this value\",\n                 minExpectedThroughput);\n    cmd.AddValue(\"maxExpectedThroughput\",\n                 \"if set, simulation fails if the highest throughput is above this value\",\n                 maxExpectedThroughput);\n    cmd.Parse(argc, argv);\n\n    if (useRts)\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"0\"));\n    }\n\n    double prevThroughput[8] = {0};\n\n    std::cout << \"MCS value\"\n              << \"\\t\\t\"\n              << \"Channel width\"\n              << \"\\t\\t\"\n              << \"short GI\"\n              << \"\\t\\t\"\n              << \"Throughput\" << '\\n';\n    int minMcs = 0;\n    int maxMcs = 7;\n    if (mcs >= 0 && mcs <= 7)\n    {\n        minMcs = mcs;\n        maxMcs = mcs;\n    }\n    for (int mcs = minMcs; mcs <= maxMcs; mcs++)\n    {\n        uint8_t index = 0;\n        double previous = 0;\n        for (int channelWidth = 20; channelWidth <= 40;)\n        {\n            for (auto sgi : {false, true})\n            {\n                uint32_t payloadSize; // 1500 byte IP packet\n                if (udp)\n                {\n                    payloadSize = 1472; // bytes\n                }\n                else\n                {\n                    payloadSize = 1448; // bytes\n                    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n                }\n\n                NodeContainer wifiStaNode;\n                wifiStaNode.Create(1);\n                NodeContainer wifiApNode;\n                wifiApNode.Create(1);\n\n                YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n                YansWifiPhyHelper phy;\n                phy.SetChannel(channel.Create());\n\n                WifiMacHelper mac;\n                WifiHelper wifi;\n                std::ostringstream ossControlMode;\n\n                if (frequency == 5.0)\n                {\n                    ossControlMode << \"OfdmRate\";\n                    wifi.SetStandard(WIFI_STANDARD_80211n);\n                }\n                else if (frequency == 2.4)\n                {\n                    wifi.SetStandard(WIFI_STANDARD_80211n);\n                    ossControlMode << \"ErpOfdmRate\";\n                    Config::SetDefault(\"ns3::LogDistancePropagationLossModel::ReferenceLoss\",\n                                       DoubleValue(40.046));\n                }\n                else\n                {\n                    NS_FATAL_ERROR(\"Wrong frequency value!\");\n                }\n\n                auto nonHtRefRateMbps = HtPhy::GetNonHtReferenceRate(mcs) / 1e6;\n                ossControlMode << nonHtRefRateMbps << \"Mbps\";\n\n                std::ostringstream ossDataMode;\n                ossDataMode << \"HtMcs\" << mcs;\n                wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                             \"DataMode\",\n                                             StringValue(ossDataMode.str()),\n                                             \"ControlMode\",\n                                             StringValue(ossControlMode.str()));\n                // Set guard interval\n                wifi.ConfigHtOptions(\"ShortGuardIntervalSupported\", BooleanValue(sgi));\n\n                Ssid ssid = Ssid(\"ns3-80211n\");\n                AttributeContainerValue<\n                    TupleValue<UintegerValue, UintegerValue, EnumValue<WifiPhyBand>, UintegerValue>,\n                    ';'>\n                    channelValue;\n                WifiPhyBand band = (frequency == 5.0 ? WIFI_PHY_BAND_5GHZ : WIFI_PHY_BAND_2_4GHZ);\n                channelValue.Set(WifiPhy::ChannelSegments{{0, channelWidth, band, 0}});\n\n                mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n                phy.Set(\"ChannelSettings\", channelValue);\n\n                NetDeviceContainer staDevice;\n                staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n                mac.SetType(\"ns3::ApWifiMac\",\n                            \"EnableBeaconJitter\",\n                            BooleanValue(false),\n                            \"Ssid\",\n                            SsidValue(ssid));\n\n                NetDeviceContainer apDevice;\n                apDevice = wifi.Install(phy, mac, wifiApNode);\n\n                int64_t streamNumber = 150;\n                streamNumber += WifiHelper::AssignStreams(apDevice, streamNumber);\n                streamNumber += WifiHelper::AssignStreams(staDevice, streamNumber);\n\n                // mobility.\n                MobilityHelper mobility;\n                Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n                positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n                positionAlloc->Add(Vector(distance, 0.0, 0.0));\n                mobility.SetPositionAllocator(positionAlloc);\n\n                mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n                mobility.Install(wifiApNode);\n                mobility.Install(wifiStaNode);\n\n                /* Internet stack*/\n                InternetStackHelper stack;\n                stack.Install(wifiApNode);\n                stack.Install(wifiStaNode);\n                streamNumber += stack.AssignStreams(wifiApNode, streamNumber);\n                streamNumber += stack.AssignStreams(wifiStaNode, streamNumber);\n\n                Ipv4AddressHelper address;\n                address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n                Ipv4InterfaceContainer staNodeInterface;\n                Ipv4InterfaceContainer apNodeInterface;\n\n                staNodeInterface = address.Assign(staDevice);\n                apNodeInterface = address.Assign(apDevice);\n\n                /* Setting applications */\n                const auto maxLoad =\n                    HtPhy::GetDataRate(mcs, channelWidth, NanoSeconds(sgi ? 400 : 800), 1);\n                ApplicationContainer serverApp;\n                if (udp)\n                {\n                    // UDP flow\n                    uint16_t port = 9;\n                    UdpServerHelper server(port);\n                    serverApp = server.Install(wifiStaNode.Get(0));\n                    streamNumber += server.AssignStreams(wifiStaNode.Get(0), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n                    const auto packetInterval = payloadSize * 8.0 / maxLoad;\n\n                    UdpClientHelper client(staNodeInterface.GetAddress(0), port);\n                    client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n                    client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n                    client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                    ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n                    streamNumber += client.AssignStreams(wifiApNode.Get(0), streamNumber);\n\n                    clientApp.Start(Seconds(1.0));\n                    clientApp.Stop(simulationTime + Seconds(1.0));\n                }\n                else\n                {\n                    // TCP flow\n                    uint16_t port = 50000;\n                    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n                    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n                    serverApp = packetSinkHelper.Install(wifiStaNode.Get(0));\n                    streamNumber +=\n                        packetSinkHelper.AssignStreams(wifiStaNode.Get(0), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n\n                    OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n                    onoff.SetAttribute(\"OnTime\",\n                                       StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n                    onoff.SetAttribute(\"OffTime\",\n                                       StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n                    onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                    onoff.SetAttribute(\"DataRate\", DataRateValue(maxLoad));\n                    AddressValue remoteAddress(\n                        InetSocketAddress(staNodeInterface.GetAddress(0), port));\n                    onoff.SetAttribute(\"Remote\", remoteAddress);\n                    ApplicationContainer clientApp = onoff.Install(wifiApNode.Get(0));\n                    streamNumber += onoff.AssignStreams(wifiApNode.Get(0), streamNumber);\n\n                    clientApp.Start(Seconds(1.0));\n                    clientApp.Stop(simulationTime + Seconds(1.0));\n                }\n\n                Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n                Simulator::Stop(simulationTime + Seconds(1.0));\n                Simulator::Run();\n\n                auto rxBytes = 0.0;\n                if (udp)\n                {\n                    rxBytes = payloadSize * DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n                }\n                else\n                {\n                    rxBytes = DynamicCast<PacketSink>(serverApp.Get(0))->GetTotalRx();\n                }\n                auto throughput = (rxBytes * 8) / simulationTime.GetMicroSeconds(); // Mbit/s\n\n                Simulator::Destroy();\n\n                std::cout << mcs << \"\\t\\t\\t\" << channelWidth << \" MHz\\t\\t\\t\" << std::boolalpha\n                          << sgi << \"\\t\\t\\t\" << throughput << \" Mbit/s\" << std::endl;\n\n                // test first element\n                if (mcs == minMcs && channelWidth == 20 && !sgi)\n                {\n                    if (throughput < minExpectedThroughput)\n                    {\n                        NS_FATAL_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                    }\n                }\n                // test last element\n                if (mcs == maxMcs && channelWidth == 40 && sgi)\n                {\n                    if (maxExpectedThroughput > 0 && throughput > maxExpectedThroughput)\n                    {\n                        NS_FATAL_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                    }\n                }\n                // test previous throughput is smaller (for the same mcs)\n                if (throughput > previous)\n                {\n                    previous = throughput;\n                }\n                else\n                {\n                    NS_FATAL_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                }\n                // test previous throughput is smaller (for the same channel width and GI)\n                if (throughput > prevThroughput[index])\n                {\n                    prevThroughput[index] = throughput;\n                }\n                else\n                {\n                    NS_FATAL_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                }\n                index++;\n            }\n            channelWidth *= 2;\n        }\n    }\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nProvide a C++ example code for NS-3 that demonstrates the configuration of a mixed network with b/g and HT/non-HT stations, compares their performance under various scenarios such as ERP protection mode, short PPDU format, short slot time, and different payload sizes, and supports both UDP and TCP traffic, while outputting throughput results for each configuration."}, {"role": "assistant", "content": "#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/ht-configuration.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/pointer.h\"\n#include \"ns3/qos-txop.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/wifi-mac.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This example shows how to configure mixed networks (i.e. mixed b/g and HT/non-HT) and how are\n// performance in several scenarios.\n//\n// The example compares first g only and mixed b/g cases with various configurations depending on\n// the following parameters:\n// - protection mode that is configured on the AP;\n// - whether short PPDU format is supported by the 802.11b station;\n// - whether short slot time is supported by both the 802.11g station and the AP.\n//\n// The example then compares HT only and mixed HT/non-HT cases.\n//\n// The output results show that the presence of an 802.11b station strongly affects 802.11g\n// performance. Protection mechanisms ensure that the NAV value of 802.11b stations is set correctly\n// in case of 802.11g transmissions. In practice, those protection mechanism add a lot of overhead,\n// resulting in reduced performance. CTS-To-Self introduces less overhead than Rts-Cts, but is not\n// heard by hidden stations (and is thus generally only recommended as a protection mechanism for\n// access points). Since short slot time is disabled once an 802.11b station enters the network,\n// benefits from short slot time are only observed in a g only configuration.\n//\n// The user can also select the payload size and can choose either an UDP or a TCP connection.\n// Example: ./ns3 run \"wifi-mixed-network --isUdp=1\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MixedNetwork\");\n\n/** Parameters */\nstruct Parameters\n{\n    std::string testName;          //!< Test name\n    bool enableErpProtection;      //!< True to enable ERP protection\n    std::string erpProtectionMode; //!< ERP protection mode\n    bool enableShortSlotTime;      //!< True to enable short slot time\n    bool enableShortPhyPreamble;   //!< True to enable short PHY preamble\n    WifiStandard apType;           //!< Wifi standard for AP\n    uint32_t nWifiB;               //!< Number of 802.11b stations\n    bool bHasTraffic;              //!< True if 802.11b stations generate traffic\n    uint32_t nWifiG;               //!< Number of 802.11g stations\n    bool gHasTraffic;              //!< True if 802.11g stations generate traffic\n    uint32_t nWifiN;               //!< Number of 802.11n stations\n    bool nHasTraffic;              //!< True if 802.11n stations generate traffic\n    bool isUdp;                    //!< True to generate UDP traffic\n    uint32_t payloadSize;          //!< Payload size in bytes\n    Time simulationTime;           //!< Simulation time\n};\n\nclass Experiment\n{\n  public:\n    Experiment();\n    /**\n     * Run an experiment with the given parameters\n     * \\param params the given parameters\n     * \\return the throughput\n     */\n    double Run(Parameters params);\n};\n\nExperiment::Experiment()\n{\n}\n\ndouble\nExperiment::Run(Parameters params)\n{\n    std::string apTypeString;\n    if (params.apType == WIFI_STANDARD_80211g)\n    {\n        apTypeString = \"WIFI_STANDARD_80211g\";\n    }\n    else if (params.apType == WIFI_STANDARD_80211n)\n    {\n        apTypeString = \"WIFI_STANDARD_80211n_2_4GHZ\";\n    }\n\n    std::cout << \"Run: \" << params.testName\n              << \"\\n\\t enableErpProtection=\" << params.enableErpProtection\n              << \"\\n\\t erpProtectionMode=\" << params.erpProtectionMode\n              << \"\\n\\t enableShortSlotTime=\" << params.enableShortSlotTime\n              << \"\\n\\t enableShortPhyPreamble=\" << params.enableShortPhyPreamble\n              << \"\\n\\t apType=\" << apTypeString << \"\\n\\t nWifiB=\" << params.nWifiB\n              << \"\\n\\t bHasTraffic=\" << params.bHasTraffic << \"\\n\\t nWifiG=\" << params.nWifiG\n              << \"\\n\\t gHasTraffic=\" << params.gHasTraffic << \"\\n\\t nWifiN=\" << params.nWifiN\n              << \"\\n\\t nHasTraffic=\" << params.nHasTraffic << std::endl;\n\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::ErpProtectionMode\",\n                       StringValue(params.erpProtectionMode));\n\n    double throughput = 0;\n    uint32_t nWifiB = params.nWifiB;\n    uint32_t nWifiG = params.nWifiG;\n    uint32_t nWifiN = params.nWifiN;\n    auto simulationTime = params.simulationTime;\n    uint32_t payloadSize = params.payloadSize;\n\n    NodeContainer wifiBStaNodes;\n    wifiBStaNodes.Create(nWifiB);\n    NodeContainer wifiGStaNodes;\n    wifiGStaNodes.Create(nWifiG);\n    NodeContainer wifiNStaNodes;\n    wifiNStaNodes.Create(nWifiN);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    channel.AddPropagationLoss(\"ns3::RangePropagationLossModel\");\n\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::IdealWifiManager\");\n\n    // 802.11b STA\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"ShortSlotTimeSupported\",\n                BooleanValue(params.enableShortSlotTime));\n\n    // Configure the PHY preamble type: long or short\n    phy.Set(\"ShortPlcpPreambleSupported\", BooleanValue(params.enableShortPhyPreamble));\n\n    NetDeviceContainer bStaDevice;\n    bStaDevice = wifi.Install(phy, mac, wifiBStaNodes);\n\n    // 802.11b/g STA\n    wifi.SetStandard(WIFI_STANDARD_80211g);\n    NetDeviceContainer gStaDevice;\n    gStaDevice = wifi.Install(phy, mac, wifiGStaNodes);\n\n    // 802.11b/g/n STA\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    NetDeviceContainer nStaDevice;\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"BE_BlockAckThreshold\",\n                UintegerValue(2),\n                \"ShortSlotTimeSupported\",\n                BooleanValue(params.enableShortSlotTime));\n    nStaDevice = wifi.Install(phy, mac, wifiNStaNodes);\n\n    // AP\n    NetDeviceContainer apDevice;\n    wifi.SetStandard(params.apType);\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false),\n                \"BE_BlockAckThreshold\",\n                UintegerValue(2),\n                \"EnableNonErpProtection\",\n                BooleanValue(params.enableErpProtection),\n                \"ShortSlotTimeSupported\",\n                BooleanValue(params.enableShortSlotTime));\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set TXOP limit\n    if (params.apType == WIFI_STANDARD_80211n)\n    {\n        Ptr<NetDevice> dev = wifiApNode.Get(0)->GetDevice(0);\n        Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n        Ptr<WifiMac> wifi_mac = wifi_dev->GetMac();\n        PointerValue ptr;\n        wifi_mac->GetAttribute(\"BE_Txop\", ptr);\n        Ptr<QosTxop> edca = ptr.Get<QosTxop>();\n        edca->SetTxopLimit(MicroSeconds(3008));\n    }\n    if (nWifiN > 0)\n    {\n        Ptr<NetDevice> dev = wifiNStaNodes.Get(0)->GetDevice(0);\n        Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n        Ptr<WifiMac> wifi_mac = wifi_dev->GetMac();\n        PointerValue ptr;\n        wifi_mac->GetAttribute(\"BE_Txop\", ptr);\n        Ptr<QosTxop> edca = ptr.Get<QosTxop>();\n        edca->SetTxopLimit(MicroSeconds(3008));\n    }\n\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/BE_MaxAmpduSize\",\n                UintegerValue(0)); // Disable A-MPDU\n\n    // Define mobility model\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    for (uint32_t i = 0; i < nWifiB; i++)\n    {\n        positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    }\n    for (uint32_t i = 0; i < nWifiG; i++)\n    {\n        positionAlloc->Add(Vector(0.0, 5.0, 0.0));\n    }\n    for (uint32_t i = 0; i < nWifiN; i++)\n    {\n        positionAlloc->Add(Vector(0.0, 0.0, 5.0));\n    }\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiBStaNodes);\n    mobility.Install(wifiGStaNodes);\n    mobility.Install(wifiNStaNodes);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiBStaNodes);\n    stack.Install(wifiGStaNodes);\n    stack.Install(wifiNStaNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer bStaInterface;\n    bStaInterface = address.Assign(bStaDevice);\n    Ipv4InterfaceContainer gStaInterface;\n    gStaInterface = address.Assign(gStaDevice);\n    Ipv4InterfaceContainer nStaInterface;\n    nStaInterface = address.Assign(nStaDevice);\n    Ipv4InterfaceContainer ApInterface;\n    ApInterface = address.Assign(apDevice);\n\n    // Setting applications\n    if (params.isUdp)\n    {\n        uint16_t port = 9;\n        UdpServerHelper server(port);\n        ApplicationContainer serverApp = server.Install(wifiApNode);\n        serverApp.Start(Seconds(0.0));\n        serverApp.Stop(simulationTime + Seconds(1.0));\n\n        UdpClientHelper client(ApInterface.GetAddress(0), port);\n        client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n        client.SetAttribute(\"Interval\", TimeValue(Time(\"0.0002\"))); // packets/s\n        client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n        ApplicationContainer clientApps;\n        if (params.bHasTraffic)\n        {\n            clientApps.Add(client.Install(wifiBStaNodes));\n        }\n        if (params.gHasTraffic)\n        {\n            clientApps.Add(client.Install(wifiGStaNodes));\n        }\n        if (params.nHasTraffic)\n        {\n            clientApps.Add(client.Install(wifiNStaNodes));\n        }\n        clientApps.Start(Seconds(1.0));\n        clientApps.Stop(simulationTime + Seconds(1.0));\n\n        Simulator::Stop(simulationTime + Seconds(1.0));\n        Simulator::Run();\n\n        double totalPacketsThrough = DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n        throughput = totalPacketsThrough * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    }\n    else\n    {\n        uint16_t port = 50000;\n        Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n        PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n\n        ApplicationContainer serverApp = packetSinkHelper.Install(wifiApNode.Get(0));\n        serverApp.Start(Seconds(0.0));\n        serverApp.Stop(simulationTime + Seconds(1.0));\n\n        OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n        onoff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        onoff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n        onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n        onoff.SetAttribute(\"DataRate\", DataRateValue(150000000)); // bit/s\n\n        AddressValue remoteAddress(InetSocketAddress(ApInterface.GetAddress(0), port));\n        onoff.SetAttribute(\"Remote\", remoteAddress);\n\n        ApplicationContainer clientApps;\n        if (params.bHasTraffic)\n        {\n            clientApps.Add(onoff.Install(wifiBStaNodes));\n        }\n        if (params.gHasTraffic)\n        {\n            clientApps.Add(onoff.Install(wifiGStaNodes));\n        }\n        if (params.nHasTraffic)\n        {\n            clientApps.Add(onoff.Install(wifiNStaNodes));\n        }\n        clientApps.Start(Seconds(1.0));\n        clientApps.Stop(simulationTime + Seconds(1.0));\n\n        Simulator::Stop(simulationTime + Seconds(1.0));\n        Simulator::Run();\n\n        double totalPacketsThrough = DynamicCast<PacketSink>(serverApp.Get(0))->GetTotalRx();\n        throughput += totalPacketsThrough * 8 / simulationTime.GetMicroSeconds();\n    }\n    Simulator::Destroy();\n    return throughput;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    Parameters params;\n    params.testName = \"\";\n    params.enableErpProtection = false;\n    params.erpProtectionMode = \"Cts-To-Self\";\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = false;\n    params.apType = WIFI_STANDARD_80211g;\n    params.nWifiB = 0;\n    params.bHasTraffic = false;\n    params.nWifiG = 1;\n    params.gHasTraffic = true;\n    params.nWifiN = 0;\n    params.nHasTraffic = false;\n    params.isUdp = true;\n    params.payloadSize = 1472; // bytes\n    params.simulationTime = Seconds(10);\n\n    bool verifyResults = false; // used for regression\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"payloadSize\", \"Payload size in bytes\", params.payloadSize);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", params.simulationTime);\n    cmd.AddValue(\"isUdp\", \"UDP if set to 1, TCP otherwise\", params.isUdp);\n    cmd.AddValue(\"verifyResults\",\n                 \"Enable/disable results verification at the end of the simulation\",\n                 verifyResults);\n    cmd.Parse(argc, argv);\n\n    Experiment experiment;\n    double throughput = 0;\n\n    params.testName = \"g only with all g features disabled\";\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 22.5 || throughput > 23.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"g only with short slot time enabled\";\n    params.enableErpProtection = false;\n    params.enableShortSlotTime = true;\n    params.enableShortPhyPreamble = false;\n    params.nWifiB = 0;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 29 || throughput > 30))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"Mixed b/g with all g features disabled\";\n    params.enableErpProtection = false;\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = false;\n    params.nWifiB = 1;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 22.5 || throughput > 23.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"Mixed b/g with short plcp preamble enabled\";\n    params.enableErpProtection = false;\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = true;\n    params.nWifiB = 1;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 22.5 || throughput > 23.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"Mixed b/g with short slot time enabled using RTS-CTS protection\";\n    params.enableErpProtection = true;\n    params.erpProtectionMode = \"Rts-Cts\";\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = false;\n    params.nWifiB = 1;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 19 || throughput > 20))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"Mixed b/g with short plcp preamble enabled using RTS-CTS protection\";\n    params.enableErpProtection = true;\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = true;\n    params.nWifiB = 1;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 19 || throughput > 20))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"Mixed b/g with short slot time enabled using CTS-TO-SELF protection\";\n    params.enableErpProtection = true;\n    params.erpProtectionMode = \"Cts-To-Self\";\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = false;\n    params.nWifiB = 1;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 20.5 || throughput > 21.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"Mixed b/g with short plcp preamble enabled using CTS-TO-SELF protection\";\n    params.enableErpProtection = true;\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = true;\n    params.nWifiB = 1;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 20.5 || throughput > 21.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"HT only\";\n    params.enableErpProtection = false;\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = false;\n    params.apType = WIFI_STANDARD_80211n;\n    params.nWifiB = 0;\n    params.bHasTraffic = false;\n    params.nWifiG = 0;\n    params.gHasTraffic = false;\n    params.nWifiN = 1;\n    params.nHasTraffic = true;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 44 || throughput > 45))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    params.testName = \"Mixed HT/non-HT\";\n    params.enableErpProtection = false;\n    params.enableShortSlotTime = false;\n    params.enableShortPhyPreamble = false;\n    params.apType = WIFI_STANDARD_80211n;\n    params.nWifiB = 0;\n    params.bHasTraffic = false;\n    params.nWifiG = 1;\n    params.gHasTraffic = false;\n    params.nWifiN = 1;\n    params.nHasTraffic = true;\n    throughput = experiment.Run(params);\n    if (verifyResults && (throughput < 44 || throughput > 45))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s \\n\" << std::endl;\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a code example in C++ using the NS-3 simulator that demonstrates the implementation of a WiFi multirate experiment with 100 nodes, multiple simultaneous flows, ad hoc routing, and node mobility. The code should include class declarations and key methods such as running the experiment, setting up applications, monitoring packet reception, calculating throughput, and handling node mobility. Ensure that logging, command-line arguments, and results collection via Gnuplot are also implemented, along with specific instructions for building, running, and debugging the simulation."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/olsr-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/rectangle.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"multirate\");\n\n/**\n * WiFi multirate experiment class.\n *\n * It handles the creation and run of an experiment.\n *\n * Scenarios: 100 nodes, multiple simultaneous flows, multi-hop ad hoc, routing,\n * and mobility\n *\n * QUICK INSTRUCTIONS:\n *\n * To optimize build:\n * ./ns3 configure -d optimized\n * ./ns3\n *\n * To compile:\n * ./ns3 run wifi-multirate\n *\n * To compile with command line(useful for varying parameters):\n * ./ns3 run \"wifi-multirate --totalTime=0.3s --rateManager=ns3::MinstrelWifiManager\"\n *\n * To turn on NS_LOG:\n * export NS_LOG=multirate=level_all\n * (can only view log if built with ./ns3 configure -d debug)\n *\n * To debug:\n * ./ns3 shell\n * gdb ./build/debug/examples/wireless/wifi-multirate\n *\n * To view pcap files:\n * tcpdump -nn -tt -r filename.pcap\n *\n * To monitor the files:\n * tail -f filename.pcap\n *\n */\nclass Experiment\n{\n  public:\n    Experiment();\n    /**\n     * \\brief Construct a new Experiment object\n     *\n     * \\param name The name of the experiment.\n     */\n    Experiment(std::string name);\n    /**\n     * Run an experiment.\n     * \\param wifi The WifiHelper class.\n     * \\param wifiPhy The YansWifiPhyHelper class.\n     * \\param wifiMac The WifiMacHelper class.\n     * \\param wifiChannel The YansWifiChannelHelper class.\n     * \\param mobility The MobilityHelper class.\n     * \\return a 2D dataset of the experiment data.\n     */\n    Gnuplot2dDataset Run(const WifiHelper& wifi,\n                         const YansWifiPhyHelper& wifiPhy,\n                         const WifiMacHelper& wifiMac,\n                         const YansWifiChannelHelper& wifiChannel,\n                         const MobilityHelper& mobility);\n\n    /**\n     * \\brief Setup the experiment from the command line arguments.\n     *\n     * \\param argc The argument count.\n     * \\param argv The argument vector.\n     * \\return true\n     */\n    bool CommandSetup(int argc, char** argv);\n\n    /**\n     * \\brief Check if routing is enabled.\n     *\n     * \\return true if routing is enabled.\n     */\n    bool IsRouting() const\n    {\n        return m_enableRouting;\n    }\n\n    /**\n     * \\brief Check if mobility is enabled.\n     *\n     * \\return true if mobility is enabled.\n     */\n    bool IsMobility() const\n    {\n        return m_enableMobility;\n    }\n\n    /**\n     * \\brief Get the Scenario number.\n     *\n     * \\return the scenario number.\n     */\n    uint32_t GetScenario() const\n    {\n        return m_scenario;\n    }\n\n    /**\n     * \\brief Get the RTS Threshold.\n     *\n     * \\return the RTS Threshold.\n     */\n    std::string GetRtsThreshold() const\n    {\n        return m_rtsThreshold;\n    }\n\n    /**\n     * \\brief Get the Output File Name.\n     *\n     * \\return the Output File Name.\n     */\n    std::string GetOutputFileName() const\n    {\n        return m_outputFileName;\n    }\n\n    /**\n     * \\brief Get the Rate Manager.\n     *\n     * \\return the Rate Manager.\n     */\n    std::string GetRateManager() const\n    {\n        return m_rateManager;\n    }\n\n  private:\n    /**\n     * \\brief Setup the receiving socket.\n     *\n     * \\param node The receiving node.\n     * \\return the Rx socket.\n     */\n    Ptr<Socket> SetupPacketReceive(Ptr<Node> node);\n    /**\n     * Generate 1-hop and 2-hop neighbors of a node in grid topology\n     * \\param c The node container.\n     * \\param senderId The sender ID.\n     * \\return the neighbor nodes.\n     */\n    NodeContainer GenerateNeighbors(NodeContainer c, uint32_t senderId);\n\n    /**\n     * \\brief Setup the application in the nodes.\n     *\n     * \\param client Client node.\n     * \\param server Server node.\n     * \\param start Start time.\n     * \\param stop Stop time.\n     */\n    void ApplicationSetup(Ptr<Node> client, Ptr<Node> server, double start, double stop);\n    /**\n     * Take the grid map, divide it into 4 quadrants\n     * Assign all nodes from each quadrant to a specific container\n     *\n     * \\param c The node container.\n     */\n    void AssignNeighbors(NodeContainer c);\n    /**\n     * Sources and destinations are randomly selected such that a node\n     * may be the source for multiple destinations and a node maybe a destination\n     * for multiple sources.\n     *\n     * \\param c The node container.\n     */\n    void SelectSrcDest(NodeContainer c);\n    /**\n     * \\brief Receive a packet.\n     *\n     * \\param socket The receiving socket.\n     */\n    void ReceivePacket(Ptr<Socket> socket);\n    /**\n     * \\brief Calculate the throughput.\n     */\n    void CheckThroughput();\n    /**\n     * A sender node will  set up a flow to each of the its neighbors\n     * in its quadrant randomly.  All the flows are exponentially distributed.\n     *\n     * \\param sender The sender node.\n     * \\param c The node neighbors.\n     */\n    void SendMultiDestinations(Ptr<Node> sender, NodeContainer c);\n\n    Gnuplot2dDataset m_output; //!< Output dataset.\n\n    double m_totalTime;      //!< Total experiment time.\n    double m_expMean;        //!< Exponential parameter for sending packets.\n    double m_samplingPeriod; //!< Sampling period.\n\n    uint32_t m_bytesTotal;   //!< Total number of received bytes.\n    uint32_t m_packetSize;   //!< Packet size.\n    uint32_t m_gridSize;     //!< Grid size.\n    uint32_t m_nodeDistance; //!< Node distance.\n    uint32_t m_port;         //!< Listening port.\n    uint32_t m_scenario;     //!< Scenario number.\n\n    bool m_enablePcap;     //!< True if PCAP output is enabled.\n    bool m_enableTracing;  //!< True if tracing output is enabled.\n    bool m_enableFlowMon;  //!< True if FlowMon is enabled.\n    bool m_enableRouting;  //!< True if routing is enabled.\n    bool m_enableMobility; //!< True if mobility is enabled.\n\n    /**\n     * Node containers for each quadrant.\n     * @{\n     */\n    NodeContainer m_containerA;\n    NodeContainer m_containerB;\n    NodeContainer m_containerC;\n    NodeContainer m_containerD;\n    /** @} */\n    std::string m_rtsThreshold;   //!< Rts threshold.\n    std::string m_rateManager;    //!< Rate manager.\n    std::string m_outputFileName; //!< Output file name.\n};\n\nExperiment::Experiment()\n{\n}\n\nExperiment::Experiment(std::string name)\n    : m_output(name),\n      m_totalTime(0.3),\n      m_expMean(0.1),\n      // flows being exponentially distributed\n      m_samplingPeriod(0.1),\n      m_bytesTotal(0),\n      m_packetSize(2000),\n      m_gridSize(10),\n      // 10x10 grid  for a total of 100 nodes\n      m_nodeDistance(30),\n      m_port(5000),\n      m_scenario(4),\n      m_enablePcap(false),\n      m_enableTracing(true),\n      m_enableFlowMon(false),\n      m_enableRouting(false),\n      m_enableMobility(false),\n      m_rtsThreshold(\"2200\"),\n      // 0 for enabling rts/cts\n      m_rateManager(\"ns3::MinstrelWifiManager\"),\n      m_outputFileName(\"minstrel\")\n{\n    m_output.SetStyle(Gnuplot2dDataset::LINES);\n}\n\nPtr<Socket>\nExperiment::SetupPacketReceive(Ptr<Node> node)\n{\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> sink = Socket::CreateSocket(node, tid);\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), m_port);\n    sink->Bind(local);\n    sink->SetRecvCallback(MakeCallback(&Experiment::ReceivePacket, this));\n\n    return sink;\n}\n\nvoid\nExperiment::ReceivePacket(Ptr<Socket> socket)\n{\n    Ptr<Packet> packet;\n    while ((packet = socket->Recv()))\n    {\n        m_bytesTotal += packet->GetSize();\n    }\n}\n\nvoid\nExperiment::CheckThroughput()\n{\n    double mbs = ((m_bytesTotal * 8.0) / 1000000 / m_samplingPeriod);\n    m_bytesTotal = 0;\n    m_output.Add((Simulator::Now()).GetSeconds(), mbs);\n\n    // check throughput every samplingPeriod second\n    Simulator::Schedule(Seconds(m_samplingPeriod), &Experiment::CheckThroughput, this);\n}\n\nvoid\nExperiment::AssignNeighbors(NodeContainer c)\n{\n    uint32_t totalNodes = c.GetN();\n    for (uint32_t i = 0; i < totalNodes; i++)\n    {\n        if ((i % m_gridSize) <= (m_gridSize / 2 - 1))\n        {\n            // lower left quadrant\n            if (i < totalNodes / 2)\n            {\n                m_containerA.Add(c.Get(i));\n            }\n\n            // upper left quadrant\n            if (i >= (uint32_t)(4 * totalNodes) / 10)\n            {\n                m_containerC.Add(c.Get(i));\n            }\n        }\n        if ((i % m_gridSize) >= (m_gridSize / 2 - 1))\n        {\n            // lower right quadrant\n            if (i < totalNodes / 2)\n            {\n                m_containerB.Add(c.Get(i));\n            }\n\n            // upper right quadrant\n            if (i >= (uint32_t)(4 * totalNodes) / 10)\n            {\n                m_containerD.Add(c.Get(i));\n            }\n        }\n    }\n}\n\nNodeContainer\nExperiment::GenerateNeighbors(NodeContainer c, uint32_t senderId)\n{\n    NodeContainer nc;\n    uint32_t limit = senderId + 2;\n    for (uint32_t i = senderId - 2; i <= limit; i++)\n    {\n        // must ensure the boundaries for other topologies\n        nc.Add(c.Get(i));\n        nc.Add(c.Get(i + 10));\n        nc.Add(c.Get(i + 20));\n        nc.Add(c.Get(i - 10));\n        nc.Add(c.Get(i - 20));\n    }\n    return nc;\n}\n\nvoid\nExperiment::SelectSrcDest(NodeContainer c)\n{\n    uint32_t totalNodes = c.GetN();\n    Ptr<UniformRandomVariable> uvSrc = CreateObject<UniformRandomVariable>();\n    uvSrc->SetAttribute(\"Min\", DoubleValue(0));\n    uvSrc->SetAttribute(\"Max\", DoubleValue(totalNodes / 2 - 1));\n    Ptr<UniformRandomVariable> uvDest = CreateObject<UniformRandomVariable>();\n    uvDest->SetAttribute(\"Min\", DoubleValue(totalNodes / 2));\n    uvDest->SetAttribute(\"Max\", DoubleValue(totalNodes));\n\n    for (uint32_t i = 0; i < totalNodes / 3; i++)\n    {\n        ApplicationSetup(c.Get(uvSrc->GetInteger()), c.Get(uvDest->GetInteger()), 0, m_totalTime);\n    }\n}\n\nvoid\nExperiment::SendMultiDestinations(Ptr<Node> sender, NodeContainer c)\n{\n    // UniformRandomVariable params: (Xrange, Yrange)\n    Ptr<UniformRandomVariable> uv = CreateObject<UniformRandomVariable>();\n    uv->SetAttribute(\"Min\", DoubleValue(0));\n    uv->SetAttribute(\"Max\", DoubleValue(c.GetN()));\n\n    // ExponentialRandomVariable params: (mean, upperbound)\n    Ptr<ExponentialRandomVariable> ev = CreateObject<ExponentialRandomVariable>();\n    ev->SetAttribute(\"Mean\", DoubleValue(m_expMean));\n    ev->SetAttribute(\"Bound\", DoubleValue(m_totalTime));\n\n    double start = 0.0;\n    double stop;\n    uint32_t destIndex;\n\n    for (uint32_t i = 0; i < c.GetN(); i++)\n    {\n        stop = start + ev->GetValue();\n        NS_LOG_DEBUG(\"Start=\" << start << \" Stop=\" << stop);\n\n        do\n        {\n            destIndex = (uint32_t)uv->GetValue();\n        } while ((c.Get(destIndex))->GetId() == sender->GetId());\n\n        ApplicationSetup(sender, c.Get(destIndex), start, stop);\n\n        start = stop;\n\n        if (start > m_totalTime)\n        {\n            break;\n        }\n    }\n}\n\n/**\n * Print the position of two nodes.\n *\n * \\param client Client node.\n * \\param server Server node.\n * \\return a string with the nodes data and positions\n */\nstatic inline std::string\nPrintPosition(Ptr<Node> client, Ptr<Node> server)\n{\n    Vector serverPos = server->GetObject<MobilityModel>()->GetPosition();\n    Vector clientPos = client->GetObject<MobilityModel>()->GetPosition();\n\n    Ptr<Ipv4> ipv4Server = server->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4Client = client->GetObject<Ipv4>();\n\n    Ipv4InterfaceAddress iaddrServer = ipv4Server->GetAddress(1, 0);\n    Ipv4InterfaceAddress iaddrClient = ipv4Client->GetAddress(1, 0);\n\n    Ipv4Address ipv4AddrServer = iaddrServer.GetLocal();\n    Ipv4Address ipv4AddrClient = iaddrClient.GetLocal();\n\n    std::ostringstream oss;\n    oss << \"Set up Server Device \" << (server->GetDevice(0))->GetAddress() << \" with ip \"\n        << ipv4AddrServer << \" position (\" << serverPos.x << \",\" << serverPos.y << \",\"\n        << serverPos.z << \")\";\n\n    oss << \"Set up Client Device \" << (client->GetDevice(0))->GetAddress() << \" with ip \"\n        << ipv4AddrClient << \" position (\" << clientPos.x << \",\" << clientPos.y << \",\"\n        << clientPos.z << \")\"\n        << \"\\n\";\n    return oss.str();\n}\n\nvoid\nExperiment::ApplicationSetup(Ptr<Node> client, Ptr<Node> server, double start, double stop)\n{\n    Ptr<Ipv4> ipv4Server = server->GetObject<Ipv4>();\n\n    Ipv4InterfaceAddress iaddrServer = ipv4Server->GetAddress(1, 0);\n    Ipv4Address ipv4AddrServer = iaddrServer.GetLocal();\n\n    NS_LOG_DEBUG(PrintPosition(client, server));\n\n    // Equipping the source  node with OnOff Application used for sending\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(Ipv4Address(\"10.0.0.1\"), m_port)));\n    onoff.SetConstantRate(DataRate(54000000));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(m_packetSize));\n    onoff.SetAttribute(\"Remote\", AddressValue(InetSocketAddress(ipv4AddrServer, m_port)));\n\n    ApplicationContainer apps = onoff.Install(client);\n    apps.Start(Seconds(start));\n    apps.Stop(Seconds(stop));\n\n    Ptr<Socket> sink = SetupPacketReceive(server);\n}\n\nGnuplot2dDataset\nExperiment::Run(const WifiHelper& wifi,\n                const YansWifiPhyHelper& wifiPhy,\n                const WifiMacHelper& wifiMac,\n                const YansWifiChannelHelper& wifiChannel,\n                const MobilityHelper& mobility)\n{\n    uint32_t nodeSize = m_gridSize * m_gridSize;\n    NodeContainer c;\n    c.Create(nodeSize);\n\n    YansWifiPhyHelper phy = wifiPhy;\n    phy.SetChannel(wifiChannel.Create());\n\n    NetDeviceContainer devices = wifi.Install(phy, wifiMac, c);\n\n    OlsrHelper olsr;\n    Ipv4StaticRoutingHelper staticRouting;\n\n    Ipv4ListRoutingHelper list;\n\n    if (m_enableRouting)\n    {\n        list.Add(staticRouting, 0);\n        list.Add(olsr, 10);\n    }\n\n    InternetStackHelper internet;\n\n    if (m_enableRouting)\n    {\n        internet.SetRoutingHelper(list); // has effect on the next Install ()\n    }\n    internet.Install(c);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer ipInterfaces;\n    ipInterfaces = address.Assign(devices);\n\n    MobilityHelper mobil = mobility;\n    mobil.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                               \"MinX\",\n                               DoubleValue(0.0),\n                               \"MinY\",\n                               DoubleValue(0.0),\n                               \"DeltaX\",\n                               DoubleValue(m_nodeDistance),\n                               \"DeltaY\",\n                               DoubleValue(m_nodeDistance),\n                               \"GridWidth\",\n                               UintegerValue(m_gridSize),\n                               \"LayoutType\",\n                               StringValue(\"RowFirst\"));\n\n    mobil.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    if (m_enableMobility && m_enableRouting)\n    {\n        // Rectangle (xMin, xMax, yMin, yMax)\n        mobil.SetMobilityModel(\"ns3::RandomDirection2dMobilityModel\",\n                               \"Bounds\",\n                               RectangleValue(Rectangle(0, 500, 0, 500)),\n                               \"Speed\",\n                               StringValue(\"ns3::ConstantRandomVariable[Constant=10]\"),\n                               \"Pause\",\n                               StringValue(\"ns3::ConstantRandomVariable[Constant=0.2]\"));\n    }\n    mobil.Install(c);\n\n    if (m_scenario == 1 && m_enableRouting)\n    {\n        SelectSrcDest(c);\n    }\n    else if (m_scenario == 2)\n    {\n        // All flows begin at the same time\n        for (uint32_t i = 0; i < nodeSize - 1; i = i + 2)\n        {\n            ApplicationSetup(c.Get(i), c.Get(i + 1), 0, m_totalTime);\n        }\n    }\n    else if (m_scenario == 3)\n    {\n        AssignNeighbors(c);\n        // Note: these senders are hand-picked in order to ensure good coverage\n        // for 10x10 grid, basically one sender for each quadrant\n        // you might have to change these values for other grids\n        NS_LOG_DEBUG(\">>>>>>>>>region A<<<<<<<<<\");\n        SendMultiDestinations(c.Get(22), m_containerA);\n\n        NS_LOG_DEBUG(\">>>>>>>>>region B<<<<<<<<<\");\n        SendMultiDestinations(c.Get(26), m_containerB);\n\n        NS_LOG_DEBUG(\">>>>>>>>>region C<<<<<<<<<\");\n        SendMultiDestinations(c.Get(72), m_containerC);\n\n        NS_LOG_DEBUG(\">>>>>>>>>region D<<<<<<<<<\");\n        SendMultiDestinations(c.Get(76), m_containerD);\n    }\n    else if (m_scenario == 4)\n    {\n        // GenerateNeighbors(NodeContainer, uint32_t sender)\n        // Note: these senders are hand-picked in order to ensure good coverage\n        // you might have to change these values for other grids\n        NodeContainer c1;\n        NodeContainer c2;\n        NodeContainer c3;\n        NodeContainer c4;\n        NodeContainer c5;\n        NodeContainer c6;\n        NodeContainer c7;\n        NodeContainer c8;\n        NodeContainer c9;\n\n        c1 = GenerateNeighbors(c, 22);\n        c2 = GenerateNeighbors(c, 24);\n        c3 = GenerateNeighbors(c, 26);\n        c4 = GenerateNeighbors(c, 42);\n        c5 = GenerateNeighbors(c, 44);\n        c6 = GenerateNeighbors(c, 46);\n        c7 = GenerateNeighbors(c, 62);\n        c8 = GenerateNeighbors(c, 64);\n        c9 = GenerateNeighbors(c, 66);\n\n        SendMultiDestinations(c.Get(22), c1);\n        SendMultiDestinations(c.Get(24), c2);\n        SendMultiDestinations(c.Get(26), c3);\n        SendMultiDestinations(c.Get(42), c4);\n        SendMultiDestinations(c.Get(44), c5);\n        SendMultiDestinations(c.Get(46), c6);\n        SendMultiDestinations(c.Get(62), c7);\n        SendMultiDestinations(c.Get(64), c8);\n        SendMultiDestinations(c.Get(66), c9);\n    }\n\n    CheckThroughput();\n\n    if (m_enablePcap)\n    {\n        phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n        phy.EnablePcapAll(GetOutputFileName());\n    }\n\n    if (m_enableTracing)\n    {\n        AsciiTraceHelper ascii;\n        phy.EnableAsciiAll(ascii.CreateFileStream(GetOutputFileName() + \".tr\"));\n    }\n\n    FlowMonitorHelper flowmonHelper;\n\n    if (m_enableFlowMon)\n    {\n        flowmonHelper.InstallAll();\n    }\n\n    Simulator::Stop(Seconds(m_totalTime));\n    Simulator::Run();\n\n    if (m_enableFlowMon)\n    {\n        flowmonHelper.SerializeToXmlFile((GetOutputFileName() + \".flomon\"), false, false);\n    }\n\n    Simulator::Destroy();\n\n    return m_output;\n}\n\nbool\nExperiment::CommandSetup(int argc, char** argv)\n{\n    // for commandline input\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"packetSize\", \"packet size\", m_packetSize);\n    cmd.AddValue(\"totalTime\", \"simulation time\", m_totalTime);\n    // according to totalTime, select an appropriate samplingPeriod automatically.\n    if (m_totalTime < 1.0)\n    {\n        m_samplingPeriod = 0.1;\n    }\n    else\n    {\n        m_samplingPeriod = 1.0;\n    }\n    // or user selects a samplingPeriod.\n    cmd.AddValue(\"samplingPeriod\", \"sampling period\", m_samplingPeriod);\n    cmd.AddValue(\"rtsThreshold\", \"rts threshold\", m_rtsThreshold);\n    cmd.AddValue(\"rateManager\", \"type of rate\", m_rateManager);\n    cmd.AddValue(\"outputFileName\", \"output filename\", m_outputFileName);\n    cmd.AddValue(\"enableRouting\", \"enable Routing\", m_enableRouting);\n    cmd.AddValue(\"enableMobility\", \"enable Mobility\", m_enableMobility);\n    cmd.AddValue(\"scenario\", \"scenario \", m_scenario);\n\n    cmd.Parse(argc, argv);\n    return true;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    Experiment experiment;\n    experiment = Experiment(\"multirate\");\n\n    // for commandline input\n    experiment.CommandSetup(argc, argv);\n\n    std::ofstream outfile(experiment.GetOutputFileName() + \".plt\");\n\n    MobilityHelper mobility;\n    Gnuplot gnuplot;\n    Gnuplot2dDataset dataset;\n\n    WifiHelper wifi;\n    WifiMacHelper wifiMac;\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n\n    wifiMac.SetType(\"ns3::AdhocWifiMac\", \"Ssid\", StringValue(\"Testbed\"));\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n    wifi.SetRemoteStationManager(experiment.GetRateManager());\n\n    NS_LOG_INFO(\"Scenario: \" << experiment.GetScenario());\n    NS_LOG_INFO(\"Rts Threshold: \" << experiment.GetRtsThreshold());\n    NS_LOG_INFO(\"Name:  \" << experiment.GetOutputFileName());\n    NS_LOG_INFO(\"Rate:  \" << experiment.GetRateManager());\n    NS_LOG_INFO(\"Routing: \" << experiment.IsRouting());\n    NS_LOG_INFO(\"Mobility: \" << experiment.IsMobility());\n\n    dataset = experiment.Run(wifi, wifiPhy, wifiMac, wifiChannel, mobility);\n\n    gnuplot.AddDataset(dataset);\n    gnuplot.GenerateOutput(outfile);\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an NS-3 simulation in C++ that sets up a network with two nodes. Install the Internet stack on these nodes and establish a point-to-point link between them with a transmission rate of 5 Mbps and a propagation delay of 2 milliseconds. Assign IP addresses from the range \"10.1.1.0/24\" to the devices on each node. The goal is to ensure that the Internet Protocol (IP) addresses are correctly assigned to the nodes, but no communication between the nodes is required in this simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"NodeIpAddressAssignment\");\n\nint main(int argc, char *argv[]) {\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link between the two nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack (IP protocol)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nProvide code for a simple NS-3 simulation that configures an IEEE 802.11n Wi-Fi network with multiple Traffic Operation Set (TOS) values. The simulation should allow the user to specify the number of stations, HT MCS value (0 to 7), channel width (20 or 40 MHz), guard interval (long or short), distance between stations and the access point, and whether RTS/CTS is used. The code should calculate and output the aggregated UDP throughput based on these parameters."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This is a simple example in order to show how to configure an IEEE 802.11n Wi-Fi network\n// with multiple TOS. It outputs the aggregated UDP throughput, which depends on the number of\n// stations, the HT MCS value (0 to 7), the channel width (20 or 40 MHz) and the guard interval\n// (long or short). The user can also specify the distance between the access point and the\n// stations (in meters), and can specify whether RTS/CTS is used or not.\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiMultiTos\");\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t nWifi{4};\n    Time simulationTime{\"10s\"};\n    meter_u distance{1.0};\n    uint16_t mcs{7};\n    uint8_t channelWidth{20}; // MHz\n    bool useShortGuardInterval{false};\n    bool useRts{false};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nWifi\", \"Number of stations\", nWifi);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the stations and the access point\",\n                 distance);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"useRts\", \"Enable/disable RTS/CTS\", useRts);\n    cmd.AddValue(\"mcs\", \"MCS value (0 - 7)\", mcs);\n    cmd.AddValue(\"channelWidth\", \"Channel width in MHz\", channelWidth);\n    cmd.AddValue(\"useShortGuardInterval\",\n                 \"Enable/disable short guard interval\",\n                 useShortGuardInterval);\n    cmd.Parse(argc, argv);\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(nWifi);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n\n    std::ostringstream oss;\n    oss << \"HtMcs\" << mcs;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(oss.str()),\n                                 \"ControlMode\",\n                                 StringValue(oss.str()),\n                                 \"RtsCtsThreshold\",\n                                 UintegerValue(useRts ? 0 : 999999));\n\n    Ssid ssid = Ssid(\"ns3-80211n\");\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set channel width\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/ChannelSettings\",\n                StringValue(\"{0, \" + std::to_string(channelWidth) + \", BAND_2_4GHZ, 0}\"));\n\n    // Set guard interval\n    Config::Set(\n        \"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/ShortGuardIntervalSupported\",\n        BooleanValue(useShortGuardInterval));\n\n    // mobility\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    for (uint32_t i = 0; i < nWifi; i++)\n    {\n        positionAlloc->Add(Vector(distance, 0.0, 0.0));\n    }\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNodes);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n    Ipv4AddressHelper address;\n\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staNodeInterfaces;\n    Ipv4InterfaceContainer apNodeInterface;\n\n    staNodeInterfaces = address.Assign(staDevices);\n    apNodeInterface = address.Assign(apDevice);\n\n    // Setting applications\n    ApplicationContainer sourceApplications;\n    ApplicationContainer sinkApplications;\n    std::vector<uint8_t> tosValues = {0x70, 0x28, 0xb8, 0xc0}; // AC_BE, AC_BK, AC_VI, AC_VO\n    uint32_t portNumber = 9;\n    for (uint32_t index = 0; index < nWifi; ++index)\n    {\n        for (uint8_t tosValue : tosValues)\n        {\n            auto ipv4 = wifiApNode.Get(0)->GetObject<Ipv4>();\n            const auto address = ipv4->GetAddress(1, 0).GetLocal();\n            InetSocketAddress sinkSocket(address, portNumber++);\n            OnOffHelper onOffHelper(\"ns3::UdpSocketFactory\", sinkSocket);\n            onOffHelper.SetAttribute(\"OnTime\",\n                                     StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n            onOffHelper.SetAttribute(\"OffTime\",\n                                     StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n            onOffHelper.SetAttribute(\"DataRate\", DataRateValue(50000000 / nWifi));\n            onOffHelper.SetAttribute(\"PacketSize\", UintegerValue(1472)); // bytes\n            onOffHelper.SetAttribute(\"Tos\", UintegerValue(tosValue));\n            sourceApplications.Add(onOffHelper.Install(wifiStaNodes.Get(index)));\n            PacketSinkHelper packetSinkHelper(\"ns3::UdpSocketFactory\", sinkSocket);\n            sinkApplications.Add(packetSinkHelper.Install(wifiApNode.Get(0)));\n        }\n    }\n\n    sinkApplications.Start(Seconds(0.0));\n    sinkApplications.Stop(simulationTime + Seconds(1.0));\n    sourceApplications.Start(Seconds(1.0));\n    sourceApplications.Stop(simulationTime + Seconds(1.0));\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    Simulator::Stop(simulationTime + Seconds(1.0));\n    Simulator::Run();\n\n    double throughput = 0;\n    for (uint32_t index = 0; index < sinkApplications.GetN(); ++index)\n    {\n        double totalPacketsThrough =\n            DynamicCast<PacketSink>(sinkApplications.Get(index))->GetTotalRx();\n        throughput += ((totalPacketsThrough * 8) / simulationTime.GetMicroSeconds()); // Mbit/s\n    }\n\n    Simulator::Destroy();\n\n    if (throughput > 0)\n    {\n        std::cout << \"Aggregated throughput: \" << throughput << \" Mbit/s\" << std::endl;\n    }\n    else\n    {\n        std::cout << \"Obtained throughput is 0!\" << std::endl;\n        exit(1);\n    }\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nProvide code that validates NIST and YANS error rate models for EHT rates in NS-3. The program should output plots of Frame Success Rate versus Signal-to-Noise Ratio (SNR) for Nist, Yans, and Table-based error rate models, iterating over every HT MCS value. The simulation should use Gnuplot to generate visual outputs and include configurations for frame size and range of SNR values."}, {"role": "assistant", "content": "// This example is used to validate NIST and YANS error rate models for EHT rates.\n//\n// It outputs plots of the Frame Success Rate versus the Signal-to-noise ratio for\n// Nist, Yans and Table-based error rate models and for every HT MCS value.\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t frameSizeBytes = 1500;\n    std::ofstream yansfile(\"yans-frame-success-rate-be.plt\");\n    std::ofstream nistfile(\"nist-frame-success-rate-be.plt\");\n    std::ofstream tablefile(\"table-frame-success-rate-be.plt\");\n\n    const std::vector<std::string> modes{\n        \"EhtMcs0\",\n        \"EhtMcs1\",\n        \"EhtMcs2\",\n        \"EhtMcs3\",\n        \"EhtMcs4\",\n        \"EhtMcs5\",\n        \"EhtMcs6\",\n        \"EhtMcs7\",\n        \"EhtMcs8\",\n        \"EhtMcs9\",\n        \"EhtMcs10\",\n        \"EhtMcs11\",\n        \"EhtMcs12\",\n        \"EhtMcs13\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"FrameSize\", \"The frame size\", frameSizeBytes);\n    cmd.Parse(argc, argv);\n\n    Gnuplot yansplot = Gnuplot(\"yans-frame-success-rate-be.eps\");\n    Gnuplot nistplot = Gnuplot(\"nist-frame-success-rate-be.eps\");\n    Gnuplot tableplot = Gnuplot(\"table-frame-success-rate-be.eps\");\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n    WifiTxVector txVector;\n\n    uint32_t frameSizeBits = frameSizeBytes * 8;\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset yansdataset(mode);\n        Gnuplot2dDataset nistdataset(mode);\n        Gnuplot2dDataset tabledataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -5.0; snrDb <= 55.0; snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double ps = yans->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            yansdataset.Add(snrDb, ps);\n\n            ps = nist->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            nistdataset.Add(snrDb, ps);\n\n            ps = table->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            tabledataset.Add(snrDb, ps);\n        }\n\n        yansplot.AddDataset(yansdataset);\n        nistplot.AddDataset(nistdataset);\n        tableplot.AddDataset(tabledataset);\n    }\n\n    std::stringstream plotExtra;\n    plotExtra << \"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\";\n\n    const std::vector<std::string> colors{\n        \"green\",\n        \"blue\",\n        \"red\",\n        \"black\",\n        \"orange\",\n        \"purple\",\n        \"yellow\",\n        \"pink\",\n        \"grey\",\n        \"magenta\",\n        \"brown\",\n        \"turquoise\",\n        \"olive\",\n        \"beige\",\n    };\n\n    NS_ASSERT_MSG(colors.size() == modes.size(), \"Colors and modes vectors have different sizes\");\n\n    for (std::size_t i = 0; i < modes.size(); i++)\n    {\n        plotExtra << \"set style line \" << (i + 1) << \" linewidth 5 linecolor rgb \\\"\" << colors[i]\n                  << \"\\\" \\n\";\n    }\n    plotExtra << \"set style increment user\";\n\n    yansplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    yansplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    yansplot.SetExtra(plotExtra.str());\n    yansplot.GenerateOutput(yansfile);\n    yansfile.close();\n\n    nistplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    nistplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    nistplot.SetExtra(plotExtra.str());\n    nistplot.GenerateOutput(nistfile);\n    nistfile.close();\n\n    tableplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    tableplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    tableplot.SetExtra(plotExtra.str());\n    tableplot.GenerateOutput(tablefile);\n    tablefile.close();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nProvide code that validates the NIST, YANS, and Table-based error rate models for HE (High Efficiency) rates in NS-3. The program should output Gnuplot plots of Frame Success Rate versus Signal-to-Noise Ratio (SNR) for each error rate model and for every HE MCS value. The code should allow configuration of frame size and iterate through a range of SNR values while generating the corresponding datasets for plotting."}, {"role": "assistant", "content": "// This example is used to validate Nist, Yans and Table-based error rate models for HE rates.\n//\n// It outputs plots of the Frame Success Rate versus the Signal-to-noise ratio for\n// Nist, Yans and Table-based error rate models and for every HE MCS value.\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t frameSizeBytes = 1500;\n    std::ofstream yansfile(\"yans-frame-success-rate-ax.plt\");\n    std::ofstream nistfile(\"nist-frame-success-rate-ax.plt\");\n    std::ofstream tablefile(\"table-frame-success-rate-ax.plt\");\n\n    const std::vector<std::string> modes{\n        \"HeMcs0\",\n        \"HeMcs1\",\n        \"HeMcs2\",\n        \"HeMcs3\",\n        \"HeMcs4\",\n        \"HeMcs5\",\n        \"HeMcs6\",\n        \"HeMcs7\",\n        \"HeMcs8\",\n        \"HeMcs9\",\n        \"HeMcs10\",\n        \"HeMcs11\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"FrameSize\", \"The frame size\", frameSizeBytes);\n    cmd.Parse(argc, argv);\n\n    Gnuplot yansplot = Gnuplot(\"yans-frame-success-rate-ax.eps\");\n    Gnuplot nistplot = Gnuplot(\"nist-frame-success-rate-ax.eps\");\n    Gnuplot tableplot = Gnuplot(\"table-frame-success-rate-ax.eps\");\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n    WifiTxVector txVector;\n\n    uint32_t frameSizeBits = frameSizeBytes * 8;\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset yansdataset(mode);\n        Gnuplot2dDataset nistdataset(mode);\n        Gnuplot2dDataset tabledataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -5.0; snrDb <= 40.0; snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double ps = yans->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            yansdataset.Add(snrDb, ps);\n\n            ps = nist->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            nistdataset.Add(snrDb, ps);\n\n            ps = table->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            tabledataset.Add(snrDb, ps);\n        }\n\n        yansplot.AddDataset(yansdataset);\n        nistplot.AddDataset(nistdataset);\n        tableplot.AddDataset(tabledataset);\n    }\n\n    yansplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    yansplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    yansplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style line 10 linewidth 5\\n\\\nset style line 11 linewidth 5\\n\\\nset style line 12 linewidth 5\\n\\\nset style increment user\");\n    yansplot.GenerateOutput(yansfile);\n    yansfile.close();\n\n    nistplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    nistplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    nistplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style line 10 linewidth 5\\n\\\nset style line 11 linewidth 5\\n\\\nset style line 12 linewidth 5\\n\\\nset style increment user\");\n\n    nistplot.GenerateOutput(nistfile);\n    nistfile.close();\n\n    tableplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    tableplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    tableplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style line 10 linewidth 5\\n\\\nset style line 11 linewidth 5\\n\\\nset style line 12 linewidth 5\\n\\\nset style increment user\");\n\n    tableplot.GenerateOutput(tablefile);\n    tablefile.close();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nProvide code that validates NIST, YANS, and Table-based error rate models for HT (High Throughput) rates in NS-3. The program should generate Gnuplot plots of Frame Success Rate versus Signal-to-Noise Ratio (SNR) for each error rate model and for every HT MCS value. It should iterate over SNR values, calculate the frame success rate for each mode and model, and output the results as Gnuplot datasets while allowing configuration of frame size."}, {"role": "assistant", "content": "// This example is used to validate Nist, Yans and Table-based error rate models for HT rates.\n//\n// It outputs plots of the Frame Success Rate versus the Signal-to-noise ratio for\n// Nist, Yans and Table-based error rate models and for every HT MCS value.\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t frameSizeBytes = 1500;\n    std::ofstream yansfile(\"yans-frame-success-rate-n.plt\");\n    std::ofstream nistfile(\"nist-frame-success-rate-n.plt\");\n    std::ofstream tablefile(\"table-frame-success-rate-n.plt\");\n\n    const std::vector<std::string> modes{\n        \"HtMcs0\",\n        \"HtMcs1\",\n        \"HtMcs2\",\n        \"HtMcs3\",\n        \"HtMcs4\",\n        \"HtMcs5\",\n        \"HtMcs6\",\n        \"HtMcs7\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"FrameSize\", \"The frame size in bytes\", frameSizeBytes);\n    cmd.Parse(argc, argv);\n\n    Gnuplot yansplot = Gnuplot(\"yans-frame-success-rate-n.eps\");\n    Gnuplot nistplot = Gnuplot(\"nist-frame-success-rate-n.eps\");\n    Gnuplot tableplot = Gnuplot(\"table-frame-success-rate-n.eps\");\n    WifiTxVector txVector;\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n\n    uint32_t frameSizeBits = frameSizeBytes * 8;\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset yansdataset(mode);\n        Gnuplot2dDataset nistdataset(mode);\n        Gnuplot2dDataset tabledataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -5.0; snrDb <= 30.0; snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double ps = yans->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            yansdataset.Add(snrDb, ps);\n\n            ps = nist->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            nistdataset.Add(snrDb, ps);\n\n            ps = table->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            tabledataset.Add(snrDb, ps);\n        }\n\n        yansplot.AddDataset(yansdataset);\n        nistplot.AddDataset(nistdataset);\n        tableplot.AddDataset(tabledataset);\n    }\n\n    yansplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    yansplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    yansplot.SetExtra(\"set xrange [-5:30]\\n\\\nset yrange [0:1.2]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style increment user\");\n    yansplot.GenerateOutput(yansfile);\n    yansfile.close();\n\n    nistplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    nistplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    nistplot.SetExtra(\"set xrange [-5:30]\\n\\\nset yrange [0:1.2]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style increment user\");\n\n    nistplot.GenerateOutput(nistfile);\n    nistfile.close();\n\n    tableplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    tableplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    tableplot.SetExtra(\"set xrange [-5:30]\\n\\\nset yrange [0:1.2]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style increment user\");\n\n    tableplot.GenerateOutput(tablefile);\n    tablefile.close();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate code that validates NIST, YANS, and Table-based error rate models for HE (High Efficiency) rates in NS-3. The program should generate Gnuplot plots of Frame Success Rate versus Signal-to-Noise Ratio (SNR) for each error rate model and for all HE MCS values. It should iterate over SNR values, compute the frame success rate for each mode and model, and output the results as Gnuplot datasets. The frame size should also be configurable via command-line arguments."}, {"role": "assistant", "content": "// This example is used to validate Nist, Yans and Table-based error rate models for HE rates.\n//\n// It outputs plots of the Frame Success Rate versus the Signal-to-noise ratio for\n// Nist, Yans and Table-based error rate models and for every HE MCS value.\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t frameSizeBytes = 1500;\n    std::ofstream yansfile(\"yans-frame-success-rate-ax.plt\");\n    std::ofstream nistfile(\"nist-frame-success-rate-ax.plt\");\n    std::ofstream tablefile(\"table-frame-success-rate-ax.plt\");\n\n    const std::vector<std::string> modes{\n        \"HeMcs0\",\n        \"HeMcs1\",\n        \"HeMcs2\",\n        \"HeMcs3\",\n        \"HeMcs4\",\n        \"HeMcs5\",\n        \"HeMcs6\",\n        \"HeMcs7\",\n        \"HeMcs8\",\n        \"HeMcs9\",\n        \"HeMcs10\",\n        \"HeMcs11\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"FrameSize\", \"The frame size\", frameSizeBytes);\n    cmd.Parse(argc, argv);\n\n    Gnuplot yansplot = Gnuplot(\"yans-frame-success-rate-ax.eps\");\n    Gnuplot nistplot = Gnuplot(\"nist-frame-success-rate-ax.eps\");\n    Gnuplot tableplot = Gnuplot(\"table-frame-success-rate-ax.eps\");\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n    WifiTxVector txVector;\n\n    uint32_t frameSizeBits = frameSizeBytes * 8;\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset yansdataset(mode);\n        Gnuplot2dDataset nistdataset(mode);\n        Gnuplot2dDataset tabledataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -5.0; snrDb <= 40.0; snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double ps = yans->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            yansdataset.Add(snrDb, ps);\n\n            ps = nist->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            nistdataset.Add(snrDb, ps);\n\n            ps = table->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            tabledataset.Add(snrDb, ps);\n        }\n\n        yansplot.AddDataset(yansdataset);\n        nistplot.AddDataset(nistdataset);\n        tableplot.AddDataset(tabledataset);\n    }\n\n    yansplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    yansplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    yansplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style line 10 linewidth 5\\n\\\nset style line 11 linewidth 5\\n\\\nset style line 12 linewidth 5\\n\\\nset style increment user\");\n    yansplot.GenerateOutput(yansfile);\n    yansfile.close();\n\n    nistplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    nistplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    nistplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style line 10 linewidth 5\\n\\\nset style line 11 linewidth 5\\n\\\nset style line 12 linewidth 5\\n\\\nset style increment user\");\n\n    nistplot.GenerateOutput(nistfile);\n    nistfile.close();\n\n    tableplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    tableplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    tableplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style line 10 linewidth 5\\n\\\nset style line 11 linewidth 5\\n\\\nset style line 12 linewidth 5\\n\\\nset style increment user\");\n\n    tableplot.GenerateOutput(tablefile);\n    tablefile.close();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simulation for a wireless network that validates NIST, YANS, and Table-based error rate models for OFDM (Orthogonal Frequency-Division Multiplexing) rates in NS-3. The program should iterate over different OFDM modes and compute the Frame Success Rate versus Signal-to-Noise Ratio (SNR) for each error rate model. The program should output plots using Gnuplot, with each OFDM mode represented as a separate dataset. Frame size should be configurable through command-line arguments, and the SNR range should be from -5 dB to 30 dB."}, {"role": "assistant", "content": "// This example is used to validate Nist, Yans and Table-based error rate models for OFDM rates.\n//\n// It outputs plots of the Frame Success Rate versus the Signal-to-noise ratio for\n// Nist, Yans and Table-based error rate models and for every OFDM mode.\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t frameSizeBytes = 1500;\n    std::ofstream yansfile(\"yans-frame-success-rate-ofdm.plt\");\n    std::ofstream nistfile(\"nist-frame-success-rate-ofdm.plt\");\n    std::ofstream tablefile(\"table-frame-success-rate-ofdm.plt\");\n\n    const std::vector<std::string> modes{\n        \"OfdmRate6Mbps\",\n        \"OfdmRate9Mbps\",\n        \"OfdmRate12Mbps\",\n        \"OfdmRate18Mbps\",\n        \"OfdmRate24Mbps\",\n        \"OfdmRate36Mbps\",\n        \"OfdmRate48Mbps\",\n        \"OfdmRate54Mbps\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"FrameSize\", \"The frame size in bytes\", frameSizeBytes);\n    cmd.Parse(argc, argv);\n\n    Gnuplot yansplot = Gnuplot(\"yans-frame-success-rate-ofdm.eps\");\n    Gnuplot nistplot = Gnuplot(\"nist-frame-success-rate-ofdm.eps\");\n    Gnuplot tableplot = Gnuplot(\"table-frame-success-rate-ofdm.eps\");\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n    WifiTxVector txVector;\n\n    uint32_t frameSizeBits = frameSizeBytes * 8;\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset yansdataset(mode);\n        Gnuplot2dDataset nistdataset(mode);\n        Gnuplot2dDataset tabledataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -5.0; snrDb <= 30.0; snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double ps = yans->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            yansdataset.Add(snrDb, ps);\n\n            ps = nist->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            nistdataset.Add(snrDb, ps);\n\n            ps = table->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            tabledataset.Add(snrDb, ps);\n        }\n\n        yansplot.AddDataset(yansdataset);\n        nistplot.AddDataset(nistdataset);\n        tableplot.AddDataset(tabledataset);\n    }\n\n    yansplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    yansplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    yansplot.SetExtra(\"set xrange [-5:30]\\n\\\nset yrange [0:1.2]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style increment user\");\n    yansplot.GenerateOutput(yansfile);\n    yansfile.close();\n\n    nistplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    nistplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    nistplot.SetExtra(\"set xrange [-5:30]\\n\\\nset yrange [0:1.2]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style increment user\");\n\n    nistplot.GenerateOutput(nistfile);\n    nistfile.close();\n\n    tableplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    tableplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    tableplot.SetExtra(\"set xrange [-5:30]\\n\\\nset yrange [0:1.2]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style increment user\");\n\n    tableplot.GenerateOutput(tablefile);\n    tablefile.close();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate code that validates NIST, YANS, and Table-based error rate models for VHT (Very High Throughput) rates in NS-3. The program should calculate and plot the Frame Success Rate versus Signal-to-Noise Ratio (SNR) for all VHT MCS values, excluding MCS 9 for 20 MHz channels, for each error rate model. The output should include separate plots using Gnuplot for each mode, and the frame size should be configurable through command-line input. SNR should range from -5 dB to 30 dB."}, {"role": "assistant", "content": "// This example is used to validate Nist, Yans and Table-based error rate models for VHT rates.\n//\n// It outputs plots of the Frame Success Rate versus the Signal-to-noise ratio for\n// Nist, Yans and Table-based error rate models and for every VHT MCS value (MCS 9 is not\n// included since it is forbidden for 20 MHz channels).\n\n#include \"ns3/command-line.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/nist-error-rate-model.h\"\n#include \"ns3/table-based-error-rate-model.h\"\n#include \"ns3/wifi-tx-vector.h\"\n#include \"ns3/yans-error-rate-model.h\"\n\n#include <cmath>\n#include <fstream>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t frameSizeBytes = 1500;\n    std::ofstream yansfile(\"yans-frame-success-rate-ac.plt\");\n    std::ofstream nistfile(\"nist-frame-success-rate-ac.plt\");\n    std::ofstream tablefile(\"table-frame-success-rate-ac.plt\");\n\n    const std::vector<std::string> modes{\n        \"VhtMcs0\",\n        \"VhtMcs1\",\n        \"VhtMcs2\",\n        \"VhtMcs3\",\n        \"VhtMcs4\",\n        \"VhtMcs5\",\n        \"VhtMcs6\",\n        \"VhtMcs7\",\n        \"VhtMcs8\",\n    };\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"FrameSize\", \"The frame size in bytes\", frameSizeBytes);\n    cmd.Parse(argc, argv);\n\n    Gnuplot yansplot = Gnuplot(\"yans-frame-success-rate-ac.eps\");\n    Gnuplot nistplot = Gnuplot(\"nist-frame-success-rate-ac.eps\");\n    Gnuplot tableplot = Gnuplot(\"table-frame-success-rate-ac.eps\");\n\n    Ptr<YansErrorRateModel> yans = CreateObject<YansErrorRateModel>();\n    Ptr<NistErrorRateModel> nist = CreateObject<NistErrorRateModel>();\n    Ptr<TableBasedErrorRateModel> table = CreateObject<TableBasedErrorRateModel>();\n    WifiTxVector txVector;\n\n    uint32_t frameSizeBits = frameSizeBytes * 8;\n\n    for (const auto& mode : modes)\n    {\n        std::cout << mode << std::endl;\n        Gnuplot2dDataset yansdataset(mode);\n        Gnuplot2dDataset nistdataset(mode);\n        Gnuplot2dDataset tabledataset(mode);\n        txVector.SetMode(mode);\n\n        WifiMode wifiMode(mode);\n\n        for (double snrDb = -5.0; snrDb <= 30.0; snrDb += 0.1)\n        {\n            double snr = std::pow(10.0, snrDb / 10.0);\n\n            double ps = yans->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            yansdataset.Add(snrDb, ps);\n\n            ps = nist->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            nistdataset.Add(snrDb, ps);\n\n            ps = table->GetChunkSuccessRate(wifiMode, txVector, snr, frameSizeBits);\n            if (ps < 0.0 || ps > 1.0)\n            {\n                // error\n                exit(1);\n            }\n            tabledataset.Add(snrDb, ps);\n        }\n\n        yansplot.AddDataset(yansdataset);\n        nistplot.AddDataset(nistdataset);\n        tableplot.AddDataset(tabledataset);\n    }\n\n    yansplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    yansplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    yansplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style increment user\");\n    yansplot.GenerateOutput(yansfile);\n    yansfile.close();\n\n    nistplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    nistplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    nistplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style increment user\");\n\n    nistplot.GenerateOutput(nistfile);\n    nistfile.close();\n\n    tableplot.SetTerminal(\"postscript eps color enh \\\"Times-BoldItalic\\\"\");\n    tableplot.SetLegend(\"SNR(dB)\", \"Frame Success Rate\");\n    tableplot.SetExtra(\"set xrange [-5:55]\\n\\\nset yrange [0:1]\\n\\\nset style line 1 linewidth 5\\n\\\nset style line 2 linewidth 5\\n\\\nset style line 3 linewidth 5\\n\\\nset style line 4 linewidth 5\\n\\\nset style line 5 linewidth 5\\n\\\nset style line 6 linewidth 5\\n\\\nset style line 7 linewidth 5\\n\\\nset style line 8 linewidth 5\\n\\\nset style line 9 linewidth 5\\n\\\nset style increment user\");\n\n    tableplot.GenerateOutput(tablefile);\n    tablefile.close();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 network simulator to compare three WiFi rate control mechanisms: `ParfWifiManager`, `AparfWifiManager`, and `RrpaaWifiManager`. The program should simulate a simple WiFi network consisting of two nodes: an access point (AP) and a station (STA). The AP should generate UDP traffic at a constant bit rate (CBR) of 54 Mbps towards the STA. The STA will move away from the AP by 1 meter every second, and you should log the changes in transmit power and rate, as well as plot average throughput and average transmit power as functions of distance. Your program should output Gnuplot-compatible files and allow the user to specify parameters such as the rate control mechanism, RTS threshold, and output filenames through command-line arguments."}, {"role": "assistant", "content": "/**\n * This example program is designed to illustrate the behavior of three\n * power/rate-adaptive WiFi rate controls; namely, ns3::ParfWifiManager,\n * ns3::AparfWifiManager and ns3::RrpaaWifiManager.\n *\n * The output of this is typically two plot files, named throughput-parf.plt\n * (or throughput-aparf.plt, if Aparf is used) and power-parf.plt. If\n * Gnuplot program is available, one can use it to convert the plt file\n * into an eps file, by running:\n * \\code{.sh}\n *   gnuplot throughput-parf.plt\n * \\endcode\n * Also, to enable logging of rate and power changes to the terminal, set this\n * environment variable:\n * \\code{.sh}\n *   export NS_LOG=PowerAdaptationDistance=level_info\n * \\endcode\n *\n * This simulation consist of 2 nodes, one AP and one STA.\n * The AP generates UDP traffic with a CBR of 54 Mbps to the STA.\n * The AP can use any power and rate control mechanism and the STA uses\n * only Minstrel rate control.\n * The STA can be configured to move away from (or towards to) the AP.\n * By default, the AP is at coordinate (0,0,0) and the STA starts at\n * coordinate (5,0,0) (meters) and moves away on the x axis by 1 meter every\n * second.\n *\n * The output consists of:\n * - A plot of average throughput vs. distance.\n * - A plot of average transmit power vs. distance.\n * - (if logging is enabled) the changes of power and rate to standard output.\n *\n * The Average Transmit Power is defined as an average of the power\n * consumed per measurement interval, expressed in milliwatts.  The\n * power level for each frame transmission is reported by the simulator,\n * and the energy consumed is obtained by multiplying the power by the\n * frame duration.  At every 'stepTime' (defaulting to 1 second), the\n * total energy for the collection period is divided by the step time\n * and converted from dbm to milliwatt units, and this average is\n * plotted against time.\n *\n * When neither Parf, Aparf or Rrpaa is selected as the rate control, the\n * generation of the plot of average transmit power vs distance is suppressed\n * since the other Wifi rate controls do not support the necessary callbacks\n * for computing the average power.\n *\n * To display all the possible arguments and their defaults:\n * \\code{.sh}\n *   ./ns3 run \"wifi-power-adaptation-distance --help\"\n * \\endcode\n *\n * Example usage (selecting Aparf rather than Parf):\n * \\code{.sh}\n *   ./ns3 run \"wifi-power-adaptation-distance --manager=ns3::AparfWifiManager\n * --outputFileName=aparf\" \\endcode\n *\n * Another example (moving towards the AP):\n * \\code{.sh}\n *   ./ns3 run \"wifi-power-adaptation-distance --manager=ns3::AparfWifiManager\n * --outputFileName=aparf --stepsSize=-1 --STA1_x=200\" \\endcode\n *\n * To enable the log of rate and power changes:\n * \\code{.sh}\n *   export NS_LOG=PowerAdaptationDistance=level_info\n * \\endcode\n */\n\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/wifi-mac-header.h\"\n#include \"ns3/wifi-mac.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PowerAdaptationDistance\");\n\n/// Packet size generated at the AP\nstatic const uint32_t packetSize = 1420;\n\n/**\n * \\brief Class to collect node statistics.\n */\nclass NodeStatistics\n{\n  public:\n    /**\n     * \\brief Constructor.\n     *\n     * \\param aps Access points\n     * \\param stas WiFi Stations.\n     */\n    NodeStatistics(NetDeviceContainer aps, NetDeviceContainer stas);\n\n    /**\n     * \\brief Callback called by WifiNetDevice/Phy/PhyTxBegin.\n     *\n     * \\param path The trace path.\n     * \\param packet The sent packet.\n     * \\param powerW The Tx power.\n     */\n    void PhyCallback(std::string path, Ptr<const Packet> packet, double powerW);\n    /**\n     * \\brief Callback called by PacketSink/Rx.\n     *\n     * \\param path The trace path.\n     * \\param packet The received packet.\n     * \\param from The sender address.\n     */\n    void RxCallback(std::string path, Ptr<const Packet> packet, const Address& from);\n    /**\n     * \\brief Callback called by WifiNetDevice/RemoteStationManager/x/PowerChange.\n     *\n     * \\param path The trace path.\n     * \\param oldPower Old Tx power.\n     * \\param newPower Actual Tx power.\n     * \\param dest Destination of the transmission.\n     */\n    void PowerCallback(std::string path, double oldPower, double newPower, Mac48Address dest);\n    /**\n     * \\brief Callback called by WifiNetDevice/RemoteStationManager/x/RateChange.\n     *\n     * \\param path The trace path.\n     * \\param oldRate Old rate.\n     * \\param newRate Actual rate.\n     * \\param dest Destination of the transmission.\n     */\n    void RateCallback(std::string path, DataRate oldRate, DataRate newRate, Mac48Address dest);\n    /**\n     * \\brief Set the Position of a node.\n     *\n     * \\param node The node.\n     * \\param position The position.\n     */\n    void SetPosition(Ptr<Node> node, Vector position);\n    /**\n     * Move a node.\n     * \\param node The node.\n     * \\param stepsSize The step size.\n     * \\param stepsTime Time on each step.\n     */\n    void AdvancePosition(Ptr<Node> node, int stepsSize, Time stepsTime);\n    /**\n     * \\brief Get the Position of a node.\n     *\n     * \\param node The node.\n     * \\return the position of the node.\n     */\n    Vector GetPosition(Ptr<Node> node);\n\n    /**\n     * \\brief Get the Throughput output data\n     *\n     * \\return the Throughput output data.\n     */\n    Gnuplot2dDataset GetDatafile();\n    /**\n     * \\brief Get the Power output data.\n     *\n     * \\return the Power output data.\n     */\n    Gnuplot2dDataset GetPowerDatafile();\n\n  private:\n    /// Time, DataRate pair vector.\n    typedef std::vector<std::pair<Time, DataRate>> TxTime;\n    /**\n     * \\brief Setup the WifiPhy object.\n     *\n     * \\param phy The WifiPhy to setup.\n     */\n    void SetupPhy(Ptr<WifiPhy> phy);\n    /**\n     * \\brief Get the time at which a given datarate has been recorded.\n     *\n     * \\param rate The datarate to search.\n     * \\return the time.\n     */\n    Time GetCalcTxTime(DataRate rate);\n\n    std::map<Mac48Address, dBm_u> m_currentPower;   //!< Current Tx power for each sender.\n    std::map<Mac48Address, DataRate> m_currentRate; //!< Current Tx rate for each sender.\n    uint32_t m_bytesTotal;                          //!< Number of received bytes on a given state.\n    double m_totalEnergy;                           //!< Energy used on a given state.\n    double m_totalTime;                             //!< Time spent on a given state.\n    TxTime m_timeTable;                             //!< Time, DataRate table.\n    Gnuplot2dDataset m_output;                      //!< Throughput output data.\n    Gnuplot2dDataset m_output_power;                //!< Power output data.\n};\n\nNodeStatistics::NodeStatistics(NetDeviceContainer aps, NetDeviceContainer stas)\n{\n    Ptr<NetDevice> device = aps.Get(0);\n    Ptr<WifiNetDevice> wifiDevice = DynamicCast<WifiNetDevice>(device);\n    Ptr<WifiPhy> phy = wifiDevice->GetPhy();\n    SetupPhy(phy);\n    DataRate dataRate = DataRate(phy->GetDefaultMode().GetDataRate(phy->GetChannelWidth()));\n    const auto power = phy->GetTxPowerEnd();\n    for (uint32_t j = 0; j < stas.GetN(); j++)\n    {\n        Ptr<NetDevice> staDevice = stas.Get(j);\n        Ptr<WifiNetDevice> wifiStaDevice = DynamicCast<WifiNetDevice>(staDevice);\n        Mac48Address addr = wifiStaDevice->GetMac()->GetAddress();\n        m_currentPower[addr] = power;\n        m_currentRate[addr] = dataRate;\n    }\n    m_currentRate[Mac48Address(\"ff:ff:ff:ff:ff:ff\")] = dataRate;\n    m_totalEnergy = 0;\n    m_totalTime = 0;\n    m_bytesTotal = 0;\n    m_output.SetTitle(\"Throughput Mbits/s\");\n    m_output_power.SetTitle(\"Average Transmit Power\");\n}\n\nvoid\nNodeStatistics::SetupPhy(Ptr<WifiPhy> phy)\n{\n    for (const auto& mode : phy->GetModeList())\n    {\n        WifiTxVector txVector;\n        txVector.SetMode(mode);\n        txVector.SetPreambleType(WIFI_PREAMBLE_LONG);\n        txVector.SetChannelWidth(phy->GetChannelWidth());\n        DataRate dataRate(mode.GetDataRate(phy->GetChannelWidth()));\n        Time time = phy->CalculateTxDuration(packetSize, txVector, phy->GetPhyBand());\n        NS_LOG_DEBUG(mode.GetUniqueName() << \" \" << time.GetSeconds() << \" \" << dataRate);\n        m_timeTable.emplace_back(time, dataRate);\n    }\n}\n\nTime\nNodeStatistics::GetCalcTxTime(DataRate rate)\n{\n    for (auto i = m_timeTable.begin(); i != m_timeTable.end(); i++)\n    {\n        if (rate == i->second)\n        {\n            return i->first;\n        }\n    }\n    NS_ASSERT(false);\n    return Seconds(0);\n}\n\nvoid\nNodeStatistics::PhyCallback(std::string path, Ptr<const Packet> packet, double powerW)\n{\n    WifiMacHeader head;\n    packet->PeekHeader(head);\n    Mac48Address dest = head.GetAddr1();\n\n    if (head.GetType() == WIFI_MAC_DATA)\n    {\n        m_totalEnergy += pow(10.0, m_currentPower[dest] / 10.0) *\n                         GetCalcTxTime(m_currentRate[dest]).GetSeconds();\n        m_totalTime += GetCalcTxTime(m_currentRate[dest]).GetSeconds();\n    }\n}\n\nvoid\nNodeStatistics::PowerCallback(std::string path, double oldPower, double newPower, Mac48Address dest)\n{\n    m_currentPower[dest] = newPower;\n}\n\nvoid\nNodeStatistics::RateCallback(std::string path,\n                             DataRate oldRate,\n                             DataRate newRate,\n                             Mac48Address dest)\n{\n    m_currentRate[dest] = newRate;\n}\n\nvoid\nNodeStatistics::RxCallback(std::string path, Ptr<const Packet> packet, const Address& from)\n{\n    m_bytesTotal += packet->GetSize();\n}\n\nvoid\nNodeStatistics::SetPosition(Ptr<Node> node, Vector position)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    mobility->SetPosition(position);\n}\n\nVector\nNodeStatistics::GetPosition(Ptr<Node> node)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    return mobility->GetPosition();\n}\n\nvoid\nNodeStatistics::AdvancePosition(Ptr<Node> node, int stepsSize, Time stepsTime)\n{\n    Vector pos = GetPosition(node);\n    double mbs = ((m_bytesTotal * 8.0) / stepsTime.GetMicroSeconds());\n    m_bytesTotal = 0;\n    double atp = m_totalEnergy / stepsTime.GetSeconds();\n    m_totalEnergy = 0;\n    m_totalTime = 0;\n    m_output_power.Add(pos.x, atp);\n    m_output.Add(pos.x, mbs);\n    pos.x += stepsSize;\n    SetPosition(node, pos);\n    NS_LOG_INFO(\"At time \" << Simulator::Now().GetSeconds() << \" sec; setting new position to \"\n                           << pos);\n    Simulator::Schedule(stepsTime,\n                        &NodeStatistics::AdvancePosition,\n                        this,\n                        node,\n                        stepsSize,\n                        stepsTime);\n}\n\nGnuplot2dDataset\nNodeStatistics::GetDatafile()\n{\n    return m_output;\n}\n\nGnuplot2dDataset\nNodeStatistics::GetPowerDatafile()\n{\n    return m_output_power;\n}\n\n/**\n * Callback called by WifiNetDevice/RemoteStationManager/x/PowerChange.\n *\n * \\param path The trace path.\n * \\param oldPower Old Tx power.\n * \\param newPower Actual Tx power.\n * \\param dest Destination of the transmission.\n */\nvoid\nPowerCallback(std::string path, double oldPower, double newPower, Mac48Address dest)\n{\n    NS_LOG_INFO((Simulator::Now()).GetSeconds()\n                << \" \" << dest << \" Old power=\" << oldPower << \" New power=\" << newPower);\n}\n\n/**\n * \\brief Callback called by WifiNetDevice/RemoteStationManager/x/RateChange.\n *\n * \\param path The trace path.\n * \\param oldRate Old rate.\n * \\param newRate Actual rate.\n * \\param dest Destination of the transmission.\n */\nvoid\nRateCallback(std::string path, DataRate oldRate, DataRate newRate, Mac48Address dest)\n{\n    NS_LOG_INFO((Simulator::Now()).GetSeconds()\n                << \" \" << dest << \" Old rate=\" << oldRate << \" New rate=\" << newRate);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    dBm_u maxPower{17};\n    dBm_u minPower{0};\n    uint32_t powerLevels{18};\n\n    uint32_t rtsThreshold{2346};\n    std::string manager{\"ns3::ParfWifiManager\"};\n    std::string outputFileName{\"parf\"};\n    int ap1_x{0};\n    int ap1_y{0};\n    int sta1_x{5};\n    int sta1_y{0};\n    uint32_t steps{200};\n    meter_u stepsSize{1};\n    Time stepsTime{\"1s\"};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"manager\", \"PRC Manager\", manager);\n    cmd.AddValue(\"rtsThreshold\", \"RTS threshold\", rtsThreshold);\n    cmd.AddValue(\"outputFileName\", \"Output filename\", outputFileName);\n    cmd.AddValue(\"steps\", \"How many different distances to try\", steps);\n    cmd.AddValue(\"stepsTime\", \"Time on each step\", stepsTime);\n    cmd.AddValue(\"stepsSize\", \"Distance between steps\", stepsSize);\n    cmd.AddValue(\"maxPower\", \"Maximum available transmission level (dbm).\", maxPower);\n    cmd.AddValue(\"minPower\", \"Minimum available transmission level (dbm).\", minPower);\n    cmd.AddValue(\"powerLevels\",\n                 \"Number of transmission power levels available between \"\n                 \"TxPowerStart and TxPowerEnd included.\",\n                 powerLevels);\n    cmd.AddValue(\"AP1_x\", \"Position of AP1 in x coordinate\", ap1_x);\n    cmd.AddValue(\"AP1_y\", \"Position of AP1 in y coordinate\", ap1_y);\n    cmd.AddValue(\"STA1_x\", \"Position of STA1 in x coordinate\", sta1_x);\n    cmd.AddValue(\"STA1_y\", \"Position of STA1 in y coordinate\", sta1_y);\n    cmd.Parse(argc, argv);\n\n    if (steps == 0)\n    {\n        std::cout << \"Exiting without running simulation; steps value of 0\" << std::endl;\n    }\n\n    Time simuTime = (steps + 1) * stepsTime;\n\n    // Define the APs\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(1);\n\n    // Define the STAs\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(1);\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n    WifiMacHelper wifiMac;\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    NetDeviceContainer wifiApDevices;\n    NetDeviceContainer wifiStaDevices;\n    NetDeviceContainer wifiDevices;\n\n    // Configure the STA node\n    wifi.SetRemoteStationManager(\"ns3::MinstrelWifiManager\",\n                                 \"RtsCtsThreshold\",\n                                 UintegerValue(rtsThreshold));\n    wifiPhy.Set(\"TxPowerStart\", DoubleValue(maxPower));\n    wifiPhy.Set(\"TxPowerEnd\", DoubleValue(maxPower));\n\n    Ssid ssid = Ssid(\"AP\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    wifiStaDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiStaNodes.Get(0)));\n\n    // Configure the AP node\n    wifi.SetRemoteStationManager(manager,\n                                 \"DefaultTxPowerLevel\",\n                                 UintegerValue(powerLevels - 1),\n                                 \"RtsCtsThreshold\",\n                                 UintegerValue(rtsThreshold));\n    wifiPhy.Set(\"TxPowerStart\", DoubleValue(minPower));\n    wifiPhy.Set(\"TxPowerEnd\", DoubleValue(maxPower));\n    wifiPhy.Set(\"TxPowerLevels\", UintegerValue(powerLevels));\n\n    ssid = Ssid(\"AP\");\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    wifiApDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiApNodes.Get(0)));\n\n    wifiDevices.Add(wifiStaDevices);\n    wifiDevices.Add(wifiApDevices);\n\n    // Configure the mobility.\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    // Initial position of AP and STA\n    positionAlloc->Add(Vector(ap1_x, ap1_y, 0.0));\n    NS_LOG_INFO(\"Setting initial AP position to \" << Vector(ap1_x, ap1_y, 0.0));\n    positionAlloc->Add(Vector(sta1_x, sta1_y, 0.0));\n    NS_LOG_INFO(\"Setting initial STA position to \" << Vector(sta1_x, sta1_y, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNodes.Get(0));\n    mobility.Install(wifiStaNodes.Get(0));\n\n    // Statistics counter\n    NodeStatistics statistics = NodeStatistics(wifiApDevices, wifiStaDevices);\n\n    // Move the STA by stepsSize meters every stepsTime seconds\n    Simulator::Schedule(Seconds(0.5) + stepsTime,\n                        &NodeStatistics::AdvancePosition,\n                        &statistics,\n                        wifiStaNodes.Get(0),\n                        stepsSize,\n                        stepsTime);\n\n    // Configure the IP stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes);\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = address.Assign(wifiDevices);\n    Ipv4Address sinkAddress = i.GetAddress(0);\n    uint16_t port = 9;\n\n    // Configure the CBR generator\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress, port));\n    ApplicationContainer apps_sink = sink.Install(wifiStaNodes.Get(0));\n\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress, port));\n    onoff.SetConstantRate(DataRate(\"54Mb/s\"), packetSize);\n    onoff.SetAttribute(\"StartTime\", TimeValue(Seconds(0.5)));\n    onoff.SetAttribute(\"StopTime\", TimeValue(simuTime));\n    ApplicationContainer apps_source = onoff.Install(wifiApNodes.Get(0));\n\n    apps_sink.Start(Seconds(0.5));\n    apps_sink.Stop(simuTime);\n\n    //------------------------------------------------------------\n    //-- Setup stats and data collection\n    //--------------------------------------------\n\n    // Register packet receptions to calculate throughput\n    Config::Connect(\"/NodeList/1/ApplicationList/*/$ns3::PacketSink/Rx\",\n                    MakeCallback(&NodeStatistics::RxCallback, &statistics));\n\n    // Register power and rate changes to calculate the Average Transmit Power\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/PowerChange\",\n                    MakeCallback(&NodeStatistics::PowerCallback, &statistics));\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/RateChange\",\n                    MakeCallback(&NodeStatistics::RateCallback, &statistics));\n\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/Phy/PhyTxBegin\",\n                    MakeCallback(&NodeStatistics::PhyCallback, &statistics));\n\n    // Callbacks to print every change of power and rate\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/PowerChange\",\n                    MakeCallback(PowerCallback));\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/RateChange\",\n                    MakeCallback(RateCallback));\n\n    Simulator::Stop(simuTime);\n    Simulator::Run();\n\n    std::ofstream outfile(\"throughput-\" + outputFileName + \".plt\");\n    Gnuplot gnuplot = Gnuplot(\"throughput-\" + outputFileName + \".eps\", \"Throughput\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Throughput (Mb/s)\");\n    gnuplot.SetTitle(\"Throughput (AP to STA) vs time\");\n    gnuplot.AddDataset(statistics.GetDatafile());\n    gnuplot.GenerateOutput(outfile);\n\n    if (manager == \"ns3::ParfWifiManager\" || manager == \"ns3::AparfWifiManager\" ||\n        manager == \"ns3::RrpaaWifiManager\")\n    {\n        std::ofstream outfile2(\"power-\" + outputFileName + \".plt\");\n        gnuplot = Gnuplot(\"power-\" + outputFileName + \".eps\", \"Average Transmit Power\");\n        gnuplot.SetTerminal(\"post eps color enhanced\");\n        gnuplot.SetLegend(\"Time (seconds)\", \"Power (mW)\");\n        gnuplot.SetTitle(\"Average transmit power (AP to STA) vs time\");\n        gnuplot.AddDataset(statistics.GetPowerDatafile());\n        gnuplot.GenerateOutput(outfile2);\n    }\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a complete NS-3 simulation script in C++ that models a WiFi network with two Access Points (APs) and two Station (STA) nodes, where positions of APs and STAs are configurable via command-line arguments. The nodes should be positioned using a `ListPositionAllocator`. Configure the WiFi network using `WifiHelper`, `YansWifiPhyHelper`, and `YansWifiChannelHelper` with the 802.11a standard, different SSIDs for each AP-STA pair, and allow adjustment of RTS/CTS thresholds and transmission power levels. Use `ns3::ParfWifiManager` as the default WiFi manager, with an option to change it through the command line. Install a `PacketSink` on each STA to receive UDP traffic, and generate constant bit rate (CBR) UDP streams from each AP to its STA using `OnOffHelper`, with traffic rate set to 54 Mbps for a simulation duration of 100 seconds. Implement a `NodeStatistics` class to track WiFi state times (`CCA_BUSY`, `IDLE`, `TX`, `RX`), total bytes received, average transmit power, and calculate throughput and other metrics, printing results every second. Plot results using Gnuplot to show throughput, average transmit power, and time spent in various WiFi states. Additionally, utilize `FlowMonitor` to calculate and display flow statistics such as throughput, delay, and jitter for each AP-STA pair. Ensure the script is modular, with appropriate helper functions, and accepts command-line arguments to modify parameters like WiFi manager, RTS/CTS threshold, transmission power levels, and simulation time. Run the simulation for 100 seconds and stop execution at the end."}, {"role": "assistant", "content": "/**\n * This example program is designed to illustrate the behavior of three\n * power/rate-adaptive WiFi rate controls; namely, ns3::ParfWifiManager,\n * ns3::AparfWifiManager and ns3::RrpaaWifiManager.\n *\n * This simulation consist of 4 nodes, two APs and two STAs.\n * The APs generates UDP traffic with a CBR of 54 Mbps to the STAs.\n * The APa use any power and rate control mechanism, and the STAs use only\n * Minstrel rate control.\n * The STAs can be configured to be at any distance from the APs.\n *\n * The objective is to test power and rate control in the links with\n * interference from the other link.\n *\n * The output consists of:\n * - A plot of average throughput vs. time.\n * - A plot of average transmit power vs. time.\n * - Plots for the percentage of time the APs are in each MAC state (IDLE, TX, RX, BUSY)\n * - If enabled, the changes of power and rate to standard output.\n * - If enabled, the average throughput, delay, jitter and tx opportunity for the total simulation\n * time.\n *\n * Example usage:\n * \\code{.sh}\n *   ./ns3 run \"wifi-power-adaptation-interference --manager=ns3::AparfWifiManager\n * --outputFileName=aparf\" \\endcode\n *\n * Another example (changing STAs position):\n * \\code{.sh}\n *   ./ns3 run \"wifi-power-adaptation-interference --manager=ns3::AparfWifiManager\n * --outputFileName=aparf --STA1_x=5 --STA2_x=205\" \\endcode\n *\n * To enable the log of rate and power changes:\n * \\code{.sh}\n *   export NS_LOG=PowerAdaptationInterference=level_info\n * \\endcode\n */\n\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-flow-classifier.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/wifi-mac-header.h\"\n#include \"ns3/wifi-mac.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PowerAdaptationInterference\");\n\n/// Packet size generated at the AP.\nstatic const uint32_t packetSize = 1420;\n\n/**\n * \\brief Class to collect node statistics.\n */\nclass NodeStatistics\n{\n  public:\n    /**\n     * \\brief Constructor.\n     *\n     * \\param aps Access points\n     * \\param stas WiFi Stations.\n     */\n    NodeStatistics(NetDeviceContainer aps, NetDeviceContainer stas);\n\n    /**\n     * \\brief Collects the statistics at a given time.\n     *\n     * \\param time Time at which the statistics are collected.\n     */\n    void CheckStatistics(double time);\n\n    /**\n     * \\brief Callback called by WifiNetDevice/Phy/PhyTxBegin.\n     *\n     * \\param path The trace path.\n     * \\param packet The sent packet.\n     * \\param powerW The Tx power.\n     */\n    void PhyCallback(std::string path, Ptr<const Packet> packet, double powerW);\n    /**\n     * \\brief Callback called by PacketSink/Rx.\n     *\n     * \\param path The trace path.\n     * \\param packet The received packet.\n     * \\param from The sender address.\n     */\n    void RxCallback(std::string path, Ptr<const Packet> packet, const Address& from);\n    /**\n     * \\brief Callback called by WifiNetDevice/RemoteStationManager/x/PowerChange.\n     *\n     * \\param path The trace path.\n     * \\param oldPower Old Tx power.\n     * \\param newPower Actual Tx power.\n     * \\param dest Destination of the transmission.\n     */\n    void PowerCallback(std::string path, double oldPower, double newPower, Mac48Address dest);\n    /**\n     * \\brief Callback called by WifiNetDevice/RemoteStationManager/x/RateChange.\n     *\n     * \\param path The trace path.\n     * \\param oldRate Old rate.\n     * \\param newRate Actual rate.\n     * \\param dest Destination of the transmission.\n     */\n    void RateCallback(std::string path, DataRate oldRate, DataRate newRate, Mac48Address dest);\n    /**\n     * \\brief Callback called by YansWifiPhy/State/State.\n     *\n     * \\param path The trace path.\n     * \\param init Time when the state started.\n     * \\param duration Amount of time we've been in (or will be in) the state.\n     * \\param state The state.\n     */\n    void StateCallback(std::string path, Time init, Time duration, WifiPhyState state);\n\n    /**\n     * \\brief Get the Throughput output data\n     *\n     * \\return the Throughput output data.\n     */\n    Gnuplot2dDataset GetDatafile();\n    /**\n     * \\brief Get the Power output data.\n     *\n     * \\return the Power output data.\n     */\n    Gnuplot2dDataset GetPowerDatafile();\n    /**\n     * \\brief Get the IDLE state output data.\n     *\n     * \\return the IDLE state output data.\n     */\n    Gnuplot2dDataset GetIdleDatafile();\n    /**\n     * \\brief Get the BUSY state output data.\n     *\n     * \\return the BUSY state output data.\n     */\n    Gnuplot2dDataset GetBusyDatafile();\n    /**\n     * \\brief Get the TX state output data.\n     *\n     * \\return the TX state output data.\n     */\n    Gnuplot2dDataset GetTxDatafile();\n    /**\n     * \\brief Get the RX state output data.\n     *\n     * \\return the RX state output data.\n     */\n    Gnuplot2dDataset GetRxDatafile();\n\n    /**\n     * \\brief Get the Busy time.\n     *\n     * \\return the busy time.\n     */\n    double GetBusyTime() const;\n\n  private:\n    /// Time, DataRate pair vector.\n    typedef std::vector<std::pair<Time, DataRate>> TxTime;\n    /**\n     * \\brief Setup the WifiPhy object.\n     *\n     * \\param phy The WifiPhy to setup.\n     */\n    void SetupPhy(Ptr<WifiPhy> phy);\n    /**\n     * \\brief Get the time at which a given datarate has been recorded.\n     *\n     * \\param rate The datarate to search.\n     * \\return the time.\n     */\n    Time GetCalcTxTime(DataRate rate);\n\n    std::map<Mac48Address, dBm_u> m_currentPower;   //!< Current Tx power for each sender.\n    std::map<Mac48Address, DataRate> m_currentRate; //!< Current Tx rate for each sender.\n    uint32_t m_bytesTotal;                          //!< Number of received bytes.\n    double m_totalEnergy;                           //!< Energy used.\n    double m_totalTime;                             //!< Time spent.\n    double busyTime;                                //!< BUSY time.\n    double idleTime;                                //!< IDLE time.\n    double txTime;                                  //!< TX time.\n    double rxTime;                                  //!< RX time.\n    double m_totalBusyTime;                         //!< Total time in BUSY state.\n    double m_totalIdleTime;                         //!< Total time in IDLE state.\n    double m_totalTxTime;                           //!< Total time in TX state.\n    double m_totalRxTime;                           //!< Total time in RX state.\n    TxTime m_timeTable;                             //!< Time, DataRate table.\n    Gnuplot2dDataset m_output;                      //!< Throughput output data.\n    Gnuplot2dDataset m_output_power;                //!< Power output data.\n    Gnuplot2dDataset m_output_idle;                 //!< IDLE output data.\n    Gnuplot2dDataset m_output_busy;                 //!< BUSY output data.\n    Gnuplot2dDataset m_output_rx;                   //!< RX output data.\n    Gnuplot2dDataset m_output_tx;                   //!< TX output data.\n};\n\nNodeStatistics::NodeStatistics(NetDeviceContainer aps, NetDeviceContainer stas)\n{\n    Ptr<NetDevice> device = aps.Get(0);\n    Ptr<WifiNetDevice> wifiDevice = DynamicCast<WifiNetDevice>(device);\n    Ptr<WifiPhy> phy = wifiDevice->GetPhy();\n    SetupPhy(phy);\n    DataRate dataRate = DataRate(phy->GetDefaultMode().GetDataRate(phy->GetChannelWidth()));\n    const auto power = phy->GetTxPowerEnd();\n    for (uint32_t j = 0; j < stas.GetN(); j++)\n    {\n        Ptr<NetDevice> staDevice = stas.Get(j);\n        Ptr<WifiNetDevice> wifiStaDevice = DynamicCast<WifiNetDevice>(staDevice);\n        Mac48Address addr = wifiStaDevice->GetMac()->GetAddress();\n        m_currentPower[addr] = power;\n        m_currentRate[addr] = dataRate;\n    }\n    m_currentRate[Mac48Address(\"ff:ff:ff:ff:ff:ff\")] = dataRate;\n    m_totalEnergy = 0;\n    m_totalTime = 0;\n    busyTime = 0;\n    idleTime = 0;\n    txTime = 0;\n    rxTime = 0;\n    m_totalBusyTime = 0;\n    m_totalIdleTime = 0;\n    m_totalTxTime = 0;\n    m_totalRxTime = 0;\n    m_bytesTotal = 0;\n    m_output.SetTitle(\"Throughput Mbits/s\");\n    m_output_idle.SetTitle(\"Idle Time\");\n    m_output_busy.SetTitle(\"Busy Time\");\n    m_output_rx.SetTitle(\"RX Time\");\n    m_output_tx.SetTitle(\"TX Time\");\n}\n\nvoid\nNodeStatistics::SetupPhy(Ptr<WifiPhy> phy)\n{\n    for (const auto& mode : phy->GetModeList())\n    {\n        WifiTxVector txVector;\n        txVector.SetMode(mode);\n        txVector.SetPreambleType(WIFI_PREAMBLE_LONG);\n        txVector.SetChannelWidth(phy->GetChannelWidth());\n        DataRate dataRate(mode.GetDataRate(phy->GetChannelWidth()));\n        Time time = phy->CalculateTxDuration(packetSize, txVector, phy->GetPhyBand());\n        NS_LOG_DEBUG(mode.GetUniqueName() << \" \" << time.GetSeconds() << \" \" << dataRate);\n        m_timeTable.emplace_back(time, dataRate);\n    }\n}\n\nTime\nNodeStatistics::GetCalcTxTime(DataRate rate)\n{\n    for (auto i = m_timeTable.begin(); i != m_timeTable.end(); i++)\n    {\n        if (rate == i->second)\n        {\n            return i->first;\n        }\n    }\n    NS_ASSERT(false);\n    return Seconds(0);\n}\n\nvoid\nNodeStatistics::PhyCallback(std::string path, Ptr<const Packet> packet, double powerW)\n{\n    WifiMacHeader head;\n    packet->PeekHeader(head);\n    Mac48Address dest = head.GetAddr1();\n\n    if (head.GetType() == WIFI_MAC_DATA)\n    {\n        m_totalEnergy += pow(10.0, m_currentPower[dest] / 10.0) *\n                         GetCalcTxTime(m_currentRate[dest]).GetSeconds();\n        m_totalTime += GetCalcTxTime(m_currentRate[dest]).GetSeconds();\n    }\n}\n\nvoid\nNodeStatistics::PowerCallback(std::string path, double oldPower, double newPower, Mac48Address dest)\n{\n    m_currentPower[dest] = newPower;\n}\n\nvoid\nNodeStatistics::RateCallback(std::string path,\n                             DataRate oldRate,\n                             DataRate newRate,\n                             Mac48Address dest)\n{\n    m_currentRate[dest] = newRate;\n}\n\nvoid\nNodeStatistics::StateCallback(std::string path, Time init, Time duration, WifiPhyState state)\n{\n    if (state == WifiPhyState::CCA_BUSY)\n    {\n        busyTime += duration.GetSeconds();\n        m_totalBusyTime += duration.GetSeconds();\n    }\n    else if (state == WifiPhyState::IDLE)\n    {\n        idleTime += duration.GetSeconds();\n        m_totalIdleTime += duration.GetSeconds();\n    }\n    else if (state == WifiPhyState::TX)\n    {\n        txTime += duration.GetSeconds();\n        m_totalTxTime += duration.GetSeconds();\n    }\n    else if (state == WifiPhyState::RX)\n    {\n        rxTime += duration.GetSeconds();\n        m_totalRxTime += duration.GetSeconds();\n    }\n}\n\nvoid\nNodeStatistics::RxCallback(std::string path, Ptr<const Packet> packet, const Address& from)\n{\n    m_bytesTotal += packet->GetSize();\n}\n\nvoid\nNodeStatistics::CheckStatistics(double time)\n{\n    double mbs = ((m_bytesTotal * 8.0) / (1000000 * time));\n    m_bytesTotal = 0;\n    double atp = m_totalEnergy / time;\n    m_totalEnergy = 0;\n    m_totalTime = 0;\n    m_output_power.Add((Simulator::Now()).GetSeconds(), atp);\n    m_output.Add((Simulator::Now()).GetSeconds(), mbs);\n\n    m_output_idle.Add((Simulator::Now()).GetSeconds(), idleTime * 100);\n    m_output_busy.Add((Simulator::Now()).GetSeconds(), busyTime * 100);\n    m_output_tx.Add((Simulator::Now()).GetSeconds(), txTime * 100);\n    m_output_rx.Add((Simulator::Now()).GetSeconds(), rxTime * 100);\n    busyTime = 0;\n    idleTime = 0;\n    txTime = 0;\n    rxTime = 0;\n\n    Simulator::Schedule(Seconds(time), &NodeStatistics::CheckStatistics, this, time);\n}\n\nGnuplot2dDataset\nNodeStatistics::GetDatafile()\n{\n    return m_output;\n}\n\nGnuplot2dDataset\nNodeStatistics::GetPowerDatafile()\n{\n    return m_output_power;\n}\n\nGnuplot2dDataset\nNodeStatistics::GetIdleDatafile()\n{\n    return m_output_idle;\n}\n\nGnuplot2dDataset\nNodeStatistics::GetBusyDatafile()\n{\n    return m_output_busy;\n}\n\nGnuplot2dDataset\nNodeStatistics::GetRxDatafile()\n{\n    return m_output_rx;\n}\n\nGnuplot2dDataset\nNodeStatistics::GetTxDatafile()\n{\n    return m_output_tx;\n}\n\ndouble\nNodeStatistics::GetBusyTime() const\n{\n    return m_totalBusyTime + m_totalRxTime;\n}\n\n/**\n * Callback called by WifiNetDevice/RemoteStationManager/x/PowerChange.\n *\n * \\param path The trace path.\n * \\param oldPower Old Tx power.\n * \\param newPower Actual Tx power.\n * \\param dest Destination of the transmission.\n */\nvoid\nPowerCallback(std::string path, double oldPower, double newPower, Mac48Address dest)\n{\n    NS_LOG_INFO((Simulator::Now()).GetSeconds()\n                << \" \" << dest << \" Old power=\" << oldPower << \" New power=\" << newPower);\n}\n\n/**\n * \\brief Callback called by WifiNetDevice/RemoteStationManager/x/RateChange.\n *\n * \\param path The trace path.\n * \\param oldRate Old rate.\n * \\param newRate Actual rate.\n * \\param dest Destination of the transmission.\n */\nvoid\nRateCallback(std::string path, DataRate oldRate, DataRate newRate, Mac48Address dest)\n{\n    NS_LOG_INFO((Simulator::Now()).GetSeconds()\n                << \" \" << dest << \" Old rate=\" << oldRate << \" New rate=\" << newRate);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    // LogComponentEnable(\"ConstantRateWifiManager\", LOG_LEVEL_FUNCTION);\n\n    dBm_u maxPower{17};\n    dBm_u minPower{0};\n    uint32_t powerLevels{18};\n\n    uint32_t rtsThreshold{2346};\n    std::string manager{\"ns3::ParfWifiManager\"};\n    std::string outputFileName{\"parf\"};\n    int ap1_x{0};\n    int ap1_y{0};\n    int sta1_x{10};\n    int sta1_y{0};\n    int ap2_x{200};\n    int ap2_y{0};\n    int sta2_x{180};\n    int sta2_y{0};\n    Time simuTime{\"100s\"};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"manager\", \"PRC Manager\", manager);\n    cmd.AddValue(\"rtsThreshold\", \"RTS threshold\", rtsThreshold);\n    cmd.AddValue(\"outputFileName\", \"Output filename\", outputFileName);\n    cmd.AddValue(\"simuTime\", \"Total simulation time (sec)\", simuTime);\n    cmd.AddValue(\"maxPower\", \"Maximum available transmission level (dbm).\", maxPower);\n    cmd.AddValue(\"minPower\", \"Minimum available transmission level (dbm).\", minPower);\n    cmd.AddValue(\"powerLevels\",\n                 \"Number of transmission power levels available between \"\n                 \"TxPowerStart and TxPowerEnd included.\",\n                 powerLevels);\n    cmd.AddValue(\"AP1_x\", \"Position of AP1 in x coordinate\", ap1_x);\n    cmd.AddValue(\"AP1_y\", \"Position of AP1 in y coordinate\", ap1_y);\n    cmd.AddValue(\"STA1_x\", \"Position of STA1 in x coordinate\", sta1_x);\n    cmd.AddValue(\"STA1_y\", \"Position of STA1 in y coordinate\", sta1_y);\n    cmd.AddValue(\"AP2_x\", \"Position of AP2 in x coordinate\", ap2_x);\n    cmd.AddValue(\"AP2_y\", \"Position of AP2 in y coordinate\", ap2_y);\n    cmd.AddValue(\"STA2_x\", \"Position of STA2 in x coordinate\", sta2_x);\n    cmd.AddValue(\"STA2_y\", \"Position of STA2 in y coordinate\", sta2_y);\n    cmd.Parse(argc, argv);\n\n    // Define the APs\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(2);\n\n    // Define the STAs\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n    WifiMacHelper wifiMac;\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    NetDeviceContainer wifiApDevices;\n    NetDeviceContainer wifiStaDevices;\n    NetDeviceContainer wifiDevices;\n\n    // Configure the STA nodes\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\",\n                                 \"RtsCtsThreshold\",\n                                 UintegerValue(rtsThreshold));\n    wifiPhy.Set(\"TxPowerStart\", DoubleValue(maxPower));\n    wifiPhy.Set(\"TxPowerEnd\", DoubleValue(maxPower));\n\n    Ssid ssid = Ssid(\"AP0\");\n    wifiMac.SetType(\"ns3::StaWifiMac\",\n                    \"Ssid\",\n                    SsidValue(ssid),\n                    \"MaxMissedBeacons\",\n                    UintegerValue(1000));\n    wifiStaDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiStaNodes.Get(0)));\n\n    ssid = Ssid(\"AP1\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    wifiStaDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiStaNodes.Get(1)));\n\n    // Configure the AP nodes\n    wifi.SetRemoteStationManager(manager,\n                                 \"DefaultTxPowerLevel\",\n                                 UintegerValue(powerLevels - 1),\n                                 \"RtsCtsThreshold\",\n                                 UintegerValue(rtsThreshold));\n    wifiPhy.Set(\"TxPowerStart\", DoubleValue(minPower));\n    wifiPhy.Set(\"TxPowerEnd\", DoubleValue(maxPower));\n    wifiPhy.Set(\"TxPowerLevels\", UintegerValue(powerLevels));\n\n    ssid = Ssid(\"AP0\");\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    wifiApDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiApNodes.Get(0)));\n\n    ssid = Ssid(\"AP1\");\n    wifiMac.SetType(\"ns3::ApWifiMac\",\n                    \"Ssid\",\n                    SsidValue(ssid),\n                    \"BeaconInterval\",\n                    TimeValue(MicroSeconds(103424))); // for avoiding collisions);\n    wifiApDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiApNodes.Get(1)));\n\n    wifiDevices.Add(wifiStaDevices);\n    wifiDevices.Add(wifiApDevices);\n\n    // Configure the mobility.\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(ap1_x, ap1_y, 0.0));\n    positionAlloc->Add(Vector(sta1_x, sta1_y, 0.0));\n    positionAlloc->Add(Vector(ap2_x, ap2_y, 0.0));\n    positionAlloc->Add(Vector(sta2_x, sta2_y, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNodes.Get(0));\n    mobility.Install(wifiStaNodes.Get(0));\n    mobility.Install(wifiApNodes.Get(1));\n    mobility.Install(wifiStaNodes.Get(1));\n\n    // Configure the IP stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes);\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = address.Assign(wifiDevices);\n    Ipv4Address sinkAddress = i.GetAddress(0);\n    Ipv4Address sinkAddress1 = i.GetAddress(1);\n    uint16_t port = 9;\n\n    // Configure the CBR generator\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress, port));\n    ApplicationContainer apps_sink = sink.Install(wifiStaNodes.Get(0));\n\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress, port));\n    onoff.SetConstantRate(DataRate(\"54Mb/s\"), packetSize);\n    onoff.SetAttribute(\"StartTime\", TimeValue(Seconds(0.0)));\n    onoff.SetAttribute(\"StopTime\", TimeValue(Seconds(100.0)));\n    ApplicationContainer apps_source = onoff.Install(wifiApNodes.Get(0));\n\n    PacketSinkHelper sink1(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress1, port));\n    apps_sink.Add(sink1.Install(wifiStaNodes.Get(1)));\n\n    OnOffHelper onoff1(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress1, port));\n    onoff1.SetConstantRate(DataRate(\"54Mb/s\"), packetSize);\n    onoff1.SetAttribute(\"StartTime\", TimeValue(Seconds(0.0)));\n    onoff1.SetAttribute(\"StopTime\", TimeValue(Seconds(100.0)));\n    apps_source.Add(onoff1.Install(wifiApNodes.Get(1)));\n\n    apps_sink.Start(Seconds(0.5));\n    apps_sink.Stop(simuTime);\n\n    //------------------------------------------------------------\n    //-- Setup stats and data collection\n    //--------------------------------------------\n\n    // Statistics counters\n    NodeStatistics statisticsAp0 = NodeStatistics(wifiApDevices, wifiStaDevices);\n    NodeStatistics statisticsAp1 = NodeStatistics(wifiApDevices, wifiStaDevices);\n\n    // Register packet receptions to calculate throughput\n    Config::Connect(\"/NodeList/2/ApplicationList/*/$ns3::PacketSink/Rx\",\n                    MakeCallback(&NodeStatistics::RxCallback, &statisticsAp0));\n    Config::Connect(\"/NodeList/3/ApplicationList/*/$ns3::PacketSink/Rx\",\n                    MakeCallback(&NodeStatistics::RxCallback, &statisticsAp1));\n\n    // Register power and rate changes to calculate the Average Transmit Power\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/PowerChange\",\n                    MakeCallback(&NodeStatistics::PowerCallback, &statisticsAp0));\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/RateChange\",\n                    MakeCallback(&NodeStatistics::RateCallback, &statisticsAp0));\n    Config::Connect(\"/NodeList/1/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/PowerChange\",\n                    MakeCallback(&NodeStatistics::PowerCallback, &statisticsAp1));\n    Config::Connect(\"/NodeList/1/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/RateChange\",\n                    MakeCallback(&NodeStatistics::RateCallback, &statisticsAp1));\n\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/Phy/PhyTxBegin\",\n                    MakeCallback(&NodeStatistics::PhyCallback, &statisticsAp0));\n    Config::Connect(\"/NodeList/1/DeviceList/*/$ns3::WifiNetDevice/Phy/PhyTxBegin\",\n                    MakeCallback(&NodeStatistics::PhyCallback, &statisticsAp1));\n\n    // Register States\n    Config::Connect(\n        \"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::YansWifiPhy/State/State\",\n        MakeCallback(&NodeStatistics::StateCallback, &statisticsAp0));\n    Config::Connect(\n        \"/NodeList/1/DeviceList/*/$ns3::WifiNetDevice/Phy/$ns3::YansWifiPhy/State/State\",\n        MakeCallback(&NodeStatistics::StateCallback, &statisticsAp1));\n\n    statisticsAp0.CheckStatistics(1);\n    statisticsAp1.CheckStatistics(1);\n\n    // Callbacks to print every change of power and rate\n    Config::Connect(\"/NodeList/[0-1]/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/PowerChange\",\n                    MakeCallback(PowerCallback));\n    Config::Connect(\"/NodeList/[0-1]/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" +\n                        manager + \"/RateChange\",\n                    MakeCallback(RateCallback));\n\n    // Calculate Throughput using Flowmonitor\n\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    Simulator::Stop(simuTime);\n    Simulator::Run();\n\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    for (auto i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n        if (t.sourceAddress == \"10.1.1.3\" && t.destinationAddress == \"10.1.1.1\")\n        {\n            NS_LOG_INFO(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \"\n                                << t.destinationAddress << \")\\n\");\n            NS_LOG_INFO(\"  Tx Bytes:   \" << i->second.txBytes << \"\\n\");\n            NS_LOG_INFO(\"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\");\n            NS_LOG_UNCOND(\"  Throughput to 10.1.1.1: \"\n                          << i->second.rxBytes * 8.0 /\n                                 (i->second.timeLastRxPacket.GetSeconds() -\n                                  i->second.timeFirstTxPacket.GetSeconds()) /\n                                 1024 / 1024\n                          << \" Mbps\\n\");\n            NS_LOG_INFO(\"  Mean delay:   \" << i->second.delaySum.GetSeconds() / i->second.rxPackets\n                                           << \"\\n\");\n            NS_LOG_INFO(\"  Mean jitter:   \"\n                        << i->second.jitterSum.GetSeconds() / (i->second.rxPackets - 1) << \"\\n\");\n            NS_LOG_INFO(\"  Tx Opp: \" << 1 - (statisticsAp0.GetBusyTime() / simuTime.GetSeconds()));\n        }\n        if (t.sourceAddress == \"10.1.1.4\" && t.destinationAddress == \"10.1.1.2\")\n        {\n            NS_LOG_INFO(\"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \"\n                                << t.destinationAddress << \")\\n\");\n            NS_LOG_INFO(\"  Tx Bytes:   \" << i->second.txBytes << \"\\n\");\n            NS_LOG_INFO(\"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\");\n            NS_LOG_UNCOND(\"  Throughput to 10.1.1.2: \"\n                          << i->second.rxBytes * 8.0 /\n                                 (i->second.timeLastRxPacket.GetSeconds() -\n                                  i->second.timeFirstTxPacket.GetSeconds()) /\n                                 1024 / 1024\n                          << \" Mbps\\n\");\n            NS_LOG_INFO(\"  Mean delay:   \" << i->second.delaySum.GetSeconds() / i->second.rxPackets\n                                           << \"\\n\");\n            NS_LOG_INFO(\"  Mean jitter:   \"\n                        << i->second.jitterSum.GetSeconds() / (i->second.rxPackets - 1) << \"\\n\");\n            NS_LOG_INFO(\"  Tx Opp: \" << 1 - (statisticsAp1.GetBusyTime() / simuTime.GetSeconds()));\n        }\n    }\n\n    // Plots for AP0\n    std::ofstream outfileTh0(\"throughput-\" + outputFileName + \"-0.plt\");\n    Gnuplot gnuplot = Gnuplot(\"throughput-\" + outputFileName + \"-0.eps\", \"Throughput\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Throughput (Mb/s)\");\n    gnuplot.SetTitle(\"Throughput (AP0 to STA) vs time\");\n    gnuplot.AddDataset(statisticsAp0.GetDatafile());\n    gnuplot.GenerateOutput(outfileTh0);\n\n    if (manager == \"ns3::ParfWifiManager\" || manager == \"ns3::AparfWifiManager\" ||\n        manager == \"ns3::RrpaaWifiManager\")\n    {\n        std::ofstream outfilePower0(\"power-\" + outputFileName + \"-0.plt\");\n        gnuplot = Gnuplot(\"power-\" + outputFileName + \"-0.eps\", \"Average Transmit Power\");\n        gnuplot.SetTerminal(\"post eps color enhanced\");\n        gnuplot.SetLegend(\"Time (seconds)\", \"Power (mW)\");\n        gnuplot.SetTitle(\"Average transmit power (AP0 to STA) vs time\");\n        gnuplot.AddDataset(statisticsAp0.GetPowerDatafile());\n        gnuplot.GenerateOutput(outfilePower0);\n    }\n\n    std::ofstream outfileTx0(\"tx-\" + outputFileName + \"-0.plt\");\n    gnuplot = Gnuplot(\"tx-\" + outputFileName + \"-0.eps\", \"Time in TX State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP0 in TX state vs time\");\n    gnuplot.AddDataset(statisticsAp0.GetTxDatafile());\n    gnuplot.GenerateOutput(outfileTx0);\n\n    std::ofstream outfileRx0(\"rx-\" + outputFileName + \"-0.plt\");\n    gnuplot = Gnuplot(\"rx-\" + outputFileName + \"-0.eps\", \"Time in RX State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP0 in RX state vs time\");\n    gnuplot.AddDataset(statisticsAp0.GetRxDatafile());\n    gnuplot.GenerateOutput(outfileRx0);\n\n    std::ofstream outfileBusy0(\"busy-\" + outputFileName + \"-0.plt\");\n    gnuplot = Gnuplot(\"busy-\" + outputFileName + \"-0.eps\", \"Time in Busy State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP0 in Busy state vs time\");\n    gnuplot.AddDataset(statisticsAp0.GetBusyDatafile());\n    gnuplot.GenerateOutput(outfileBusy0);\n\n    std::ofstream outfileIdle0(\"idle-\" + outputFileName + \"-0.plt\");\n    gnuplot = Gnuplot(\"idle-\" + outputFileName + \"-0.eps\", \"Time in Idle State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP0 in Idle state vs time\");\n    gnuplot.AddDataset(statisticsAp0.GetIdleDatafile());\n    gnuplot.GenerateOutput(outfileIdle0);\n\n    // Plots for AP1\n    std::ofstream outfileTh1(\"throughput-\" + outputFileName + \"-1.plt\");\n    gnuplot = Gnuplot(\"throughput-\" + outputFileName + \"-1.eps\", \"Throughput\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Throughput (Mb/s)\");\n    gnuplot.SetTitle(\"Throughput (AP1 to STA) vs time\");\n    gnuplot.AddDataset(statisticsAp1.GetDatafile());\n    gnuplot.GenerateOutput(outfileTh1);\n\n    if (manager == \"ns3::ParfWifiManager\" || manager == \"ns3::AparfWifiManager\" ||\n        manager == \"ns3::RrpaaWifiManager\")\n    {\n        std::ofstream outfilePower1(\"power-\" + outputFileName + \"-1.plt\");\n        gnuplot = Gnuplot(\"power-\" + outputFileName + \"-1.eps\", \"Average Transmit Power\");\n        gnuplot.SetTerminal(\"post eps color enhanced\");\n        gnuplot.SetLegend(\"Time (seconds)\", \"Power (mW)\");\n        gnuplot.SetTitle(\"Average transmit power (AP1 to STA) vs time\");\n        gnuplot.AddDataset(statisticsAp1.GetPowerDatafile());\n        gnuplot.GenerateOutput(outfilePower1);\n    }\n\n    std::ofstream outfileTx1(\"tx-\" + outputFileName + \"-1.plt\");\n    gnuplot = Gnuplot(\"tx-\" + outputFileName + \"-1.eps\", \"Time in TX State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP1 in TX state vs time\");\n    gnuplot.AddDataset(statisticsAp1.GetTxDatafile());\n    gnuplot.GenerateOutput(outfileTx1);\n\n    std::ofstream outfileRx1(\"rx-\" + outputFileName + \"-1.plt\");\n    gnuplot = Gnuplot(\"rx-\" + outputFileName + \"-1.eps\", \"Time in RX State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP1 in RX state vs time\");\n    gnuplot.AddDataset(statisticsAp1.GetRxDatafile());\n    gnuplot.GenerateOutput(outfileRx1);\n\n    std::ofstream outfileBusy1(\"busy-\" + outputFileName + \"-1.plt\");\n    gnuplot = Gnuplot(\"busy-\" + outputFileName + \"-1.eps\", \"Time in Busy State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP1 in Busy state vs time\");\n    gnuplot.AddDataset(statisticsAp1.GetBusyDatafile());\n    gnuplot.GenerateOutput(outfileBusy1);\n\n    std::ofstream outfileIdle1(\"idle-\" + outputFileName + \"-1.plt\");\n    gnuplot = Gnuplot(\"idle-\" + outputFileName + \"-1.eps\", \"Time in Idle State\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Time (seconds)\", \"Percent\");\n    gnuplot.SetTitle(\"Percentage time AP1 in Idle state vs time\");\n    gnuplot.AddDataset(statisticsAp1.GetIdleDatafile());\n    gnuplot.GenerateOutput(outfileIdle1);\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a simulation program for ns-3 to illustrate rate-adaptive Wi-Fi controls like Minstrel in a scenario with two nodes: an AP and a STA. The AP sends UDP traffic to the STA using a CBR of 400 Mbps. The AP can use any power or rate control, while the STA uses Minstrel for rate adaptation. The simulation should allow the STA to move away from the AP, with distance steps and time intervals adjustable via command-line arguments. Collect statistics such as throughput and distance, and log rate changes if logging is enabled. Output a Gnuplot file showing throughput versus distance."}, {"role": "assistant", "content": "/**\n * This example program is designed to illustrate the behavior of\n * rate-adaptive WiFi rate controls such as Minstrel.  Power-adaptive\n * rate controls can be illustrated also, but separate examples exist for\n * highlighting the power adaptation.\n *\n * This simulation consist of 2 nodes, one AP and one STA.\n * The AP generates UDP traffic with a CBR of 400 Mbps to the STA.\n * The AP can use any power and rate control mechanism and the STA uses\n * only Minstrel rate control.\n * The STA can be configured to move away from (or towards to) the AP.\n * By default, the AP is at coordinate (0,0,0) and the STA starts at\n * coordinate (5,0,0) (meters) and moves away on the x axis by 1 meter every\n * second.\n *\n * The output consists of:\n * - A plot of average throughput vs. distance.\n * - (if logging is enabled) the changes of rate to standard output.\n *\n * Example usage:\n * ./ns3 run \"wifi-rate-adaptation-distance --standard=802.11a --staManager=ns3::MinstrelWifiManager\n * --apManager=ns3::MinstrelWifiManager --outputFileName=minstrel\"\n *\n * Another example (moving towards the AP):\n * ./ns3 run \"wifi-rate-adaptation-distance --standard=802.11a --staManager=ns3::MinstrelWifiManager\n * --apManager=ns3::MinstrelWifiManager --outputFileName=minstrel --stepsSize=1 --STA1_x=-200\"\n *\n * Example for HT rates with SGI and channel width of 40MHz:\n * ./ns3 run \"wifi-rate-adaptation-distance --staManager=ns3::MinstrelHtWifiManager\n * --apManager=ns3::MinstrelHtWifiManager --outputFileName=minstrelHt --shortGuardInterval=true\n * --channelWidth=40\"\n *\n * To enable the log of rate changes:\n * export NS_LOG=RateAdaptationDistance=level_info\n */\n\n#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/gnuplot.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RateAdaptationDistance\");\n\n/** Node statistics */\nclass NodeStatistics\n{\n  public:\n    /**\n     * Constructor\n     * \\param aps AP devices\n     * \\param stas STA devices\n     */\n    NodeStatistics(NetDeviceContainer aps, NetDeviceContainer stas);\n\n    /**\n     * RX callback\n     * \\param path path\n     * \\param packet received packet\n     * \\param from sender\n     */\n    void RxCallback(std::string path, Ptr<const Packet> packet, const Address& from);\n    /**\n     * Set node position\n     * \\param node the node\n     * \\param position the position\n     */\n    void SetPosition(Ptr<Node> node, Vector position);\n    /**\n     * Advance node position\n     * \\param node the node\n     * \\param stepsSize the size of a step\n     * \\param stepsTime the time interval between steps\n     */\n    void AdvancePosition(Ptr<Node> node, int stepsSize, int stepsTime);\n    /**\n     * Get node position\n     * \\param node the node\n     * \\return the position\n     */\n    Vector GetPosition(Ptr<Node> node);\n    /**\n     * \\return the gnuplot 2d dataset\n     */\n    Gnuplot2dDataset GetDatafile();\n\n  private:\n    uint32_t m_bytesTotal;     //!< total bytes\n    Gnuplot2dDataset m_output; //!< gnuplot 2d dataset\n};\n\nNodeStatistics::NodeStatistics(NetDeviceContainer aps, NetDeviceContainer stas)\n{\n    m_bytesTotal = 0;\n}\n\nvoid\nNodeStatistics::RxCallback(std::string path, Ptr<const Packet> packet, const Address& from)\n{\n    m_bytesTotal += packet->GetSize();\n}\n\nvoid\nNodeStatistics::SetPosition(Ptr<Node> node, Vector position)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    mobility->SetPosition(position);\n}\n\nVector\nNodeStatistics::GetPosition(Ptr<Node> node)\n{\n    Ptr<MobilityModel> mobility = node->GetObject<MobilityModel>();\n    return mobility->GetPosition();\n}\n\nvoid\nNodeStatistics::AdvancePosition(Ptr<Node> node, int stepsSize, int stepsTime)\n{\n    Vector pos = GetPosition(node);\n    double mbs = ((m_bytesTotal * 8.0) / (1000000 * stepsTime));\n    m_bytesTotal = 0;\n    m_output.Add(pos.x, mbs);\n    pos.x += stepsSize;\n    SetPosition(node, pos);\n    Simulator::Schedule(Seconds(stepsTime),\n                        &NodeStatistics::AdvancePosition,\n                        this,\n                        node,\n                        stepsSize,\n                        stepsTime);\n}\n\nGnuplot2dDataset\nNodeStatistics::GetDatafile()\n{\n    return m_output;\n}\n\n/**\n * Callback for 'Rate' trace source\n *\n * \\param oldRate old MCS rate (bits/sec)\n * \\param newRate new MCS rate (bits/sec)\n */\nvoid\nRateCallback(uint64_t oldRate, uint64_t newRate)\n{\n    NS_LOG_INFO(\"Rate \" << newRate / 1000000.0 << \" Mbps\");\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t rtsThreshold{65535};\n    std::string staManager{\"ns3::MinstrelHtWifiManager\"};\n    std::string apManager{\"ns3::MinstrelHtWifiManager\"};\n    std::string standard{\"802.11n-5GHz\"};\n    std::string outputFileName{\"minstrelHT\"};\n    uint32_t BeMaxAmpduSize{65535};\n    bool shortGuardInterval{false};\n    uint32_t chWidth{20};\n    int ap1_x{0};\n    int ap1_y{0};\n    int sta1_x{5};\n    int sta1_y{0};\n    int steps{100};\n    int stepsSize{1};\n    int stepsTime{1};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"staManager\", \"Rate adaptation manager of the STA\", staManager);\n    cmd.AddValue(\"apManager\", \"Rate adaptation manager of the AP\", apManager);\n    cmd.AddValue(\"standard\", \"Wifi standard (a/b/g/n/ac only)\", standard);\n    cmd.AddValue(\"shortGuardInterval\",\n                 \"Enable Short Guard Interval in all stations\",\n                 shortGuardInterval);\n    cmd.AddValue(\"channelWidth\", \"Channel width of all the stations\", chWidth);\n    cmd.AddValue(\"rtsThreshold\", \"RTS threshold\", rtsThreshold);\n    cmd.AddValue(\"BeMaxAmpduSize\", \"BE Mac A-MPDU size\", BeMaxAmpduSize);\n    cmd.AddValue(\"outputFileName\", \"Output filename\", outputFileName);\n    cmd.AddValue(\"steps\", \"How many different distances to try\", steps);\n    cmd.AddValue(\"stepsTime\", \"Time on each step\", stepsTime);\n    cmd.AddValue(\"stepsSize\", \"Distance between steps\", stepsSize);\n    cmd.AddValue(\"AP1_x\", \"Position of AP1 in x coordinate\", ap1_x);\n    cmd.AddValue(\"AP1_y\", \"Position of AP1 in y coordinate\", ap1_y);\n    cmd.AddValue(\"STA1_x\", \"Position of STA1 in x coordinate\", sta1_x);\n    cmd.AddValue(\"STA1_y\", \"Position of STA1 in y coordinate\", sta1_y);\n    cmd.Parse(argc, argv);\n\n    int simuTime = steps * stepsTime;\n\n    if (standard != \"802.11a\" && standard != \"802.11b\" && standard != \"802.11g\" &&\n        standard != \"802.11n-2.4GHz\" && standard != \"802.11n-5GHz\" && standard != \"802.11ac\")\n    {\n        NS_FATAL_ERROR(\"Standard \" << standard << \" is not supported by this program\");\n    }\n\n    // Define the APs\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(1);\n\n    // Define the STAs\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(1);\n\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n    // Channel configuration via ChannelSettings attribute can be performed here\n    std::string frequencyBand;\n    if (standard == \"802.11b\" || standard == \"802.11g\" || standard == \"802.11n-2.4GHz\")\n    {\n        frequencyBand = \"BAND_2_4GHZ\";\n    }\n    else\n    {\n        frequencyBand = \"BAND_5GHZ\";\n    }\n    wifiPhy.Set(\"ChannelSettings\",\n                StringValue(\"{0, \" + std::to_string(chWidth) + \", \" + frequencyBand + \", 0}\"));\n\n    // By default, the CCA sensitivity is -82 dBm, meaning if the RSS is\n    // below this value, the receiver will reject the Wi-Fi frame.\n    // However, we want to allow the rate adaptation to work down to low\n    // SNR values.  To allow this, we need to do three things:  1) disable\n    // the noise figure (set it to 0 dB) so that the noise level in 20 MHz\n    // is around -101 dBm, 2) lower the CCA sensitivity to a value that\n    // disables it (e.g. -110 dBm), and 3) disable the Wi-Fi preamble\n    // detection model.\n    wifiPhy.Set(\"CcaSensitivity\", DoubleValue(-110));\n    wifiPhy.Set(\"RxNoiseFigure\", DoubleValue(0));\n    wifiPhy.DisablePreambleDetectionModel();\n\n    NetDeviceContainer wifiApDevices;\n    NetDeviceContainer wifiStaDevices;\n    NetDeviceContainer wifiDevices;\n\n    WifiHelper wifi;\n    if (standard == \"802.11a\" || standard == \"802.11b\" || standard == \"802.11g\")\n    {\n        if (standard == \"802.11a\")\n        {\n            wifi.SetStandard(WIFI_STANDARD_80211a);\n        }\n        else if (standard == \"802.11b\")\n        {\n            wifi.SetStandard(WIFI_STANDARD_80211b);\n        }\n        else if (standard == \"802.11g\")\n        {\n            wifi.SetStandard(WIFI_STANDARD_80211g);\n        }\n        WifiMacHelper wifiMac;\n\n        // Configure the STA node\n        wifi.SetRemoteStationManager(staManager, \"RtsCtsThreshold\", UintegerValue(rtsThreshold));\n\n        Ssid ssid = Ssid(\"AP\");\n        wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n        wifiStaDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiStaNodes.Get(0)));\n\n        // Configure the AP node\n        wifi.SetRemoteStationManager(apManager, \"RtsCtsThreshold\", UintegerValue(rtsThreshold));\n\n        ssid = Ssid(\"AP\");\n        wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n        wifiApDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiApNodes.Get(0)));\n    }\n    else if (standard == \"802.11n-2.4GHz\" || standard == \"802.11n-5GHz\" || standard == \"802.11ac\")\n    {\n        if (standard == \"802.11n-2.4GHz\" || standard == \"802.11n-5GHz\")\n        {\n            wifi.SetStandard(WIFI_STANDARD_80211n);\n        }\n        else if (standard == \"802.11ac\")\n        {\n            wifi.SetStandard(WIFI_STANDARD_80211ac);\n        }\n\n        WifiMacHelper wifiMac;\n\n        // Configure the STA node\n        wifi.SetRemoteStationManager(staManager, \"RtsCtsThreshold\", UintegerValue(rtsThreshold));\n\n        Ssid ssid = Ssid(\"AP\");\n        wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n        wifiStaDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiStaNodes.Get(0)));\n\n        // Configure the AP node\n        wifi.SetRemoteStationManager(apManager, \"RtsCtsThreshold\", UintegerValue(rtsThreshold));\n\n        ssid = Ssid(\"AP\");\n        wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n        wifiApDevices.Add(wifi.Install(wifiPhy, wifiMac, wifiApNodes.Get(0)));\n\n        Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/BE_MaxAmpduSize\",\n                    UintegerValue(BeMaxAmpduSize));\n    }\n\n    wifiDevices.Add(wifiStaDevices);\n    wifiDevices.Add(wifiApDevices);\n\n    // Set guard interval\n    Config::Set(\n        \"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/ShortGuardIntervalSupported\",\n        BooleanValue(shortGuardInterval));\n\n    // Configure the mobility.\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    // Initial position of AP and STA\n    positionAlloc->Add(Vector(ap1_x, ap1_y, 0.0));\n    positionAlloc->Add(Vector(sta1_x, sta1_y, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNodes.Get(0));\n    mobility.Install(wifiStaNodes.Get(0));\n\n    // Statistics counter\n    NodeStatistics atpCounter = NodeStatistics(wifiApDevices, wifiStaDevices);\n\n    // Move the STA by stepsSize meters every stepsTime seconds\n    Simulator::Schedule(Seconds(0.5 + stepsTime),\n                        &NodeStatistics::AdvancePosition,\n                        &atpCounter,\n                        wifiStaNodes.Get(0),\n                        stepsSize,\n                        stepsTime);\n\n    // Configure the IP stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes);\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = address.Assign(wifiDevices);\n    Ipv4Address sinkAddress = i.GetAddress(0);\n    uint16_t port = 9;\n\n    // Configure the CBR generator\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress, port));\n    ApplicationContainer apps_sink = sink.Install(wifiStaNodes.Get(0));\n\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(sinkAddress, port));\n    onoff.SetConstantRate(DataRate(\"400Mb/s\"), 1420);\n    onoff.SetAttribute(\"StartTime\", TimeValue(Seconds(0.5)));\n    onoff.SetAttribute(\"StopTime\", TimeValue(Seconds(simuTime)));\n    ApplicationContainer apps_source = onoff.Install(wifiApNodes.Get(0));\n\n    apps_sink.Start(Seconds(0.5));\n    apps_sink.Stop(Seconds(simuTime));\n\n    //------------------------------------------------------------\n    //-- Setup stats and data collection\n    //--------------------------------------------\n\n    // Register packet receptions to calculate throughput\n    Config::Connect(\"/NodeList/1/ApplicationList/*/$ns3::PacketSink/Rx\",\n                    MakeCallback(&NodeStatistics::RxCallback, &atpCounter));\n\n    // Callbacks to print every change of rate\n    Config::ConnectWithoutContextFailSafe(\n        \"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/RemoteStationManager/$\" + apManager + \"/Rate\",\n        MakeCallback(RateCallback));\n\n    Simulator::Stop(Seconds(simuTime));\n    Simulator::Run();\n\n    std::ofstream outfile(\"throughput-\" + outputFileName + \".plt\");\n    Gnuplot gnuplot = Gnuplot(\"throughput-\" + outputFileName + \".eps\", \"Throughput\");\n    gnuplot.SetTerminal(\"post eps color enhanced\");\n    gnuplot.SetLegend(\"Distance (meters)\", \"Throughput (Mb/s)\");\n    gnuplot.SetTitle(\"Throughput (AP to STA) vs distance\");\n    gnuplot.AddDataset(atpCounter.GetDatafile());\n    gnuplot.GenerateOutput(outfile);\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using NS-3 that creates two network nodes and connects them using a point-to-point link. The link should have a data transmission rate of 5 Mbps and a propagation delay of 2 milliseconds. Install the Internet stack on both nodes, which includes the IP protocol, and assign IP addresses to the devices using the address range \"10.1.1.0/24\". The goal is to ensure that the nodes are correctly assigned IP addresses, but there is no need to implement any communication between them. Finally, run and destroy the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"NodeIpAddressAssignment\");\n\nint main(int argc, char *argv[]) {\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link between the two nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack (IP protocol)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ script using ns-3 that configures two nodes with 802.11b NICs operating in ad-hoc mode. The nodes are set to communicate over a physical layer that uses a fixed received signal strength (RSS), regardless of their positions. The script should allow sending one 1000-byte packet by default between the nodes and provide several command-line options for modifying behavior. Ensure the physical layer stops receiving packets when the RSS drops below a threshold, and implement verbose logging, pcap trace generation, and command-line control for attributes like RSS and packet size."}, {"role": "assistant", "content": "// This script configures two nodes on an 802.11b physical layer, with\n// 802.11b NICs in adhoc mode, and by default, sends one packet of 1000\n// (application) bytes to the other node.  The physical layer is configured\n// to receive at a fixed RSS (regardless of the distance and transmit\n// power); therefore, changing position of the nodes has no effect.\n//\n// There are a number of command-line options available to control\n// the default behavior.  The list of available command-line options\n// can be listed with the following command:\n// ./ns3 run \"wifi-simple-adhoc --help\"\n//\n// For instance, for this configuration, the physical layer will\n// stop successfully receiving packets when rss drops below -97 dBm.\n// To see this effect, try running:\n//\n// ./ns3 run \"wifi-simple-adhoc --rss=-97 --numPackets=20\"\n// ./ns3 run \"wifi-simple-adhoc --rss=-98 --numPackets=20\"\n// ./ns3 run \"wifi-simple-adhoc --rss=-99 --numPackets=20\"\n//\n// Note that all ns-3 attributes (not just the ones exposed in the below\n// script) can be changed at command line; see the documentation.\n//\n// This script can also be helpful to put the Wifi layer into verbose\n// logging mode; this command will turn on all wifi logging:\n//\n// ./ns3 run \"wifi-simple-adhoc --verbose=1\"\n//\n// When you are done, you will notice two pcap trace files in your directory.\n// If you have tcpdump installed, you can try this:\n//\n// tcpdump -r wifi-simple-adhoc-0-0.pcap -nn -tt\n//\n\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/string.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleAdhoc\");\n\n/**\n * Function called when a packet is received.\n *\n * \\param socket The receiving socket.\n */\nvoid\nReceivePacket(Ptr<Socket> socket)\n{\n    while (socket->Recv())\n    {\n        NS_LOG_UNCOND(\"Received one packet!\");\n    }\n}\n\n/**\n * Generate traffic.\n *\n * \\param socket The sending socket.\n * \\param pktSize The packet size.\n * \\param pktCount The packet count.\n * \\param pktInterval The interval between two packets.\n */\nstatic void\nGenerateTraffic(Ptr<Socket> socket, uint32_t pktSize, uint32_t pktCount, Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval,\n                            &GenerateTraffic,\n                            socket,\n                            pktSize,\n                            pktCount - 1,\n                            pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string phyMode(\"DsssRate1Mbps\");\n    dBm_u rss{-80};\n    uint32_t packetSize{1000}; // bytes\n    uint32_t numPackets{1};\n    Time interPacketInterval{\"1s\"};\n    bool verbose{false};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"phyMode\", \"Wifi Phy mode\", phyMode);\n    cmd.AddValue(\"rss\", \"received signal strength\", rss);\n    cmd.AddValue(\"packetSize\", \"size of application packet sent\", packetSize);\n    cmd.AddValue(\"numPackets\", \"number of packets generated\", numPackets);\n    cmd.AddValue(\"interval\", \"interval between packets\", interPacketInterval);\n    cmd.AddValue(\"verbose\", \"turn on all WifiNetDevice log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    // Fix non-unicast data rate to be the same as that of unicast\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(phyMode));\n\n    NodeContainer c;\n    c.Create(2);\n\n    // The below set of helpers will help us to put together the wifi NICs we want\n    WifiHelper wifi;\n    if (verbose)\n    {\n        WifiHelper::EnableLogComponents(); // Turn on all Wifi logging\n    }\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy;\n    // This is one parameter that matters when using FixedRssLossModel\n    // set it to zero; otherwise, gain will be added\n    wifiPhy.Set(\"RxGain\", DoubleValue(0));\n    // ns-3 supports RadioTap and Prism tracing extensions for 802.11b\n    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    // The below FixedRssLossModel will cause the rss to be fixed regardless\n    // of the distance between the two stations, and the transmit power\n    wifiChannel.AddPropagationLoss(\"ns3::FixedRssLossModel\", \"Rss\", DoubleValue(rss));\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Add a mac and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n    // Set it to adhoc mode\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, c);\n\n    // Note that with FixedRssLossModel, the positions below are not\n    // used for received signal strength.\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    Ipv4AddressHelper ipv4;\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(c.Get(0), tid);\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 80);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    Ptr<Socket> source = Socket::CreateSocket(c.Get(1), tid);\n    InetSocketAddress remote = InetSocketAddress(Ipv4Address(\"255.255.255.255\"), 80);\n    source->SetAllowBroadcast(true);\n    source->Connect(remote);\n\n    // Tracing\n    wifiPhy.EnablePcap(\"wifi-simple-adhoc\", devices);\n\n    // Output what we are doing\n    NS_LOG_UNCOND(\"Testing \" << numPackets << \" packets sent with receiver rss \" << rss);\n\n    Simulator::ScheduleWithContext(source->GetNode()->GetId(),\n                                   Seconds(1.0),\n                                   &GenerateTraffic,\n                                   source,\n                                   packetSize,\n                                   numPackets,\n                                   interPacketInterval);\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using ns-3 that configures a grid of nodes with 802.11b NICs operating in adhoc mode. The grid is by default 5x5, and each node is positioned using the GridPositionAllocator. The program should allow command-line options to modify parameters such as the physical layer mode, grid distance, packet size, number of packets, source and sink nodes, and enable verbose logging. By default, one 1000-byte packet is sent from the highest-numbered node (node 24) to node 0, and OLSR routing is enabled to determine the packet forwarding path. Include options to enable packet tracing using pcap and ASCII trace files, and allow customization of the source and sink nodes. The script should also simulate wireless transmission effects, including distance-based RSSI cutoff."}, {"role": "assistant", "content": "// This program configures a grid (default 5x5) of nodes on an\n// 802.11b physical layer, with\n// 802.11b NICs in adhoc mode, and by default, sends one packet of 1000\n// (application) bytes to node 1.\n//\n// The default layout is like this, on a 2-D grid.\n//\n// n20  n21  n22  n23  n24\n// n15  n16  n17  n18  n19\n// n10  n11  n12  n13  n14\n// n5   n6   n7   n8   n9\n// n0   n1   n2   n3   n4\n//\n// the layout is affected by the parameters given to GridPositionAllocator;\n// by default, GridWidth is 5 (nodes per row) and numNodes is 25..\n//\n// There are a number of command-line options available to control\n// the default behavior.  The list of available command-line options\n// can be listed with the following command:\n// ./ns3 run \"wifi-simple-adhoc-grid --help\"\n//\n// Note that all ns-3 attributes (not just the ones exposed in the below\n// script) can be changed at command line; see the ns-3 documentation.\n//\n// For instance, for this configuration, the physical layer will\n// stop successfully receiving packets when distance increases beyond\n// the default of 100m.  The cutoff is around 116m; below that value, the\n// received signal strength falls below the (default) RSSI limit of -82 dBm\n// used by Wi-Fi's threshold preamble detection running.\n//\n// To see this effect, try running at a larger distance, and no packet\n// reception will be reported:\n//\n// ./ns3 run \"wifi-simple-adhoc-grid --distance=200\"\n//\n// The default path through the topology will follow the following node\n// numbers:  24->23->18->13->12->11->10->5->0\n//\n// To see this, the following Bash commands will list the UDP packet\n// transmissions hop-by-hop, if tracing is enabled:\n//\n// ./ns3 run \"wifi-simple-adhoc-grid --tracing=1\"\n// grep ^t wifi-simple-adhoc-grid.tr  | grep Udp | grep -v olsr | less\n//\n// By changing the distance to a smaller value, more nodes can be reached\n// by each transmission, and the number of forwarding hops will decrease.\n//\n// The source node and sink node can be changed like this:\n//\n// ./ns3 run \"wifi-simple-adhoc-grid --sourceNode=20 --sinkNode=10\"\n//\n// This script can also be helpful to put the Wifi layer into verbose\n// logging mode; this command will turn on all wifi logging:\n//\n// ./ns3 run \"wifi-simple-adhoc-grid --verbose=1\"\n//\n// By default, trace file writing is off-- to enable it, try:\n// ./ns3 run \"wifi-simple-adhoc-grid --tracing=1\"\n//\n// When you are done tracing, you will notice many pcap trace files\n// in your directory.  If you have tcpdump installed, you can try this:\n//\n// tcpdump -r wifi-simple-adhoc-grid-0-0.pcap -nn -tt\n//\n// or you can examine the text-based trace wifi-simple-adhoc-grid.tr with\n// an editor.\n//\n\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/olsr-helper.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleAdhocGrid\");\n\n/**\n * Function called when a packet is received.\n *\n * \\param socket The receiving socket.\n */\nvoid\nReceivePacket(Ptr<Socket> socket)\n{\n    while (socket->Recv())\n    {\n        NS_LOG_UNCOND(\"Received one packet!\");\n    }\n}\n\n/**\n * Generate traffic.\n *\n * \\param socket The sending socket.\n * \\param pktSize The packet size.\n * \\param pktCount The packet count.\n * \\param pktInterval The interval between two packets.\n */\nstatic void\nGenerateTraffic(Ptr<Socket> socket, uint32_t pktSize, uint32_t pktCount, Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval,\n                            &GenerateTraffic,\n                            socket,\n                            pktSize,\n                            pktCount - 1,\n                            pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string phyMode{\"DsssRate1Mbps\"};\n    meter_u distance{100};\n    uint32_t packetSize{1000}; // bytes\n    uint32_t numPackets{1};\n    uint32_t numNodes{25}; // by default, 5x5\n    uint32_t sinkNode{0};\n    uint32_t sourceNode{24};\n    Time interPacketInterval{\"1s\"};\n    bool verbose{false};\n    bool tracing{false};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"phyMode\", \"Wifi Phy mode\", phyMode);\n    cmd.AddValue(\"distance\", \"distance (m)\", distance);\n    cmd.AddValue(\"packetSize\", \"size of application packet sent\", packetSize);\n    cmd.AddValue(\"numPackets\", \"number of packets generated\", numPackets);\n    cmd.AddValue(\"interval\", \"interval (seconds) between packets\", interPacketInterval);\n    cmd.AddValue(\"verbose\", \"turn on all WifiNetDevice log components\", verbose);\n    cmd.AddValue(\"tracing\", \"turn on ascii and pcap tracing\", tracing);\n    cmd.AddValue(\"numNodes\", \"number of nodes\", numNodes);\n    cmd.AddValue(\"sinkNode\", \"Receiver node number\", sinkNode);\n    cmd.AddValue(\"sourceNode\", \"Sender node number\", sourceNode);\n    cmd.Parse(argc, argv);\n\n    // Fix non-unicast data rate to be the same as that of unicast\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(phyMode));\n\n    NodeContainer c;\n    c.Create(numNodes);\n\n    // The below set of helpers will help us to put together the wifi NICs we want\n    WifiHelper wifi;\n    if (verbose)\n    {\n        WifiHelper::EnableLogComponents(); // Turn on all Wifi logging\n    }\n\n    YansWifiPhyHelper wifiPhy;\n    // set it to zero; otherwise, gain will be added\n    wifiPhy.Set(\"RxGain\", DoubleValue(-10));\n    // ns-3 supports RadioTap and Prism tracing extensions for 802.11b\n    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Add an upper mac and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n    // Set it to adhoc mode\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, c);\n\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\",\n                                  DoubleValue(0.0),\n                                  \"MinY\",\n                                  DoubleValue(0.0),\n                                  \"DeltaX\",\n                                  DoubleValue(distance),\n                                  \"DeltaY\",\n                                  DoubleValue(distance),\n                                  \"GridWidth\",\n                                  UintegerValue(5),\n                                  \"LayoutType\",\n                                  StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    // Enable OLSR\n    OlsrHelper olsr;\n    Ipv4StaticRoutingHelper staticRouting;\n\n    Ipv4ListRoutingHelper list;\n    list.Add(staticRouting, 0);\n    list.Add(olsr, 10);\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(list); // has effect on the next Install ()\n    internet.Install(c);\n\n    Ipv4AddressHelper ipv4;\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(c.Get(sinkNode), tid);\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 80);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    Ptr<Socket> source = Socket::CreateSocket(c.Get(sourceNode), tid);\n    InetSocketAddress remote = InetSocketAddress(i.GetAddress(sinkNode, 0), 80);\n    source->Connect(remote);\n\n    if (tracing)\n    {\n        AsciiTraceHelper ascii;\n        wifiPhy.EnableAsciiAll(ascii.CreateFileStream(\"wifi-simple-adhoc-grid.tr\"));\n        wifiPhy.EnablePcap(\"wifi-simple-adhoc-grid\", devices);\n        // Trace routing tables\n        Ptr<OutputStreamWrapper> routingStream =\n            Create<OutputStreamWrapper>(\"wifi-simple-adhoc-grid.routes\", std::ios::out);\n        Ipv4RoutingHelper::PrintRoutingTableAllEvery(Seconds(2), routingStream);\n        Ptr<OutputStreamWrapper> neighborStream =\n            Create<OutputStreamWrapper>(\"wifi-simple-adhoc-grid.neighbors\", std::ios::out);\n        Ipv4RoutingHelper::PrintNeighborCacheAllEvery(Seconds(2), neighborStream);\n\n        // To do-- enable an IP-level trace that shows forwarding events only\n    }\n\n    // Give OLSR time to converge-- 30 seconds perhaps\n    Simulator::Schedule(Seconds(30.0),\n                        &GenerateTraffic,\n                        source,\n                        packetSize,\n                        numPackets,\n                        interPacketInterval);\n\n    // Output what we are doing\n    NS_LOG_UNCOND(\"Testing from node \" << sourceNode << \" to \" << sinkNode << \" with grid distance \"\n                                       << distance);\n\n    Simulator::Stop(Seconds(33.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using ns-3 that simulates two hidden stations in an 802.11n Wi-Fi network with MPDU aggregation support. The simulation should allow the user to specify whether RTS/CTS is enabled and control the number of aggregated MPDUs via command-line arguments. The program should set up a network topology with one access point (AP) and two stations (n1 and n2), where the stations are hidden from each other due to limited wireless range. The payload size, simulation time, and expected throughput bounds can also be adjusted via command-line arguments. The stations send UDP traffic to the AP, and the simulation logs throughput and generates trace files (PCAP and ASCII)."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/rng-seed-manager.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This example considers two hidden stations in an 802.11n network which supports MPDU aggregation.\n// The user can specify whether RTS/CTS is used and can set the number of aggregated MPDUs.\n//\n// Example: ./ns3 run \"wifi-simple-ht-hidden-stations --enableRts=1 --nMpdus=8\"\n//\n// Network topology:\n//\n//   Wifi 192.168.1.0\n//\n//        AP\n//   *    *    *\n//   |    |    |\n//   n1   n2   n3\n//\n// Packets in this simulation belong to BestEffort Access Class (AC_BE).\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimplesHtHiddenStations\");\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t payloadSize{1472}; // bytes\n    Time simulationTime{\"10s\"};\n    uint32_t nMpdus{1};\n    uint32_t maxAmpduSize{0};\n    bool enableRts{false};\n    double minExpectedThroughput{0};\n    double maxExpectedThroughput{0};\n\n    RngSeedManager::SetSeed(1);\n    RngSeedManager::SetRun(7);\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nMpdus\", \"Number of aggregated MPDUs\", nMpdus);\n    cmd.AddValue(\"payloadSize\", \"Payload size in bytes\", payloadSize);\n    cmd.AddValue(\"enableRts\", \"Enable RTS/CTS\", enableRts);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"minExpectedThroughput\",\n                 \"if set, simulation fails if the lowest throughput is below this value\",\n                 minExpectedThroughput);\n    cmd.AddValue(\"maxExpectedThroughput\",\n                 \"if set, simulation fails if the highest throughput is above this value\",\n                 maxExpectedThroughput);\n    cmd.Parse(argc, argv);\n\n    if (!enableRts)\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"999999\"));\n    }\n    else\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"0\"));\n    }\n\n    // Set the maximum size for A-MPDU with regards to the payload size\n    maxAmpduSize = nMpdus * (payloadSize + 200);\n\n    // Set the maximum wireless range to 5 meters in order to reproduce a hidden nodes scenario,\n    // i.e. the distance between hidden stations is larger than 5 meters\n    Config::SetDefault(\"ns3::RangePropagationLossModel::MaxRange\", DoubleValue(5));\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    channel.AddPropagationLoss(\n        \"ns3::RangePropagationLossModel\"); // wireless range limited to 5 meters!\n\n    YansWifiPhyHelper phy;\n    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    phy.SetChannel(channel.Create());\n    phy.Set(\"ChannelSettings\", StringValue(\"{36, 0, BAND_5GHZ, 0}\"));\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"HtMcs7\"),\n                                 \"ControlMode\",\n                                 StringValue(\"HtMcs0\"));\n    WifiMacHelper mac;\n\n    Ssid ssid = Ssid(\"simple-mpdu-aggregation\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/BE_MaxAmpduSize\",\n                UintegerValue(maxAmpduSize));\n\n    int64_t streamNumber = 20;\n    streamNumber += WifiHelper::AssignStreams(apDevice, streamNumber);\n    streamNumber += WifiHelper::AssignStreams(staDevices, streamNumber);\n\n    // Setting mobility model\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n    // AP is between the two stations, each station being located at 5 meters from the AP.\n    // The distance between the two stations is thus equal to 10 meters.\n    // Since the wireless range is limited to 5 meters, the two stations are hidden from each other.\n    positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(10.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNodes);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n    streamNumber += stack.AssignStreams(wifiApNode, streamNumber);\n    streamNumber += stack.AssignStreams(wifiStaNodes, streamNumber);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterface;\n    StaInterface = address.Assign(staDevices);\n    Ipv4InterfaceContainer ApInterface;\n    ApInterface = address.Assign(apDevice);\n\n    // Setting applications\n    uint16_t port = 9;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiApNode);\n    serverApp.Start(Seconds(0.0));\n    serverApp.Stop(simulationTime + Seconds(1.0));\n    streamNumber += server.AssignStreams(wifiApNode, streamNumber);\n\n    UdpClientHelper client(ApInterface.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    client.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    // Saturated UDP traffic from stations to AP\n    ApplicationContainer clientApp1 = client.Install(wifiStaNodes);\n    clientApp1.Start(Seconds(1.0));\n    clientApp1.Stop(simulationTime + Seconds(1.0));\n    streamNumber += client.AssignStreams(wifiStaNodes, streamNumber);\n\n    phy.EnablePcap(\"SimpleHtHiddenStations_Ap\", apDevice.Get(0));\n    phy.EnablePcap(\"SimpleHtHiddenStations_Sta1\", staDevices.Get(0));\n    phy.EnablePcap(\"SimpleHtHiddenStations_Sta2\", staDevices.Get(1));\n\n    AsciiTraceHelper ascii;\n    phy.EnableAsciiAll(ascii.CreateFileStream(\"SimpleHtHiddenStations.tr\"));\n\n    Simulator::Stop(simulationTime + Seconds(1.0));\n\n    Simulator::Run();\n\n    double totalPacketsThrough = DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n\n    Simulator::Destroy();\n\n    auto throughput = totalPacketsThrough * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s\" << '\\n';\n    if (throughput < minExpectedThroughput ||\n        (maxExpectedThroughput > 0 && throughput > maxExpectedThroughput))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using ns-3 that simulates an 802.11n Wi-Fi network with MPDU aggregation support, consisting of an access point (AP) and two hidden stations. Allow the user to configure options for RTS/CTS, the number of aggregated MPDUs, payload size, simulation time, and expected throughput via command-line arguments. Set up the simulation to limit the wireless range to 5 meters, ensuring a hidden node scenario, and use UDP traffic with saturated flow from the stations to the AP. The program should generate PCAP and ASCII trace files, calculate throughput, and verify it against the user-specified bounds."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/rng-seed-manager.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This example considers two hidden stations in an 802.11n network which supports MPDU aggregation.\n// The user can specify whether RTS/CTS is used and can set the number of aggregated MPDUs.\n//\n// Example: ./ns3 run \"wifi-simple-ht-hidden-stations --enableRts=1 --nMpdus=8\"\n//\n// Network topology:\n//\n//   Wifi 192.168.1.0\n//\n//        AP\n//   *    *    *\n//   |    |    |\n//   n1   n2   n3\n//\n// Packets in this simulation belong to BestEffort Access Class (AC_BE).\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimplesHtHiddenStations\");\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t payloadSize{1472}; // bytes\n    Time simulationTime{\"10s\"};\n    uint32_t nMpdus{1};\n    uint32_t maxAmpduSize{0};\n    bool enableRts{false};\n    double minExpectedThroughput{0};\n    double maxExpectedThroughput{0};\n\n    RngSeedManager::SetSeed(1);\n    RngSeedManager::SetRun(7);\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nMpdus\", \"Number of aggregated MPDUs\", nMpdus);\n    cmd.AddValue(\"payloadSize\", \"Payload size in bytes\", payloadSize);\n    cmd.AddValue(\"enableRts\", \"Enable RTS/CTS\", enableRts);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"minExpectedThroughput\",\n                 \"if set, simulation fails if the lowest throughput is below this value\",\n                 minExpectedThroughput);\n    cmd.AddValue(\"maxExpectedThroughput\",\n                 \"if set, simulation fails if the highest throughput is above this value\",\n                 maxExpectedThroughput);\n    cmd.Parse(argc, argv);\n\n    if (!enableRts)\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"999999\"));\n    }\n    else\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"0\"));\n    }\n\n    // Set the maximum size for A-MPDU with regards to the payload size\n    maxAmpduSize = nMpdus * (payloadSize + 200);\n\n    // Set the maximum wireless range to 5 meters in order to reproduce a hidden nodes scenario,\n    // i.e. the distance between hidden stations is larger than 5 meters\n    Config::SetDefault(\"ns3::RangePropagationLossModel::MaxRange\", DoubleValue(5));\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    channel.AddPropagationLoss(\n        \"ns3::RangePropagationLossModel\"); // wireless range limited to 5 meters!\n\n    YansWifiPhyHelper phy;\n    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    phy.SetChannel(channel.Create());\n    phy.Set(\"ChannelSettings\", StringValue(\"{36, 0, BAND_5GHZ, 0}\"));\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"HtMcs7\"),\n                                 \"ControlMode\",\n                                 StringValue(\"HtMcs0\"));\n    WifiMacHelper mac;\n\n    Ssid ssid = Ssid(\"simple-mpdu-aggregation\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Mac/BE_MaxAmpduSize\",\n                UintegerValue(maxAmpduSize));\n\n    int64_t streamNumber = 20;\n    streamNumber += WifiHelper::AssignStreams(apDevice, streamNumber);\n    streamNumber += WifiHelper::AssignStreams(staDevices, streamNumber);\n\n    // Setting mobility model\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n    // AP is between the two stations, each station being located at 5 meters from the AP.\n    // The distance between the two stations is thus equal to 10 meters.\n    // Since the wireless range is limited to 5 meters, the two stations are hidden from each other.\n    positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(10.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNodes);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n    streamNumber += stack.AssignStreams(wifiApNode, streamNumber);\n    streamNumber += stack.AssignStreams(wifiStaNodes, streamNumber);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterface;\n    StaInterface = address.Assign(staDevices);\n    Ipv4InterfaceContainer ApInterface;\n    ApInterface = address.Assign(apDevice);\n\n    // Setting applications\n    uint16_t port = 9;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiApNode);\n    serverApp.Start(Seconds(0.0));\n    serverApp.Stop(simulationTime + Seconds(1.0));\n    streamNumber += server.AssignStreams(wifiApNode, streamNumber);\n\n    UdpClientHelper client(ApInterface.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    client.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    // Saturated UDP traffic from stations to AP\n    ApplicationContainer clientApp1 = client.Install(wifiStaNodes);\n    clientApp1.Start(Seconds(1.0));\n    clientApp1.Stop(simulationTime + Seconds(1.0));\n    streamNumber += client.AssignStreams(wifiStaNodes, streamNumber);\n\n    phy.EnablePcap(\"SimpleHtHiddenStations_Ap\", apDevice.Get(0));\n    phy.EnablePcap(\"SimpleHtHiddenStations_Sta1\", staDevices.Get(0));\n    phy.EnablePcap(\"SimpleHtHiddenStations_Sta2\", staDevices.Get(1));\n\n    AsciiTraceHelper ascii;\n    phy.EnableAsciiAll(ascii.CreateFileStream(\"SimpleHtHiddenStations.tr\"));\n\n    Simulator::Stop(simulationTime + Seconds(1.0));\n\n    Simulator::Run();\n\n    double totalPacketsThrough = DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n\n    Simulator::Destroy();\n\n    auto throughput = totalPacketsThrough * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s\" << '\\n';\n    if (throughput < minExpectedThroughput ||\n        (maxExpectedThroughput > 0 && throughput > maxExpectedThroughput))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using ns-3 that simulates a simple Wi-Fi infrastructure network with two nodes operating on the 802.11b physical layer. One node acts as a station and the other as an access point. The station sends packets to the access point, and the signal strength is controlled by a FixedRssLossModel, independent of the distance between nodes. The user can configure parameters such as RSS, packet size, number of packets, interval between packets, and verbose logging via command-line options. The script should generate PCAP trace files and allow analysis of packet reception based on signal strength."}, {"role": "assistant", "content": "// This script configures two nodes on an 802.11b physical layer, with\n// 802.11b NICs in infrastructure mode, and by default, the station sends\n// one packet of 1000 (application) bytes to the access point.  Unlike\n// the default physical layer configuration in which the path loss increases\n// (and the received signal strength decreases) as the distance between the\n// nodes increases, this example uses an artificial path loss model that\n// allows the configuration of the received signal strength (RSS) regardless\n// of other transmitter parameters (such as transmit power) or distance.\n// Therefore, changing position of the nodes has no effect.\n//\n// There are a number of command-line options available to control\n// the default behavior.  The list of available command-line options\n// can be listed with the following command:\n// ./ns3 run \"wifi-simple-infra --help\"\n// Additional command-line options are available via the generic attribute\n// configuration system.\n//\n// For instance, for the default configuration, the physical layer will\n// stop successfully receiving packets when rss drops to -82 dBm or below.\n// To see this effect, try running:\n//\n// ./ns3 run \"wifi-simple-infra --rss=-80 --numPackets=20\"\n// ./ns3 run \"wifi-simple-infra --rss=-81 --numPackets=20\"\n// ./ns3 run \"wifi-simple-infra --rss=-82 --numPackets=20\"\n//\n// The last command (and any RSS value lower than this) results in no\n// packets received.  This is due to the preamble detection model that\n// dominates the reception performance.  By default, the\n// ThresholdPreambleDetectionModel is added to all WifiPhy objects, and this\n// model prevents reception unless the incoming signal has a RSS above its\n// 'MinimumRssi' value (default of -82 dBm) and has a SNR above the\n// 'Threshold' value (default of 4).\n//\n// If we relax these values, we can instead observe that signal reception\n// due to the 802.11b error model alone is much lower.  For instance,\n// setting the MinimumRssi to -101 (around the thermal noise floor).\n// and the SNR Threshold to -10 dB, shows that the DsssErrorRateModel can\n// successfully decode at RSS values of -97 or -98 dBm.\n//\n// ./ns3 run \"wifi-simple-infra --rss=-97 --numPackets=20\n// --ns3::ThresholdPreambleDetectionModel::Threshold=-10\n// --ns3::ThresholdPreambleDetectionModel::MinimumRssi=-101\"\n// ./ns3 run \"wifi-simple-infra --rss=-98 --numPackets=20\n// --ns3::ThresholdPreambleDetectionModel::Threshold=-10\n// --ns3::ThresholdPreambleDetectionModel::MinimumRssi=-101\"\n// ./ns3 run \"wifi-simple-infra --rss=-99 --numPackets=20\n// --ns3::ThresholdPreambleDetectionModel::Threshold=-10\n// --ns3::ThresholdPreambleDetectionModel::MinimumRssi=-101\"\n\n//\n// Note that all ns-3 attributes (not just the ones exposed in the below\n// script) can be changed at command line; see the documentation.\n//\n// This script can also be helpful to put the Wifi layer into verbose\n// logging mode; this command will turn on all wifi logging:\n//\n// ./ns3 run \"wifi-simple-infra --verbose=1\"\n//\n// When you are done, you will notice two pcap trace files in your directory.\n// If you have tcpdump installed, you can try this:\n//\n// tcpdump -r wifi-simple-infra-0-0.pcap -nn -tt\n//\n\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleInfra\");\n\n/**\n * Function called when a packet is received.\n *\n * \\param socket The receiving socket.\n */\nvoid\nReceivePacket(Ptr<Socket> socket)\n{\n    while (socket->Recv())\n    {\n        std::cout << \"Received one packet!\" << std::endl;\n    }\n}\n\n/**\n * Generate traffic.\n *\n * \\param socket The sending socket.\n * \\param pktSize The packet size.\n * \\param pktCount The packet count.\n * \\param pktInterval The interval between two packets.\n */\nstatic void\nGenerateTraffic(Ptr<Socket> socket, uint32_t pktSize, uint32_t pktCount, Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        NS_LOG_INFO(\"Generating one packet of size \" << pktSize);\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval,\n                            &GenerateTraffic,\n                            socket,\n                            pktSize,\n                            pktCount - 1,\n                            pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string phyMode{\"DsssRate1Mbps\"};\n    dBm_u rss{-80};\n    uint32_t packetSize{1000}; // bytes\n    uint32_t numPackets{1};\n    Time interval{\"1s\"};\n    bool verbose{false};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"phyMode\", \"Wifi Phy mode\", phyMode);\n    cmd.AddValue(\"rss\", \"received signal strength\", rss);\n    cmd.AddValue(\"packetSize\", \"size of application packet sent\", packetSize);\n    cmd.AddValue(\"numPackets\", \"number of packets generated\", numPackets);\n    cmd.AddValue(\"interval\", \"interval between packets\", interval);\n    cmd.AddValue(\"verbose\", \"turn on all WifiNetDevice log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    // Fix non-unicast data rate to be the same as that of unicast\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(phyMode));\n\n    NodeContainer c;\n    c.Create(2);\n\n    // The below set of helpers will help us to put together the wifi NICs we want\n    WifiHelper wifi;\n    if (verbose)\n    {\n        WifiHelper::EnableLogComponents(); // Turn on all Wifi logging\n    }\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy;\n    // This is one parameter that matters when using FixedRssLossModel\n    // set it to zero; otherwise, gain will be added\n    wifiPhy.Set(\"RxGain\", DoubleValue(0));\n    // ns-3 supports RadioTap and Prism tracing extensions for 802.11b\n    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    // The below FixedRssLossModel will cause the rss to be fixed regardless\n    // of the distance between the two stations, and the transmit power\n    wifiChannel.AddPropagationLoss(\"ns3::FixedRssLossModel\", \"Rss\", DoubleValue(rss));\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Add a mac and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n\n    // Setup the rest of the MAC\n    Ssid ssid = Ssid(\"wifi-default\");\n    // setup STA\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevice = wifi.Install(wifiPhy, wifiMac, c.Get(0));\n    NetDeviceContainer devices = staDevice;\n    // setup AP\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(wifiPhy, wifiMac, c.Get(1));\n    devices.Add(apDevice);\n\n    // Note that with FixedRssLossModel, the positions below are not\n    // used for received signal strength.\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(5.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(c.Get(0), tid);\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 80);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    Ptr<Socket> source = Socket::CreateSocket(c.Get(1), tid);\n    InetSocketAddress remote = InetSocketAddress(Ipv4Address(\"255.255.255.255\"), 80);\n    source->SetAllowBroadcast(true);\n    source->Connect(remote);\n\n    // Tracing\n    wifiPhy.EnablePcap(\"wifi-simple-infra\", devices);\n\n    // Output what we are doing\n    std::cout << \"Testing \" << numPackets << \" packets sent with receiver rss \" << rss << std::endl;\n\n    Simulator::ScheduleWithContext(source->GetNode()->GetId(),\n                                   Seconds(1.0),\n                                   &GenerateTraffic,\n                                   source,\n                                   packetSize,\n                                   numPackets,\n                                   interval);\n\n    Simulator::Stop(Seconds(30.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a script in ns-3 that sets up a wireless network with three nodes operating on an 802.11b physical layer, where one node is a transmitter, another a receiver, and the third an interferer. The transmitter sends a packet to the receiver with a configurable RSS (defaulting to -80 dBm), while the interferer also sends a packet without carrier sense, interfering with the primary packet. Configurable parameters include primary and interfering RSS, the time offset between the primary and interfering signals, and packet sizes for both transmissions. The script should allow the user to enable verbose Wi-Fi logging and produce a pcap trace file for analysis."}, {"role": "assistant", "content": "// This script configures three nodes on an 802.11b physical layer, with\n// 802.11b NICs in adhoc mode.  There is a transmitter, receiver, and\n// interferer.  The transmitter sends one packet to the receiver and\n// the receiver receives it with a certain configurable RSS (by default,\n// -80 dBm).  The interferer does not do carrier sense and also sends\n// the packet to interfere with the primary packet.  The channel model\n// is clear channel.\n//\n// Therefore, at the receiver, the reception looks like this:\n//\n//     ------------------time---------------->\n//     t0\n//\n//     |------------------------------------|\n//     |                                    |\n//     | primary received frame (time t0)   |\n//     |                                    |\n//     |------------------------------------|\n//\n//\n//         t1\n//         |-----------------------------------|\n//         |                                   |\n//         |  interfering frame (time t1)      |\n//         |                                   |\n//         |-----------------------------------|\n//\n// The orientation is:\n//     n2  ---------> n0 <---------- n1\n//  interferer      receiver       transmitter\n//\n// The configurable parameters are:\n//   - Prss (primary rss) (-80 dBm default)\n//   - Irss (interfering rss) (-95 dBm default)\n//   - delta (t1-t0, may be negative, default 0ns)\n//   - PpacketSize (primary packet size) (bytes, default 1000)\n//   - IpacketSize (interferer packet size) (bytes, default 1000)\n//\n// For instance, for this configuration, the interfering frame arrives\n// at -90 dBm with a time offset of 3.2 microseconds:\n//\n// ./ns3 run \"wifi-simple-interference --Irss=-90 --delta=3.2ns\"\n//\n// Note that all ns-3 attributes (not just the ones exposed in the below\n// script) can be changed at command line; see the documentation.\n//\n// This script can also be helpful to put the Wifi layer into verbose\n// logging mode; this command will turn on all wifi logging:\n//\n// ./ns3 run \"wifi-simple-interference --verbose=1\"\n//\n// When you are done, you will notice a pcap trace file in your directory.\n// If you have tcpdump installed, you can try this:\n//\n// tcpdump -r wifi-simple-interference-0-0.pcap -nn -tt\n// reading from file wifi-simple-interference-0-0.pcap, link-type IEEE802_11_RADIO (802.11 plus BSD\n// radio information header) 10.008704 10008704us tsft 1.0 Mb/s 2437 MHz (0x00c0) -80dB signal -98dB\n// noise IP 10.1.1.2.49153 > 10.1.1.255.80: UDP, length 1000\n//\n// Next, try this command and look at the tcpdump-- you should see two packets\n// that are no longer interfering:\n// ./ns3 run \"wifi-simple-interference --delta=30000ns\"\n\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleInterference\");\n\n/**\n * Print a packer that has been received.\n *\n * \\param socket The receiving socket.\n * \\return a string with the packet details.\n */\nstatic inline std::string\nPrintReceivedPacket(Ptr<Socket> socket)\n{\n    Address addr;\n\n    std::ostringstream oss;\n\n    while (socket->Recv())\n    {\n        socket->GetSockName(addr);\n        InetSocketAddress iaddr = InetSocketAddress::ConvertFrom(addr);\n\n        oss << \"Received one packet!  Socket: \" << iaddr.GetIpv4() << \" port: \" << iaddr.GetPort();\n    }\n\n    return oss.str();\n}\n\n/**\n * Function called when a packet is received.\n *\n * \\param socket The receiving socket.\n */\nstatic void\nReceivePacket(Ptr<Socket> socket)\n{\n    NS_LOG_UNCOND(PrintReceivedPacket(socket));\n}\n\n/**\n * Generate traffic\n *\n * \\param socket The seding socket.\n * \\param pktSize The packet size.\n * \\param pktCount The packet counter.\n * \\param pktInterval The interval between two packets.\n */\nstatic void\nGenerateTraffic(Ptr<Socket> socket, uint32_t pktSize, uint32_t pktCount, Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval,\n                            &GenerateTraffic,\n                            socket,\n                            pktSize,\n                            pktCount - 1,\n                            pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string phyMode{\"DsssRate1Mbps\"};\n    dBm_u Prss{-80};\n    dBm_u Irss{-95};\n    Time delta{\"0ns\"};\n    uint32_t PpacketSize{1000}; // bytes\n    uint32_t IpacketSize{1000}; // bytes\n    bool verbose{false};\n\n    // these are not command line arguments for this version\n    uint32_t numPackets{1};\n    Time interPacketInterval{\"1s\"};\n    Time startTime{\"10s\"};\n    meter_u distanceToRx{100.0};\n\n    double offset{91}; // This is a magic number used to set the\n                       // transmit power, based on other configuration\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"phyMode\", \"Wifi Phy mode\", phyMode);\n    cmd.AddValue(\"Prss\", \"Intended primary received signal strength (dBm)\", Prss);\n    cmd.AddValue(\"Irss\", \"Intended interfering received signal strength (dBm)\", Irss);\n    cmd.AddValue(\"delta\", \"time offset for interfering signal\", delta);\n    cmd.AddValue(\"PpacketSize\", \"size of application packet sent\", PpacketSize);\n    cmd.AddValue(\"IpacketSize\", \"size of interfering packet sent\", IpacketSize);\n    cmd.AddValue(\"verbose\", \"turn on all WifiNetDevice log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    // Fix non-unicast data rate to be the same as that of unicast\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(phyMode));\n\n    NodeContainer c;\n    c.Create(3);\n\n    // The below set of helpers will help us to put together the wifi NICs we want\n    WifiHelper wifi;\n    if (verbose)\n    {\n        WifiHelper::EnableLogComponents(); // Turn on all Wifi logging\n    }\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy;\n\n    // ns-3 supports RadioTap and Prism tracing extensions for 802.11b\n    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::LogDistancePropagationLossModel\");\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Add a mac and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n    // Set it to adhoc mode\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, c.Get(0));\n    // This will disable these sending devices from detecting a signal\n    // so that they do not backoff\n    wifiPhy.Set(\"TxGain\", DoubleValue(offset + Prss));\n    devices.Add(wifi.Install(wifiPhy, wifiMac, c.Get(1)));\n    wifiPhy.Set(\"TxGain\", DoubleValue(offset + Irss));\n    devices.Add(wifi.Install(wifiPhy, wifiMac, c.Get(2)));\n\n    // Note that with FixedRssLossModel, the positions below are not\n    // used for received signal strength.\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(distanceToRx, 0.0, 0.0));\n    positionAlloc->Add(Vector(-1 * distanceToRx, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(c.Get(0), tid);\n    InetSocketAddress local = InetSocketAddress(Ipv4Address(\"10.1.1.1\"), 80);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    Ptr<Socket> source = Socket::CreateSocket(c.Get(1), tid);\n    InetSocketAddress remote = InetSocketAddress(Ipv4Address(\"255.255.255.255\"), 80);\n    source->SetAllowBroadcast(true);\n    source->Connect(remote);\n\n    // Interferer will send to a different port; we will not see a\n    // \"Received packet\" message\n    Ptr<Socket> interferer = Socket::CreateSocket(c.Get(2), tid);\n    InetSocketAddress interferingAddr = InetSocketAddress(Ipv4Address(\"255.255.255.255\"), 49000);\n    interferer->SetAllowBroadcast(true);\n    interferer->Connect(interferingAddr);\n\n    // Tracing\n    wifiPhy.EnablePcap(\"wifi-simple-interference\", devices.Get(0));\n\n    // Output what we are doing\n    NS_LOG_UNCOND(\"Primary packet RSS=\" << Prss << \" dBm and interferer RSS=\" << Irss\n                                        << \" dBm at time offset=\" << delta.As(Time::US));\n\n    Simulator::ScheduleWithContext(source->GetNode()->GetId(),\n                                   startTime,\n                                   &GenerateTraffic,\n                                   source,\n                                   PpacketSize,\n                                   numPackets,\n                                   interPacketInterval);\n\n    Simulator::ScheduleWithContext(interferer->GetNode()->GetId(),\n                                   startTime + delta,\n                                   &GenerateTraffic,\n                                   interferer,\n                                   IpacketSize,\n                                   numPackets,\n                                   interPacketInterval);\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ script using the ns-3 network simulator that configures two nodes with 802.11b physical layer in adhoc mode. One node generates on-off traffic destined for the other node. The script should allow for testing energy depletion of nodes, and trigger a callback when the node enters a sleep state due to energy depletion. The script should also include the ability to adjust transmission power and log remaining energy and state transitions to trace files. Include command-line options for configuring data rate, packet size, transmission power levels, and energy model parameters."}, {"role": "assistant", "content": "// This script configures two nodes on an 802.11b physical layer, with\n// 802.11b NICs in adhoc mode. One of the nodes generates on-off traffic\n// destined to the other node.\n//\n// The purpose is to test the energy depletion on the nodes and the\n// activation of the callback that puts a node in the sleep state when\n// its energy is depleted. Furthermore, this script can be used to test\n// the available policies for updating the transmit current based on\n// the nominal tx power used to transmit each frame.\n//\n// There are a number of command-line options available to control\n// the default behavior.  The list of available command-line options\n// can be listed with the following command:\n// ./ns3 run \"wifi-sleep --help\"\n//\n// Note that all ns-3 attributes (not just the ones exposed in the below\n// script) can be changed at command line; see the documentation.\n//\n// This script can also be helpful to put the Wifi layer into verbose\n// logging mode; this command will turn on all wifi logging:\n//\n// ./ns3 run \"wifi-sleep --verbose=1\"\n//\n// When you are done, you will notice four trace files in your directory:\n// two for the remaining energy on each node and two for the state transitions\n// of each node.\n\n#include \"ns3/basic-energy-source-helper.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/string.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/wifi-radio-energy-model-helper.h\"\n#include \"ns3/wifi-utils.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\nusing namespace ns3::energy;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSleep\");\n\n/**\n * Remaining energy trace sink\n *\n * \\tparam node The node ID this trace belongs to.\n * \\param oldValue Old value.\n * \\param newValue New value.\n */\ntemplate <int node>\nvoid\nRemainingEnergyTrace(double oldValue, double newValue)\n{\n    std::stringstream ss;\n    ss << \"energy_\" << node << \".log\";\n\n    static std::fstream f(ss.str(), std::ios::out);\n\n    f << Simulator::Now().GetSeconds() << \"    remaining energy=\" << newValue << std::endl;\n}\n\n/**\n * PHY state trace sink\n *\n * \\tparam node The node ID this trace belongs to.\n * \\param context The context\n * \\param start Start time for the current state\n * \\param duration Duratio of the current state\n * \\param state State\n */\ntemplate <int node>\nvoid\nPhyStateTrace(std::string context, Time start, Time duration, WifiPhyState state)\n{\n    std::stringstream ss;\n    ss << \"state_\" << node << \".log\";\n\n    static std::fstream f(ss.str(), std::ios::out);\n\n    f << Simulator::Now().GetSeconds() << \"    state=\" << state << \" start=\" << start\n      << \" duration=\" << duration << std::endl;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    DataRate dataRate{\"1Mb/s\"};\n    uint32_t packetSize{1000}; // bytes\n    Time duration{\"10s\"};\n    joule_u initialEnergy{7.5};\n    volt_u voltage{3.0};\n    dBm_u txPowerStart{0.0};\n    dBm_u txPowerEnd{15.0};\n    uint32_t nTxPowerLevels{16};\n    uint32_t txPowerLevel{0};\n    ampere_u idleCurrent{0.273};\n    ampere_u txCurrent{0.380};\n    bool verbose{false};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"dataRate\", \"Data rate\", dataRate);\n    cmd.AddValue(\"packetSize\", \"size of application packet sent\", packetSize);\n    cmd.AddValue(\"duration\", \"duration of the experiment\", duration);\n    cmd.AddValue(\"initialEnergy\", \"Initial Energy (Joule) of each node\", initialEnergy);\n    cmd.AddValue(\"voltage\", \"Supply voltage (Joule)\", voltage);\n    cmd.AddValue(\"txPowerStart\", \"Minimum available transmission level (dbm)\", txPowerStart);\n    cmd.AddValue(\"txPowerEnd\", \"Maximum available transmission level (dbm)\", txPowerEnd);\n    cmd.AddValue(\"nTxPowerLevels\",\n                 \"Number of transmission power levels available between txPowerStart and \"\n                 \"txPowerEnd included\",\n                 nTxPowerLevels);\n    cmd.AddValue(\"txPowerLevel\", \"Transmission power level\", txPowerLevel);\n    cmd.AddValue(\"idleCurrent\", \"The radio Idle current in Ampere\", idleCurrent);\n    cmd.AddValue(\"txCurrent\", \"The radio Tx current in Ampere\", txCurrent);\n    cmd.AddValue(\"verbose\", \"turn on all WifiNetDevice log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    NodeContainer c;\n    c.Create(2);\n\n    // The below set of helpers will help us to put together the wifi NICs we want\n    WifiHelper wifi;\n    if (verbose)\n    {\n        WifiHelper::EnableLogComponents(); // Turn on all Wifi logging\n    }\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.Set(\"TxPowerStart\", DoubleValue(txPowerStart));\n    wifiPhy.Set(\"TxPowerEnd\", DoubleValue(txPowerEnd));\n    wifiPhy.Set(\"TxPowerLevels\", UintegerValue(nTxPowerLevels));\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Add a mac and set the selected tx power level\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ArfWifiManager\",\n                                 \"DefaultTxPowerLevel\",\n                                 UintegerValue(txPowerLevel));\n    // Set it to adhoc mode\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, c);\n\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(10.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    Ipv4AddressHelper ipv4;\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    ApplicationContainer apps;\n\n    std::string transportProto = std::string(\"ns3::UdpSocketFactory\");\n    OnOffHelper onOff(transportProto, InetSocketAddress(Ipv4Address(\"10.1.1.2\"), 9000));\n\n    onOff.SetAttribute(\"DataRate\", DataRateValue(DataRate(dataRate)));\n    onOff.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n    onOff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0.001]\"));\n\n    apps = onOff.Install(c.Get(0));\n\n    apps.Start(Seconds(0.01));\n    apps.Stop(duration);\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(transportProto, InetSocketAddress(Ipv4Address::GetAny(), 9001));\n    apps = sink.Install(c.Get(1));\n    apps.Start(Seconds(0.01));\n    apps.Stop(duration);\n\n    // Energy sources\n    EnergySourceContainer eSources;\n    BasicEnergySourceHelper basicSourceHelper;\n    WifiRadioEnergyModelHelper radioEnergyHelper;\n\n    basicSourceHelper.Set(\"BasicEnergySourceInitialEnergyJ\", DoubleValue(initialEnergy));\n    basicSourceHelper.Set(\"BasicEnergySupplyVoltageV\", DoubleValue(voltage));\n\n    radioEnergyHelper.Set(\"IdleCurrentA\", DoubleValue(idleCurrent));\n    radioEnergyHelper.Set(\"TxCurrentA\", DoubleValue(txCurrent));\n\n    // compute the efficiency of the power amplifier (eta) assuming that the provided value for tx\n    // current corresponds to the minimum tx power level\n    double eta = DbmToW(txPowerStart) / ((txCurrent - idleCurrent) * voltage);\n\n    radioEnergyHelper.SetTxCurrentModel(\"ns3::LinearWifiTxCurrentModel\",\n                                        \"Voltage\",\n                                        DoubleValue(voltage),\n                                        \"IdleCurrent\",\n                                        DoubleValue(idleCurrent),\n                                        \"Eta\",\n                                        DoubleValue(eta));\n\n    // install an energy source on each node\n    for (auto n = c.Begin(); n != c.End(); n++)\n    {\n        eSources.Add(basicSourceHelper.Install(*n));\n\n        Ptr<WifiNetDevice> wnd;\n\n        for (uint32_t i = 0; i < (*n)->GetNDevices(); ++i)\n        {\n            wnd = (*n)->GetDevice(i)->GetObject<WifiNetDevice>();\n            // if it is a WifiNetDevice\n            if (wnd)\n            {\n                // this device draws power from the last created energy source\n                radioEnergyHelper.Install(wnd, eSources.Get(eSources.GetN() - 1));\n            }\n        }\n    }\n\n    // Tracing\n    eSources.Get(0)->TraceConnectWithoutContext(\"RemainingEnergy\",\n                                                MakeCallback(&RemainingEnergyTrace<0>));\n    eSources.Get(1)->TraceConnectWithoutContext(\"RemainingEnergy\",\n                                                MakeCallback(&RemainingEnergyTrace<1>));\n\n    Config::Connect(\"/NodeList/0/DeviceList/*/Phy/State/State\", MakeCallback(&PhyStateTrace<0>));\n    Config::Connect(\"/NodeList/1/DeviceList/*/Phy/State/State\", MakeCallback(&PhyStateTrace<1>));\n\n    Simulator::Stop(duration + Seconds(1.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a simulation program using the ns-3 network simulator to experiment with 802.11ax spatial reuse mechanisms. The scenario should involve two Basic Service Sets (BSS) represented by two access points (AP1, AP2) and their corresponding stations (STA1, STA2), each transmitting data with configurable parameters like distance (d1, d2, d3), transmit power, CCA-ED thresholds, and OBSS-PD thresholds. The prompt should explain that STA1 sends data to AP1, while STA2 sends to AP2, both continuously transmitting with specified traffic loads (intervals, packet size). OBSS-PD spatial reuse, which allows stations to ignore transmissions below a certain threshold, can be enabled or disabled, affecting the throughput. The model should support dynamic configuration through command-line arguments, logging reset events related to spatial reuse in text files, and output the resulting throughput of each BSS at the end of the simulation. The simulation should also include appropriate channel configuration, such as handling varying channel widths (20 MHz, 40 MHz, 80 MHz), and the corresponding effects on RSSI and collision probability."}, {"role": "assistant", "content": "//  This example program can be used to experiment with spatial\n//  reuse mechanisms of 802.11ax.\n//\n//  The geometry is as follows:\n//\n//                STA1          STA2\n//                 |              |\n//              d1 |              |d2\n//                 |       d3     |\n//                AP1 -----------AP2\n//\n//  STA1 and AP1 are in one BSS (with color set to 1), while STA2 and AP2 are in\n//  another BSS (with color set to 2). The distances are configurable (d1 through d3).\n//\n//  STA1 is continuously transmitting data to AP1, while STA2 is continuously sending data to AP2.\n//  Each STA has configurable traffic loads (inter packet interval and packet size).\n//  It is also possible to configure TX power per node as well as their CCA-ED thresholds.\n//  OBSS_PD spatial reuse feature can be enabled (default) or disabled, and the OBSS_PD\n//  threshold can be set as well (default: -72 dBm).\n//  A simple Friis path loss model is used and a constant PHY rate is considered.\n//\n//  In general, the program can be configured at run-time by passing command-line arguments.\n//  The following command will display all of the available run-time help options:\n//    ./ns3 run \"wifi-spatial-reuse --help\"\n//\n//  According to the Wi-Fi models of ns-3.36 release, throughput with\n//  OBSS PD enabled (--enableObssPd=True) was roughly 6.5 Mbps, and with\n//  it disabled (--enableObssPd=False) was roughly 3.5 Mbps.\n//\n//  This difference between those results is because OBSS_PD spatial\n//  reuse enables to ignore transmissions from another BSS when the\n//  received power is below the configured threshold, and therefore\n//  either defer during ongoing transmission or transmit at the same\n//  time.\n//\n//  Note that, by default, this script configures a network using a\n//  channel width of 20 MHz. Changing this value alone (through\n//  the --channelWidth argument) without properly adjusting other\n//  parameters will void the effect of spatial reuse: since energy is\n//  measured over the 20 MHz primary channel regardless of the channel\n//  width, doubling the transmission bandwidth creates a 3 dB drop in\n//  the measured energy level (i.e., a halving of the measured\n//  energy). Because of this, when using the channelWidth argument\n//  users should also adjust the CCA-ED Thresholds (via --ccaEdTrSta1,\n//  --ccaEdTrSta2, --ccaEdTrAp1, and --ccaEdTrAp2), the Minimum RSSI\n//  for preamble detection (via --minimumRssi), and the OBSS PD\n//  Threshold (via --obssPdThreshold) appropriately. For instance,\n//  this can be accomplished for a channel width of 40 MHz by lowering\n//  all these values by 3 dB compared to their defaults.\n//\n//  In addition, consider that adapting the adjustments shown above\n//  for an 80 MHz channel width (using a 6 dB threshold adjustment instead\n//  of 3 dB) will not produce any changes when enableObssPd is enabled\n//  or disabled. The cause for this is the insufficient amount of\n//  traffic that is generated by default in the example: increasing\n//  the channel width shortens the frame durations, and lowers the\n//  collision probability. Collisions between BSSs are a necessary\n//  condition to see the improvements brought by spatial reuse, and\n//  thus increasing the amount of generated traffic by setting the\n//  interval argument to a lower value is necessary to see the\n//  benefits of spatial reuse in this scenario. This can, for\n//  instance, be accomplished by setting --interval=100us.\n//\n//  Spatial reuse reset events are traced in two text files:\n//  - wifi-spatial-reuse-resets-bss-1.txt (for STA 1)\n//  - wifi-spatial-reuse-resets-bss-2.txt (for STA 2)\n\n#include \"ns3/abort.h\"\n#include \"ns3/ap-wifi-mac.h\"\n#include \"ns3/application-container.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/he-configuration.h\"\n#include \"ns3/he-phy.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/obss-pd-algorithm.h\"\n#include \"ns3/packet-socket-client.h\"\n#include \"ns3/packet-socket-helper.h\"\n#include \"ns3/packet-socket-server.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/wifi-net-device.h\"\n\nusing namespace ns3;\n\nstd::vector<uint32_t> bytesReceived(4);\nstd::ofstream g_resetFile1;\nstd::ofstream g_resetFile2;\n\nuint32_t\nContextToNodeId(std::string context)\n{\n    std::string sub = context.substr(10);\n    uint32_t pos = sub.find(\"/Device\");\n    return std::stoi(sub.substr(0, pos));\n}\n\nvoid\nSocketRx(std::string context, Ptr<const Packet> p, const Address& addr)\n{\n    uint32_t nodeId = ContextToNodeId(context);\n    bytesReceived[nodeId] += p->GetSize();\n}\n\nvoid\nResetTrace(std::string context,\n           uint8_t bssColor,\n           double rssiDbm,\n           bool powerRestricted,\n           double txPowerMaxDbmSiso,\n           double txPowerMaxDbmMimo)\n{\n    if (context == \"1\")\n    {\n        g_resetFile1 << Simulator::Now().GetSeconds() << \" bssColor: \" << +bssColor\n                     << \" rssiDbm: \" << rssiDbm << \" powerRestricted: \" << powerRestricted\n                     << \" txPowerMaxDbmSiso: \" << txPowerMaxDbmSiso\n                     << \" txPowerMaxDbmMimo: \" << txPowerMaxDbmMimo << std::endl;\n    }\n    else if (context == \"2\")\n    {\n        g_resetFile2 << Simulator::Now().GetSeconds() << \" bssColor: \" << +bssColor\n                     << \" rssiDbm: \" << rssiDbm << \" powerRestricted: \" << powerRestricted\n                     << \" txPowerMaxDbmSiso: \" << txPowerMaxDbmSiso\n                     << \" txPowerMaxDbmMimo: \" << txPowerMaxDbmMimo << std::endl;\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Unknown context \" << context);\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    Time duration{\"10s\"};\n    meter_u d1{30.0};\n    meter_u d2{30.0};\n    meter_u d3{150.0};\n    dBm_u powSta1{10.0};\n    dBm_u powSta2{10.0};\n    dBm_u powAp1{21.0};\n    dBm_u powAp2{21.0};\n    dBm_u ccaEdTrSta1{-62};\n    dBm_u ccaEdTrSta2{-62};\n    dBm_u ccaEdTrAp1{-62};\n    dBm_u ccaEdTrAp2{-62};\n    dBm_u minimumRssi{-82};\n    int channelWidth{20};       // MHz\n    uint32_t payloadSize{1500}; // bytes\n    uint32_t mcs{0};            // MCS value\n    Time interval{\"1ms\"};\n    bool enableObssPd{true};\n    dBm_u obssPdThreshold{-72.0};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"duration\", \"Duration of simulation\", duration);\n    cmd.AddValue(\"interval\", \"Inter packet interval\", interval);\n    cmd.AddValue(\"enableObssPd\", \"Enable/disable OBSS_PD\", enableObssPd);\n    cmd.AddValue(\"d1\", \"Distance between STA1 and AP1 (m)\", d1);\n    cmd.AddValue(\"d2\", \"Distance between STA2 and AP2 (m)\", d2);\n    cmd.AddValue(\"d3\", \"Distance between AP1 and AP2 (m)\", d3);\n    cmd.AddValue(\"powSta1\", \"Power of STA1 (dBm)\", powSta1);\n    cmd.AddValue(\"powSta2\", \"Power of STA2 (dBm)\", powSta2);\n    cmd.AddValue(\"powAp1\", \"Power of AP1 (dBm)\", powAp1);\n    cmd.AddValue(\"powAp2\", \"Power of AP2 (dBm)\", powAp2);\n    cmd.AddValue(\"ccaEdTrSta1\", \"CCA-ED Threshold of STA1 (dBm)\", ccaEdTrSta1);\n    cmd.AddValue(\"ccaEdTrSta2\", \"CCA-ED Threshold of STA2 (dBm)\", ccaEdTrSta2);\n    cmd.AddValue(\"ccaEdTrAp1\", \"CCA-ED Threshold of AP1 (dBm)\", ccaEdTrAp1);\n    cmd.AddValue(\"ccaEdTrAp2\", \"CCA-ED Threshold of AP2 (dBm)\", ccaEdTrAp2);\n    cmd.AddValue(\"minimumRssi\",\n                 \"Minimum RSSI for the ThresholdPreambleDetectionModel\",\n                 minimumRssi);\n    cmd.AddValue(\"channelWidth\", \"Bandwidth of the channel in MHz [20, 40, or 80]\", channelWidth);\n    cmd.AddValue(\"obssPdThreshold\", \"Threshold for the OBSS PD Algorithm\", obssPdThreshold);\n    cmd.AddValue(\"mcs\", \"The constant MCS value to transmit HE PPDUs\", mcs);\n    cmd.Parse(argc, argv);\n\n    g_resetFile1.open(\"wifi-spatial-reuse-resets-bss-1.txt\", std::ofstream::out);\n    g_resetFile2.open(\"wifi-spatial-reuse-resets-bss-2.txt\", std::ofstream::out);\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(2);\n\n    SpectrumWifiPhyHelper spectrumPhy;\n    Ptr<MultiModelSpectrumChannel> spectrumChannel = CreateObject<MultiModelSpectrumChannel>();\n    Ptr<FriisPropagationLossModel> lossModel = CreateObject<FriisPropagationLossModel>();\n    spectrumChannel->AddPropagationLossModel(lossModel);\n    Ptr<ConstantSpeedPropagationDelayModel> delayModel =\n        CreateObject<ConstantSpeedPropagationDelayModel>();\n    spectrumChannel->SetPropagationDelayModel(delayModel);\n\n    spectrumPhy.SetChannel(spectrumChannel);\n    spectrumPhy.SetErrorRateModel(\"ns3::YansErrorRateModel\");\n    switch (channelWidth)\n    {\n    case 20:\n        spectrumPhy.Set(\"ChannelSettings\", StringValue(\"{36, 20, BAND_5GHZ, 0}\"));\n        break;\n    case 40:\n        spectrumPhy.Set(\"ChannelSettings\", StringValue(\"{62, 40, BAND_5GHZ, 0}\"));\n        break;\n    case 80:\n        spectrumPhy.Set(\"ChannelSettings\", StringValue(\"{171, 80, BAND_5GHZ, 0}\"));\n        break;\n    default:\n        NS_ABORT_MSG(\"Unrecognized channel width: \" << channelWidth);\n        break;\n    }\n    spectrumPhy.SetPreambleDetectionModel(\"ns3::ThresholdPreambleDetectionModel\",\n                                          \"MinimumRssi\",\n                                          DoubleValue(minimumRssi));\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211ax);\n    if (enableObssPd)\n    {\n        wifi.SetObssPdAlgorithm(\"ns3::ConstantObssPdAlgorithm\",\n                                \"ObssPdLevel\",\n                                DoubleValue(obssPdThreshold));\n    }\n\n    WifiMacHelper mac;\n    std::ostringstream oss;\n    oss << \"HeMcs\" << mcs;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(oss.str()),\n                                 \"ControlMode\",\n                                 StringValue(oss.str()));\n\n    spectrumPhy.Set(\"TxPowerStart\", DoubleValue(powSta1));\n    spectrumPhy.Set(\"TxPowerEnd\", DoubleValue(powSta1));\n    spectrumPhy.Set(\"CcaEdThreshold\", DoubleValue(ccaEdTrSta1));\n    spectrumPhy.Set(\"RxSensitivity\", DoubleValue(-92.0));\n\n    Ssid ssidA = Ssid(\"A\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssidA));\n    NetDeviceContainer staDeviceA = wifi.Install(spectrumPhy, mac, wifiStaNodes.Get(0));\n\n    spectrumPhy.Set(\"TxPowerStart\", DoubleValue(powAp1));\n    spectrumPhy.Set(\"TxPowerEnd\", DoubleValue(powAp1));\n    spectrumPhy.Set(\"CcaEdThreshold\", DoubleValue(ccaEdTrAp1));\n    spectrumPhy.Set(\"RxSensitivity\", DoubleValue(-92.0));\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssidA));\n    NetDeviceContainer apDeviceA = wifi.Install(spectrumPhy, mac, wifiApNodes.Get(0));\n\n    Ptr<WifiNetDevice> apDevice = apDeviceA.Get(0)->GetObject<WifiNetDevice>();\n    Ptr<ApWifiMac> apWifiMac = apDevice->GetMac()->GetObject<ApWifiMac>();\n    if (enableObssPd)\n    {\n        apDevice->GetHeConfiguration()->SetAttribute(\"BssColor\", UintegerValue(1));\n    }\n\n    spectrumPhy.Set(\"TxPowerStart\", DoubleValue(powSta2));\n    spectrumPhy.Set(\"TxPowerEnd\", DoubleValue(powSta2));\n    spectrumPhy.Set(\"CcaEdThreshold\", DoubleValue(ccaEdTrSta2));\n    spectrumPhy.Set(\"RxSensitivity\", DoubleValue(-92.0));\n\n    Ssid ssidB = Ssid(\"B\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssidB));\n    NetDeviceContainer staDeviceB = wifi.Install(spectrumPhy, mac, wifiStaNodes.Get(1));\n\n    spectrumPhy.Set(\"TxPowerStart\", DoubleValue(powAp2));\n    spectrumPhy.Set(\"TxPowerEnd\", DoubleValue(powAp2));\n    spectrumPhy.Set(\"CcaEdThreshold\", DoubleValue(ccaEdTrAp2));\n    spectrumPhy.Set(\"RxSensitivity\", DoubleValue(-92.0));\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssidB));\n    NetDeviceContainer apDeviceB = wifi.Install(spectrumPhy, mac, wifiApNodes.Get(1));\n\n    Ptr<WifiNetDevice> ap2Device = apDeviceB.Get(0)->GetObject<WifiNetDevice>();\n    apWifiMac = ap2Device->GetMac()->GetObject<ApWifiMac>();\n    if (enableObssPd)\n    {\n        ap2Device->GetHeConfiguration()->SetAttribute(\"BssColor\", UintegerValue(2));\n    }\n\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0)); // AP1\n    positionAlloc->Add(Vector(d3, 0.0, 0.0));  // AP2\n    positionAlloc->Add(Vector(0.0, d1, 0.0));  // STA1\n    positionAlloc->Add(Vector(d3, d2, 0.0));   // STA2\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(wifiApNodes);\n    mobility.Install(wifiStaNodes);\n\n    PacketSocketHelper packetSocket;\n    packetSocket.Install(wifiApNodes);\n    packetSocket.Install(wifiStaNodes);\n    ApplicationContainer apps;\n\n    // BSS 1\n    {\n        PacketSocketAddress socketAddr;\n        socketAddr.SetSingleDevice(staDeviceA.Get(0)->GetIfIndex());\n        socketAddr.SetPhysicalAddress(apDeviceA.Get(0)->GetAddress());\n        socketAddr.SetProtocol(1);\n        Ptr<PacketSocketClient> client = CreateObject<PacketSocketClient>();\n        client->SetRemote(socketAddr);\n        wifiStaNodes.Get(0)->AddApplication(client);\n        client->SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n        client->SetAttribute(\"MaxPackets\", UintegerValue(0));\n        client->SetAttribute(\"Interval\", TimeValue(interval));\n        Ptr<PacketSocketServer> server = CreateObject<PacketSocketServer>();\n        server->SetLocal(socketAddr);\n        wifiApNodes.Get(0)->AddApplication(server);\n    }\n\n    // BSS 2\n    {\n        PacketSocketAddress socketAddr;\n        socketAddr.SetSingleDevice(staDeviceB.Get(0)->GetIfIndex());\n        socketAddr.SetPhysicalAddress(apDeviceB.Get(0)->GetAddress());\n        socketAddr.SetProtocol(1);\n        Ptr<PacketSocketClient> client = CreateObject<PacketSocketClient>();\n        client->SetRemote(socketAddr);\n        wifiStaNodes.Get(1)->AddApplication(client);\n        client->SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n        client->SetAttribute(\"MaxPackets\", UintegerValue(0));\n        client->SetAttribute(\"Interval\", TimeValue(interval));\n        Ptr<PacketSocketServer> server = CreateObject<PacketSocketServer>();\n        server->SetLocal(socketAddr);\n        wifiApNodes.Get(1)->AddApplication(server);\n    }\n\n    Config::Connect(\"/NodeList/*/ApplicationList/*/$ns3::PacketSocketServer/Rx\",\n                    MakeCallback(&SocketRx));\n\n    // Obtain pointers to the ObssPdAlgorithm objects and hook trace sinks\n    // to the Reset trace source on each STA.  Note that this trace connection\n    // cannot be done through the Config path system, so pointers are used.\n    auto deviceA = staDeviceA.Get(0)->GetObject<WifiNetDevice>();\n    auto hePhyA = DynamicCast<HePhy>(deviceA->GetPhy()->GetPhyEntity(WIFI_MOD_CLASS_HE));\n    // Pass in the context string \"1\" to allow the trace to distinguish objects\n    hePhyA->GetObssPdAlgorithm()->TraceConnect(\"Reset\", \"1\", MakeCallback(&ResetTrace));\n    auto deviceB = staDeviceB.Get(0)->GetObject<WifiNetDevice>();\n    auto hePhyB = DynamicCast<HePhy>(deviceB->GetPhy()->GetPhyEntity(WIFI_MOD_CLASS_HE));\n    // Pass in the context string \"2\" to allow the trace to distinguish objects\n    hePhyB->GetObssPdAlgorithm()->TraceConnect(\"Reset\", \"2\", MakeCallback(&ResetTrace));\n\n    Simulator::Stop(duration);\n    Simulator::Run();\n\n    Simulator::Destroy();\n\n    for (uint32_t i = 0; i < 2; i++)\n    {\n        const auto throughput = bytesReceived[2 + i] * 8.0 / duration.GetMicroSeconds();\n        std::cout << \"Throughput for BSS \" << i + 1 << \": \" << throughput << \" Mbit/s\" << std::endl;\n    }\n\n    g_resetFile1.close();\n    g_resetFile2.close();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple simulation of an IEEE 802.11n Wi-Fi network using ns-3 with the ability to test different Wi-Fi PHY models like SpectrumWifiPhy and YansWifiPhy, configure various parameters such as simulation time, distance between nodes, and modulation and coding scheme (MCS) index, and log signal and noise information. It should also explain how to toggle between UDP and TCP traffic, capture packets if needed, and iterate through different MCS, channel widths, and guard intervals, reporting throughput, signal strength, noise, and SNR for each configuration."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/propagation-loss-model.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <iomanip>\n\n// This is a simple example of an IEEE 802.11n Wi-Fi network.\n//\n// The main use case is to enable and test SpectrumWifiPhy vs YansWifiPhy\n// for packet error ratio\n//\n// Network topology:\n//\n//  Wi-Fi 192.168.1.0\n//\n//   STA                  AP\n//    * <-- distance -->  *\n//    |                   |\n//    n1                  n2\n//\n// Users may vary the following command-line arguments in addition to the\n// attributes, global values, and default values typically available:\n//\n//    --simulationTime:  Simulation time [10s]\n//    --udp:             UDP if set to 1, TCP otherwise [true]\n//    --distance:        meters separation between nodes [50]\n//    --index:           restrict index to single value between 0 and 31 [256]\n//    --wifiType:        select ns3::SpectrumWifiPhy or ns3::YansWifiPhy [ns3::SpectrumWifiPhy]\n//    --errorModelType:  select ns3::NistErrorRateModel or ns3::YansErrorRateModel\n//    [ns3::NistErrorRateModel]\n//    --enablePcap:      enable pcap output [false]\n//\n// By default, the program will step through 32 index values, corresponding\n// to the following MCS, channel width, and guard interval combinations:\n//   index 0-7:    MCS 0-7, long guard interval, 20 MHz channel\n//   index 8-15:   MCS 0-7, short guard interval, 20 MHz channel\n//   index 16-23:  MCS 0-7, long guard interval, 40 MHz channel\n//   index 24-31:  MCS 0-7, short guard interval, 40 MHz channel\n// and send UDP for 10 seconds using each MCS, using the SpectrumWifiPhy and the\n// NistErrorRateModel, at a distance of 50 meters.  The program outputs\n// results such as:\n//\n// wifiType: ns3::SpectrumWifiPhy distance: 50m; time: 10; TxPower: 1 dBm (1.3 mW)\n// index   MCS  Rate (Mb/s) Tput (Mb/s) Received Signal (dBm) Noise (dBm) SNR (dB)\n//     0     0      6.50        5.77    7414      -79.71      -93.97       14.25\n//     1     1     13.00       11.58   14892      -79.71      -93.97       14.25\n//     2     2     19.50       17.39   22358      -79.71      -93.97       14.25\n//     3     3     26.00       22.96   29521      -79.71      -93.97       14.25\n//   ...\n//\n\nusing namespace ns3;\n\n// Global variables for use in callbacks.\ndouble g_signalDbmAvg; //!< Average signal power [dBm]\ndouble g_noiseDbmAvg;  //!< Average noise power [dBm]\nuint32_t g_samples;    //!< Number of samples\n\n/**\n * Monitor sniffer Rx trace\n *\n * \\param packet The sensed packet.\n * \\param channelFreqMhz The channel frequency [MHz].\n * \\param txVector The Tx vector.\n * \\param aMpdu The aMPDU.\n * \\param signalNoise The signal and noise dBm.\n * \\param staId The STA ID.\n */\nvoid\nMonitorSniffRx(Ptr<const Packet> packet,\n               uint16_t channelFreqMhz,\n               WifiTxVector txVector,\n               MpduInfo aMpdu,\n               SignalNoiseDbm signalNoise,\n               uint16_t staId)\n\n{\n    g_samples++;\n    g_signalDbmAvg += ((signalNoise.signal - g_signalDbmAvg) / g_samples);\n    g_noiseDbmAvg += ((signalNoise.noise - g_noiseDbmAvg) / g_samples);\n}\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSpectrumPerExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    bool udp{true};\n    meter_u distance{50};\n    Time simulationTime{\"10s\"};\n    uint16_t index{256};\n    std::string wifiType{\"ns3::SpectrumWifiPhy\"};\n    std::string errorModelType{\"ns3::NistErrorRateModel\"};\n    bool enablePcap{false};\n    const uint32_t tcpPacketSize{1448};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"udp\", \"UDP if set to 1, TCP otherwise\", udp);\n    cmd.AddValue(\"distance\", \"meters separation between nodes\", distance);\n    cmd.AddValue(\"index\", \"restrict index to single value between 0 and 31\", index);\n    cmd.AddValue(\"wifiType\", \"select ns3::SpectrumWifiPhy or ns3::YansWifiPhy\", wifiType);\n    cmd.AddValue(\"errorModelType\",\n                 \"select ns3::NistErrorRateModel or ns3::YansErrorRateModel\",\n                 errorModelType);\n    cmd.AddValue(\"enablePcap\", \"enable pcap output\", enablePcap);\n    cmd.Parse(argc, argv);\n\n    uint16_t startIndex = 0;\n    uint16_t stopIndex = 31;\n    if (index < 32)\n    {\n        startIndex = index;\n        stopIndex = index;\n    }\n\n    std::cout << \"wifiType: \" << wifiType << \" distance: \" << distance\n              << \"m; time: \" << simulationTime << \"; TxPower: 1 dBm (1.3 mW)\" << std::endl;\n    std::cout << std::setw(5) << \"index\" << std::setw(6) << \"MCS\" << std::setw(13) << \"Rate (Mb/s)\"\n              << std::setw(12) << \"Tput (Mb/s)\" << std::setw(10) << \"Received \" << std::setw(12)\n              << \"Signal (dBm)\" << std::setw(12) << \"Noise (dBm)\" << std::setw(9) << \"SNR (dB)\"\n              << std::endl;\n    for (uint16_t i = startIndex; i <= stopIndex; i++)\n    {\n        uint32_t payloadSize;\n        if (udp)\n        {\n            payloadSize = 972; // 1000 bytes IPv4\n        }\n        else\n        {\n            payloadSize = 1448; // 1500 bytes IPv6\n            Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n        }\n\n        NodeContainer wifiStaNode;\n        wifiStaNode.Create(1);\n        NodeContainer wifiApNode;\n        wifiApNode.Create(1);\n\n        YansWifiPhyHelper yansPhy;\n        SpectrumWifiPhyHelper spectrumPhy;\n        if (wifiType == \"ns3::YansWifiPhy\")\n        {\n            YansWifiChannelHelper channel;\n            channel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\",\n                                       \"Frequency\",\n                                       DoubleValue(5.180e9));\n            channel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n            yansPhy.SetChannel(channel.Create());\n            yansPhy.Set(\"TxPowerStart\", DoubleValue(1)); // dBm (1.26 mW)\n            yansPhy.Set(\"TxPowerEnd\", DoubleValue(1));\n        }\n        else if (wifiType == \"ns3::SpectrumWifiPhy\")\n        {\n            Ptr<MultiModelSpectrumChannel> spectrumChannel =\n                CreateObject<MultiModelSpectrumChannel>();\n            Ptr<FriisPropagationLossModel> lossModel = CreateObject<FriisPropagationLossModel>();\n            lossModel->SetFrequency(5.180e9);\n            spectrumChannel->AddPropagationLossModel(lossModel);\n\n            Ptr<ConstantSpeedPropagationDelayModel> delayModel =\n                CreateObject<ConstantSpeedPropagationDelayModel>();\n            spectrumChannel->SetPropagationDelayModel(delayModel);\n\n            spectrumPhy.SetChannel(spectrumChannel);\n            spectrumPhy.SetErrorRateModel(errorModelType);\n            spectrumPhy.Set(\"TxPowerStart\", DoubleValue(1)); // dBm  (1.26 mW)\n            spectrumPhy.Set(\"TxPowerEnd\", DoubleValue(1));\n        }\n        else\n        {\n            NS_FATAL_ERROR(\"Unsupported WiFi type \" << wifiType);\n        }\n\n        WifiHelper wifi;\n        wifi.SetStandard(WIFI_STANDARD_80211n);\n        WifiMacHelper mac;\n\n        Ssid ssid = Ssid(\"ns380211n\");\n\n        double datarate = 0;\n        StringValue DataRate;\n        if (i == 0)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 6.5;\n        }\n        else if (i == 1)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 13;\n        }\n        else if (i == 2)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 19.5;\n        }\n        else if (i == 3)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 26;\n        }\n        else if (i == 4)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 39;\n        }\n        else if (i == 5)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 52;\n        }\n        else if (i == 6)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 58.5;\n        }\n        else if (i == 7)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 65;\n        }\n        else if (i == 8)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 7.2;\n        }\n        else if (i == 9)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 14.4;\n        }\n        else if (i == 10)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 21.7;\n        }\n        else if (i == 11)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 28.9;\n        }\n        else if (i == 12)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 43.3;\n        }\n        else if (i == 13)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 57.8;\n        }\n        else if (i == 14)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 65;\n        }\n        else if (i == 15)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 72.2;\n        }\n        else if (i == 16)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 13.5;\n        }\n        else if (i == 17)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 27;\n        }\n        else if (i == 18)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 40.5;\n        }\n        else if (i == 19)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 54;\n        }\n        else if (i == 20)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 81;\n        }\n        else if (i == 21)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 108;\n        }\n        else if (i == 22)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 121.5;\n        }\n        else if (i == 23)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 135;\n        }\n        else if (i == 24)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 15;\n        }\n        else if (i == 25)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 30;\n        }\n        else if (i == 26)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 45;\n        }\n        else if (i == 27)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 60;\n        }\n        else if (i == 28)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 90;\n        }\n        else if (i == 29)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 120;\n        }\n        else if (i == 30)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 135;\n        }\n        else\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 150;\n        }\n\n        wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                     \"DataMode\",\n                                     DataRate,\n                                     \"ControlMode\",\n                                     DataRate);\n\n        NetDeviceContainer staDevice;\n        NetDeviceContainer apDevice;\n\n        if (wifiType == \"ns3::YansWifiPhy\")\n        {\n            mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n            yansPhy.Set(\n                \"ChannelSettings\",\n                StringValue(std::string(\"{0, \") + (i <= 15 ? \"20\" : \"40\") + \", BAND_5GHZ, 0}\"));\n            staDevice = wifi.Install(yansPhy, mac, wifiStaNode);\n            mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n            apDevice = wifi.Install(yansPhy, mac, wifiApNode);\n        }\n        else if (wifiType == \"ns3::SpectrumWifiPhy\")\n        {\n            mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n            spectrumPhy.Set(\n                \"ChannelSettings\",\n                StringValue(std::string(\"{0, \") + (i <= 15 ? \"20\" : \"40\") + \", BAND_5GHZ, 0}\"));\n            staDevice = wifi.Install(spectrumPhy, mac, wifiStaNode);\n            mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n            apDevice = wifi.Install(spectrumPhy, mac, wifiApNode);\n        }\n\n        bool shortGuardIntervalSupported = (i > 7 && i <= 15) || (i > 23);\n        Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/\"\n                    \"ShortGuardIntervalSupported\",\n                    BooleanValue(shortGuardIntervalSupported));\n\n        // mobility.\n        MobilityHelper mobility;\n        Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n        positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n        positionAlloc->Add(Vector(distance, 0.0, 0.0));\n        mobility.SetPositionAllocator(positionAlloc);\n\n        mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n        mobility.Install(wifiApNode);\n        mobility.Install(wifiStaNode);\n\n        /* Internet stack*/\n        InternetStackHelper stack;\n        stack.Install(wifiApNode);\n        stack.Install(wifiStaNode);\n\n        Ipv4AddressHelper address;\n        address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer staNodeInterface;\n        Ipv4InterfaceContainer apNodeInterface;\n\n        staNodeInterface = address.Assign(staDevice);\n        apNodeInterface = address.Assign(apDevice);\n\n        /* Setting applications */\n        ApplicationContainer serverApp;\n        if (udp)\n        {\n            // UDP flow\n            uint16_t port = 9;\n            UdpServerHelper server(port);\n            serverApp = server.Install(wifiStaNode.Get(0));\n            serverApp.Start(Seconds(0.0));\n            serverApp.Stop(simulationTime + Seconds(1.0));\n            const auto packetInterval = payloadSize * 8.0 / (datarate * 1e6);\n\n            UdpClientHelper client(staNodeInterface.GetAddress(0), port);\n            client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n            client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n            client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n            ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n            clientApp.Start(Seconds(1.0));\n            clientApp.Stop(simulationTime + Seconds(1.0));\n        }\n        else\n        {\n            // TCP flow\n            uint16_t port = 50000;\n            Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n            PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n            serverApp = packetSinkHelper.Install(wifiStaNode.Get(0));\n            serverApp.Start(Seconds(0.0));\n            serverApp.Stop(simulationTime + Seconds(1.0));\n\n            OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n            onoff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n            onoff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n            onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n            onoff.SetAttribute(\"DataRate\", DataRateValue(datarate * 1e6));\n            AddressValue remoteAddress(InetSocketAddress(staNodeInterface.GetAddress(0), port));\n            onoff.SetAttribute(\"Remote\", remoteAddress);\n            ApplicationContainer clientApp = onoff.Install(wifiApNode.Get(0));\n            clientApp.Start(Seconds(1.0));\n            clientApp.Stop(simulationTime + Seconds(1.0));\n        }\n\n        Config::ConnectWithoutContext(\"/NodeList/0/DeviceList/*/Phy/MonitorSnifferRx\",\n                                      MakeCallback(&MonitorSniffRx));\n\n        if (enablePcap)\n        {\n            auto& phy = wifiType == \"ns3::YansWifiPhy\" ? dynamic_cast<WifiPhyHelper&>(yansPhy)\n                                                       : dynamic_cast<WifiPhyHelper&>(spectrumPhy);\n\n            phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n            std::stringstream ss;\n            ss << \"wifi-spectrum-per-example-\" << i;\n            phy.EnablePcap(ss.str(), apDevice);\n        }\n\n        g_signalDbmAvg = 0;\n        g_noiseDbmAvg = 0;\n        g_samples = 0;\n\n        Simulator::Stop(simulationTime + Seconds(1.0));\n        Simulator::Run();\n\n        auto throughput = 0.0;\n        uint64_t totalPacketsThrough = 0;\n        if (udp)\n        {\n            // UDP\n            totalPacketsThrough = DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n            throughput =\n                totalPacketsThrough * payloadSize * 8 / simulationTime.GetMicroSeconds(); // Mbit/s\n        }\n        else\n        {\n            // TCP\n            auto totalBytesRx = DynamicCast<PacketSink>(serverApp.Get(0))->GetTotalRx();\n            totalPacketsThrough = static_cast<uint64_t>(totalBytesRx / tcpPacketSize);\n            throughput = totalBytesRx * 8 / simulationTime.GetMicroSeconds(); // Mbit/s\n        }\n        std::cout << std::setw(5) << i << std::setw(6) << (i % 8) << std::setprecision(2)\n                  << std::fixed << std::setw(10) << datarate << std::setw(12) << throughput\n                  << std::setw(8) << totalPacketsThrough;\n        if (totalPacketsThrough > 0)\n        {\n            std::cout << std::setw(12) << g_signalDbmAvg << std::setw(12) << g_noiseDbmAvg\n                      << std::setw(12) << (g_signalDbmAvg - g_noiseDbmAvg) << std::endl;\n        }\n        else\n        {\n            std::cout << std::setw(12) << \"N/A\" << std::setw(12) << \"N/A\" << std::setw(12) << \"N/A\"\n                      << std::endl;\n        }\n        Simulator::Destroy();\n    }\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a complete NS-3 simulation program that models an IEEE 802.11n Wi-Fi network with a non-Wi-Fi interferer. The code should include appropriate NS-3 libraries, setup for spectrum-based and Yans-based Wi-Fi channels, and the ability to handle both TCP and UDP traffic. Implement command-line argument parsing to control simulation parameters such as simulation time, distance between nodes, index values (for MCS, channel width, and guard interval combinations), waveform power, Wi-Fi type, and error model. Provide detailed output regarding transmission rates, throughput, received signal strength, noise, and SNR during the simulation. Ensure proper configuration of node mobility, internet stack, and the installation of Wi-Fi devices. Include support for packet tracing and allow toggling PCAP generation."}, {"role": "assistant", "content": "#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/non-communicating-net-device.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/propagation-loss-model.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/waveform-generator-helper.h\"\n#include \"ns3/waveform-generator.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <iomanip>\n\n// This is a simple example of an IEEE 802.11n Wi-Fi network with a\n// non-Wi-Fi interferer.  It is an adaptation of the wifi-spectrum-per-example\n//\n// Unless the --waveformPower argument is passed, it will operate similarly to\n// wifi-spectrum-per-example.  Adding --waveformPower=value for values\n// greater than 0.0001 will result in frame losses beyond those that\n// result from the normal SNR based on distance path loss.\n//\n// If YansWifiPhy is selected as the wifiType, --waveformPower will have\n// no effect.\n//\n// Network topology:\n//\n//  Wi-Fi 192.168.1.0\n//\n//   STA                  AP\n//    * <-- distance -->  *\n//    |                   |\n//    n1                  n2\n//\n// Users may vary the following command-line arguments in addition to the\n// attributes, global values, and default values typically available:\n//\n//    --simulationTime:  Simulation time [10s]\n//    --udp:             UDP if set to 1, TCP otherwise [true]\n//    --distance:        meters separation between nodes [50]\n//    --index:           restrict index to single value between 0 and 31 [256]\n//    --wifiType:        select ns3::SpectrumWifiPhy or ns3::YansWifiPhy [ns3::SpectrumWifiPhy]\n//    --errorModelType:  select ns3::NistErrorRateModel or ns3::YansErrorRateModel\n//    [ns3::NistErrorRateModel]\n//    --enablePcap:      enable pcap output [false]\n//    --waveformPower:   Waveform power (linear W) [0]\n//\n// By default, the program will step through 32 index values, corresponding\n// to the following MCS, channel width, and guard interval combinations:\n//   index 0-7:    MCS 0-7, long guard interval, 20 MHz channel\n//   index 8-15:   MCS 0-7, short guard interval, 20 MHz channel\n//   index 16-23:  MCS 0-7, long guard interval, 40 MHz channel\n//   index 24-31:  MCS 0-7, short guard interval, 40 MHz channel\n// and send UDP for 10 seconds using each MCS, using the SpectrumWifiPhy and the\n// NistErrorRateModel, at a distance of 50 meters.  The program outputs\n// results such as:\n//\n// wifiType: ns3::SpectrumWifiPhy distance: 50m; time: 10; TxPower: 16 dBm (40 mW)\n// index   MCS  Rate (Mb/s) Tput (Mb/s) Received Signal (dBm)Noi+Inf(dBm) SNR (dB)\n//     0     0      6.50        5.77    7414      -64.69      -93.97       29.27\n//     1     1     13.00       11.58   14892      -64.69      -93.97       29.27\n//     2     2     19.50       17.39   22358      -64.69      -93.97       29.27\n//     3     3     26.00       23.23   29875      -64.69      -93.97       29.27\n//   ...\n//\n\nusing namespace ns3;\n\n// Global variables for use in callbacks.\ndouble g_signalDbmAvg; //!< Average signal power [dBm]\ndouble g_noiseDbmAvg;  //!< Average noise power [dBm]\nuint32_t g_samples;    //!< Number of samples\n\n/**\n * Monitor sniffer Rx trace\n *\n * \\param packet The sensed packet.\n * \\param channelFreqMhz The channel frequency [MHz].\n * \\param txVector The Tx vector.\n * \\param aMpdu The aMPDU.\n * \\param signalNoise The signal and noise dBm.\n * \\param staId The STA ID.\n */\nvoid\nMonitorSniffRx(Ptr<const Packet> packet,\n               uint16_t channelFreqMhz,\n               WifiTxVector txVector,\n               MpduInfo aMpdu,\n               SignalNoiseDbm signalNoise,\n               uint16_t staId)\n\n{\n    g_samples++;\n    g_signalDbmAvg += ((signalNoise.signal - g_signalDbmAvg) / g_samples);\n    g_noiseDbmAvg += ((signalNoise.noise - g_noiseDbmAvg) / g_samples);\n}\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSpectrumPerInterference\");\n\nPtr<SpectrumModel> SpectrumModelWifi5180MHz; //!< Spectrum model at 5180 MHz.\nPtr<SpectrumModel> SpectrumModelWifi5190MHz; //!< Spectrum model at 5190 MHz.\n\n/** Initializer for a static spectrum model centered around 5180 MHz */\nclass static_SpectrumModelWifi5180MHz_initializer\n{\n  public:\n    static_SpectrumModelWifi5180MHz_initializer()\n    {\n        BandInfo bandInfo;\n        bandInfo.fc = 5180e6;\n        bandInfo.fl = 5180e6 - 10e6;\n        bandInfo.fh = 5180e6 + 10e6;\n\n        Bands bands;\n        bands.push_back(bandInfo);\n\n        SpectrumModelWifi5180MHz = Create<SpectrumModel>(bands);\n    }\n};\n\n/// Static instance to initizlize the spectrum model around 5180 MHz.\nstatic_SpectrumModelWifi5180MHz_initializer static_SpectrumModelWifi5180MHz_initializer_instance;\n\n/** Initializer for a static spectrum model centered around 5190 MHz */\nclass static_SpectrumModelWifi5190MHz_initializer\n{\n  public:\n    static_SpectrumModelWifi5190MHz_initializer()\n    {\n        BandInfo bandInfo;\n        bandInfo.fc = 5190e6;\n        bandInfo.fl = 5190e6 - 10e6;\n        bandInfo.fh = 5190e6 + 10e6;\n\n        Bands bands;\n        bands.push_back(bandInfo);\n\n        SpectrumModelWifi5190MHz = Create<SpectrumModel>(bands);\n    }\n};\n\n/// Static instance to initizlize the spectrum model around 5190 MHz.\nstatic_SpectrumModelWifi5190MHz_initializer static_SpectrumModelWifi5190MHz_initializer_instance;\n\nint\nmain(int argc, char* argv[])\n{\n    bool udp{true};\n    meter_u distance{50};\n    Time simulationTime{\"10s\"};\n    uint16_t index{256};\n    std::string wifiType{\"ns3::SpectrumWifiPhy\"};\n    std::string errorModelType{\"ns3::NistErrorRateModel\"};\n    bool enablePcap{false};\n    const uint32_t tcpPacketSize{1448};\n    Watt_u waveformPower{0};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"udp\", \"UDP if set to 1, TCP otherwise\", udp);\n    cmd.AddValue(\"distance\", \"meters separation between nodes\", distance);\n    cmd.AddValue(\"index\", \"restrict index to single value between 0 and 31\", index);\n    cmd.AddValue(\"wifiType\", \"select ns3::SpectrumWifiPhy or ns3::YansWifiPhy\", wifiType);\n    cmd.AddValue(\"errorModelType\",\n                 \"select ns3::NistErrorRateModel or ns3::YansErrorRateModel\",\n                 errorModelType);\n    cmd.AddValue(\"enablePcap\", \"enable pcap output\", enablePcap);\n    cmd.AddValue(\"waveformPower\", \"Waveform power (linear W)\", waveformPower);\n    cmd.Parse(argc, argv);\n\n    uint16_t startIndex = 0;\n    uint16_t stopIndex = 31;\n    if (index < 32)\n    {\n        startIndex = index;\n        stopIndex = index;\n    }\n\n    std::cout << \"wifiType: \" << wifiType << \" distance: \" << distance\n              << \"m; time: \" << simulationTime << \"; TxPower: 16 dBm (40 mW)\" << std::endl;\n    std::cout << std::setw(5) << \"index\" << std::setw(6) << \"MCS\" << std::setw(13) << \"Rate (Mb/s)\"\n              << std::setw(12) << \"Tput (Mb/s)\" << std::setw(10) << \"Received \" << std::setw(12)\n              << \"Signal (dBm)\" << std::setw(12) << \"Noi+Inf(dBm)\" << std::setw(9) << \"SNR (dB)\"\n              << std::endl;\n    for (uint16_t i = startIndex; i <= stopIndex; i++)\n    {\n        uint32_t payloadSize;\n        if (udp)\n        {\n            payloadSize = 972; // 1000 bytes IPv4\n        }\n        else\n        {\n            payloadSize = 1448; // 1500 bytes IPv6\n            Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n        }\n\n        NodeContainer wifiStaNode;\n        wifiStaNode.Create(1);\n        NodeContainer wifiApNode;\n        wifiApNode.Create(1);\n        NodeContainer interferingNode;\n        interferingNode.Create(1);\n\n        YansWifiPhyHelper phy;\n        SpectrumWifiPhyHelper spectrumPhy;\n        Ptr<MultiModelSpectrumChannel> spectrumChannel;\n        uint16_t frequency = (i <= 15 ? 5180 : 5190);\n        if (wifiType == \"ns3::YansWifiPhy\")\n        {\n            YansWifiChannelHelper channel;\n            channel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\",\n                                       \"Frequency\",\n                                       DoubleValue(frequency * 1e6));\n            channel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n            phy.SetChannel(channel.Create());\n            phy.Set(\"ChannelSettings\",\n                    StringValue(std::string(\"{\") + (frequency == 5180 ? \"36\" : \"38\") +\n                                \", 0, BAND_5GHZ, 0}\"));\n        }\n        else if (wifiType == \"ns3::SpectrumWifiPhy\")\n        {\n            spectrumChannel = CreateObject<MultiModelSpectrumChannel>();\n            Ptr<FriisPropagationLossModel> lossModel = CreateObject<FriisPropagationLossModel>();\n            lossModel->SetFrequency(frequency * 1e6);\n            spectrumChannel->AddPropagationLossModel(lossModel);\n\n            Ptr<ConstantSpeedPropagationDelayModel> delayModel =\n                CreateObject<ConstantSpeedPropagationDelayModel>();\n            spectrumChannel->SetPropagationDelayModel(delayModel);\n\n            spectrumPhy.SetChannel(spectrumChannel);\n            spectrumPhy.SetErrorRateModel(errorModelType);\n            // channel 36 at 20 MHz, 38 at 40 MHz\n            spectrumPhy.Set(\"ChannelSettings\",\n                            StringValue(std::string(\"{\") + (frequency == 5180 ? \"36\" : \"38\") +\n                                        \", 0, BAND_5GHZ, 0}\"));\n        }\n        else\n        {\n            NS_FATAL_ERROR(\"Unsupported WiFi type \" << wifiType);\n        }\n\n        WifiHelper wifi;\n        wifi.SetStandard(WIFI_STANDARD_80211n);\n        WifiMacHelper mac;\n\n        Ssid ssid = Ssid(\"ns380211n\");\n\n        double datarate = 0;\n        StringValue DataRate;\n        if (i == 0)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 6.5;\n        }\n        else if (i == 1)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 13;\n        }\n        else if (i == 2)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 19.5;\n        }\n        else if (i == 3)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 26;\n        }\n        else if (i == 4)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 39;\n        }\n        else if (i == 5)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 52;\n        }\n        else if (i == 6)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 58.5;\n        }\n        else if (i == 7)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 65;\n        }\n        else if (i == 8)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 7.2;\n        }\n        else if (i == 9)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 14.4;\n        }\n        else if (i == 10)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 21.7;\n        }\n        else if (i == 11)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 28.9;\n        }\n        else if (i == 12)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 43.3;\n        }\n        else if (i == 13)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 57.8;\n        }\n        else if (i == 14)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 65;\n        }\n        else if (i == 15)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 72.2;\n        }\n        else if (i == 16)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 13.5;\n        }\n        else if (i == 17)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 27;\n        }\n        else if (i == 18)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 40.5;\n        }\n        else if (i == 19)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 54;\n        }\n        else if (i == 20)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 81;\n        }\n        else if (i == 21)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 108;\n        }\n        else if (i == 22)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 121.5;\n        }\n        else if (i == 23)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 135;\n        }\n        else if (i == 24)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 15;\n        }\n        else if (i == 25)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 30;\n        }\n        else if (i == 26)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 45;\n        }\n        else if (i == 27)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 60;\n        }\n        else if (i == 28)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 90;\n        }\n        else if (i == 29)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 120;\n        }\n        else if (i == 30)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 135;\n        }\n        else\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 150;\n        }\n\n        wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                     \"DataMode\",\n                                     DataRate,\n                                     \"ControlMode\",\n                                     DataRate);\n\n        NetDeviceContainer staDevice;\n        NetDeviceContainer apDevice;\n\n        if (wifiType == \"ns3::YansWifiPhy\")\n        {\n            mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n            staDevice = wifi.Install(phy, mac, wifiStaNode);\n            mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n            apDevice = wifi.Install(phy, mac, wifiApNode);\n        }\n        else if (wifiType == \"ns3::SpectrumWifiPhy\")\n        {\n            mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n            staDevice = wifi.Install(spectrumPhy, mac, wifiStaNode);\n            mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n            apDevice = wifi.Install(spectrumPhy, mac, wifiApNode);\n        }\n\n        bool shortGuardIntervalSupported = (i > 7 && i <= 15) || (i > 23);\n        Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/\"\n                    \"ShortGuardIntervalSupported\",\n                    BooleanValue(shortGuardIntervalSupported));\n\n        // mobility.\n        MobilityHelper mobility;\n        Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n        positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n        positionAlloc->Add(Vector(distance, 0.0, 0.0));\n        positionAlloc->Add(Vector(distance, distance, 0.0));\n        mobility.SetPositionAllocator(positionAlloc);\n\n        mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n        mobility.Install(wifiApNode);\n        mobility.Install(wifiStaNode);\n        mobility.Install(interferingNode);\n\n        /* Internet stack*/\n        InternetStackHelper stack;\n        stack.Install(wifiApNode);\n        stack.Install(wifiStaNode);\n\n        Ipv4AddressHelper address;\n        address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer staNodeInterface;\n        Ipv4InterfaceContainer apNodeInterface;\n\n        staNodeInterface = address.Assign(staDevice);\n        apNodeInterface = address.Assign(apDevice);\n\n        /* Setting applications */\n        ApplicationContainer serverApp;\n        if (udp)\n        {\n            // UDP flow\n            uint16_t port = 9;\n            UdpServerHelper server(port);\n            serverApp = server.Install(wifiStaNode.Get(0));\n            serverApp.Start(Seconds(0.0));\n            serverApp.Stop(simulationTime + Seconds(1.0));\n            const auto packetInterval = payloadSize * 8.0 / (datarate * 1e6);\n\n            UdpClientHelper client(staNodeInterface.GetAddress(0), port);\n            client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n            client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n            client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n            ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n            clientApp.Start(Seconds(1.0));\n            clientApp.Stop(simulationTime + Seconds(1.0));\n        }\n        else\n        {\n            // TCP flow\n            uint16_t port = 50000;\n            Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n            PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n            serverApp = packetSinkHelper.Install(wifiStaNode.Get(0));\n            serverApp.Start(Seconds(0.0));\n            serverApp.Stop(simulationTime + Seconds(1.0));\n\n            OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n            onoff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n            onoff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n            onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n            onoff.SetAttribute(\"DataRate\", DataRateValue(datarate * 1e6));\n            AddressValue remoteAddress(InetSocketAddress(staNodeInterface.GetAddress(0), port));\n            onoff.SetAttribute(\"Remote\", remoteAddress);\n            ApplicationContainer clientApp = onoff.Install(wifiApNode.Get(0));\n            clientApp.Start(Seconds(1.0));\n            clientApp.Stop(simulationTime + Seconds(1.0));\n        }\n\n        // Configure waveform generator\n        Ptr<SpectrumValue> wgPsd =\n            Create<SpectrumValue>(i <= 15 ? SpectrumModelWifi5180MHz : SpectrumModelWifi5190MHz);\n        *wgPsd = waveformPower / 20e6; // PSD spread across 20 MHz\n        NS_LOG_INFO(\"wgPsd : \" << *wgPsd\n                               << \" integrated power: \" << Integral(*(GetPointer(wgPsd))));\n\n        if (wifiType == \"ns3::SpectrumWifiPhy\")\n        {\n            WaveformGeneratorHelper waveformGeneratorHelper;\n            waveformGeneratorHelper.SetChannel(spectrumChannel);\n            waveformGeneratorHelper.SetTxPowerSpectralDensity(wgPsd);\n\n            waveformGeneratorHelper.SetPhyAttribute(\"Period\", TimeValue(Seconds(0.0007)));\n            waveformGeneratorHelper.SetPhyAttribute(\"DutyCycle\", DoubleValue(1));\n            NetDeviceContainer waveformGeneratorDevices =\n                waveformGeneratorHelper.Install(interferingNode);\n\n            Simulator::Schedule(Seconds(0.002),\n                                &WaveformGenerator::Start,\n                                waveformGeneratorDevices.Get(0)\n                                    ->GetObject<NonCommunicatingNetDevice>()\n                                    ->GetPhy()\n                                    ->GetObject<WaveformGenerator>());\n        }\n\n        Config::ConnectWithoutContext(\"/NodeList/0/DeviceList/*/Phy/MonitorSnifferRx\",\n                                      MakeCallback(&MonitorSniffRx));\n\n        if (enablePcap)\n        {\n            phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n            std::stringstream ss;\n            ss << \"wifi-spectrum-per-example-\" << i;\n            phy.EnablePcap(ss.str(), apDevice);\n        }\n        g_signalDbmAvg = 0;\n        g_noiseDbmAvg = 0;\n        g_samples = 0;\n\n        // Make sure we are tuned to 5180 MHz; if not, the example will\n        // not work properly\n        Ptr<NetDevice> staDevicePtr = staDevice.Get(0);\n        Ptr<WifiPhy> wifiPhyPtr = staDevicePtr->GetObject<WifiNetDevice>()->GetPhy();\n        if (i <= 15)\n        {\n            NS_ABORT_MSG_IF(wifiPhyPtr->GetChannelWidth() != 20,\n                            \"Error: Channel width must be 20 MHz if MCS index <= 15\");\n            NS_ABORT_MSG_IF(\n                wifiPhyPtr->GetFrequency() != 5180,\n                \"Error:  Wi-Fi nodes must be tuned to 5180 MHz to match the waveform generator\");\n        }\n        else\n        {\n            NS_ABORT_MSG_IF(wifiPhyPtr->GetChannelWidth() != 40,\n                            \"Error: Channel width must be 40 MHz if MCS index > 15\");\n            NS_ABORT_MSG_IF(\n                wifiPhyPtr->GetFrequency() != 5190,\n                \"Error:  Wi-Fi nodes must be tuned to 5190 MHz to match the waveform generator\");\n        }\n\n        Simulator::Stop(simulationTime + Seconds(1.0));\n        Simulator::Run();\n\n        auto throughput = 0.0;\n        auto totalPacketsThrough = 0.0;\n        if (udp)\n        {\n            // UDP\n            totalPacketsThrough = DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n            throughput =\n                totalPacketsThrough * payloadSize * 8 / simulationTime.GetMicroSeconds(); // Mbit/s\n        }\n        else\n        {\n            // TCP\n            auto totalBytesRx = DynamicCast<PacketSink>(serverApp.Get(0))->GetTotalRx();\n            totalPacketsThrough = totalBytesRx / tcpPacketSize;\n            throughput = totalBytesRx * 8 / simulationTime.GetMicroSeconds(); // Mbit/s\n        }\n        std::cout << std::setw(5) << i << std::setw(6) << (i % 8) << std::setprecision(2)\n                  << std::fixed << std::setw(10) << datarate << std::setw(12) << throughput\n                  << std::setw(8) << totalPacketsThrough;\n        if (totalPacketsThrough > 0)\n        {\n            std::cout << std::setw(12) << g_signalDbmAvg << std::setw(12) << g_noiseDbmAvg\n                      << std::setw(12) << (g_signalDbmAvg - g_noiseDbmAvg) << std::endl;\n        }\n        else\n        {\n            std::cout << std::setw(12) << \"N/A\" << std::setw(12) << \"N/A\" << std::setw(12) << \"N/A\"\n                      << std::endl;\n        }\n        Simulator::Destroy();\n    }\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using NS-3 that simulates network traffic capture between two nodes connected via a point-to-point link. Set the data transmission rate of the link to 5 Mbps and a propagation delay of 2 milliseconds. Install the Internet stack on both nodes and assign IP addresses to the devices using the range \"10.1.1.0/24\". Enable packet capture to record the traffic exchanged between the nodes into a .pcap file. Focus solely on capturing the network traffic, without configuring additional communication protocols or applications. Run and destroy the simulation afterward."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PacketCaptureExample\");\n\nint main(int argc, char *argv[]) {\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link between the two nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack (IP protocol)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Enable packet capture\n    pointToPoint.EnablePcapAll(\"simple-point-to-point\");\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ simulation program using the ns-3 network simulator that sets up a simple Wi-Fi network using either `ns3::SpectrumWifiPhy` or `ns3::YansWifiPhy` for the physical layer. This program should include configuration for multiple modulation and coding schemes (MCS), channel widths, and guard intervals, and allow the user to modify the simulation's parameters through the command line, such as simulation time, distance between nodes, and Wi-Fi and error model types. It should create a Wi-Fi station (STA) and access point (AP) node, transmit UDP packets under different conditions, and output throughput statistics like modulation scheme, channel width, and received data throughput for each MCS index."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/propagation-loss-model.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <iomanip>\n\n// This is a simple example of an IEEE 802.11n Wi-Fi network.\n//\n// The main use case is to enable and test SpectrumWifiPhy vs YansWifiPhy\n// under saturation conditions (for max throughput).\n//\n// Network topology:\n//\n//  Wi-Fi 192.168.1.0\n//\n//   STA                  AP\n//    * <-- distance -->  *\n//    |                   |\n//    n1                  n2\n//\n// Users may vary the following command-line arguments in addition to the\n// attributes, global values, and default values typically available:\n//\n//    --simulationTime:  Simulation time [10s]\n//    --distance:        meters separation between nodes [1]\n//    --index:           restrict index to single value between 0 and 31 [256]\n//    --wifiType:        select ns3::SpectrumWifiPhy or ns3::YansWifiPhy [ns3::SpectrumWifiPhy]\n//    --errorModelType:  select ns3::NistErrorRateModel or ns3::YansErrorRateModel\n//    [ns3::NistErrorRateModel]\n//    --enablePcap:      enable pcap output [false]\n//\n// By default, the program will step through 64 index values, corresponding\n// to the following MCS, channel width, and guard interval combinations:\n//   index 0-7:    MCS 0-7, long guard interval, 20 MHz channel\n//   index 8-15:   MCS 0-7, short guard interval, 20 MHz channel\n//   index 16-23:  MCS 0-7, long guard interval, 40 MHz channel\n//   index 24-31:  MCS 0-7, short guard interval, 40 MHz channel\n//   index 32-39:    MCS 8-15, long guard interval, 20 MHz channel\n//   index 40-47:   MCS 8-15, short guard interval, 20 MHz channel\n//   index 48-55:  MCS 8-15, long guard interval, 40 MHz channel\n//   index 56-63:  MCS 8-15, short guard interval, 40 MHz channel\n// and send packets at a high rate using each MCS, using the SpectrumWifiPhy\n// and the NistErrorRateModel, at a distance of 1 meter.  The program outputs\n// results such as:\n//\n// wifiType: ns3::SpectrumWifiPhy distance: 1m\n// index   MCS   width Rate (Mb/s) Tput (Mb/s) Received\n//     0     0      20       6.5     5.96219    5063\n//     1     1      20        13     11.9491   10147\n//     2     2      20      19.5     17.9184   15216\n//     3     3      20        26     23.9253   20317\n//     ...\n//\n// selection of index values 32-63 will result in MCS selection 8-15\n// involving two spatial streams\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSpectrumSaturationExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    meter_u distance{1};\n    Time simulationTime{\"10s\"};\n    uint16_t index{256};\n    uint32_t channelWidth{0};\n    std::string wifiType{\"ns3::SpectrumWifiPhy\"};\n    std::string errorModelType{\"ns3::NistErrorRateModel\"};\n    bool enablePcap{false};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"distance\", \"meters separation between nodes\", distance);\n    cmd.AddValue(\"index\", \"restrict index to single value between 0 and 63\", index);\n    cmd.AddValue(\"wifiType\", \"select ns3::SpectrumWifiPhy or ns3::YansWifiPhy\", wifiType);\n    cmd.AddValue(\"errorModelType\",\n                 \"select ns3::NistErrorRateModel or ns3::YansErrorRateModel\",\n                 errorModelType);\n    cmd.AddValue(\"enablePcap\", \"enable pcap output\", enablePcap);\n    cmd.Parse(argc, argv);\n\n    uint16_t startIndex = 0;\n    uint16_t stopIndex = 63;\n    if (index < 64)\n    {\n        startIndex = index;\n        stopIndex = index;\n    }\n\n    std::cout << \"wifiType: \" << wifiType << \" distance: \" << distance << \"m\" << std::endl;\n    std::cout << std::setw(5) << \"index\" << std::setw(6) << \"MCS\" << std::setw(8) << \"width\"\n              << std::setw(12) << \"Rate (Mb/s)\" << std::setw(12) << \"Tput (Mb/s)\" << std::setw(10)\n              << \"Received \" << std::endl;\n    for (uint16_t i = startIndex; i <= stopIndex; i++)\n    {\n        uint32_t payloadSize;\n        payloadSize = 1472; // 1500 bytes IPv4\n\n        NodeContainer wifiStaNode;\n        wifiStaNode.Create(1);\n        NodeContainer wifiApNode;\n        wifiApNode.Create(1);\n\n        YansWifiPhyHelper yansPhy;\n        SpectrumWifiPhyHelper spectrumPhy;\n        if (wifiType == \"ns3::YansWifiPhy\")\n        {\n            YansWifiChannelHelper channel;\n            channel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n            channel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n            yansPhy.SetChannel(channel.Create());\n            yansPhy.Set(\"TxPowerStart\", DoubleValue(1));\n            yansPhy.Set(\"TxPowerEnd\", DoubleValue(1));\n\n            if (i > 31 && i <= 63)\n            {\n                yansPhy.Set(\"Antennas\", UintegerValue(2));\n                yansPhy.Set(\"MaxSupportedTxSpatialStreams\", UintegerValue(2));\n                yansPhy.Set(\"MaxSupportedRxSpatialStreams\", UintegerValue(2));\n            }\n        }\n        else if (wifiType == \"ns3::SpectrumWifiPhy\")\n        {\n            Ptr<MultiModelSpectrumChannel> spectrumChannel =\n                CreateObject<MultiModelSpectrumChannel>();\n            Ptr<FriisPropagationLossModel> lossModel = CreateObject<FriisPropagationLossModel>();\n            spectrumChannel->AddPropagationLossModel(lossModel);\n\n            Ptr<ConstantSpeedPropagationDelayModel> delayModel =\n                CreateObject<ConstantSpeedPropagationDelayModel>();\n            spectrumChannel->SetPropagationDelayModel(delayModel);\n\n            spectrumPhy.SetChannel(spectrumChannel);\n            spectrumPhy.SetErrorRateModel(errorModelType);\n            spectrumPhy.Set(\"TxPowerStart\", DoubleValue(1));\n            spectrumPhy.Set(\"TxPowerEnd\", DoubleValue(1));\n\n            if (i > 31 && i <= 63)\n            {\n                spectrumPhy.Set(\"Antennas\", UintegerValue(2));\n                spectrumPhy.Set(\"MaxSupportedTxSpatialStreams\", UintegerValue(2));\n                spectrumPhy.Set(\"MaxSupportedRxSpatialStreams\", UintegerValue(2));\n            }\n        }\n        else\n        {\n            NS_FATAL_ERROR(\"Unsupported WiFi type \" << wifiType);\n        }\n\n        WifiHelper wifi;\n        wifi.SetStandard(WIFI_STANDARD_80211n);\n        WifiMacHelper mac;\n\n        Ssid ssid = Ssid(\"ns380211n\");\n\n        double datarate = 0;\n        StringValue DataRate;\n        if (i == 0)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 6.5;\n        }\n        else if (i == 1)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 13;\n        }\n        else if (i == 2)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 19.5;\n        }\n        else if (i == 3)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 26;\n        }\n        else if (i == 4)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 39;\n        }\n        else if (i == 5)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 52;\n        }\n        else if (i == 6)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 58.5;\n        }\n        else if (i == 7)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 65;\n        }\n        else if (i == 8)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 7.2;\n        }\n        else if (i == 9)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 14.4;\n        }\n        else if (i == 10)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 21.7;\n        }\n        else if (i == 11)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 28.9;\n        }\n        else if (i == 12)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 43.3;\n        }\n        else if (i == 13)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 57.8;\n        }\n        else if (i == 14)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 65;\n        }\n        else if (i == 15)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 72.2;\n        }\n        else if (i == 16)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 13.5;\n        }\n        else if (i == 17)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 27;\n        }\n        else if (i == 18)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 40.5;\n        }\n        else if (i == 19)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 54;\n        }\n        else if (i == 20)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 81;\n        }\n        else if (i == 21)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 108;\n        }\n        else if (i == 22)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 121.5;\n        }\n        else if (i == 23)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 135;\n        }\n        else if (i == 24)\n        {\n            DataRate = StringValue(\"HtMcs0\");\n            datarate = 15;\n        }\n        else if (i == 25)\n        {\n            DataRate = StringValue(\"HtMcs1\");\n            datarate = 30;\n        }\n        else if (i == 26)\n        {\n            DataRate = StringValue(\"HtMcs2\");\n            datarate = 45;\n        }\n        else if (i == 27)\n        {\n            DataRate = StringValue(\"HtMcs3\");\n            datarate = 60;\n        }\n        else if (i == 28)\n        {\n            DataRate = StringValue(\"HtMcs4\");\n            datarate = 90;\n        }\n        else if (i == 29)\n        {\n            DataRate = StringValue(\"HtMcs5\");\n            datarate = 120;\n        }\n        else if (i == 30)\n        {\n            DataRate = StringValue(\"HtMcs6\");\n            datarate = 135;\n        }\n        else if (i == 31)\n        {\n            DataRate = StringValue(\"HtMcs7\");\n            datarate = 150;\n        }\n        else if (i == 32)\n        {\n            DataRate = StringValue(\"HtMcs8\");\n            datarate = 13;\n        }\n        else if (i == 33)\n        {\n            DataRate = StringValue(\"HtMcs9\");\n            datarate = 26;\n        }\n        else if (i == 34)\n        {\n            DataRate = StringValue(\"HtMcs10\");\n            datarate = 39;\n        }\n        else if (i == 35)\n        {\n            DataRate = StringValue(\"HtMcs11\");\n            datarate = 52;\n        }\n        else if (i == 36)\n        {\n            DataRate = StringValue(\"HtMcs12\");\n            datarate = 78;\n        }\n        else if (i == 37)\n        {\n            DataRate = StringValue(\"HtMcs13\");\n            datarate = 104;\n        }\n        else if (i == 38)\n        {\n            DataRate = StringValue(\"HtMcs14\");\n            datarate = 117;\n        }\n        else if (i == 39)\n        {\n            DataRate = StringValue(\"HtMcs15\");\n            datarate = 130;\n        }\n        else if (i == 40)\n        {\n            DataRate = StringValue(\"HtMcs8\");\n            datarate = 14.4;\n        }\n        else if (i == 41)\n        {\n            DataRate = StringValue(\"HtMcs9\");\n            datarate = 28.9;\n        }\n        else if (i == 42)\n        {\n            DataRate = StringValue(\"HtMcs10\");\n            datarate = 43.3;\n        }\n        else if (i == 43)\n        {\n            DataRate = StringValue(\"HtMcs11\");\n            datarate = 57.8;\n        }\n        else if (i == 44)\n        {\n            DataRate = StringValue(\"HtMcs12\");\n            datarate = 86.7;\n        }\n        else if (i == 45)\n        {\n            DataRate = StringValue(\"HtMcs13\");\n            datarate = 115.6;\n        }\n        else if (i == 46)\n        {\n            DataRate = StringValue(\"HtMcs14\");\n            datarate = 130.3;\n        }\n        else if (i == 47)\n        {\n            DataRate = StringValue(\"HtMcs15\");\n            datarate = 144.4;\n        }\n        else if (i == 48)\n        {\n            DataRate = StringValue(\"HtMcs8\");\n            datarate = 27;\n        }\n        else if (i == 49)\n        {\n            DataRate = StringValue(\"HtMcs9\");\n            datarate = 54;\n        }\n        else if (i == 50)\n        {\n            DataRate = StringValue(\"HtMcs10\");\n            datarate = 81;\n        }\n        else if (i == 51)\n        {\n            DataRate = StringValue(\"HtMcs11\");\n            datarate = 108;\n        }\n        else if (i == 52)\n        {\n            DataRate = StringValue(\"HtMcs12\");\n            datarate = 162;\n        }\n        else if (i == 53)\n        {\n            DataRate = StringValue(\"HtMcs13\");\n            datarate = 216;\n        }\n        else if (i == 54)\n        {\n            DataRate = StringValue(\"HtMcs14\");\n            datarate = 243;\n        }\n        else if (i == 55)\n        {\n            DataRate = StringValue(\"HtMcs15\");\n            datarate = 270;\n        }\n        else if (i == 56)\n        {\n            DataRate = StringValue(\"HtMcs8\");\n            datarate = 30;\n        }\n        else if (i == 57)\n        {\n            DataRate = StringValue(\"HtMcs9\");\n            datarate = 60;\n        }\n        else if (i == 58)\n        {\n            DataRate = StringValue(\"HtMcs10\");\n            datarate = 90;\n        }\n        else if (i == 59)\n        {\n            DataRate = StringValue(\"HtMcs11\");\n            datarate = 120;\n        }\n        else if (i == 60)\n        {\n            DataRate = StringValue(\"HtMcs12\");\n            datarate = 180;\n        }\n        else if (i == 61)\n        {\n            DataRate = StringValue(\"HtMcs13\");\n            datarate = 240;\n        }\n        else if (i == 62)\n        {\n            DataRate = StringValue(\"HtMcs14\");\n            datarate = 270;\n        }\n        else if (i == 63)\n        {\n            DataRate = StringValue(\"HtMcs15\");\n            datarate = 300;\n        }\n        else\n        {\n            NS_FATAL_ERROR(\"Illegal index i \" << i);\n        }\n\n        wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                     \"DataMode\",\n                                     DataRate,\n                                     \"ControlMode\",\n                                     DataRate);\n\n        NetDeviceContainer staDevice;\n        NetDeviceContainer apDevice;\n\n        channelWidth = (i <= 15 || (i > 31 && i <= 47) ? 20 : 40);\n        std::string channelStr = \"{0, \" + std::to_string(channelWidth) + \", BAND_5GHZ, 0}\";\n\n        if (wifiType == \"ns3::YansWifiPhy\")\n        {\n            mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n            yansPhy.Set(\"ChannelSettings\", StringValue(channelStr));\n\n            staDevice = wifi.Install(yansPhy, mac, wifiStaNode);\n            mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n            yansPhy.Set(\"ChannelSettings\", StringValue(channelStr));\n            apDevice = wifi.Install(yansPhy, mac, wifiApNode);\n        }\n        else if (wifiType == \"ns3::SpectrumWifiPhy\")\n        {\n            mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n            spectrumPhy.Set(\"ChannelSettings\", StringValue(channelStr));\n            staDevice = wifi.Install(spectrumPhy, mac, wifiStaNode);\n            mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n            spectrumPhy.Set(\"ChannelSettings\", StringValue(channelStr));\n            apDevice = wifi.Install(spectrumPhy, mac, wifiApNode);\n        }\n\n        bool shortGuardIntervalSupported =\n            (i > 7 && i <= 15) || (i > 23 && i <= 31) || (i > 39 && i <= 47) || (i > 55);\n        Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/HtConfiguration/\"\n                    \"ShortGuardIntervalSupported\",\n                    BooleanValue(shortGuardIntervalSupported));\n\n        // mobility.\n        MobilityHelper mobility;\n        Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n        positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n        positionAlloc->Add(Vector(distance, 0.0, 0.0));\n        mobility.SetPositionAllocator(positionAlloc);\n\n        mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n        mobility.Install(wifiApNode);\n        mobility.Install(wifiStaNode);\n\n        /* Internet stack*/\n        InternetStackHelper stack;\n        stack.Install(wifiApNode);\n        stack.Install(wifiStaNode);\n\n        Ipv4AddressHelper address;\n        address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer staNodeInterface;\n        Ipv4InterfaceContainer apNodeInterface;\n\n        staNodeInterface = address.Assign(staDevice);\n        apNodeInterface = address.Assign(apDevice);\n\n        /* Setting applications */\n        uint16_t port = 9;\n        UdpServerHelper server(port);\n        ApplicationContainer serverApp = server.Install(wifiStaNode.Get(0));\n        serverApp.Start(Seconds(0.0));\n        serverApp.Stop(simulationTime + Seconds(1.0));\n        const auto packetInterval = payloadSize * 8.0 / (datarate * 1e6);\n\n        UdpClientHelper client(staNodeInterface.GetAddress(0), port);\n        client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n        client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n        client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n        ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n        clientApp.Start(Seconds(1.0));\n        clientApp.Stop(simulationTime + Seconds(1.0));\n\n        if (enablePcap)\n        {\n            auto& phy =\n                (wifiType == \"ns3::YansWifiPhy\" ? dynamic_cast<WifiPhyHelper&>(yansPhy)\n                                                : dynamic_cast<WifiPhyHelper&>(spectrumPhy));\n            phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n            std::stringstream ss;\n            ss << \"wifi-spectrum-saturation-example-\" << i;\n            phy.EnablePcap(ss.str(), apDevice);\n        }\n\n        Simulator::Stop(simulationTime + Seconds(1.0));\n        Simulator::Run();\n\n        double totalPacketsThrough = DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n        auto throughput =\n            totalPacketsThrough * payloadSize * 8 / simulationTime.GetMicroSeconds(); // Mbit/s\n        std::cout << std::setw(5) << i << std::setw(6) << (i % 8) + 8 * (i / 32) << std::setw(8)\n                  << channelWidth << std::setw(10) << datarate << std::setw(12) << throughput\n                  << std::setw(8) << totalPacketsThrough << std::endl;\n        Simulator::Destroy();\n    }\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ simulation script using NS-3 to test TCP performance over an 802.11n wireless network with MPDU aggregation enabled. The topology consists of one access point (AP) and one station (STA). The STA sends TCP packets to the AP, and the simulation reports the total throughput every 100ms. The simulation should allow for command-line configuration of parameters such as the TCP congestion control algorithm, application data rate, payload size, physical layer bitrate, simulation duration, and whether PCAP tracing is enabled. Use NS-3's YansWifiHelper for configuring the Wi-Fi channel and mobility models."}, {"role": "assistant", "content": "/*\n * This is a simple example to test TCP over 802.11n (with MPDU aggregation enabled).\n *\n * Network topology:\n *\n *   Ap    STA\n *   *      *\n *   |      |\n *   n1     n2\n *\n * In this example, an HT station sends TCP packets to the access point.\n * We report the total throughput received during a window of 100ms.\n * The user can specify the application data rate and choose the variant\n * of TCP i.e. congestion control algorithm to use.\n */\n\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/tcp-westwood-plus.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nNS_LOG_COMPONENT_DEFINE(\"wifi-tcp\");\n\nusing namespace ns3;\n\nPtr<PacketSink> sink;     //!< Pointer to the packet sink application\nuint64_t lastTotalRx = 0; //!< The value of the last total received bytes\n\n/**\n * Calculate the throughput\n */\nvoid\nCalculateThroughput()\n{\n    Time now = Simulator::Now(); /* Return the simulator's virtual time. */\n    double cur = (sink->GetTotalRx() - lastTotalRx) * 8.0 /\n                 1e5; /* Convert Application RX Packets to MBits. */\n    std::cout << now.GetSeconds() << \"s: \\t\" << cur << \" Mbit/s\" << std::endl;\n    lastTotalRx = sink->GetTotalRx();\n    Simulator::Schedule(MilliSeconds(100), &CalculateThroughput);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t payloadSize{1472};           /* Transport layer payload size in bytes. */\n    DataRate dataRate{\"100Mb/s\"};         /* Application layer datarate. */\n    std::string tcpVariant{\"TcpNewReno\"}; /* TCP variant type. */\n    std::string phyRate{\"HtMcs7\"};        /* Physical layer bitrate. */\n    Time simulationTime{\"10s\"};           /* Simulation time. */\n    bool pcapTracing{false};              /* PCAP Tracing is enabled or not. */\n\n    /* Command line argument parser setup. */\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"payloadSize\", \"Payload size in bytes\", payloadSize);\n    cmd.AddValue(\"dataRate\", \"Application data ate\", dataRate);\n    cmd.AddValue(\"tcpVariant\",\n                 \"Transport protocol to use: TcpNewReno, \"\n                 \"TcpHybla, TcpHighSpeed, TcpHtcp, TcpVegas, TcpScalable, TcpVeno, \"\n                 \"TcpBic, TcpYeah, TcpIllinois, TcpWestwood, TcpWestwoodPlus, TcpLedbat \",\n                 tcpVariant);\n    cmd.AddValue(\"phyRate\", \"Physical layer bitrate\", phyRate);\n    cmd.AddValue(\"simulationTime\", \"Simulation time in seconds\", simulationTime);\n    cmd.AddValue(\"pcap\", \"Enable/disable PCAP Tracing\", pcapTracing);\n    cmd.Parse(argc, argv);\n\n    tcpVariant = std::string(\"ns3::\") + tcpVariant;\n    // Select TCP variant\n    TypeId tcpTid;\n    NS_ABORT_MSG_UNLESS(TypeId::LookupByNameFailSafe(tcpVariant, &tcpTid),\n                        \"TypeId \" << tcpVariant << \" not found\");\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\",\n                       TypeIdValue(TypeId::LookupByName(tcpVariant)));\n\n    /* Configure TCP Options */\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n\n    WifiMacHelper wifiMac;\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_STANDARD_80211n);\n\n    /* Set up Legacy Channel */\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\", \"Frequency\", DoubleValue(5e9));\n\n    /* Setup Physical Layer */\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.SetChannel(wifiChannel.Create());\n    wifiPhy.SetErrorRateModel(\"ns3::YansErrorRateModel\");\n    wifiHelper.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                       \"DataMode\",\n                                       StringValue(phyRate),\n                                       \"ControlMode\",\n                                       StringValue(\"HtMcs0\"));\n\n    NodeContainer networkNodes;\n    networkNodes.Create(2);\n    Ptr<Node> apWifiNode = networkNodes.Get(0);\n    Ptr<Node> staWifiNode = networkNodes.Get(1);\n\n    /* Configure AP */\n    Ssid ssid = Ssid(\"network\");\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifiHelper.Install(wifiPhy, wifiMac, apWifiNode);\n\n    /* Configure STA */\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifiHelper.Install(wifiPhy, wifiMac, staWifiNode);\n\n    /* Mobility model */\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(1.0, 1.0, 0.0));\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(apWifiNode);\n    mobility.Install(staWifiNode);\n\n    /* Internet stack */\n    InternetStackHelper stack;\n    stack.Install(networkNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apInterface;\n    apInterface = address.Assign(apDevice);\n    Ipv4InterfaceContainer staInterface;\n    staInterface = address.Assign(staDevices);\n\n    /* Populate routing table */\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    /* Install TCP Receiver on the access point */\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\",\n                                InetSocketAddress(Ipv4Address::GetAny(), 9));\n    ApplicationContainer sinkApp = sinkHelper.Install(apWifiNode);\n    sink = StaticCast<PacketSink>(sinkApp.Get(0));\n\n    /* Install TCP/UDP Transmitter on the station */\n    OnOffHelper server(\"ns3::TcpSocketFactory\", (InetSocketAddress(apInterface.GetAddress(0), 9)));\n    server.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n    server.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    server.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    server.SetAttribute(\"DataRate\", DataRateValue(DataRate(dataRate)));\n    ApplicationContainer serverApp = server.Install(staWifiNode);\n\n    /* Start Applications */\n    sinkApp.Start(Seconds(0.0));\n    serverApp.Start(Seconds(1.0));\n    Simulator::Schedule(Seconds(1.1), &CalculateThroughput);\n\n    /* Enable Traces */\n    if (pcapTracing)\n    {\n        wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n        wifiPhy.EnablePcap(\"AccessPoint\", apDevice);\n        wifiPhy.EnablePcap(\"Station\", staDevices);\n    }\n\n    /* Start Simulation */\n    Simulator::Stop(simulationTime + Seconds(1.0));\n    Simulator::Run();\n\n    auto averageThroughput =\n        (static_cast<double>(sink->GetTotalRx() * 8) / simulationTime.GetMicroSeconds());\n\n    Simulator::Destroy();\n\n    if (averageThroughput < 50)\n    {\n        NS_LOG_ERROR(\"Obtained throughput is not in the expected boundaries!\");\n        exit(1);\n    }\n    std::cout << \"\\nAverage throughput: \" << averageThroughput << \" Mbit/s\" << std::endl;\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ simulation script using NS-3 to demonstrate how to modify Wi-Fi timing parameters, such as slot time, SIFS, and PIFS, through command-line arguments. The simulation features a simple network topology with an access point (AP) and a station (STA) using 802.11n over a 2.4 GHz channel. The AP runs a UDP client that sends packets to a UDP server on the STA, and the throughput is calculated at the end of the simulation. Implement the required wireless channel, PHY, MAC, mobility, and internet stacks, while adjusting Wi-Fi timing attributes like slot, SIFS, and PIFS dynamically."}, {"role": "assistant", "content": "#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/mobility-model.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This example shows how to set Wi-Fi timing parameters through WifiMac attributes.\n//\n// Example: set slot time to 20 microseconds, while keeping other values as defined in the\n// simulation script:\n//\n//          ./ns3 run \"wifi-timing-attributes --slot=20us\"\n//\n// Network topology:\n//\n//  Wifi 192.168.1.0\n//\n//       AP\n//  *    *\n//  |    |\n//  n1   n2\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"wifi-timing-attributes\");\n\nint\nmain(int argc, char* argv[])\n{\n    Time slot{\"9us\"};           // slot time\n    Time sifs{\"10us\"};          // SIFS duration\n    Time pifs{\"19us\"};          // PIFS duration\n    Time simulationTime{\"10s\"}; // Simulation time\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"slot\", \"Slot time\", slot);\n    cmd.AddValue(\"sifs\", \"SIFS duration\", sifs);\n    cmd.AddValue(\"pifs\", \"PIFS duration\", pifs);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.Parse(argc, argv);\n\n    // Since default reference loss is defined for 5 GHz, it needs to be changed when operating\n    // at 2.4 GHz\n    Config::SetDefault(\"ns3::LogDistancePropagationLossModel::ReferenceLoss\", DoubleValue(40.046));\n\n    // Create nodes\n    NodeContainer wifiStaNode;\n    wifiStaNode.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Create wireless channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    // Default IEEE 802.11n (2.4 GHz)\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"HtMcs7\"),\n                                 \"ControlMode\",\n                                 StringValue(\"HtMcs0\"));\n    WifiMacHelper mac;\n\n    // Install PHY and MAC\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevice;\n    staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Once install is done, we overwrite the standard timing values\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/Slot\", TimeValue(slot));\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/Sifs\", TimeValue(sifs));\n    Config::Set(\"/NodeList/*/DeviceList/*/$ns3::WifiNetDevice/Phy/Pifs\", TimeValue(pifs));\n\n    // Mobility\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(1.0, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNode);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNode);\n\n    Ipv4AddressHelper address;\n\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staNodeInterface;\n    Ipv4InterfaceContainer apNodeInterface;\n\n    staNodeInterface = address.Assign(staDevice);\n    apNodeInterface = address.Assign(apDevice);\n\n    // Setting applications\n    uint16_t port = 9;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiStaNode.Get(0));\n    serverApp.Start(Seconds(0.0));\n    serverApp.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper client(staNodeInterface.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    client.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    client.SetAttribute(\"PacketSize\", UintegerValue(1472));     // bytes\n\n    ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(simulationTime + Seconds(1.0));\n\n    // Populate routing table\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Set simulation time and launch simulation\n    Simulator::Stop(simulationTime + Seconds(1.0));\n    Simulator::Run();\n\n    // Get and print results\n    double totalPacketsThrough = DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n    auto throughput = totalPacketsThrough * 1472 * 8 / simulationTime.GetMicroSeconds(); // Mbit/s\n    std::cout << \"Throughput: \" << throughput << \" Mbit/s\" << std::endl;\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulator to demonstrate 802.11n aggregation across four independent Wi-Fi networks, each operating on a different channel (36, 40, 44, and 48) with one access point (AP) and one station (STA) per network. Configure different aggregation settings for each station: station A uses default A-MPDU with a max size of 65kB, station B disables aggregation, station C enables A-MSDU with a max size of 8kB but disables A-MPDU, and station D enables both A-MPDU with a max size of 32kB and A-MSDU with 4kB. Include options for adjusting distance between the AP and STA, enabling/disabling RTS/CTS, and modifying TXOP durations, then output the throughput and maximum TXOP duration for each network. Use the YansWifiPhy, YansWifiChannel, and mobility models to set up the simulation, and trace TXOP durations for each access point using callbacks."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/pointer.h\"\n#include \"ns3/qos-txop.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/wifi-mac.h\"\n#include \"ns3/wifi-net-device.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This is an example that illustrates how 802.11n aggregation is configured.\n// It defines 4 independent Wi-Fi networks (working on different channels).\n// Each network contains one access point and one station. Each station\n// continuously transmits data packets to its respective AP.\n//\n// Network topology (numbers in parentheses are channel numbers):\n//\n//  Network A (36)   Network B (40)   Network C (44)   Network D (48)\n//   *      *          *      *         *      *          *      *\n//   |      |          |      |         |      |          |      |\n//  AP A   STA A      AP B   STA B     AP C   STA C      AP D   STA D\n//\n// The aggregation parameters are configured differently on the 4 stations:\n// - station A uses default aggregation parameter values (A-MSDU disabled, A-MPDU enabled with\n// maximum size of 65 kB);\n// - station B doesn't use aggregation (both A-MPDU and A-MSDU are disabled);\n// - station C enables A-MSDU (with maximum size of 8 kB) but disables A-MPDU;\n// - station D uses two-level aggregation (A-MPDU with maximum size of 32 kB and A-MSDU with maximum\n// size of 4 kB).\n//\n// The user can select the distance between the stations and the APs, can enable/disable the RTS/CTS\n// mechanism and can modify the duration of a TXOP. Example: ./ns3 run \"wifi-txop-aggregation\n// --distance=10 --enableRts=0 --simulationTime=20s\"\n//\n// The output prints the throughput and the maximum TXOP duration measured for the 4 cases/networks\n// described above. When default aggregation parameters are enabled, the\n// maximum A-MPDU size is 65 kB and the throughput is maximal. When aggregation is disabled, the\n// throughput is about the half of the physical bitrate. When only A-MSDU is enabled, the throughput\n// is increased but is not maximal, since the maximum A-MSDU size is limited to 7935 bytes (whereas\n// the maximum A-MPDU size is limited to 65535 bytes). When A-MSDU and A-MPDU are both enabled (=\n// two-level aggregation), the throughput is slightly smaller than the first scenario since we set a\n// smaller maximum A-MPDU size.\n//\n// When the distance is increased, the frame error rate gets higher, and the output shows how it\n// affects the throughput for the 4 networks. Even through A-MSDU has less overheads than A-MPDU,\n// A-MSDU is less robust against transmission errors than A-MPDU. When the distance is augmented,\n// the throughput for the third scenario is more affected than the throughput obtained in other\n// networks.\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TxopMpduAggregation\");\n\n/**\n * Keeps the maximum duration among all TXOPs\n */\nstruct TxopDurationTracer\n{\n    /**\n     * Callback connected to TXOP duration trace source.\n     *\n     * \\param startTime TXOP start time\n     * \\param duration TXOP duration\n     * \\param linkId the ID of the link\n     */\n    void Trace(Time startTime, Time duration, uint8_t linkId);\n    Time m_max{Seconds(0)}; //!< maximum TXOP duration\n};\n\nvoid\nTxopDurationTracer::Trace(Time startTime, Time duration, uint8_t linkId)\n{\n    if (duration > m_max)\n    {\n        m_max = duration;\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t payloadSize{1472}; // bytes\n    Time simulationTime{\"10s\"};\n    double txopLimit{3520}; // microseconds\n    meter_u distance{5};\n    bool enableRts{false};\n    bool enablePcap{false};\n    bool verifyResults{false}; // used for regression\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"payloadSize\", \"Payload size in bytes\", payloadSize);\n    cmd.AddValue(\"enableRts\", \"Enable or disable RTS/CTS\", enableRts);\n    cmd.AddValue(\"txopLimit\", \"TXOP duration in microseconds\", txopLimit);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the station and the access point\",\n                 distance);\n    cmd.AddValue(\"enablePcap\", \"Enable/disable pcap file generation\", enablePcap);\n    cmd.AddValue(\"verifyResults\",\n                 \"Enable/disable results verification at the end of the simulation\",\n                 verifyResults);\n    cmd.Parse(argc, argv);\n\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\",\n                       enableRts ? StringValue(\"0\") : StringValue(\"999999\"));\n\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(4);\n    NodeContainer wifiApNodes;\n    wifiApNodes.Create(4);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(\"HtMcs7\"),\n                                 \"ControlMode\",\n                                 StringValue(\"HtMcs0\"));\n    WifiMacHelper mac;\n\n    NetDeviceContainer staDeviceA;\n    NetDeviceContainer staDeviceB;\n    NetDeviceContainer staDeviceC;\n    NetDeviceContainer staDeviceD;\n    NetDeviceContainer apDeviceA;\n    NetDeviceContainer apDeviceB;\n    NetDeviceContainer apDeviceC;\n    NetDeviceContainer apDeviceD;\n    Ssid ssid;\n\n    // Network A\n    ssid = Ssid(\"network-A\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{36, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    staDeviceA = wifi.Install(phy, mac, wifiStaNodes.Get(0));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    // Modify EDCA configuration (TXOP limit) for AC_BE\n    mac.SetEdca(AC_BE, \"TxopLimits\", StringValue(std::to_string(txopLimit) + \"us\"));\n    apDeviceA = wifi.Install(phy, mac, wifiApNodes.Get(0));\n\n    // Modify EDCA configuration (TXOP limit) for AC_BE\n    Ptr<NetDevice> dev = wifiApNodes.Get(0)->GetDevice(0);\n    Ptr<WifiNetDevice> wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    PointerValue ptr;\n    Ptr<QosTxop> edca;\n    wifi_dev->GetMac()->GetAttribute(\"BE_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n\n    // Trace TXOP duration for BE on AP A\n    TxopDurationTracer netA;\n    edca->TraceConnectWithoutContext(\"TxopTrace\", MakeCallback(&TxopDurationTracer::Trace, &netA));\n\n    // Network B\n    ssid = Ssid(\"network-B\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{40, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    staDeviceB = wifi.Install(phy, mac, wifiStaNodes.Get(1));\n\n    // Disable A-MPDU\n    dev = wifiStaNodes.Get(1)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    // Modify EDCA configuration (TXOP limit) for AC_BE\n    mac.SetEdca(AC_BE, \"TxopLimits\", StringValue(std::to_string(txopLimit) + \"us\"));\n    apDeviceB = wifi.Install(phy, mac, wifiApNodes.Get(1));\n\n    // Disable A-MPDU\n    dev = wifiApNodes.Get(1)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n\n    wifi_dev->GetMac()->GetAttribute(\"BE_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n\n    // Trace TXOP duration for BE on AP B\n    TxopDurationTracer netB;\n    edca->TraceConnectWithoutContext(\"TxopTrace\", MakeCallback(&TxopDurationTracer::Trace, &netB));\n\n    // Network C\n    ssid = Ssid(\"network-C\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{44, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    staDeviceC = wifi.Install(phy, mac, wifiStaNodes.Get(2));\n\n    // Disable A-MPDU and enable A-MSDU with the highest maximum size allowed by the standard (7935\n    // bytes)\n    dev = wifiStaNodes.Get(2)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(7935));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    // Modify EDCA configuration (TXOP limit) for AC_BE\n    mac.SetEdca(AC_BE, \"TxopLimits\", StringValue(std::to_string(txopLimit) + \"us\"));\n    apDeviceC = wifi.Install(phy, mac, wifiApNodes.Get(2));\n\n    // Disable A-MPDU and enable A-MSDU with the highest maximum size allowed by the standard (7935\n    // bytes)\n    dev = wifiApNodes.Get(2)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(0));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(7935));\n\n    wifi_dev->GetMac()->GetAttribute(\"BE_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n\n    // Trace TXOP duration for BE on AP C\n    TxopDurationTracer netC;\n    edca->TraceConnectWithoutContext(\"TxopTrace\", MakeCallback(&TxopDurationTracer::Trace, &netC));\n\n    // Network D\n    ssid = Ssid(\"network-D\");\n    phy.Set(\"ChannelSettings\", StringValue(\"{48, 0, BAND_5GHZ, 0}\"));\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    staDeviceD = wifi.Install(phy, mac, wifiStaNodes.Get(3));\n\n    // Enable A-MPDU with a smaller size than the default one and\n    // enable A-MSDU with the smallest maximum size allowed by the standard (3839 bytes)\n    dev = wifiStaNodes.Get(3)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(32768));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(3839));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\",\n                SsidValue(ssid),\n                \"EnableBeaconJitter\",\n                BooleanValue(false));\n    // Modify EDCA configuration (TXOP limit) for AC_BE\n    mac.SetEdca(AC_BE, \"TxopLimits\", StringValue(std::to_string(txopLimit) + \"us\"));\n    apDeviceD = wifi.Install(phy, mac, wifiApNodes.Get(3));\n\n    // Enable A-MPDU with a smaller size than the default one and\n    // enable A-MSDU with the smallest maximum size allowed by the standard (3839 bytes)\n    dev = wifiApNodes.Get(3)->GetDevice(0);\n    wifi_dev = DynamicCast<WifiNetDevice>(dev);\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmpduSize\", UintegerValue(32768));\n    wifi_dev->GetMac()->SetAttribute(\"BE_MaxAmsduSize\", UintegerValue(3839));\n\n    wifi_dev->GetMac()->GetAttribute(\"BE_Txop\", ptr);\n    edca = ptr.Get<QosTxop>();\n\n    // Trace TXOP duration for BE on AP D\n    TxopDurationTracer netD;\n    edca->TraceConnectWithoutContext(\"TxopTrace\", MakeCallback(&TxopDurationTracer::Trace, &netD));\n\n    // Setting mobility model\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n    // Set position for APs\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(10.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(20.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(30.0, 0.0, 0.0));\n    // Set position for STAs\n    positionAlloc->Add(Vector(distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(10 + distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(20 + distance, 0.0, 0.0));\n    positionAlloc->Add(Vector(30 + distance, 0.0, 0.0));\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(wifiApNodes);\n    mobility.Install(wifiStaNodes);\n\n    // Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNodes);\n    stack.Install(wifiStaNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceA;\n    StaInterfaceA = address.Assign(staDeviceA);\n    Ipv4InterfaceContainer ApInterfaceA;\n    ApInterfaceA = address.Assign(apDeviceA);\n\n    address.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceB;\n    StaInterfaceB = address.Assign(staDeviceB);\n    Ipv4InterfaceContainer ApInterfaceB;\n    ApInterfaceB = address.Assign(apDeviceB);\n\n    address.SetBase(\"192.168.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceC;\n    StaInterfaceC = address.Assign(staDeviceC);\n    Ipv4InterfaceContainer ApInterfaceC;\n    ApInterfaceC = address.Assign(apDeviceC);\n\n    address.SetBase(\"192.168.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer StaInterfaceD;\n    StaInterfaceD = address.Assign(staDeviceD);\n    Ipv4InterfaceContainer ApInterfaceD;\n    ApInterfaceD = address.Assign(apDeviceD);\n\n    // Setting applications\n    uint16_t port = 9;\n    UdpServerHelper serverA(port);\n    ApplicationContainer serverAppA = serverA.Install(wifiStaNodes.Get(0));\n    serverAppA.Start(Seconds(0.0));\n    serverAppA.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientA(StaInterfaceA.GetAddress(0), port);\n    clientA.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientA.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientA.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppA = clientA.Install(wifiApNodes.Get(0));\n    clientAppA.Start(Seconds(1.0));\n    clientAppA.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverB(port);\n    ApplicationContainer serverAppB = serverB.Install(wifiStaNodes.Get(1));\n    serverAppB.Start(Seconds(0.0));\n    serverAppB.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientB(StaInterfaceB.GetAddress(0), port);\n    clientB.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientB.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientB.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppB = clientB.Install(wifiApNodes.Get(1));\n    clientAppB.Start(Seconds(1.0));\n    clientAppB.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverC(port);\n    ApplicationContainer serverAppC = serverC.Install(wifiStaNodes.Get(2));\n    serverAppC.Start(Seconds(0.0));\n    serverAppC.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientC(StaInterfaceC.GetAddress(0), port);\n    clientC.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientC.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientC.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppC = clientC.Install(wifiApNodes.Get(2));\n    clientAppC.Start(Seconds(1.0));\n    clientAppC.Stop(simulationTime + Seconds(1.0));\n\n    UdpServerHelper serverD(port);\n    ApplicationContainer serverAppD = serverD.Install(wifiStaNodes.Get(3));\n    serverAppD.Start(Seconds(0.0));\n    serverAppD.Stop(simulationTime + Seconds(1.0));\n\n    UdpClientHelper clientD(StaInterfaceD.GetAddress(0), port);\n    clientD.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n    clientD.SetAttribute(\"Interval\", TimeValue(Time(\"0.0001\"))); // packets/s\n    clientD.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n\n    ApplicationContainer clientAppD = clientD.Install(wifiApNodes.Get(3));\n    clientAppD.Start(Seconds(1.0));\n    clientAppD.Stop(simulationTime + Seconds(1.0));\n\n    if (enablePcap)\n    {\n        phy.EnablePcap(\"AP_A\", apDeviceA.Get(0));\n        phy.EnablePcap(\"STA_A\", staDeviceA.Get(0));\n        phy.EnablePcap(\"AP_B\", apDeviceB.Get(0));\n        phy.EnablePcap(\"STA_B\", staDeviceB.Get(0));\n        phy.EnablePcap(\"AP_C\", apDeviceC.Get(0));\n        phy.EnablePcap(\"STA_C\", staDeviceC.Get(0));\n        phy.EnablePcap(\"AP_D\", apDeviceD.Get(0));\n        phy.EnablePcap(\"STA_D\", staDeviceD.Get(0));\n    }\n\n    Simulator::Stop(simulationTime + Seconds(1.0));\n    Simulator::Run();\n\n    // Show results\n    double totalPacketsThroughA = DynamicCast<UdpServer>(serverAppA.Get(0))->GetReceived();\n    double totalPacketsThroughB = DynamicCast<UdpServer>(serverAppB.Get(0))->GetReceived();\n    double totalPacketsThroughC = DynamicCast<UdpServer>(serverAppC.Get(0))->GetReceived();\n    double totalPacketsThroughD = DynamicCast<UdpServer>(serverAppD.Get(0))->GetReceived();\n\n    Simulator::Destroy();\n\n    auto throughput = totalPacketsThroughA * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Default configuration (A-MPDU aggregation enabled, 65kB): \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 57.5 || throughput > 58.5))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    if (txopLimit)\n    {\n        std::cout << \"  Maximum TXOP duration (TXOP limit = \" << txopLimit\n                  << \"us): \" << netA.m_max.GetMicroSeconds() << \" us\" << '\\n';\n        if (verifyResults && txopLimit &&\n            (netA.m_max < MicroSeconds(3350) || netA.m_max > MicroSeconds(3520)))\n        {\n            NS_LOG_ERROR(\"Maximum TXOP duration \" << netA.m_max\n                                                  << \" is not in the expected boundaries!\");\n            exit(1);\n        }\n    }\n\n    throughput = totalPacketsThroughB * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"Aggregation disabled: \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 38 || throughput > 39))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    if (txopLimit)\n    {\n        std::cout << \"  Maximum TXOP duration (TXOP limit = \" << txopLimit\n                  << \"us): \" << netB.m_max.GetMicroSeconds() << \" us\" << '\\n';\n        if (verifyResults && (netB.m_max < MicroSeconds(3350) || netB.m_max > MicroSeconds(3520)))\n        {\n            NS_LOG_ERROR(\"Maximum TXOP duration \" << netB.m_max\n                                                  << \" is not in the expected boundaries!\");\n            exit(1);\n        }\n    }\n\n    throughput = totalPacketsThroughC * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"A-MPDU disabled and A-MSDU enabled (8kB): \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 52 || throughput > 53))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    if (txopLimit)\n    {\n        std::cout << \"  Maximum TXOP duration (TXOP limit = \" << txopLimit\n                  << \"us): \" << netC.m_max.GetMicroSeconds() << \" us\" << '\\n';\n        if (verifyResults && (netC.m_max < MicroSeconds(3350) || netC.m_max > MicroSeconds(3520)))\n        {\n            NS_LOG_ERROR(\"Maximum TXOP duration \" << netC.m_max\n                                                  << \" is not in the expected boundaries!\");\n            exit(1);\n        }\n    }\n\n    throughput = totalPacketsThroughD * payloadSize * 8 / simulationTime.GetMicroSeconds();\n    std::cout << \"A-MPDU enabled (32kB) and A-MSDU enabled (4kB): \" << '\\n'\n              << \"  Throughput = \" << throughput << \" Mbit/s\" << '\\n';\n    if (verifyResults && (throughput < 58 || throughput > 59))\n    {\n        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not in the expected boundaries!\");\n        exit(1);\n    }\n    if (txopLimit)\n    {\n        std::cout << \"  Maximum TXOP duration (TXOP limit = \" << txopLimit\n                  << \"us): \" << netD.m_max.GetMicroSeconds() << \" us\" << '\\n';\n        if (verifyResults && txopLimit &&\n            (netD.m_max < MicroSeconds(3350) || netD.m_max > MicroSeconds(3520)))\n        {\n            NS_LOG_ERROR(\"Maximum TXOP duration \" << netD.m_max\n                                                  << \" is not in the expected boundaries!\");\n            exit(1);\n        }\n    }\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a program in C++ using the ns-3 network simulator that configures an IEEE 802.11ac Wi-Fi network with options for UDP or TCP traffic, RTS/CTS, 80+80 MHz channel width, different modulation and coding schemes (MCS 0-9), various channel widths (20, 40, 80, 160 MHz), and guard intervals (short or long). The program should simulate a simple network with one station and one access point (STA-AP), allow customization of distance between the nodes, and output the goodput (throughput) for every combination of the parameters. Include necessary ns-3 headers and use appropriate helper classes such as `SpectrumWifiPhy`, `YansWifiPhy`, `UdpClientHelper`, `UdpServerHelper`, `OnOffHelper`, `PacketSinkHelper`, and others to simulate the network and applications."}, {"role": "assistant", "content": "#include \"ns3/boolean.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/config.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/log.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/multi-model-spectrum-channel.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-sink-helper.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/spectrum-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/udp-client-server-helper.h\"\n#include \"ns3/udp-server.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/vht-phy.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n// This is a simple example in order to show how to configure an IEEE 802.11ac Wi-Fi network.\n//\n// It outputs the UDP or TCP goodput for every VHT MCS value, which depends on the MCS value (0 to\n// 9, where 9 is forbidden when the channel width is 20 MHz), the channel width (20, 40, 80 or 160\n// MHz) and the guard interval (long or short). The PHY bitrate is constant over all the simulation\n// run. The user can also specify the distance between the access point and the station: the larger\n// the distance the smaller the goodput.\n//\n// The simulation assumes a single station in an infrastructure network:\n//\n//  STA     AP\n//    *     *\n//    |     |\n//   n1     n2\n//\n// Packets in this simulation belong to BestEffort Access Class (AC_BE).\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"vht-wifi-network\");\n\nint\nmain(int argc, char* argv[])\n{\n    bool udp{true};\n    bool useRts{false};\n    bool use80Plus80{false};\n    Time simulationTime{\"10s\"};\n    meter_u distance{1.0};\n    int mcs{-1}; // -1 indicates an unset value\n    std::string phyModel{\"Yans\"};\n    double minExpectedThroughput{0.0};\n    double maxExpectedThroughput{0.0};\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"distance\",\n                 \"Distance in meters between the station and the access point\",\n                 distance);\n    cmd.AddValue(\"simulationTime\", \"Simulation time\", simulationTime);\n    cmd.AddValue(\"udp\", \"UDP if set to 1, TCP otherwise\", udp);\n    cmd.AddValue(\"useRts\", \"Enable/disable RTS/CTS\", useRts);\n    cmd.AddValue(\"use80Plus80\", \"Enable/disable use of 80+80 MHz\", use80Plus80);\n    cmd.AddValue(\"mcs\", \"if set, limit testing to a specific MCS (0-9)\", mcs);\n    cmd.AddValue(\"phyModel\",\n                 \"PHY model to use (Yans or Spectrum). If 80+80 MHz is enabled, then Spectrum is \"\n                 \"automatically selected\",\n                 phyModel);\n    cmd.AddValue(\"minExpectedThroughput\",\n                 \"if set, simulation fails if the lowest throughput is below this value\",\n                 minExpectedThroughput);\n    cmd.AddValue(\"maxExpectedThroughput\",\n                 \"if set, simulation fails if the highest throughput is above this value\",\n                 maxExpectedThroughput);\n    cmd.Parse(argc, argv);\n\n    if (phyModel != \"Yans\" && phyModel != \"Spectrum\")\n    {\n        NS_ABORT_MSG(\"Invalid PHY model (must be Yans or Spectrum)\");\n    }\n    if (use80Plus80)\n    {\n        // SpectrumWifiPhy is required for 80+80 MHz\n        phyModel = \"Spectrum\";\n    }\n\n    if (useRts)\n    {\n        Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"0\"));\n    }\n\n    double prevThroughput[8] = {0};\n\n    std::cout << \"MCS value\"\n              << \"\\t\\t\"\n              << \"Channel width\"\n              << \"\\t\\t\"\n              << \"short GI\"\n              << \"\\t\\t\"\n              << \"Throughput\" << '\\n';\n    int minMcs = 0;\n    int maxMcs = 9;\n    if (mcs >= 0 && mcs <= 9)\n    {\n        minMcs = mcs;\n        maxMcs = mcs;\n    }\n    for (int mcs = minMcs; mcs <= maxMcs; mcs++)\n    {\n        uint8_t index = 0;\n        double previous = 0;\n        for (int channelWidth = 20; channelWidth <= 160;)\n        {\n            if (mcs == 9 && channelWidth == 20)\n            {\n                channelWidth *= 2;\n                continue;\n            }\n            const auto is80Plus80 = (use80Plus80 && (channelWidth == 160));\n            const std::string widthStr = is80Plus80 ? \"80+80\" : std::to_string(channelWidth);\n            const auto segmentWidthStr = is80Plus80 ? \"80\" : widthStr;\n            for (auto sgi : {false, true})\n            {\n                uint32_t payloadSize; // 1500 byte IP packet\n                if (udp)\n                {\n                    payloadSize = 1472; // bytes\n                }\n                else\n                {\n                    payloadSize = 1448; // bytes\n                    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n                }\n\n                NodeContainer wifiStaNode;\n                wifiStaNode.Create(1);\n                NodeContainer wifiApNode;\n                wifiApNode.Create(1);\n\n                NetDeviceContainer apDevice;\n                NetDeviceContainer staDevice;\n                WifiMacHelper mac;\n                WifiHelper wifi;\n                std::string channelStr{\"{0, \" + segmentWidthStr + \", BAND_5GHZ, 0}\"};\n\n                std::ostringstream ossControlMode;\n                auto nonHtRefRateMbps = VhtPhy::GetNonHtReferenceRate(mcs) / 1e6;\n                ossControlMode << \"OfdmRate\" << nonHtRefRateMbps << \"Mbps\";\n\n                std::ostringstream ossDataMode;\n                ossDataMode << \"VhtMcs\" << mcs;\n\n                if (is80Plus80)\n                {\n                    channelStr += std::string(\";\") + channelStr;\n                }\n\n                wifi.SetStandard(WIFI_STANDARD_80211ac);\n                wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                             \"DataMode\",\n                                             StringValue(ossDataMode.str()),\n                                             \"ControlMode\",\n                                             StringValue(ossControlMode.str()));\n\n                // Set guard interval\n                wifi.ConfigHtOptions(\"ShortGuardIntervalSupported\", BooleanValue(sgi));\n\n                Ssid ssid = Ssid(\"ns3-80211ac\");\n\n                if (phyModel == \"Spectrum\")\n                {\n                    auto spectrumChannel = CreateObject<MultiModelSpectrumChannel>();\n                    auto lossModel = CreateObject<LogDistancePropagationLossModel>();\n                    spectrumChannel->AddPropagationLossModel(lossModel);\n\n                    SpectrumWifiPhyHelper phy;\n                    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n                    phy.SetChannel(spectrumChannel);\n\n                    phy.Set(\"ChannelSettings\",\n                            StringValue(\"{0, \" + std::to_string(channelWidth) + \", BAND_5GHZ, 0}\"));\n\n                    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n                    staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n                    mac.SetType(\"ns3::ApWifiMac\",\n                                \"EnableBeaconJitter\",\n                                BooleanValue(false),\n                                \"Ssid\",\n                                SsidValue(ssid));\n                    apDevice = wifi.Install(phy, mac, wifiApNode);\n                }\n                else\n                {\n                    auto channel = YansWifiChannelHelper::Default();\n                    YansWifiPhyHelper phy;\n                    phy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n                    phy.SetChannel(channel.Create());\n\n                    phy.Set(\"ChannelSettings\",\n                            StringValue(\"{0, \" + std::to_string(channelWidth) + \", BAND_5GHZ, 0}\"));\n\n                    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n                    staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n                    mac.SetType(\"ns3::ApWifiMac\",\n                                \"EnableBeaconJitter\",\n                                BooleanValue(false),\n                                \"Ssid\",\n                                SsidValue(ssid));\n                    apDevice = wifi.Install(phy, mac, wifiApNode);\n                }\n\n                int64_t streamNumber = 150;\n                streamNumber += WifiHelper::AssignStreams(apDevice, streamNumber);\n                streamNumber += WifiHelper::AssignStreams(staDevice, streamNumber);\n\n                // mobility.\n                MobilityHelper mobility;\n                Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n\n                positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n                positionAlloc->Add(Vector(distance, 0.0, 0.0));\n                mobility.SetPositionAllocator(positionAlloc);\n\n                mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n\n                mobility.Install(wifiApNode);\n                mobility.Install(wifiStaNode);\n\n                /* Internet stack*/\n                InternetStackHelper stack;\n                stack.Install(wifiApNode);\n                stack.Install(wifiStaNode);\n                streamNumber += stack.AssignStreams(wifiApNode, streamNumber);\n                streamNumber += stack.AssignStreams(wifiStaNode, streamNumber);\n\n                Ipv4AddressHelper address;\n                address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n                Ipv4InterfaceContainer staNodeInterface;\n                Ipv4InterfaceContainer apNodeInterface;\n\n                staNodeInterface = address.Assign(staDevice);\n                apNodeInterface = address.Assign(apDevice);\n\n                /* Setting applications */\n                const auto maxLoad =\n                    VhtPhy::GetDataRate(mcs, channelWidth, NanoSeconds(sgi ? 400 : 800), 1);\n                ApplicationContainer serverApp;\n                if (udp)\n                {\n                    // UDP flow\n                    uint16_t port = 9;\n                    UdpServerHelper server(port);\n                    serverApp = server.Install(wifiStaNode.Get(0));\n                    streamNumber += server.AssignStreams(wifiStaNode.Get(0), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n                    const auto packetInterval = payloadSize * 8.0 / maxLoad;\n\n                    UdpClientHelper client(staNodeInterface.GetAddress(0), port);\n                    client.SetAttribute(\"MaxPackets\", UintegerValue(4294967295U));\n                    client.SetAttribute(\"Interval\", TimeValue(Seconds(packetInterval)));\n                    client.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                    ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n                    streamNumber += client.AssignStreams(wifiApNode.Get(0), streamNumber);\n\n                    clientApp.Start(Seconds(1.0));\n                    clientApp.Stop(simulationTime + Seconds(1.0));\n                }\n                else\n                {\n                    // TCP flow\n                    uint16_t port = 50000;\n                    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n                    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n                    serverApp = packetSinkHelper.Install(wifiStaNode.Get(0));\n                    streamNumber +=\n                        packetSinkHelper.AssignStreams(wifiStaNode.Get(0), streamNumber);\n\n                    serverApp.Start(Seconds(0.0));\n                    serverApp.Stop(simulationTime + Seconds(1.0));\n\n                    OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n                    onoff.SetAttribute(\"OnTime\",\n                                       StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n                    onoff.SetAttribute(\"OffTime\",\n                                       StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n                    onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n                    onoff.SetAttribute(\"DataRate\", DataRateValue(maxLoad));\n                    AddressValue remoteAddress(\n                        InetSocketAddress(staNodeInterface.GetAddress(0), port));\n                    onoff.SetAttribute(\"Remote\", remoteAddress);\n                    ApplicationContainer clientApp = onoff.Install(wifiApNode.Get(0));\n                    streamNumber += onoff.AssignStreams(wifiApNode.Get(0), streamNumber);\n\n                    clientApp.Start(Seconds(1.0));\n                    clientApp.Stop(simulationTime + Seconds(1.0));\n                }\n\n                Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n                Simulator::Stop(simulationTime + Seconds(1.0));\n                Simulator::Run();\n\n                auto rxBytes = 0.0;\n                if (udp)\n                {\n                    rxBytes = payloadSize * DynamicCast<UdpServer>(serverApp.Get(0))->GetReceived();\n                }\n                else\n                {\n                    rxBytes = DynamicCast<PacketSink>(serverApp.Get(0))->GetTotalRx();\n                }\n                auto throughput = (rxBytes * 8) / simulationTime.GetMicroSeconds(); // Mbit/s\n\n                Simulator::Destroy();\n\n                std::cout << +mcs << \"\\t\\t\\t\" << widthStr << \" MHz\\t\\t\"\n                          << (widthStr.size() > 3 ? \"\" : \"\\t\") << (sgi ? \"400 ns\" : \"800 ns\")\n                          << \"\\t\\t\\t\" << throughput << \" Mbit/s\" << std::endl;\n\n                // test first element\n                if (mcs == minMcs && channelWidth == 20 && !sgi)\n                {\n                    if (throughput < minExpectedThroughput)\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                }\n                // test last element\n                if (mcs == maxMcs && channelWidth == 160 && sgi)\n                {\n                    if (maxExpectedThroughput > 0 && throughput > maxExpectedThroughput)\n                    {\n                        NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                        exit(1);\n                    }\n                }\n                // test previous throughput is smaller (for the same mcs)\n                if (throughput > previous)\n                {\n                    previous = throughput;\n                }\n                else\n                {\n                    NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                    exit(1);\n                }\n                // test previous throughput is smaller (for the same channel width and GI)\n                if (throughput > prevThroughput[index])\n                {\n                    prevThroughput[index] = throughput;\n                }\n                else\n                {\n                    NS_LOG_ERROR(\"Obtained throughput \" << throughput << \" is not expected!\");\n                    exit(1);\n                }\n                index++;\n            }\n            channelWidth *= 2;\n        }\n    }\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\n// Default network topology includes some number of AP nodes specified by\n// the variable nWifis (defaults to two).  Off of each AP node, there are some\n// number of STA nodes specified by the variable nStas (defaults to two).\n// Each AP talks to its associated STA nodes.  There are bridge net devices\n// on each AP node that bridge the whole thing into one network.\n//\n//      +-----+      +-----+            +-----+      +-----+\n//      | STA |      | STA |            | STA |      | STA |\n//      +-----+      +-----+            +-----+      +-----+\n//    192.168.0.2  192.168.0.3        192.168.0.5  192.168.0.6\n//      --------     --------           --------     --------\n//      WIFI STA     WIFI STA           WIFI STA     WIFI STA\n//      --------     --------           --------     --------\n//        ((*))       ((*))       |      ((*))        ((*))\n//                                |\n//              ((*))             |             ((*))\n//             -------                         -------\n//             WIFI AP   CSMA ========= CSMA   WIFI AP\n//             -------   ----           ----   -------\n//             ##############           ##############\n//                 BRIDGE                   BRIDGE\n//             ##############           ##############\n//               192.168.0.1              192.168.0.4\n//               +---------+              +---------+\n//               | AP Node |              | AP Node |\n//               +---------+              +---------+\n\n#include \"ns3/bridge-helper.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/csma-helper.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-socket-address.h\"\n#include \"ns3/rectangle.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t nWifis = 2;\n    uint32_t nStas = 2;\n    bool sendIp = true;\n    bool writeMobility = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nWifis\", \"Number of wifi networks\", nWifis);\n    cmd.AddValue(\"nStas\", \"Number of stations per wifi network\", nStas);\n    cmd.AddValue(\"SendIp\", \"Send Ipv4 or raw packets\", sendIp);\n    cmd.AddValue(\"writeMobility\", \"Write mobility trace\", writeMobility);\n    cmd.Parse(argc, argv);\n\n    NodeContainer backboneNodes;\n    NetDeviceContainer backboneDevices;\n    Ipv4InterfaceContainer backboneInterfaces;\n    std::vector<NodeContainer> staNodes;\n    std::vector<NetDeviceContainer> staDevices;\n    std::vector<NetDeviceContainer> apDevices;\n    std::vector<Ipv4InterfaceContainer> staInterfaces;\n    std::vector<Ipv4InterfaceContainer> apInterfaces;\n\n    InternetStackHelper stack;\n    CsmaHelper csma;\n    Ipv4AddressHelper ip;\n    ip.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n\n    backboneNodes.Create(nWifis);\n    stack.Install(backboneNodes);\n\n    backboneDevices = csma.Install(backboneNodes);\n\n    meter_u wifiX = 0.0;\n\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    for (uint32_t i = 0; i < nWifis; ++i)\n    {\n        // calculate ssid for wifi subnetwork\n        std::ostringstream oss;\n        oss << \"wifi-default-\" << i;\n        Ssid ssid = Ssid(oss.str());\n\n        NodeContainer sta;\n        NetDeviceContainer staDev;\n        NetDeviceContainer apDev;\n        Ipv4InterfaceContainer staInterface;\n        Ipv4InterfaceContainer apInterface;\n        MobilityHelper mobility;\n        BridgeHelper bridge;\n        WifiHelper wifi;\n        WifiMacHelper wifiMac;\n        YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n        wifiPhy.SetChannel(wifiChannel.Create());\n\n        sta.Create(nStas);\n        mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                      \"MinX\",\n                                      DoubleValue(wifiX),\n                                      \"MinY\",\n                                      DoubleValue(0.0),\n                                      \"DeltaX\",\n                                      DoubleValue(5.0),\n                                      \"DeltaY\",\n                                      DoubleValue(5.0),\n                                      \"GridWidth\",\n                                      UintegerValue(1),\n                                      \"LayoutType\",\n                                      StringValue(\"RowFirst\"));\n\n        // setup the AP.\n        mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n        mobility.Install(backboneNodes.Get(i));\n        wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n        apDev = wifi.Install(wifiPhy, wifiMac, backboneNodes.Get(i));\n\n        NetDeviceContainer bridgeDev;\n        bridgeDev =\n            bridge.Install(backboneNodes.Get(i), NetDeviceContainer(apDev, backboneDevices.Get(i)));\n\n        // assign AP IP address to bridge, not wifi\n        apInterface = ip.Assign(bridgeDev);\n\n        // setup the STAs\n        stack.Install(sta);\n        mobility.SetMobilityModel(\n            \"ns3::RandomWalk2dMobilityModel\",\n            \"Mode\",\n            StringValue(\"Time\"),\n            \"Time\",\n            StringValue(\"2s\"),\n            \"Speed\",\n            StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"),\n            \"Bounds\",\n            RectangleValue(Rectangle(wifiX, wifiX + 5.0, 0.0, (nStas + 1) * 5.0)));\n        mobility.Install(sta);\n        wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n        staDev = wifi.Install(wifiPhy, wifiMac, sta);\n        staInterface = ip.Assign(staDev);\n\n        // save everything in containers.\n        staNodes.push_back(sta);\n        apDevices.push_back(apDev);\n        apInterfaces.push_back(apInterface);\n        staDevices.push_back(staDev);\n        staInterfaces.push_back(staInterface);\n\n        wifiX += 20.0;\n    }\n\n    Address dest;\n    std::string protocol;\n    if (sendIp)\n    {\n        dest = InetSocketAddress(staInterfaces[1].GetAddress(1), 1025);\n        protocol = \"ns3::UdpSocketFactory\";\n    }\n    else\n    {\n        PacketSocketAddress tmp;\n        tmp.SetSingleDevice(staDevices[0].Get(0)->GetIfIndex());\n        tmp.SetPhysicalAddress(staDevices[1].Get(0)->GetAddress());\n        tmp.SetProtocol(0x807);\n        dest = tmp;\n        protocol = \"ns3::PacketSocketFactory\";\n    }\n\n    OnOffHelper onoff = OnOffHelper(protocol, dest);\n    onoff.SetConstantRate(DataRate(\"500kb/s\"));\n    ApplicationContainer apps = onoff.Install(staNodes[0].Get(0));\n    apps.Start(Seconds(0.5));\n    apps.Stop(Seconds(3.0));\n\n    wifiPhy.EnablePcap(\"wifi-wired-bridging\", apDevices[0]);\n    wifiPhy.EnablePcap(\"wifi-wired-bridging\", apDevices[1]);\n\n    if (writeMobility)\n    {\n        AsciiTraceHelper ascii;\n        MobilityHelper::EnableAsciiAll(ascii.CreateFileStream(\"wifi-wired-bridging.mob\"));\n    }\n\n    Simulator::Stop(Seconds(5.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}, {"role": "assistant", "content": "// Default network topology includes some number of AP nodes specified by\n// the variable nWifis (defaults to two).  Off of each AP node, there are some\n// number of STA nodes specified by the variable nStas (defaults to two).\n// Each AP talks to its associated STA nodes.  There are bridge net devices\n// on each AP node that bridge the whole thing into one network.\n//\n//      +-----+      +-----+            +-----+      +-----+\n//      | STA |      | STA |            | STA |      | STA |\n//      +-----+      +-----+            +-----+      +-----+\n//    192.168.0.2  192.168.0.3        192.168.0.5  192.168.0.6\n//      --------     --------           --------     --------\n//      WIFI STA     WIFI STA           WIFI STA     WIFI STA\n//      --------     --------           --------     --------\n//        ((*))       ((*))       |      ((*))        ((*))\n//                                |\n//              ((*))             |             ((*))\n//             -------                         -------\n//             WIFI AP   CSMA ========= CSMA   WIFI AP\n//             -------   ----           ----   -------\n//             ##############           ##############\n//                 BRIDGE                   BRIDGE\n//             ##############           ##############\n//               192.168.0.1              192.168.0.4\n//               +---------+              +---------+\n//               | AP Node |              | AP Node |\n//               +---------+              +---------+\n\n#include \"ns3/bridge-helper.h\"\n#include \"ns3/command-line.h\"\n#include \"ns3/csma-helper.h\"\n#include \"ns3/double.h\"\n#include \"ns3/internet-stack-helper.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/mobility-helper.h\"\n#include \"ns3/on-off-helper.h\"\n#include \"ns3/packet-socket-address.h\"\n#include \"ns3/rectangle.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/string.h\"\n#include \"ns3/uinteger.h\"\n#include \"ns3/yans-wifi-channel.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t nWifis = 2;\n    uint32_t nStas = 2;\n    bool sendIp = true;\n    bool writeMobility = false;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nWifis\", \"Number of wifi networks\", nWifis);\n    cmd.AddValue(\"nStas\", \"Number of stations per wifi network\", nStas);\n    cmd.AddValue(\"SendIp\", \"Send Ipv4 or raw packets\", sendIp);\n    cmd.AddValue(\"writeMobility\", \"Write mobility trace\", writeMobility);\n    cmd.Parse(argc, argv);\n\n    NodeContainer backboneNodes;\n    NetDeviceContainer backboneDevices;\n    Ipv4InterfaceContainer backboneInterfaces;\n    std::vector<NodeContainer> staNodes;\n    std::vector<NetDeviceContainer> staDevices;\n    std::vector<NetDeviceContainer> apDevices;\n    std::vector<Ipv4InterfaceContainer> staInterfaces;\n    std::vector<Ipv4InterfaceContainer> apInterfaces;\n\n    InternetStackHelper stack;\n    CsmaHelper csma;\n    Ipv4AddressHelper ip;\n    ip.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n\n    backboneNodes.Create(nWifis);\n    stack.Install(backboneNodes);\n\n    backboneDevices = csma.Install(backboneNodes);\n\n    meter_u wifiX = 0.0;\n\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.SetPcapDataLinkType(WifiPhyHelper::DLT_IEEE802_11_RADIO);\n\n    for (uint32_t i = 0; i < nWifis; ++i)\n    {\n        // calculate ssid for wifi subnetwork\n        std::ostringstream oss;\n        oss << \"wifi-default-\" << i;\n        Ssid ssid = Ssid(oss.str());\n\n        NodeContainer sta;\n        NetDeviceContainer staDev;\n        NetDeviceContainer apDev;\n        Ipv4InterfaceContainer staInterface;\n        Ipv4InterfaceContainer apInterface;\n        MobilityHelper mobility;\n        BridgeHelper bridge;\n        WifiHelper wifi;\n        WifiMacHelper wifiMac;\n        YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n        wifiPhy.SetChannel(wifiChannel.Create());\n\n        sta.Create(nStas);\n        mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                      \"MinX\",\n                                      DoubleValue(wifiX),\n                                      \"MinY\",\n                                      DoubleValue(0.0),\n                                      \"DeltaX\",\n                                      DoubleValue(5.0),\n                                      \"DeltaY\",\n                                      DoubleValue(5.0),\n                                      \"GridWidth\",\n                                      UintegerValue(1),\n                                      \"LayoutType\",\n                                      StringValue(\"RowFirst\"));\n\n        // setup the AP.\n        mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n        mobility.Install(backboneNodes.Get(i));\n        wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n        apDev = wifi.Install(wifiPhy, wifiMac, backboneNodes.Get(i));\n\n        NetDeviceContainer bridgeDev;\n        bridgeDev =\n            bridge.Install(backboneNodes.Get(i), NetDeviceContainer(apDev, backboneDevices.Get(i)));\n\n        // assign AP IP address to bridge, not wifi\n        apInterface = ip.Assign(bridgeDev);\n\n        // setup the STAs\n        stack.Install(sta);\n        mobility.SetMobilityModel(\n            \"ns3::RandomWalk2dMobilityModel\",\n            \"Mode\",\n            StringValue(\"Time\"),\n            \"Time\",\n            StringValue(\"2s\"),\n            \"Speed\",\n            StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"),\n            \"Bounds\",\n            RectangleValue(Rectangle(wifiX, wifiX + 5.0, 0.0, (nStas + 1) * 5.0)));\n        mobility.Install(sta);\n        wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n        staDev = wifi.Install(wifiPhy, wifiMac, sta);\n        staInterface = ip.Assign(staDev);\n\n        // save everything in containers.\n        staNodes.push_back(sta);\n        apDevices.push_back(apDev);\n        apInterfaces.push_back(apInterface);\n        staDevices.push_back(staDev);\n        staInterfaces.push_back(staInterface);\n\n        wifiX += 20.0;\n    }\n\n    Address dest;\n    std::string protocol;\n    if (sendIp)\n    {\n        dest = InetSocketAddress(staInterfaces[1].GetAddress(1), 1025);\n        protocol = \"ns3::UdpSocketFactory\";\n    }\n    else\n    {\n        PacketSocketAddress tmp;\n        tmp.SetSingleDevice(staDevices[0].Get(0)->GetIfIndex());\n        tmp.SetPhysicalAddress(staDevices[1].Get(0)->GetAddress());\n        tmp.SetProtocol(0x807);\n        dest = tmp;\n        protocol = \"ns3::PacketSocketFactory\";\n    }\n\n    OnOffHelper onoff = OnOffHelper(protocol, dest);\n    onoff.SetConstantRate(DataRate(\"500kb/s\"));\n    ApplicationContainer apps = onoff.Install(staNodes[0].Get(0));\n    apps.Start(Seconds(0.5));\n    apps.Stop(Seconds(3.0));\n\n    wifiPhy.EnablePcap(\"wifi-wired-bridging\", apDevices[0]);\n    wifiPhy.EnablePcap(\"wifi-wired-bridging\", apDevices[1]);\n\n    if (writeMobility)\n    {\n        AsciiTraceHelper ascii;\n        MobilityHelper::EnableAsciiAll(ascii.CreateFileStream(\"wifi-wired-bridging.mob\"));\n    }\n\n    Simulator::Stop(Seconds(5.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a program that simulates a network topology based on the description in Figure 17 of the paper \"Data Center TCP (DCTCP)\" by Mohammad Alizadeh et al. The topology should include two bottlenecks: the interface between switches T1 and T2 (30 senders over a 10 Gbps link) and the T2-R1 link (20 senders over a 1 Gbps link). Use RED queues configured for ECN marking at the bottlenecks. The program should stagger 40 TCP flows during a one-second startup window, and measure throughput during a one-second interval after a three-second convergence time. It should output throughput per flow, aggregate fairness, and queue statistics, as described."}, {"role": "assistant", "content": "// The network topology used in this example is based on Fig. 17 described in\n// Mohammad Alizadeh, Albert Greenberg, David A. Maltz, Jitendra Padhye,\n// Parveen Patel, Balaji Prabhakar, Sudipta Sengupta, and Murari Sridharan.\n// \"Data Center TCP (DCTCP).\" In ACM SIGCOMM Computer Communication Review,\n// Vol. 40, No. 4, pp. 63-74. ACM, 2010.\n\n// The topology is roughly as follows\n//\n//  S1         S3\n//  |           |  (1 Gbps)\n//  T1 ------- T2 -- R1\n//  |           |  (1 Gbps)\n//  S2         R2\n//\n// The link between switch T1 and T2 is 10 Gbps.  All other\n// links are 1 Gbps.  In the SIGCOMM paper, there is a Scorpion switch\n// between T1 and T2, but it doesn't contribute another bottleneck.\n//\n// S1 and S3 each have 10 senders sending to receiver R1 (20 total)\n// S2 (20 senders) sends traffic to R2 (20 receivers)\n//\n// This sets up two bottlenecks: 1) T1 -> T2 interface (30 senders\n// using the 10 Gbps link) and 2) T2 -> R1 (20 senders using 1 Gbps link)\n//\n// RED queues configured for ECN marking are used at the bottlenecks.\n//\n// Figure 17 published results are that each sender in S1 gets 46 Mbps\n// and each in S3 gets 54 Mbps, while each S2 sender gets 475 Mbps, and\n// that these are within 10% of their fair-share throughputs (Jain index\n// of 0.99).\n//\n// This program runs the program by default for five seconds.  The first\n// second is devoted to flow startup (all 40 TCP flows are stagger started\n// during this period).  There is a three second convergence time where\n// no measurement data is taken, and then there is a one second measurement\n// interval to gather raw throughput for each flow.  These time intervals\n// can be changed at the command line.\n//\n// The program outputs six files.  The first three:\n// * dctcp-example-s1-r1-throughput.dat\n// * dctcp-example-s2-r2-throughput.dat\n// * dctcp-example-s3-r1-throughput.dat\n// provide per-flow throughputs (in Mb/s) for each of the forty flows, summed\n// over the measurement window.  The fourth file,\n// * dctcp-example-fairness.dat\n// provides average throughputs for the three flow paths, and computes\n// Jain's fairness index for each flow group (i.e. across each group of\n// 10, 20, and 10 flows).  It also sums the throughputs across each bottleneck.\n// The fifth and sixth:\n// * dctcp-example-t1-length.dat\n// * dctcp-example-t2-length.dat\n// report on the bottleneck queue length (in packets and microseconds\n// of delay) at 10 ms intervals during the measurement window.\n//\n// By default, the throughput averages are 23 Mbps for S1 senders, 471 Mbps\n// for S2 senders, and 74 Mbps for S3 senders, and the Jain index is greater\n// than 0.99 for each group of flows.  The average queue delay is about 1ms\n// for the T2->R2 bottleneck, and about 200us for the T1->T2 bottleneck.\n//\n// The RED parameters (min_th and max_th) are set to the same values as\n// reported in the paper, but we observed that throughput distributions\n// and queue delays are very sensitive to these parameters, as was also\n// observed in the paper; it is likely that the paper's throughput results\n// could be achieved by further tuning of the RED parameters.  However,\n// the default results show that DCTCP is able to achieve high link\n// utilization and low queueing delay and fairness across competing flows\n// sharing the same path.\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <iomanip>\n#include <iostream>\n\nusing namespace ns3;\n\nstd::stringstream filePlotQueue1;\nstd::stringstream filePlotQueue2;\nstd::ofstream rxS1R1Throughput;\nstd::ofstream rxS2R2Throughput;\nstd::ofstream rxS3R1Throughput;\nstd::ofstream fairnessIndex;\nstd::ofstream t1QueueLength;\nstd::ofstream t2QueueLength;\nstd::vector<uint64_t> rxS1R1Bytes;\nstd::vector<uint64_t> rxS2R2Bytes;\nstd::vector<uint64_t> rxS3R1Bytes;\n\nvoid\nPrintProgress(Time interval)\n{\n    std::cout << \"Progress to \" << std::fixed << std::setprecision(1)\n              << Simulator::Now().GetSeconds() << \" seconds simulation time\" << std::endl;\n    Simulator::Schedule(interval, &PrintProgress, interval);\n}\n\nvoid\nTraceS1R1Sink(std::size_t index, Ptr<const Packet> p, const Address& a)\n{\n    rxS1R1Bytes[index] += p->GetSize();\n}\n\nvoid\nTraceS2R2Sink(std::size_t index, Ptr<const Packet> p, const Address& a)\n{\n    rxS2R2Bytes[index] += p->GetSize();\n}\n\nvoid\nTraceS3R1Sink(std::size_t index, Ptr<const Packet> p, const Address& a)\n{\n    rxS3R1Bytes[index] += p->GetSize();\n}\n\nvoid\nInitializeCounters()\n{\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        rxS1R1Bytes[i] = 0;\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        rxS2R2Bytes[i] = 0;\n    }\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        rxS3R1Bytes[i] = 0;\n    }\n}\n\nvoid\nPrintThroughput(Time measurementWindow)\n{\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        rxS1R1Throughput << measurementWindow.GetSeconds() << \"s \" << i << \" \"\n                         << (rxS1R1Bytes[i] * 8) / (measurementWindow.GetSeconds()) / 1e6\n                         << std::endl;\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        rxS2R2Throughput << Simulator::Now().GetSeconds() << \"s \" << i << \" \"\n                         << (rxS2R2Bytes[i] * 8) / (measurementWindow.GetSeconds()) / 1e6\n                         << std::endl;\n    }\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        rxS3R1Throughput << Simulator::Now().GetSeconds() << \"s \" << i << \" \"\n                         << (rxS3R1Bytes[i] * 8) / (measurementWindow.GetSeconds()) / 1e6\n                         << std::endl;\n    }\n}\n\n// Jain's fairness index:  https://en.wikipedia.org/wiki/Fairness_measure\nvoid\nPrintFairness(Time measurementWindow)\n{\n    double average = 0;\n    uint64_t sumSquares = 0;\n    uint64_t sum = 0;\n    double fairness = 0;\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        sum += rxS1R1Bytes[i];\n        sumSquares += (rxS1R1Bytes[i] * rxS1R1Bytes[i]);\n    }\n    average = ((sum / 10) * 8 / measurementWindow.GetSeconds()) / 1e6;\n    fairness = static_cast<double>(sum * sum) / (10 * sumSquares);\n    fairnessIndex << \"Average throughput for S1-R1 flows: \" << std::fixed << std::setprecision(2)\n                  << average << \" Mbps; fairness: \" << std::fixed << std::setprecision(3)\n                  << fairness << std::endl;\n    average = 0;\n    sumSquares = 0;\n    sum = 0;\n    fairness = 0;\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        sum += rxS2R2Bytes[i];\n        sumSquares += (rxS2R2Bytes[i] * rxS2R2Bytes[i]);\n    }\n    average = ((sum / 20) * 8 / measurementWindow.GetSeconds()) / 1e6;\n    fairness = static_cast<double>(sum * sum) / (20 * sumSquares);\n    fairnessIndex << \"Average throughput for S2-R2 flows: \" << std::fixed << std::setprecision(2)\n                  << average << \" Mbps; fairness: \" << std::fixed << std::setprecision(3)\n                  << fairness << std::endl;\n    average = 0;\n    sumSquares = 0;\n    sum = 0;\n    fairness = 0;\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        sum += rxS3R1Bytes[i];\n        sumSquares += (rxS3R1Bytes[i] * rxS3R1Bytes[i]);\n    }\n    average = ((sum / 10) * 8 / measurementWindow.GetSeconds()) / 1e6;\n    fairness = static_cast<double>(sum * sum) / (10 * sumSquares);\n    fairnessIndex << \"Average throughput for S3-R1 flows: \" << std::fixed << std::setprecision(2)\n                  << average << \" Mbps; fairness: \" << std::fixed << std::setprecision(3)\n                  << fairness << std::endl;\n    sum = 0;\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        sum += rxS1R1Bytes[i];\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        sum += rxS2R2Bytes[i];\n    }\n    fairnessIndex << \"Aggregate user-level throughput for flows through T1: \"\n                  << static_cast<double>(sum * 8) / 1e9 << \" Gbps\" << std::endl;\n    sum = 0;\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        sum += rxS3R1Bytes[i];\n    }\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        sum += rxS1R1Bytes[i];\n    }\n    fairnessIndex << \"Aggregate user-level throughput for flows to R1: \"\n                  << static_cast<double>(sum * 8) / 1e9 << \" Gbps\" << std::endl;\n}\n\nvoid\nCheckT1QueueSize(Ptr<QueueDisc> queue)\n{\n    // 1500 byte packets\n    uint32_t qSize = queue->GetNPackets();\n    Time backlog = Seconds(static_cast<double>(qSize * 1500 * 8) / 1e10); // 10 Gb/s\n    // report size in units of packets and ms\n    t1QueueLength << std::fixed << std::setprecision(2) << Simulator::Now().GetSeconds() << \" \"\n                  << qSize << \" \" << backlog.GetMicroSeconds() << std::endl;\n    // check queue size every 1/100 of a second\n    Simulator::Schedule(MilliSeconds(10), &CheckT1QueueSize, queue);\n}\n\nvoid\nCheckT2QueueSize(Ptr<QueueDisc> queue)\n{\n    uint32_t qSize = queue->GetNPackets();\n    Time backlog = Seconds(static_cast<double>(qSize * 1500 * 8) / 1e9); // 1 Gb/s\n    // report size in units of packets and ms\n    t2QueueLength << std::fixed << std::setprecision(2) << Simulator::Now().GetSeconds() << \" \"\n                  << qSize << \" \" << backlog.GetMicroSeconds() << std::endl;\n    // check queue size every 1/100 of a second\n    Simulator::Schedule(MilliSeconds(10), &CheckT2QueueSize, queue);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string outputFilePath = \".\";\n    std::string tcpTypeId = \"TcpDctcp\";\n    Time flowStartupWindow = Seconds(1);\n    Time convergenceTime = Seconds(3);\n    Time measurementWindow = Seconds(1);\n    bool enableSwitchEcn = true;\n    Time progressInterval = MilliSeconds(100);\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"tcpTypeId\", \"ns-3 TCP TypeId\", tcpTypeId);\n    cmd.AddValue(\"flowStartupWindow\",\n                 \"startup time window (TCP staggered starts)\",\n                 flowStartupWindow);\n    cmd.AddValue(\"convergenceTime\", \"convergence time\", convergenceTime);\n    cmd.AddValue(\"measurementWindow\", \"measurement window\", measurementWindow);\n    cmd.AddValue(\"enableSwitchEcn\", \"enable ECN at switches\", enableSwitchEcn);\n    cmd.Parse(argc, argv);\n\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\", StringValue(\"ns3::\" + tcpTypeId));\n\n    Time startTime = Seconds(0);\n    Time stopTime = flowStartupWindow + convergenceTime + measurementWindow;\n\n    rxS1R1Bytes.reserve(10);\n    rxS2R2Bytes.reserve(20);\n    rxS3R1Bytes.reserve(10);\n\n    NodeContainer S1;\n    NodeContainer S2;\n    NodeContainer S3;\n    NodeContainer R2;\n    Ptr<Node> T1 = CreateObject<Node>();\n    Ptr<Node> T2 = CreateObject<Node>();\n    Ptr<Node> R1 = CreateObject<Node>();\n    S1.Create(10);\n    S2.Create(20);\n    S3.Create(10);\n    R2.Create(20);\n\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(1448));\n    Config::SetDefault(\"ns3::TcpSocket::DelAckCount\", UintegerValue(2));\n    GlobalValue::Bind(\"ChecksumEnabled\", BooleanValue(false));\n\n    // Set default parameters for RED queue disc\n    Config::SetDefault(\"ns3::RedQueueDisc::UseEcn\", BooleanValue(enableSwitchEcn));\n    // ARED may be used but the queueing delays will increase; it is disabled\n    // here because the SIGCOMM paper did not mention it\n    // Config::SetDefault (\"ns3::RedQueueDisc::ARED\", BooleanValue (true));\n    // Config::SetDefault (\"ns3::RedQueueDisc::Gentle\", BooleanValue (true));\n    Config::SetDefault(\"ns3::RedQueueDisc::UseHardDrop\", BooleanValue(false));\n    Config::SetDefault(\"ns3::RedQueueDisc::MeanPktSize\", UintegerValue(1500));\n    // Triumph and Scorpion switches used in DCTCP Paper have 4 MB of buffer\n    // If every packet is 1500 bytes, 2666 packets can be stored in 4 MB\n    Config::SetDefault(\"ns3::RedQueueDisc::MaxSize\", QueueSizeValue(QueueSize(\"2666p\")));\n    // DCTCP tracks instantaneous queue length only; so set QW = 1\n    Config::SetDefault(\"ns3::RedQueueDisc::QW\", DoubleValue(1));\n    Config::SetDefault(\"ns3::RedQueueDisc::MinTh\", DoubleValue(20));\n    Config::SetDefault(\"ns3::RedQueueDisc::MaxTh\", DoubleValue(60));\n\n    PointToPointHelper pointToPointSR;\n    pointToPointSR.SetDeviceAttribute(\"DataRate\", StringValue(\"1Gbps\"));\n    pointToPointSR.SetChannelAttribute(\"Delay\", StringValue(\"10us\"));\n\n    PointToPointHelper pointToPointT;\n    pointToPointT.SetDeviceAttribute(\"DataRate\", StringValue(\"10Gbps\"));\n    pointToPointT.SetChannelAttribute(\"Delay\", StringValue(\"10us\"));\n\n    // Create a total of 62 links.\n    std::vector<NetDeviceContainer> S1T1;\n    S1T1.reserve(10);\n    std::vector<NetDeviceContainer> S2T1;\n    S2T1.reserve(20);\n    std::vector<NetDeviceContainer> S3T2;\n    S3T2.reserve(10);\n    std::vector<NetDeviceContainer> R2T2;\n    R2T2.reserve(20);\n    NetDeviceContainer T1T2 = pointToPointT.Install(T1, T2);\n    NetDeviceContainer R1T2 = pointToPointSR.Install(R1, T2);\n\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        Ptr<Node> n = S1.Get(i);\n        S1T1.push_back(pointToPointSR.Install(n, T1));\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        Ptr<Node> n = S2.Get(i);\n        S2T1.push_back(pointToPointSR.Install(n, T1));\n    }\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        Ptr<Node> n = S3.Get(i);\n        S3T2.push_back(pointToPointSR.Install(n, T2));\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        Ptr<Node> n = R2.Get(i);\n        R2T2.push_back(pointToPointSR.Install(n, T2));\n    }\n\n    InternetStackHelper stack;\n    stack.InstallAll();\n\n    TrafficControlHelper tchRed10;\n    // MinTh = 50, MaxTh = 150 recommended in ACM SIGCOMM 2010 DCTCP Paper\n    // This yields a target (MinTh) queue depth of 60us at 10 Gb/s\n    tchRed10.SetRootQueueDisc(\"ns3::RedQueueDisc\",\n                              \"LinkBandwidth\",\n                              StringValue(\"10Gbps\"),\n                              \"LinkDelay\",\n                              StringValue(\"10us\"),\n                              \"MinTh\",\n                              DoubleValue(50),\n                              \"MaxTh\",\n                              DoubleValue(150));\n    QueueDiscContainer queueDiscs1 = tchRed10.Install(T1T2);\n\n    TrafficControlHelper tchRed1;\n    // MinTh = 20, MaxTh = 60 recommended in ACM SIGCOMM 2010 DCTCP Paper\n    // This yields a target queue depth of 250us at 1 Gb/s\n    tchRed1.SetRootQueueDisc(\"ns3::RedQueueDisc\",\n                             \"LinkBandwidth\",\n                             StringValue(\"1Gbps\"),\n                             \"LinkDelay\",\n                             StringValue(\"10us\"),\n                             \"MinTh\",\n                             DoubleValue(20),\n                             \"MaxTh\",\n                             DoubleValue(60));\n    QueueDiscContainer queueDiscs2 = tchRed1.Install(R1T2.Get(1));\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        tchRed1.Install(S1T1[i].Get(1));\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        tchRed1.Install(S2T1[i].Get(1));\n    }\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        tchRed1.Install(S3T2[i].Get(1));\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        tchRed1.Install(R2T2[i].Get(1));\n    }\n\n    Ipv4AddressHelper address;\n    std::vector<Ipv4InterfaceContainer> ipS1T1;\n    ipS1T1.reserve(10);\n    std::vector<Ipv4InterfaceContainer> ipS2T1;\n    ipS2T1.reserve(20);\n    std::vector<Ipv4InterfaceContainer> ipS3T2;\n    ipS3T2.reserve(10);\n    std::vector<Ipv4InterfaceContainer> ipR2T2;\n    ipR2T2.reserve(20);\n    address.SetBase(\"172.16.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipT1T2 = address.Assign(T1T2);\n    address.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipR1T2 = address.Assign(R1T2);\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        ipS1T1.push_back(address.Assign(S1T1[i]));\n        address.NewNetwork();\n    }\n    address.SetBase(\"10.2.1.0\", \"255.255.255.0\");\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        ipS2T1.push_back(address.Assign(S2T1[i]));\n        address.NewNetwork();\n    }\n    address.SetBase(\"10.3.1.0\", \"255.255.255.0\");\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        ipS3T2.push_back(address.Assign(S3T2[i]));\n        address.NewNetwork();\n    }\n    address.SetBase(\"10.4.1.0\", \"255.255.255.0\");\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        ipR2T2.push_back(address.Assign(R2T2[i]));\n        address.NewNetwork();\n    }\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Each sender in S2 sends to a receiver in R2\n    std::vector<Ptr<PacketSink>> r2Sinks;\n    r2Sinks.reserve(20);\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        uint16_t port = 50000 + i;\n        Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n        PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n        ApplicationContainer sinkApp = sinkHelper.Install(R2.Get(i));\n        Ptr<PacketSink> packetSink = sinkApp.Get(0)->GetObject<PacketSink>();\n        r2Sinks.push_back(packetSink);\n        sinkApp.Start(startTime);\n        sinkApp.Stop(stopTime);\n\n        OnOffHelper clientHelper1(\"ns3::TcpSocketFactory\", Address());\n        clientHelper1.SetAttribute(\"OnTime\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        clientHelper1.SetAttribute(\"OffTime\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n        clientHelper1.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"1Gbps\")));\n        clientHelper1.SetAttribute(\"PacketSize\", UintegerValue(1000));\n\n        ApplicationContainer clientApps1;\n        AddressValue remoteAddress(InetSocketAddress(ipR2T2[i].GetAddress(0), port));\n        clientHelper1.SetAttribute(\"Remote\", remoteAddress);\n        clientApps1.Add(clientHelper1.Install(S2.Get(i)));\n        clientApps1.Start(i * flowStartupWindow / 20 + startTime + MilliSeconds(i * 5));\n        clientApps1.Stop(stopTime);\n    }\n\n    // Each sender in S1 and S3 sends to R1\n    std::vector<Ptr<PacketSink>> s1r1Sinks;\n    std::vector<Ptr<PacketSink>> s3r1Sinks;\n    s1r1Sinks.reserve(10);\n    s3r1Sinks.reserve(10);\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        uint16_t port = 50000 + i;\n        Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n        PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n        ApplicationContainer sinkApp = sinkHelper.Install(R1);\n        Ptr<PacketSink> packetSink = sinkApp.Get(0)->GetObject<PacketSink>();\n        if (i < 10)\n        {\n            s1r1Sinks.push_back(packetSink);\n        }\n        else\n        {\n            s3r1Sinks.push_back(packetSink);\n        }\n        sinkApp.Start(startTime);\n        sinkApp.Stop(stopTime);\n\n        OnOffHelper clientHelper1(\"ns3::TcpSocketFactory\", Address());\n        clientHelper1.SetAttribute(\"OnTime\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n        clientHelper1.SetAttribute(\"OffTime\",\n                                   StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n        clientHelper1.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"1Gbps\")));\n        clientHelper1.SetAttribute(\"PacketSize\", UintegerValue(1000));\n\n        ApplicationContainer clientApps1;\n        AddressValue remoteAddress(InetSocketAddress(ipR1T2.GetAddress(0), port));\n        clientHelper1.SetAttribute(\"Remote\", remoteAddress);\n        if (i < 10)\n        {\n            clientApps1.Add(clientHelper1.Install(S1.Get(i)));\n            clientApps1.Start(i * flowStartupWindow / 10 + startTime + MilliSeconds(i * 5));\n        }\n        else\n        {\n            clientApps1.Add(clientHelper1.Install(S3.Get(i - 10)));\n            clientApps1.Start((i - 10) * flowStartupWindow / 10 + startTime + MilliSeconds(i * 5));\n        }\n\n        clientApps1.Stop(stopTime);\n    }\n\n    rxS1R1Throughput.open(\"dctcp-example-s1-r1-throughput.dat\", std::ios::out);\n    rxS1R1Throughput << \"#Time(s) flow thruput(Mb/s)\" << std::endl;\n    rxS2R2Throughput.open(\"dctcp-example-s2-r2-throughput.dat\", std::ios::out);\n    rxS2R2Throughput << \"#Time(s) flow thruput(Mb/s)\" << std::endl;\n    rxS3R1Throughput.open(\"dctcp-example-s3-r1-throughput.dat\", std::ios::out);\n    rxS3R1Throughput << \"#Time(s) flow thruput(Mb/s)\" << std::endl;\n    fairnessIndex.open(\"dctcp-example-fairness.dat\", std::ios::out);\n    t1QueueLength.open(\"dctcp-example-t1-length.dat\", std::ios::out);\n    t1QueueLength << \"#Time(s) qlen(pkts) qlen(us)\" << std::endl;\n    t2QueueLength.open(\"dctcp-example-t2-length.dat\", std::ios::out);\n    t2QueueLength << \"#Time(s) qlen(pkts) qlen(us)\" << std::endl;\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        s1r1Sinks[i]->TraceConnectWithoutContext(\"Rx\", MakeBoundCallback(&TraceS1R1Sink, i));\n    }\n    for (std::size_t i = 0; i < 20; i++)\n    {\n        r2Sinks[i]->TraceConnectWithoutContext(\"Rx\", MakeBoundCallback(&TraceS2R2Sink, i));\n    }\n    for (std::size_t i = 0; i < 10; i++)\n    {\n        s3r1Sinks[i]->TraceConnectWithoutContext(\"Rx\", MakeBoundCallback(&TraceS3R1Sink, i));\n    }\n    Simulator::Schedule(flowStartupWindow + convergenceTime, &InitializeCounters);\n    Simulator::Schedule(flowStartupWindow + convergenceTime + measurementWindow,\n                        &PrintThroughput,\n                        measurementWindow);\n    Simulator::Schedule(flowStartupWindow + convergenceTime + measurementWindow,\n                        &PrintFairness,\n                        measurementWindow);\n    Simulator::Schedule(progressInterval, &PrintProgress, progressInterval);\n    Simulator::Schedule(flowStartupWindow + convergenceTime, &CheckT1QueueSize, queueDiscs1.Get(0));\n    Simulator::Schedule(flowStartupWindow + convergenceTime, &CheckT2QueueSize, queueDiscs2.Get(0));\n    Simulator::Stop(stopTime + TimeStep(1));\n\n    Simulator::Run();\n\n    rxS1R1Throughput.close();\n    rxS2R2Throughput.close();\n    rxS3R1Throughput.close();\n    fairnessIndex.close();\n    t1QueueLength.close();\n    t2QueueLength.close();\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using ns-3 to create a star topology network, where the central node (hub) connects to eight surrounding nodes (spokes) using point-to-point links. Install the internet stack on all nodes and assign IPv4 addresses. Set default application configurations: an OnOffApplication with a packet size of 137 bytes and a data rate of 14kbps. Create a packet sink on the hub node to receive TCP traffic on port 50000, and configure each spoke node to send TCP traffic to the hub using OnOff applications. Enable static global routing and capture pcap traces for all devices. Run the simulation for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-layout-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n// Network topology (default)\n//\n//        n2 n3 n4              .\n//         \\ | /                .\n//          \\|/                 .\n//     n1--- n0---n5            .\n//          /|\\                 .\n//         / | \\                .\n//        n8 n7 n6              .\n//\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Star\");\n\nint\nmain(int argc, char* argv[])\n{\n    //\n    // Set up some default values for the simulation.\n    //\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(137));\n\n    // ??? try and stick 15kb/s into the data rate\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(\"14kb/s\"));\n\n    //\n    // Default number of nodes in the star.  Overridable by command line argument.\n    //\n    uint32_t nSpokes = 8;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nSpokes\", \"Number of nodes to place in the star\", nSpokes);\n    cmd.Parse(argc, argv);\n\n    NS_LOG_INFO(\"Build star topology.\");\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    PointToPointStarHelper star(nSpokes, pointToPoint);\n\n    NS_LOG_INFO(\"Install internet stack on all nodes.\");\n    InternetStackHelper internet;\n    star.InstallStack(internet);\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    star.AssignIpv4Addresses(Ipv4AddressHelper(\"10.1.1.0\", \"255.255.255.0\"));\n\n    NS_LOG_INFO(\"Create applications.\");\n    //\n    // Create a packet sink on the star \"hub\" to receive packets.\n    //\n    uint16_t port = 50000;\n    Address hubLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", hubLocalAddress);\n    ApplicationContainer hubApp = packetSinkHelper.Install(star.GetHub());\n    hubApp.Start(Seconds(1.0));\n    hubApp.Stop(Seconds(10.0));\n\n    //\n    // Create OnOff applications to send TCP to the hub, one on each spoke node.\n    //\n    OnOffHelper onOffHelper(\"ns3::TcpSocketFactory\", Address());\n    onOffHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    ApplicationContainer spokeApps;\n\n    for (uint32_t i = 0; i < star.SpokeCount(); ++i)\n    {\n        AddressValue remoteAddress(InetSocketAddress(star.GetHubIpv4Address(i), port));\n        onOffHelper.SetAttribute(\"Remote\", remoteAddress);\n        spokeApps.Add(onOffHelper.Install(star.GetSpokeNode(i)));\n    }\n    spokeApps.Start(Seconds(1.0));\n    spokeApps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Enable static global routing.\");\n    //\n    // Turn on global static routing so we can actually be routed across the star.\n    //\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    NS_LOG_INFO(\"Enable pcap tracing.\");\n    //\n    // Do pcap tracing on all point-to-point devices on all nodes.\n    //\n    pointToPoint.EnablePcapAll(\"star\");\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using ns-3 to simulate a network with four nodes: a sender, two routers (R1 and R2), and a receiver. Create three point-to-point links: sender to R1 and R2 to receiver with 1000 Mbps bandwidth and 5ms delay, and a bottleneck link between R1 and R2 with 10 Mbps bandwidth and 10ms delay. Set the simulation to run for 100 seconds, and configure the TCP BBR congestion control algorithm on the sender. Enable pcap tracing on all interfaces, save congestion window traces, sender throughput traces, and queue size traces from the bottleneck link to output files. Ensure the BBR algorithm enters the PROBE_RTT phase every 10 seconds, reducing the congestion window to 4 segments."}, {"role": "assistant", "content": "// This program simulates the following topology:\n//\n//           1000 Mbps           10Mbps          1000 Mbps\n//  Sender -------------- R1 -------------- R2 -------------- Receiver\n//              5ms               10ms               5ms\n//\n// The link between R1 and R2 is a bottleneck link with 10 Mbps. All other\n// links are 1000 Mbps.\n//\n// This program runs by default for 100 seconds and creates a new directory\n// called 'bbr-results' in the ns-3 root directory. The program creates one\n// sub-directory called 'pcap' in 'bbr-results' directory (if pcap generation\n// is enabled) and three .dat files.\n//\n// (1) 'pcap' sub-directory contains six PCAP files:\n//     * bbr-0-0.pcap for the interface on Sender\n//     * bbr-1-0.pcap for the interface on Receiver\n//     * bbr-2-0.pcap for the first interface on R1\n//     * bbr-2-1.pcap for the second interface on R1\n//     * bbr-3-0.pcap for the first interface on R2\n//     * bbr-3-1.pcap for the second interface on R2\n// (2) cwnd.dat file contains congestion window trace for the sender node\n// (3) throughput.dat file contains sender side throughput trace (throughput is in Mbit/s)\n// (4) queueSize.dat file contains queue length trace from the bottleneck link\n//\n// BBR algorithm enters PROBE_RTT phase in every 10 seconds. The congestion\n// window is fixed to 4 segments in this phase with a goal to achieve a better\n// estimate of minimum RTT (because queue at the bottleneck link tends to drain\n// when the congestion window is reduced to 4 segments).\n//\n// The congestion window and queue occupancy traces output by this program show\n// periodic drops every 10 seconds when BBR algorithm is in PROBE_RTT phase.\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <filesystem>\n\nusing namespace ns3;\nusing namespace ns3::SystemPath;\n\nstd::string dir;\nstd::ofstream throughput;\nstd::ofstream queueSize;\n\nuint32_t prev = 0;\nTime prevTime = Seconds(0);\n\n// Calculate throughput\nstatic void\nTraceThroughput(Ptr<FlowMonitor> monitor)\n{\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n    if (!stats.empty())\n    {\n        auto itr = stats.begin();\n        Time curTime = Now();\n\n        // Convert (curTime - prevTime) to microseconds so that throughput is in bits per\n        // microsecond (which is equivalent to Mbps)\n        throughput << curTime.GetSeconds() << \"s \"\n                   << 8 * (itr->second.txBytes - prev) / ((curTime - prevTime).ToDouble(Time::US))\n                   << \" Mbps\" << std::endl;\n        prevTime = curTime;\n        prev = itr->second.txBytes;\n    }\n    Simulator::Schedule(Seconds(0.2), &TraceThroughput, monitor);\n}\n\n// Check the queue size\nvoid\nCheckQueueSize(Ptr<QueueDisc> qd)\n{\n    uint32_t qsize = qd->GetCurrentSize().GetValue();\n    Simulator::Schedule(Seconds(0.2), &CheckQueueSize, qd);\n    queueSize << Simulator::Now().GetSeconds() << \" \" << qsize << std::endl;\n}\n\n// Trace congestion window\nstatic void\nCwndTracer(Ptr<OutputStreamWrapper> stream, uint32_t oldval, uint32_t newval)\n{\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << newval / 1448.0 << std::endl;\n}\n\nvoid\nTraceCwnd(uint32_t nodeId, uint32_t socketId)\n{\n    AsciiTraceHelper ascii;\n    Ptr<OutputStreamWrapper> stream = ascii.CreateFileStream(dir + \"/cwnd.dat\");\n    Config::ConnectWithoutContext(\"/NodeList/\" + std::to_string(nodeId) +\n                                      \"/$ns3::TcpL4Protocol/SocketList/\" +\n                                      std::to_string(socketId) + \"/CongestionWindow\",\n                                  MakeBoundCallback(&CwndTracer, stream));\n}\n\nint\nmain(int argc, char* argv[])\n{\n    // Naming the output directory using local system time\n    time_t rawtime;\n    struct tm* timeinfo;\n    char buffer[80];\n    time(&rawtime);\n    timeinfo = localtime(&rawtime);\n    strftime(buffer, sizeof(buffer), \"%d-%m-%Y-%I-%M-%S\", timeinfo);\n    std::string currentTime(buffer);\n\n    std::string tcpTypeId = \"TcpBbr\";\n    std::string queueDisc = \"FifoQueueDisc\";\n    uint32_t delAckCount = 2;\n    bool bql = true;\n    bool enablePcap = false;\n    Time stopTime = Seconds(100);\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"tcpTypeId\", \"Transport protocol to use: TcpNewReno, TcpBbr\", tcpTypeId);\n    cmd.AddValue(\"delAckCount\", \"Delayed ACK count\", delAckCount);\n    cmd.AddValue(\"enablePcap\", \"Enable/Disable pcap file generation\", enablePcap);\n    cmd.AddValue(\"stopTime\",\n                 \"Stop time for applications / simulation time will be stopTime + 1\",\n                 stopTime);\n    cmd.Parse(argc, argv);\n\n    queueDisc = std::string(\"ns3::\") + queueDisc;\n\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\", StringValue(\"ns3::\" + tcpTypeId));\n\n    // The maximum send buffer size is set to 4194304 bytes (4MB) and the\n    // maximum receive buffer size is set to 6291456 bytes (6MB) in the Linux\n    // kernel. The same buffer sizes are used as default in this example.\n    Config::SetDefault(\"ns3::TcpSocket::SndBufSize\", UintegerValue(4194304));\n    Config::SetDefault(\"ns3::TcpSocket::RcvBufSize\", UintegerValue(6291456));\n    Config::SetDefault(\"ns3::TcpSocket::InitialCwnd\", UintegerValue(10));\n    Config::SetDefault(\"ns3::TcpSocket::DelAckCount\", UintegerValue(delAckCount));\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(1448));\n    Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\", QueueSizeValue(QueueSize(\"1p\")));\n    Config::SetDefault(queueDisc + \"::MaxSize\", QueueSizeValue(QueueSize(\"100p\")));\n\n    NodeContainer sender;\n    NodeContainer receiver;\n    NodeContainer routers;\n    sender.Create(1);\n    receiver.Create(1);\n    routers.Create(2);\n\n    // Create the point-to-point link helpers\n    PointToPointHelper bottleneckLink;\n    bottleneckLink.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    bottleneckLink.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n\n    PointToPointHelper edgeLink;\n    edgeLink.SetDeviceAttribute(\"DataRate\", StringValue(\"1000Mbps\"));\n    edgeLink.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    // Create NetDevice containers\n    NetDeviceContainer senderEdge = edgeLink.Install(sender.Get(0), routers.Get(0));\n    NetDeviceContainer r1r2 = bottleneckLink.Install(routers.Get(0), routers.Get(1));\n    NetDeviceContainer receiverEdge = edgeLink.Install(routers.Get(1), receiver.Get(0));\n\n    // Install Stack\n    InternetStackHelper internet;\n    internet.Install(sender);\n    internet.Install(receiver);\n    internet.Install(routers);\n\n    // Configure the root queue discipline\n    TrafficControlHelper tch;\n    tch.SetRootQueueDisc(queueDisc);\n\n    if (bql)\n    {\n        tch.SetQueueLimits(\"ns3::DynamicQueueLimits\", \"HoldTime\", StringValue(\"1000ms\"));\n    }\n\n    tch.Install(senderEdge);\n    tch.Install(receiverEdge);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer i1i2 = ipv4.Assign(r1r2);\n\n    ipv4.NewNetwork();\n    Ipv4InterfaceContainer is1 = ipv4.Assign(senderEdge);\n\n    ipv4.NewNetwork();\n    Ipv4InterfaceContainer ir1 = ipv4.Assign(receiverEdge);\n\n    // Populate routing tables\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Select sender side port\n    uint16_t port = 50001;\n\n    // Install application on the sender\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", InetSocketAddress(ir1.GetAddress(1), port));\n    source.SetAttribute(\"MaxBytes\", UintegerValue(0));\n    ApplicationContainer sourceApps = source.Install(sender.Get(0));\n    sourceApps.Start(Seconds(0.1));\n    // Hook trace source after application starts\n    Simulator::Schedule(Seconds(0.1) + MilliSeconds(1), &TraceCwnd, 0, 0);\n    sourceApps.Stop(stopTime);\n\n    // Install application on the receiver\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApps = sink.Install(receiver.Get(0));\n    sinkApps.Start(Seconds(0.0));\n    sinkApps.Stop(stopTime);\n\n    // Create a new directory to store the output of the program\n    dir = \"bbr-results/\" + currentTime + \"/\";\n    MakeDirectories(dir);\n\n    // The plotting scripts are provided in the following repository, if needed:\n    // https://github.com/mohittahiliani/BBR-Validation/\n    //\n    // Download 'PlotScripts' directory (which is inside ns-3 scripts directory)\n    // from the link given above and place it in the ns-3 root directory.\n    // Uncomment the following three lines to copy plot scripts for\n    // Congestion Window, sender side throughput and queue occupancy on the\n    // bottleneck link into the output directory.\n    //\n    // std::filesystem::copy(\"PlotScripts/gnuplotScriptCwnd\", dir);\n    // std::filesystem::copy(\"PlotScripts/gnuplotScriptThroughput\", dir);\n    // std::filesystem::copy(\"PlotScripts/gnuplotScriptQueueSize\", dir);\n\n    // Trace the queue occupancy on the second interface of R1\n    tch.Uninstall(routers.Get(0)->GetDevice(1));\n    QueueDiscContainer qd;\n    qd = tch.Install(routers.Get(0)->GetDevice(1));\n    Simulator::ScheduleNow(&CheckQueueSize, qd.Get(0));\n\n    // Generate PCAP traces if it is enabled\n    if (enablePcap)\n    {\n        MakeDirectories(dir + \"pcap/\");\n        bottleneckLink.EnablePcapAll(dir + \"/pcap/bbr\", true);\n    }\n\n    // Open files for writing throughput traces and queue size\n    throughput.open(dir + \"/throughput.dat\", std::ios::out);\n    queueSize.open(dir + \"/queueSize.dat\", std::ios::out);\n\n    NS_ASSERT_MSG(throughput.is_open(), \"Throughput file was not opened correctly\");\n    NS_ASSERT_MSG(queueSize.is_open(), \"Queue size file was not opened correctly\");\n\n    // Check for dropped packets using Flow Monitor\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n    Simulator::Schedule(Seconds(0 + 0.000001), &TraceThroughput, monitor);\n\n    Simulator::Stop(stopTime + TimeStep(1));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    throughput.close();\n    queueSize.close();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using ns-3 to simulate a network with two nodes (n0 and n1) connected by a point-to-point link with 500 Kbps bandwidth and 5ms delay. Install a BulkSendApplication on node n0 to send data to node n1 over TCP, and a PacketSinkApplication on node n1 to receive the data. Set the simulation time to 10 seconds and allow the user to specify the maximum bytes to send and whether to enable tracing. If tracing is enabled, generate an ASCII trace file named 'tcp-bulk-send.tr' and a pcap file. Finally, print the total bytes received by the sink."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0 ----------- n1\n//            500 Kbps\n//             5 ms\n//\n// - Flow from n0 to n1 using BulkSendApplication.\n// - Tracing of queues and packet receptions to file \"tcp-bulk-send.tr\"\n//   and pcap tracing available when tracing is turned on.\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <fstream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpBulkSendExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    bool tracing = false;\n    uint32_t maxBytes = 0;\n\n    //\n    // Allow the user to override any of the defaults at\n    // run-time, via command-line arguments\n    //\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"tracing\", \"Flag to enable/disable tracing\", tracing);\n    cmd.AddValue(\"maxBytes\", \"Total number of bytes for application to send\", maxBytes);\n    cmd.Parse(argc, argv);\n\n    //\n    // Explicitly create the nodes required by the topology (shown above).\n    //\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    NS_LOG_INFO(\"Create channels.\");\n\n    //\n    // Explicitly create the point-to-point link required by the topology (shown above).\n    //\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"500Kbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    //\n    // Install the internet stack on the nodes\n    //\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    //\n    // We've got the \"hardware\" in place.  Now we need to add IP addresses.\n    //\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    //\n    // Create a BulkSendApplication and install it on node 0\n    //\n    uint16_t port = 9; // well-known echo port number\n\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", InetSocketAddress(i.GetAddress(1), port));\n    // Set the amount of data to send in bytes.  Zero is unlimited.\n    source.SetAttribute(\"MaxBytes\", UintegerValue(maxBytes));\n    ApplicationContainer sourceApps = source.Install(nodes.Get(0));\n    sourceApps.Start(Seconds(0.0));\n    sourceApps.Stop(Seconds(10.0));\n\n    //\n    // Create a PacketSinkApplication and install it on node 1\n    //\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApps = sink.Install(nodes.Get(1));\n    sinkApps.Start(Seconds(0.0));\n    sinkApps.Stop(Seconds(10.0));\n\n    //\n    // Set up tracing if enabled\n    //\n    if (tracing)\n    {\n        AsciiTraceHelper ascii;\n        pointToPoint.EnableAsciiAll(ascii.CreateFileStream(\"tcp-bulk-send.tr\"));\n        pointToPoint.EnablePcapAll(\"tcp-bulk-send\", false);\n    }\n\n    //\n    // Now, do the actual simulation.\n    //\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    Ptr<PacketSink> sink1 = DynamicCast<PacketSink>(sinkApps.Get(0));\n    std::cout << \"Total Bytes Received: \" << sink1->GetTotalRx() << std::endl;\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using NS-3 to simulate a basic Wi-Fi network consisting of three nodes: one acting as an access point (AP) and the other two as Wi-Fi stations (STAs). The stations should communicate with each other through the AP. Set up an IPv4 network and assign IP addresses to all nodes. Implement a UDP echo protocol where one station acts as a client and the other as a server. The client should send a 512-byte message to the server. Capture network traffic in a .pcap file. The simulation should run for 20 seconds, with the UDP server starting at 1 second and the client starting at 2 seconds. Ensure the simulation ends after all messages are exchanged."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleAdhocExample\");\n\nint main(int argc, char *argv[]) {\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create three nodes (1 Access Point, 2 Stations)\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Configure Wi-Fi channel and physical layer\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    // Set Wi-Fi standard and install on nodes\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\", \"DataMode\", StringValue(\"HtMcs7\"), \"ControlMode\", StringValue(\"HtMcs0\"));\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n\n    // Configure the stations (STAs)\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure the access point (AP)\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set mobility model for all nodes (random positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \n                                  \"MinX\", DoubleValue(0.0), \n                                  \"MinY\", DoubleValue(0.0), \n                                  \"DeltaX\", DoubleValue(5.0), \n                                  \"DeltaY\", DoubleValue(10.0), \n                                  \"GridWidth\", UintegerValue(3), \n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    \n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Install Internet stack (IP protocol)\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Create a UDP echo server on one of the stations (node 0)\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Create a UDP echo client on the other station (node 1)\n    UdpEchoClientHelper echoClient(staInterfaces.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10)); // Send 10 packets\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp = echoClient.Install(wifiStaNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(20.0));\n\n    // Enable packet capture\n    phy.EnablePcap(\"wifi-simple\", staDevices.Get(0));\n\n    // Enable logging for debugging purposes\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"ArpL3Protocol\", LOG_LEVEL_INFO); // For ARP resolution\n\n    // Run the simulation\n    Simulator::Stop(Seconds(21.0)); // Ensure the simulation stops after 21 seconds\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using ns-3 to simulate a network with three nodes connected by point-to-point links with 10 Mbps bandwidth and 10 ms delay between n0, n1, and n2. Install a PacketSinkApplication on node n2 to receive data sent over TCP from node n0. Use a socket to implement the sender directly at node n0. Set the simulation to send 2,000,000 bytes and track the congestion window using a callback. Enable tracing of queues and packet receptions, saving traces in an ASCII file 'tcp-large-transfer.tr' and generating pcap files named 'tcp-large-transfer-$n-$i.pcap'."}, {"role": "assistant", "content": "//\n// Network topology\n//\n//           10Mb/s, 10ms       10Mb/s, 10ms\n//       n0-----------------n1-----------------n2\n//\n//\n// - Tracing of queues and packet receptions to file\n//   \"tcp-large-transfer.tr\"\n// - pcap traces also generated in the following files\n//   \"tcp-large-transfer-$n-$i.pcap\" where n and i represent node and interface\n// numbers respectively\n//  Usage (e.g.): ./ns3 run tcp-large-transfer\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpLargeTransfer\");\n\n/// The number of bytes to send in this simulation.\nstatic const uint32_t totalTxBytes = 2000000;\n/// The actual number of sent bytes.\nstatic uint32_t currentTxBytes = 0;\n\n// Perform series of 1040 byte writes (this is a multiple of 26 since\n// we want to detect data splicing in the output stream)\n/// Write size.\nstatic const uint32_t writeSize = 1040;\n/// Data to be written.\nuint8_t data[writeSize];\n\n// These are for starting the writing process, and handling the sending\n// socket's notification upcalls (events).  These two together more or less\n// implement a sending \"Application\", although not a proper ns3::Application\n// subclass.\n\n/**\n * Start a flow.\n *\n * \\param localSocket The local (sending) socket.\n * \\param servAddress The server address.\n * \\param servPort The server port.\n */\nvoid StartFlow(Ptr<Socket> localSocket, Ipv4Address servAddress, uint16_t servPort);\n\n/**\n * Write to the buffer, filling it.\n *\n * \\param localSocket The socket.\n * \\param txSpace The number of bytes to write.\n */\nvoid WriteUntilBufferFull(Ptr<Socket> localSocket, uint32_t txSpace);\n\n/**\n * Congestion window tracker function.\n *\n * \\param oldval Old value.\n * \\param newval New value.\n */\nstatic void\nCwndTracer(uint32_t oldval, uint32_t newval)\n{\n    NS_LOG_INFO(\"Moving cwnd from \" << oldval << \" to \" << newval);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    // Users may find it convenient to turn on explicit debugging\n    // for selected modules; the below lines suggest how to do this\n    //  LogComponentEnable(\"TcpL4Protocol\", LOG_LEVEL_ALL);\n    //  LogComponentEnable(\"TcpSocketImpl\", LOG_LEVEL_ALL);\n    //  LogComponentEnable(\"PacketSink\", LOG_LEVEL_ALL);\n    //  LogComponentEnable(\"TcpLargeTransfer\", LOG_LEVEL_ALL);\n\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    // initialize the tx buffer.\n    for (uint32_t i = 0; i < writeSize; ++i)\n    {\n        char m = toascii(97 + i % 26);\n        data[i] = m;\n    }\n\n    // Here, we will explicitly create three nodes.  The first container contains\n    // nodes 0 and 1 from the diagram above, and the second one contains nodes\n    // 1 and 2.  This reflects the channel connectivity, and will be used to\n    // install the network interfaces and connect them with a channel.\n    NodeContainer n0n1;\n    n0n1.Create(2);\n\n    NodeContainer n1n2;\n    n1n2.Add(n0n1.Get(1));\n    n1n2.Create(1);\n\n    // We create the channels first without any IP addressing information\n    // First make and configure the helper, so that it will put the appropriate\n    // attributes on the network interfaces and channels we are about to install.\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(10000000)));\n    p2p.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(10)));\n\n    // And then install devices and channels connecting our topology.\n    NetDeviceContainer dev0 = p2p.Install(n0n1);\n    NetDeviceContainer dev1 = p2p.Install(n1n2);\n\n    // Now add ip/tcp stack to all nodes.\n    InternetStackHelper internet;\n    internet.InstallAll();\n\n    // Later, we add IP addresses.\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    ipv4.Assign(dev0);\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfs = ipv4.Assign(dev1);\n\n    // and setup ip routing tables to get total ip-level connectivity.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    ///////////////////////////////////////////////////////////////////////////\n    // Simulation 1\n    //\n    // Send 2000000 bytes over a connection to server port 50000 at time 0\n    // Should observe SYN exchange, a lot of data segments and ACKS, and FIN\n    // exchange.  FIN exchange isn't quite compliant with TCP spec (see release\n    // notes for more info)\n    //\n    ///////////////////////////////////////////////////////////////////////////\n\n    uint16_t servPort = 50000;\n\n    // Create a packet sink to receive these packets on n2...\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(Ipv4Address::GetAny(), servPort));\n\n    ApplicationContainer apps = sink.Install(n1n2.Get(1));\n    apps.Start(Seconds(0.0));\n    apps.Stop(Seconds(3.0));\n\n    // Create a source to send packets from n0.  Instead of a full Application\n    // and the helper APIs you might see in other example files, this example\n    // will use sockets directly and register some socket callbacks as a sending\n    // \"Application\".\n\n    // Create and bind the socket...\n    Ptr<Socket> localSocket = Socket::CreateSocket(n0n1.Get(0), TcpSocketFactory::GetTypeId());\n    localSocket->Bind();\n\n    // Trace changes to the congestion window\n    Config::ConnectWithoutContext(\"/NodeList/0/$ns3::TcpL4Protocol/SocketList/0/CongestionWindow\",\n                                  MakeCallback(&CwndTracer));\n\n    // ...and schedule the sending \"Application\"; This is similar to what an\n    // ns3::Application subclass would do internally.\n    Simulator::ScheduleNow(&StartFlow, localSocket, ipInterfs.GetAddress(1), servPort);\n\n    // One can toggle the comment for the following line on or off to see the\n    // effects of finite send buffer modelling.  One can also change the size of\n    // said buffer.\n\n    // localSocket->SetAttribute(\"SndBufSize\", UintegerValue(4096));\n\n    // Ask for ASCII and pcap traces of network traffic\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"tcp-large-transfer.tr\"));\n    p2p.EnablePcapAll(\"tcp-large-transfer\");\n\n    // Finally, set up the simulator to run.  The 1000 second hard limit is a\n    // failsafe in case some change above causes the simulation to never end\n    Simulator::Stop(Seconds(1000));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}\n\n//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n//-----------------------------------------------------------------------------\n// begin implementation of sending \"Application\"\nvoid\nStartFlow(Ptr<Socket> localSocket, Ipv4Address servAddress, uint16_t servPort)\n{\n    NS_LOG_LOGIC(\"Starting flow at time \" << Simulator::Now().GetSeconds());\n    localSocket->Connect(InetSocketAddress(servAddress, servPort)); // connect\n\n    // tell the tcp implementation to call WriteUntilBufferFull again\n    // if we blocked and new tx buffer space becomes available\n    localSocket->SetSendCallback(MakeCallback(&WriteUntilBufferFull));\n    WriteUntilBufferFull(localSocket, localSocket->GetTxAvailable());\n}\n\nvoid\nWriteUntilBufferFull(Ptr<Socket> localSocket, uint32_t txSpace)\n{\n    while (currentTxBytes < totalTxBytes && localSocket->GetTxAvailable() > 0)\n    {\n        uint32_t left = totalTxBytes - currentTxBytes;\n        uint32_t dataOffset = currentTxBytes % writeSize;\n        uint32_t toWrite = writeSize - dataOffset;\n        toWrite = std::min(toWrite, left);\n        toWrite = std::min(toWrite, localSocket->GetTxAvailable());\n        int amountSent = localSocket->Send(&data[dataOffset], toWrite, 0);\n        if (amountSent < 0)\n        {\n            // we will be called again when new tx space becomes available.\n            return;\n        }\n        currentTxBytes += amountSent;\n    }\n    if (currentTxBytes >= totalTxBytes)\n    {\n        localSocket->Close();\n    }\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate code that creates a network topology with four nodes (n0, n1, n2, and n3) connected in a series, where n0 to n1 has a 10 Mbps link with 1 ms delay, n1 to n2 has a 1 Mbps link with 10 ms delay, and n2 to n3 has a 10 Mbps link with 1 ms delay. Implement a TCP flow from n0 to n3 using the BulkSendApplication. Store simulation output in the \"results/\" directory, including cwnd traces in \"cwndTraces\", queue length statistics in \"queue-size.dat\", PCAP files in \"pcap\", queue drop statistics in \"queueTraces\", and queue stats in \"queueStats.txt\". Include configuration details in \"config.txt\"."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0 ---------- n1 ---------- n2 ---------- n3\n//            10 Mbps       1 Mbps        10 Mbps\n//             1 ms         10 ms          1 ms\n//\n// - TCP flow from n0 to n3 using BulkSendApplication.\n// - The following simulation output is stored in results/ in ns-3 top-level directory:\n//   - cwnd traces are stored in cwndTraces folder\n//   - queue length statistics are stored in queue-size.dat file\n//   - pcaps are stored in pcap folder\n//   - queueTraces folder contain the drop statistics at queue\n//   - queueStats.txt file contains the queue stats and config.txt file contains\n//     the simulation configuration.\n// - The cwnd and queue length traces obtained from this example were tested against\n//   the respective traces obtained from Linux Reno by using ns-3 Direct Code Execution.\n//   See internet/doc/tcp.rst for more details.\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <sys/stat.h>\n\nusing namespace ns3;\nstd::string dir = \"results/\";\nTime stopTime = Seconds(60);\nuint32_t segmentSize = 524;\n\nstd::ofstream fPlotQueue;\nstd::ofstream fPlotCwnd;\n\n// Function to check queue length of Router 1\nvoid\nCheckQueueSize(Ptr<QueueDisc> queue)\n{\n    uint32_t qSize = queue->GetCurrentSize().GetValue();\n\n    // Check queue size every 1/100 of a second\n    Simulator::Schedule(Seconds(0.001), &CheckQueueSize, queue);\n    fPlotQueue << Simulator::Now().GetSeconds() << \" \" << qSize << std::endl;\n}\n\n// Function to trace change in cwnd at n0\nstatic void\nCwndChange(uint32_t oldCwnd, uint32_t newCwnd)\n{\n    fPlotCwnd << Simulator::Now().GetSeconds() << \" \" << newCwnd / segmentSize << std::endl;\n}\n\n// Function to calculate drops in a particular Queue\nstatic void\nDropAtQueue(Ptr<OutputStreamWrapper> stream, Ptr<const QueueDiscItem> item)\n{\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" 1\" << std::endl;\n}\n\n// Trace Function for cwnd\nvoid\nTraceCwnd(uint32_t node, uint32_t cwndWindow, Callback<void, uint32_t, uint32_t> CwndTrace)\n{\n    Config::ConnectWithoutContext(\"/NodeList/\" + std::to_string(node) +\n                                      \"/$ns3::TcpL4Protocol/SocketList/\" +\n                                      std::to_string(cwndWindow) + \"/CongestionWindow\",\n                                  CwndTrace);\n}\n\n// Function to install BulkSend application\nvoid\nInstallBulkSend(Ptr<Node> node,\n                Ipv4Address address,\n                uint16_t port,\n                std::string socketFactory,\n                uint32_t nodeId,\n                uint32_t cwndWindow,\n                Callback<void, uint32_t, uint32_t> CwndTrace)\n{\n    BulkSendHelper source(socketFactory, InetSocketAddress(address, port));\n    source.SetAttribute(\"MaxBytes\", UintegerValue(0));\n    ApplicationContainer sourceApps = source.Install(node);\n    sourceApps.Start(Seconds(10.0));\n    Simulator::Schedule(Seconds(10.0) + Seconds(0.001), &TraceCwnd, nodeId, cwndWindow, CwndTrace);\n    sourceApps.Stop(stopTime);\n}\n\n// Function to install sink application\nvoid\nInstallPacketSink(Ptr<Node> node, uint16_t port, std::string socketFactory)\n{\n    PacketSinkHelper sink(socketFactory, InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApps = sink.Install(node);\n    sinkApps.Start(Seconds(10.0));\n    sinkApps.Stop(stopTime);\n}\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t stream = 1;\n    std::string socketFactory = \"ns3::TcpSocketFactory\";\n    std::string tcpTypeId = \"ns3::TcpLinuxReno\";\n    std::string qdiscTypeId = \"ns3::FifoQueueDisc\";\n    bool isSack = true;\n    uint32_t delAckCount = 1;\n    std::string recovery = \"ns3::TcpClassicRecovery\";\n\n    CommandLine cmd;\n    cmd.AddValue(\"tcpTypeId\",\n                 \"TCP variant to use (e.g., ns3::TcpNewReno, ns3::TcpLinuxReno, etc.)\",\n                 tcpTypeId);\n    cmd.AddValue(\"qdiscTypeId\", \"Queue disc for gateway (e.g., ns3::CoDelQueueDisc)\", qdiscTypeId);\n    cmd.AddValue(\"segmentSize\", \"TCP segment size (bytes)\", segmentSize);\n    cmd.AddValue(\"delAckCount\", \"Delayed ack count\", delAckCount);\n    cmd.AddValue(\"enableSack\", \"Flag to enable/disable sack in TCP\", isSack);\n    cmd.AddValue(\"stopTime\",\n                 \"Stop time for applications / simulation time will be stopTime\",\n                 stopTime);\n    cmd.AddValue(\"recovery\", \"Recovery algorithm type to use (e.g., ns3::TcpPrrRecovery\", recovery);\n    cmd.Parse(argc, argv);\n\n    TypeId qdTid;\n    NS_ABORT_MSG_UNLESS(TypeId::LookupByNameFailSafe(qdiscTypeId, &qdTid),\n                        \"TypeId \" << qdiscTypeId << \" not found\");\n\n    // Set recovery algorithm and TCP variant\n    Config::SetDefault(\"ns3::TcpL4Protocol::RecoveryType\",\n                       TypeIdValue(TypeId::LookupByName(recovery)));\n    TypeId tcpTid;\n    NS_ABORT_MSG_UNLESS(TypeId::LookupByNameFailSafe(tcpTypeId, &tcpTid),\n                        \"TypeId \" << tcpTypeId << \" not found\");\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\",\n                       TypeIdValue(TypeId::LookupByName(tcpTypeId)));\n\n    // Create nodes\n    NodeContainer leftNodes;\n    NodeContainer rightNodes;\n    NodeContainer routers;\n    routers.Create(2);\n    leftNodes.Create(1);\n    rightNodes.Create(1);\n\n    std::vector<NetDeviceContainer> leftToRouter;\n    std::vector<NetDeviceContainer> routerToRight;\n\n    // Create the point-to-point link helpers and connect two router nodes\n    PointToPointHelper pointToPointRouter;\n    pointToPointRouter.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    pointToPointRouter.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    NetDeviceContainer r1r2ND = pointToPointRouter.Install(routers.Get(0), routers.Get(1));\n\n    // Create the point-to-point link helpers and connect leaf nodes to router\n    PointToPointHelper pointToPointLeaf;\n    pointToPointLeaf.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPointLeaf.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n    leftToRouter.push_back(pointToPointLeaf.Install(leftNodes.Get(0), routers.Get(0)));\n    routerToRight.push_back(pointToPointLeaf.Install(routers.Get(1), rightNodes.Get(0)));\n\n    InternetStackHelper internetStack;\n\n    internetStack.Install(leftNodes);\n    internetStack.Install(rightNodes);\n    internetStack.Install(routers);\n\n    // Assign IP addresses to all the network devices\n    Ipv4AddressHelper ipAddresses(\"10.0.0.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer r1r2IPAddress = ipAddresses.Assign(r1r2ND);\n    ipAddresses.NewNetwork();\n\n    std::vector<Ipv4InterfaceContainer> leftToRouterIPAddress;\n    leftToRouterIPAddress.push_back(ipAddresses.Assign(leftToRouter[0]));\n    ipAddresses.NewNetwork();\n\n    std::vector<Ipv4InterfaceContainer> routerToRightIPAddress;\n    routerToRightIPAddress.push_back(ipAddresses.Assign(routerToRight[0]));\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Set default sender and receiver buffer size as 1MB\n    Config::SetDefault(\"ns3::TcpSocket::SndBufSize\", UintegerValue(1 << 20));\n    Config::SetDefault(\"ns3::TcpSocket::RcvBufSize\", UintegerValue(1 << 20));\n\n    // Set default initial congestion window as 10 segments\n    Config::SetDefault(\"ns3::TcpSocket::InitialCwnd\", UintegerValue(10));\n\n    // Set default delayed ack count to a specified value\n    Config::SetDefault(\"ns3::TcpSocket::DelAckCount\", UintegerValue(delAckCount));\n\n    // Set default segment size of TCP packet to a specified value\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(segmentSize));\n\n    // Enable/Disable SACK in TCP\n    Config::SetDefault(\"ns3::TcpSocketBase::Sack\", BooleanValue(isSack));\n\n    // Create directories to store dat files\n    struct stat buffer;\n    int retVal [[maybe_unused]];\n    if ((stat(dir.c_str(), &buffer)) == 0)\n    {\n        std::string dirToRemove = \"rm -rf \" + dir;\n        retVal = system(dirToRemove.c_str());\n        NS_ASSERT_MSG(retVal == 0, \"Error in return value\");\n    }\n\n    SystemPath::MakeDirectories(dir);\n    SystemPath::MakeDirectories(dir + \"/pcap/\");\n    SystemPath::MakeDirectories(dir + \"/queueTraces/\");\n    SystemPath::MakeDirectories(dir + \"/cwndTraces/\");\n\n    // Set default parameters for queue discipline\n    Config::SetDefault(qdiscTypeId + \"::MaxSize\", QueueSizeValue(QueueSize(\"100p\")));\n\n    // Install queue discipline on router\n    TrafficControlHelper tch;\n    tch.SetRootQueueDisc(qdiscTypeId);\n    QueueDiscContainer qd;\n    tch.Uninstall(routers.Get(0)->GetDevice(0));\n    qd.Add(tch.Install(routers.Get(0)->GetDevice(0)).Get(0));\n\n    // Enable BQL\n    tch.SetQueueLimits(\"ns3::DynamicQueueLimits\");\n\n    // Open files for writing queue size and cwnd traces\n    fPlotQueue.open(dir + \"queue-size.dat\", std::ios::out);\n    fPlotCwnd.open(dir + \"cwndTraces/n0.dat\", std::ios::out);\n\n    // Calls function to check queue size\n    Simulator::ScheduleNow(&CheckQueueSize, qd.Get(0));\n\n    AsciiTraceHelper asciiTraceHelper;\n    Ptr<OutputStreamWrapper> streamWrapper;\n\n    // Create dat to store packets dropped and marked at the router\n    streamWrapper = asciiTraceHelper.CreateFileStream(dir + \"/queueTraces/drop-0.dat\");\n    qd.Get(0)->TraceConnectWithoutContext(\"Drop\", MakeBoundCallback(&DropAtQueue, streamWrapper));\n\n    // Install packet sink at receiver side\n    uint16_t port = 50000;\n    InstallPacketSink(rightNodes.Get(0), port, \"ns3::TcpSocketFactory\");\n\n    // Install BulkSend application\n    InstallBulkSend(leftNodes.Get(0),\n                    routerToRightIPAddress[0].GetAddress(1),\n                    port,\n                    socketFactory,\n                    2,\n                    0,\n                    MakeCallback(&CwndChange));\n\n    // Enable PCAP on all the point to point interfaces\n    pointToPointLeaf.EnablePcapAll(dir + \"pcap/ns-3\", true);\n\n    Simulator::Stop(stopTime);\n    Simulator::Run();\n\n    // Store queue stats in a file\n    std::ofstream myfile;\n    myfile.open(dir + \"queueStats.txt\", std::fstream::in | std::fstream::out | std::fstream::app);\n    myfile << std::endl;\n    myfile << \"Stat for Queue 1\";\n    myfile << qd.Get(0)->GetStats();\n    myfile.close();\n\n    // Store configuration of the simulation in a file\n    myfile.open(dir + \"config.txt\", std::fstream::in | std::fstream::out | std::fstream::app);\n    myfile << \"qdiscTypeId \" << qdiscTypeId << \"\\n\";\n    myfile << \"stream  \" << stream << \"\\n\";\n    myfile << \"segmentSize \" << segmentSize << \"\\n\";\n    myfile << \"delAckCount \" << delAckCount << \"\\n\";\n    myfile << \"stopTime \" << stopTime.As(Time::S) << \"\\n\";\n    myfile.close();\n\n    Simulator::Destroy();\n\n    fPlotQueue.close();\n    fPlotCwnd.close();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a complete NS-3 simulation code that models a TCP pacing scenario using a specific network topology, derived from a real-world example. The topology includes six nodes interconnected with varying bandwidths and delays, including a bottleneck link with a TCP flow crossing from node n2 to n3. Enable TCP pacing on the sockets, configure the initial congestion window, and trace various TCP metrics such as congestion window size, pacing rate, and packet transmission/reception times. Ensure to include command-line options for configuring pacing, simulation time, and other relevant TCP parameters. At the end of the simulation, print flow statistics and generate data files that track changes in these metrics."}, {"role": "assistant", "content": "//    n0                          n4\n//    |                           |\n//    |(4x Mbps, 5ms)             |(4x Mbps, 5ms)\n//    |                           |\n//    |                           |\n//    |      (x Mbps, 40ms)       |\n//    n2 ------------------------ n3\n//    |                           |\n//    |                           |\n//    |(4x Mbps, 5ms)             |(4x Mbps, 5ms)\n//    |                           |\n//    n1                          n5\n//\n//\n\n// This example illustrates how TCP pacing can be enabled on a socket.\n// Two long-running TCP flows are instantiated at nodes n0 and n1 to\n// send data over a bottleneck link (n2->n3) to sink nodes n4 and n5.\n// At the end of the simulation, the IP-level flow monitor tool will\n// print out summary statistics of the flows.  The flow monitor detects\n// four flows, but that is because the flow records are unidirectional;\n// the latter two flows reported are actually ack streams.\n//\n// At the end of this simulation, data files are also generated\n// that track changes in Congestion Window, Slow Start threshold and\n// TCP pacing rate for the first flow (n0). Additionally, a data file\n// that contains information about packet transmission and reception times\n// (collected through TxTrace and RxTrace respectively) is also produced.\n// This transmission and reception (ack) trace is the most direct way to\n// observe the effects of pacing.  All the above information is traced\n// just for the single node n0.\n//\n// A small amount of randomness is introduced to the program to control\n// the start time of the flows.\n//\n// This example has pacing enabled by default, which means that TCP\n// does not send packets back-to-back, but instead paces them out over\n// an RTT. The size of initial congestion window is set to 10, and pacing\n// of the initial window is enabled. The available command-line options and\n// their default values can be observed in the usual way by running the\n// program to print the help info; i.e.: ./ns3 run 'tcp-pacing --PrintHelp'\n//\n// When pacing is disabled, TCP sends eligible packets back-to-back. The\n// differences in behaviour when pacing is disabled can be observed from the\n// packet transmission data file. For instance, one can observe that\n// packets in the initial window are sent one after the other simultaneously,\n// without any inter-packet gaps. Another instance is when n0 receives a\n// packet in the form of an acknowledgement, and sends out data packets without\n// pacing them.\n//\n// Although this example serves as a useful demonstration of how pacing could\n// be enabled/disabled in ns-3 TCP congestion controls, we could not observe\n// significant improvements in throughput for the above topology when pacing\n// was enabled. In future, one could try and incorporate models such as\n// TCP Prague and ACK-filtering, which may show a stronger performance\n// impact for TCP pacing.\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/packet-sink.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpPacingExample\");\n\nstd::ofstream cwndStream;\nstd::ofstream pacingRateStream;\nstd::ofstream ssThreshStream;\nstd::ofstream packetTraceStream;\n\nstatic void\nCwndTracer(uint32_t oldval, uint32_t newval)\n{\n    cwndStream << std::fixed << std::setprecision(6) << Simulator::Now().GetSeconds()\n               << std::setw(12) << newval << std::endl;\n}\n\nstatic void\nPacingRateTracer(DataRate oldval, DataRate newval)\n{\n    pacingRateStream << std::fixed << std::setprecision(6) << Simulator::Now().GetSeconds()\n                     << std::setw(12) << newval.GetBitRate() / 1e6 << std::endl;\n}\n\nstatic void\nSsThreshTracer(uint32_t oldval, uint32_t newval)\n{\n    ssThreshStream << std::fixed << std::setprecision(6) << Simulator::Now().GetSeconds()\n                   << std::setw(12) << newval << std::endl;\n}\n\nstatic void\nTxTracer(Ptr<const Packet> p, Ptr<Ipv4> ipv4, uint32_t interface)\n{\n    packetTraceStream << std::fixed << std::setprecision(6) << Simulator::Now().GetSeconds()\n                      << \" tx \" << p->GetSize() << std::endl;\n}\n\nstatic void\nRxTracer(Ptr<const Packet> p, Ptr<Ipv4> ipv4, uint32_t interface)\n{\n    packetTraceStream << std::fixed << std::setprecision(6) << Simulator::Now().GetSeconds()\n                      << \" rx \" << p->GetSize() << std::endl;\n}\n\nvoid\nConnectSocketTraces()\n{\n    Config::ConnectWithoutContext(\"/NodeList/0/$ns3::TcpL4Protocol/SocketList/0/CongestionWindow\",\n                                  MakeCallback(&CwndTracer));\n    Config::ConnectWithoutContext(\"/NodeList/0/$ns3::TcpL4Protocol/SocketList/0/PacingRate\",\n                                  MakeCallback(&PacingRateTracer));\n    Config::ConnectWithoutContext(\"/NodeList/0/$ns3::TcpL4Protocol/SocketList/0/SlowStartThreshold\",\n                                  MakeCallback(&SsThreshTracer));\n    Config::ConnectWithoutContext(\"/NodeList/0/$ns3::Ipv4L3Protocol/Tx\", MakeCallback(&TxTracer));\n    Config::ConnectWithoutContext(\"/NodeList/0/$ns3::Ipv4L3Protocol/Rx\", MakeCallback(&RxTracer));\n}\n\nint\nmain(int argc, char* argv[])\n{\n    bool tracing = false;\n\n    uint32_t maxBytes = 0; // value of zero corresponds to unlimited send\n    std::string transportProtocol = \"ns3::TcpCubic\";\n\n    Time simulationEndTime = Seconds(5);\n    DataRate bottleneckBandwidth(\"10Mbps\"); // value of x as shown in the above network topology\n    Time bottleneckDelay = MilliSeconds(40);\n    DataRate regLinkBandwidth(4 * bottleneckBandwidth.GetBitRate());\n    Time regLinkDelay = MilliSeconds(5);\n    DataRate maxPacingRate(\"4Gbps\");\n\n    bool isPacingEnabled = true;\n    bool useEcn = true;\n    bool useQueueDisc = true;\n    bool shouldPaceInitialWindow = true;\n\n    // Configure defaults that are not based on explicit command-line arguments\n    // They may be overridden by general attribute configuration of command line\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\",\n                       TypeIdValue(TypeId::LookupByName(transportProtocol)));\n    Config::SetDefault(\"ns3::TcpSocket::InitialCwnd\", UintegerValue(10));\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"tracing\", \"Flag to enable/disable Ascii and Pcap tracing\", tracing);\n    cmd.AddValue(\"maxBytes\", \"Total number of bytes for application to send\", maxBytes);\n    cmd.AddValue(\"isPacingEnabled\", \"Flag to enable/disable pacing in TCP\", isPacingEnabled);\n    cmd.AddValue(\"maxPacingRate\", \"Max Pacing Rate\", maxPacingRate);\n    cmd.AddValue(\"useEcn\", \"Flag to enable/disable ECN\", useEcn);\n    cmd.AddValue(\"useQueueDisc\", \"Flag to enable/disable queue disc on bottleneck\", useQueueDisc);\n    cmd.AddValue(\"shouldPaceInitialWindow\",\n                 \"Flag to enable/disable pacing of TCP initial window\",\n                 shouldPaceInitialWindow);\n    cmd.AddValue(\"simulationEndTime\", \"Simulation end time\", simulationEndTime);\n    cmd.Parse(argc, argv);\n\n    // Configure defaults based on command-line arguments\n    Config::SetDefault(\"ns3::TcpSocketState::EnablePacing\", BooleanValue(isPacingEnabled));\n    Config::SetDefault(\"ns3::TcpSocketState::PaceInitialWindow\",\n                       BooleanValue(shouldPaceInitialWindow));\n    Config::SetDefault(\"ns3::TcpSocketBase::UseEcn\",\n                       (useEcn ? EnumValue(TcpSocketState::On) : EnumValue(TcpSocketState::Off)));\n    Config::SetDefault(\"ns3::TcpSocketState::MaxPacingRate\", DataRateValue(maxPacingRate));\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer c;\n    c.Create(6);\n\n    NS_LOG_INFO(\"Create channels.\");\n    NodeContainer n0n2 = NodeContainer(c.Get(0), c.Get(2));\n    NodeContainer n1n2 = NodeContainer(c.Get(1), c.Get(2));\n\n    NodeContainer n2n3 = NodeContainer(c.Get(2), c.Get(3));\n\n    NodeContainer n3n4 = NodeContainer(c.Get(3), c.Get(4));\n    NodeContainer n3n5 = NodeContainer(c.Get(3), c.Get(5));\n\n    // Define Node link properties\n    PointToPointHelper regLink;\n    regLink.SetDeviceAttribute(\"DataRate\", DataRateValue(regLinkBandwidth));\n    regLink.SetChannelAttribute(\"Delay\", TimeValue(regLinkDelay));\n\n    NetDeviceContainer d0d2 = regLink.Install(n0n2);\n    NetDeviceContainer d1d2 = regLink.Install(n1n2);\n    NetDeviceContainer d3d4 = regLink.Install(n3n4);\n    NetDeviceContainer d3d5 = regLink.Install(n3n5);\n\n    PointToPointHelper bottleNeckLink;\n    bottleNeckLink.SetDeviceAttribute(\"DataRate\", DataRateValue(bottleneckBandwidth));\n    bottleNeckLink.SetChannelAttribute(\"Delay\", TimeValue(bottleneckDelay));\n\n    NetDeviceContainer d2d3 = bottleNeckLink.Install(n2n3);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(c);\n\n    // Install traffic control\n    if (useQueueDisc)\n    {\n        TrafficControlHelper tchBottleneck;\n        tchBottleneck.SetRootQueueDisc(\"ns3::FqCoDelQueueDisc\");\n        tchBottleneck.Install(d2d3);\n    }\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer regLinkInterface0 = ipv4.Assign(d0d2);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer regLinkInterface1 = ipv4.Assign(d1d2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer bottleneckInterface = ipv4.Assign(d2d3);\n\n    ipv4.SetBase(\"10.1.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer regLinkInterface4 = ipv4.Assign(d3d4);\n\n    ipv4.SetBase(\"10.1.5.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer regLinkInterface5 = ipv4.Assign(d3d5);\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    // Two Sink Applications at n4 and n5\n    uint16_t sinkPort = 8080;\n    Address sinkAddress4(\n        InetSocketAddress(regLinkInterface4.GetAddress(1), sinkPort)); // interface of n4\n    Address sinkAddress5(\n        InetSocketAddress(regLinkInterface5.GetAddress(1), sinkPort)); // interface of n5\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\",\n                                      InetSocketAddress(Ipv4Address::GetAny(), sinkPort));\n    ApplicationContainer sinkApps4 = packetSinkHelper.Install(c.Get(4)); // n4 as sink\n    ApplicationContainer sinkApps5 = packetSinkHelper.Install(c.Get(5)); // n5 as sink\n\n    sinkApps4.Start(Seconds(0));\n    sinkApps4.Stop(simulationEndTime);\n    sinkApps5.Start(Seconds(0));\n    sinkApps5.Stop(simulationEndTime);\n\n    // Randomize the start time between 0 and 1ms\n    Ptr<UniformRandomVariable> uniformRv = CreateObject<UniformRandomVariable>();\n    uniformRv->SetStream(0);\n\n    // Two Source Applications at n0 and n1\n    BulkSendHelper source0(\"ns3::TcpSocketFactory\", sinkAddress4);\n    BulkSendHelper source1(\"ns3::TcpSocketFactory\", sinkAddress5);\n    // Set the amount of data to send in bytes.  Zero is unlimited.\n    source0.SetAttribute(\"MaxBytes\", UintegerValue(maxBytes));\n    source1.SetAttribute(\"MaxBytes\", UintegerValue(maxBytes));\n    ApplicationContainer sourceApps0 = source0.Install(c.Get(0));\n    ApplicationContainer sourceApps1 = source1.Install(c.Get(1));\n\n    sourceApps0.Start(MicroSeconds(uniformRv->GetInteger(0, 1000)));\n    sourceApps0.Stop(simulationEndTime);\n    sourceApps1.Start(MicroSeconds(uniformRv->GetInteger(0, 1000)));\n    sourceApps1.Stop(simulationEndTime);\n\n    if (tracing)\n    {\n        AsciiTraceHelper ascii;\n        regLink.EnableAsciiAll(ascii.CreateFileStream(\"tcp-dynamic-pacing.tr\"));\n        regLink.EnablePcapAll(\"tcp-dynamic-pacing\", false);\n    }\n\n    cwndStream.open(\"tcp-dynamic-pacing-cwnd.dat\", std::ios::out);\n    cwndStream << \"#Time(s) Congestion Window (B)\" << std::endl;\n\n    pacingRateStream.open(\"tcp-dynamic-pacing-pacing-rate.dat\", std::ios::out);\n    pacingRateStream << \"#Time(s) Pacing Rate (Mb/s)\" << std::endl;\n\n    ssThreshStream.open(\"tcp-dynamic-pacing-ssthresh.dat\", std::ios::out);\n    ssThreshStream << \"#Time(s) Slow Start threshold (B)\" << std::endl;\n\n    packetTraceStream.open(\"tcp-dynamic-pacing-packet-trace.dat\", std::ios::out);\n    packetTraceStream << \"#Time(s) tx/rx size (B)\" << std::endl;\n\n    Simulator::Schedule(MicroSeconds(1001), &ConnectSocketTraces);\n\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Stop(simulationEndTime);\n    Simulator::Run();\n\n    monitor->CheckForLostPackets();\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    FlowMonitor::FlowStatsContainer stats = monitor->GetFlowStats();\n    for (auto i = stats.begin(); i != stats.end(); ++i)\n    {\n        Ipv4FlowClassifier::FiveTuple t = classifier->FindFlow(i->first);\n\n        std::cout << \"Flow \" << i->first << \" (\" << t.sourceAddress << \" -> \"\n                  << t.destinationAddress << \")\\n\";\n        std::cout << \"  Tx Packets: \" << i->second.txPackets << \"\\n\";\n        std::cout << \"  Tx Bytes:   \" << i->second.txBytes << \"\\n\";\n        std::cout << \"  TxOffered:  \"\n                  << i->second.txBytes * 8.0 / simulationEndTime.GetSeconds() / 1000 / 1000\n                  << \" Mbps\\n\";\n        std::cout << \"  Rx Packets: \" << i->second.rxPackets << \"\\n\";\n        std::cout << \"  Rx Bytes:   \" << i->second.rxBytes << \"\\n\";\n        std::cout << \"  Throughput: \"\n                  << i->second.rxBytes * 8.0 / simulationEndTime.GetSeconds() / 1000 / 1000\n                  << \" Mbps\\n\";\n    }\n\n    cwndStream.close();\n    pacingRateStream.close();\n    ssThreshStream.close();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the NS-3 simulator that sets up a simple point-to-point network topology with two nodes, `n0` and `n1`, connected by a 500 Kbps link with a 5 ms delay. The application on node `n0` should use a `BulkSendApplication` to send data to node `n1`, which uses a `PacketSinkApplication` to receive the data. The user should be able to enable packet tracing and choose whether to use nanosecond timestamps for the pcap trace file via command-line options. The pcap trace should be written to a file named \"tcp-pcap-nanosec-example.pcap\". Ensure that IP addresses are assigned, the internet stack is installed, and the simulation runs for 10 seconds."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0 ----------- n1\n//            500 Kbps\n//             5 ms\n//\n// - Flow from n0 to n1 using BulkSendApplication.\n// - Tracing of queues and packet receptions to file \"tcp-pcap-nanosec-example.pcap\"\n//     when tracing is turned on.\n// - Trace file timestamps are recorded in nanoseconds, when requested\n//\n\n// ============================================================ //\n// NOTE: You can check the \"magic\" number of a pcap file with   //\n//       the following command:                                 //\n//                                                              //\n//                    od -N4 -tx1 filename.pcap                 //\n//                                                              //\n// ============================================================ //\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <fstream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpPcapNanosecExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    bool tracing = false;\n    bool nanosec = false;\n    uint32_t maxBytes = 0;\n\n    //\n    // Allow the user to override any of the defaults at\n    // run-time, via command-line arguments\n    //\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"tracing\", \"Flag to enable tracing\", tracing);\n    cmd.AddValue(\"nanosec\", \"Flag to use nanosecond timestamps for pcap as default\", nanosec);\n    cmd.AddValue(\"maxBytes\", \"Total number of bytes for application to send\", maxBytes);\n    cmd.Parse(argc, argv);\n\n    //\n    // If requested via the --nanosec cmdline flag, generate nanosecond timestamp for pcap traces\n    //\n    if (nanosec)\n    {\n        Config::SetDefault(\"ns3::PcapFileWrapper::NanosecMode\", BooleanValue(true));\n    }\n\n    //\n    // Explicitly create the nodes required by the topology (shown above).\n    //\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    NS_LOG_INFO(\"Create channels.\");\n\n    //\n    // Explicitly create the point-to-point link required by the topology (shown above).\n    //\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"500Kbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    //\n    // Install the internet stack on the nodes\n    //\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    //\n    // We've got the \"hardware\" in place.  Now we need to add IP addresses.\n    //\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    //\n    // Create a BulkSendApplication and install it on node 0\n    //\n    uint16_t port = 9; // well-known echo port number\n\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", InetSocketAddress(i.GetAddress(1), port));\n    // Set the amount of data to send in bytes.  Zero is unlimited.\n    source.SetAttribute(\"MaxBytes\", UintegerValue(maxBytes));\n    ApplicationContainer sourceApps = source.Install(nodes.Get(0));\n    sourceApps.Start(Seconds(0.0));\n    sourceApps.Stop(Seconds(10.0));\n\n    //\n    // Create a PacketSinkApplication and install it on node 1\n    //\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApps = sink.Install(nodes.Get(1));\n    sinkApps.Start(Seconds(0.0));\n    sinkApps.Stop(Seconds(10.0));\n\n    //\n    // Set up tracing if enabled\n    //\n    if (tracing)\n    {\n        AsciiTraceHelper ascii;\n        pointToPoint.EnablePcapAll(\"tcp-pcap-nanosec-example\", false);\n    }\n\n    //\n    // Now, do the actual simulation.\n    //\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    Ptr<PacketSink> sink1 = DynamicCast<PacketSink>(sinkApps.Get(0));\n    std::cout << \"Total Bytes Received: \" << sink1->GetTotalRx() << std::endl;\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using NS-3 to simulate a star network topology with 9 nodes, where 8 \"arm\" nodes are connected to a central \"hub\" node. The nodes on the arms will send Constant Bit Rate (CBR) traffic to the hub using TCP. Enable packet tracing and output trace files in pcap format, with filenames of the format \"tcp-star-server-\\$n-\\$i.pcap\", where `n` and `i` represent node and interface numbers. The command line should allow users to specify the number of nodes and modify the packet size and data rate of the traffic. Output should include queue and packet reception traces in the file \"tcp-star-server.tr\"."}, {"role": "assistant", "content": "// Default Network topology, 9 nodes in a star\n/*\n          n2 n3 n4\n           \\ | /\n            \\|/\n       n1---n0---n5\n            /| \\\n           / | \\\n          n8 n7 n6\n*/\n// - CBR Traffic goes from the star \"arms\" to the \"hub\"\n// - Tracing of queues and packet receptions to file\n//   \"tcp-star-server.tr\"\n// - pcap traces also generated in the following files\n//   \"tcp-star-server-$n-$i.pcap\" where n and i represent node and interface\n//   numbers respectively\n// Usage examples for things you might want to tweak:\n//       ./ns3 run \"tcp-star-server\"\n//       ./ns3 run \"tcp-star-server --nNodes=25\"\n//       ./ns3 run \"tcp-star-server --ns3::OnOffApplication::DataRate=10000\"\n//       ./ns3 run \"tcp-star-server --ns3::OnOffApplication::PacketSize=500\"\n// See the ns-3 tutorial for more info on the command line:\n// https://www.nsnam.org/docs/tutorial/html/index.html\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpServer\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Users may find it convenient to turn on explicit debugging\n    // for selected modules; the below lines suggest how to do this\n\n    // LogComponentEnable (\"TcpServer\", LOG_LEVEL_INFO);\n    // LogComponentEnable (\"TcpL4Protocol\", LOG_LEVEL_ALL);\n    // LogComponentEnable (\"TcpSocketImpl\", LOG_LEVEL_ALL);\n    // LogComponentEnable (\"PacketSink\", LOG_LEVEL_ALL);\n\n    // Set up some default values for the simulation.\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(250));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(\"5kb/s\"));\n    uint32_t N = 9; // number of nodes in the star\n\n    // Allow the user to override any of the defaults and the above\n    // Config::SetDefault()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nNodes\", \"Number of nodes to place in the star\", N);\n    cmd.Parse(argc, argv);\n\n    // Here, we will create N nodes in a star.\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer serverNode;\n    NodeContainer clientNodes;\n    serverNode.Create(1);\n    clientNodes.Create(N - 1);\n    NodeContainer allNodes = NodeContainer(serverNode, clientNodes);\n\n    // Install network stacks on the nodes\n    InternetStackHelper internet;\n    internet.Install(allNodes);\n\n    // Collect an adjacency list of nodes for the p2p topology\n    std::vector<NodeContainer> nodeAdjacencyList(N - 1);\n    for (uint32_t i = 0; i < nodeAdjacencyList.size(); ++i)\n    {\n        nodeAdjacencyList[i] = NodeContainer(serverNode, clientNodes.Get(i));\n    }\n\n    // We create the channels first without any IP addressing information\n    NS_LOG_INFO(\"Create channels.\");\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    std::vector<NetDeviceContainer> deviceAdjacencyList(N - 1);\n    for (uint32_t i = 0; i < deviceAdjacencyList.size(); ++i)\n    {\n        deviceAdjacencyList[i] = p2p.Install(nodeAdjacencyList[i]);\n    }\n\n    // Later, we add IP addresses.\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    std::vector<Ipv4InterfaceContainer> interfaceAdjacencyList(N - 1);\n    for (uint32_t i = 0; i < interfaceAdjacencyList.size(); ++i)\n    {\n        std::ostringstream subnet;\n        subnet << \"10.1.\" << i + 1 << \".0\";\n        ipv4.SetBase(subnet.str().c_str(), \"255.255.255.0\");\n        interfaceAdjacencyList[i] = ipv4.Assign(deviceAdjacencyList[i]);\n    }\n\n    // Turn on global static routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create a packet sink on the star \"hub\" to receive these packets\n    uint16_t port = 50000;\n    Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n    ApplicationContainer sinkApp = sinkHelper.Install(serverNode);\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Create the OnOff applications to send TCP to the server\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", Address());\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    // normally wouldn't need a loop here but the server IP address is different\n    // on each p2p subnet\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < clientNodes.GetN(); ++i)\n    {\n        AddressValue remoteAddress(\n            InetSocketAddress(interfaceAdjacencyList[i].GetAddress(0), port));\n        clientHelper.SetAttribute(\"Remote\", remoteAddress);\n        clientApps.Add(clientHelper.Install(clientNodes.Get(i)));\n    }\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // configure tracing\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"tcp-star-server.tr\"));\n    p2p.EnablePcapAll(\"tcp-star-server\");\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ script for an NS-3 simulation that integrates traffic control, network devices, and application setup. Start by configuring the network topology with nodes, point-to-point devices, and traffic control queues. Use the InternetStackHelper to install the traffic control layer and override the default queue configuration to explicitly configure FqCoDelQueueDiscs and dynamic queue limits on devices. Assign IPv4 addresses to devices using Ipv4AddressHelper and set up global routing tables. Implement PingHelper for sending ICMP echo requests and BulkSendHelper for TCP communication between clients and servers, configuring MaxBytes for TCP and PacketSinkHelpers for each client. Also, install queue disc tracers on the bottleneck device to monitor packet drops, marks, and queue lengths, scheduling RTT, CWND, and throughput traces. Schedule TCP traces for DCTCP if enabled, and ensure PCAP tracing if requested. Set simulation stop time, run the simulation, and close all streams after validation."}, {"role": "assistant", "content": "// This program is designed to observe long-running TCP congestion control\n// behavior over a configurable bottleneck link.  The program is also\n// instrumented to check program data against validated results, when\n// the validation option is enabled.\n//\n// ---> downstream (primary data transfer from servers to clients)\n// <--- upstream (return acks and ICMP echo response)\n//\n//              ----   bottleneck link    ----\n//  servers ---| WR |--------------------| LR |--- clients\n//              ----                      ----\n//  ns-3 node IDs:\n//  nodes 0-2    3                         4        5-7\n//\n// - The box WR is notionally a WAN router, aggregating all server links\n// - The box LR is notionally a LAN router, aggregating all client links\n// - Three servers are connected to WR, three clients are connected to LR\n//\n// clients and servers are configured for ICMP measurements and TCP throughput\n// and latency measurements in the downstream direction\n//\n// All link rates are enforced by a point-to-point (P2P) ns-3 model with full\n// duplex operation.  Dynamic queue limits\n// (BQL) are enabled to allow for queueing to occur at the priority queue layer;\n// the notional P2P hardware device queue is limited to three packets.\n//\n// One-way link delays and link rates\n// -----------------------------------\n// (1) server to WR links, 1000 Mbps, 1us delay\n// (2) bottleneck link:  configurable rate, configurable delay\n// (3) client to LR links, 1000 Mbps, 1us delay\n//\n// By default, ns-3 FQ-CoDel model is installed on all interfaces, but\n// the bottleneck queue uses CoDel by default and is configurable.\n//\n// The ns-3 FQ-CoDel model uses ns-3 defaults:\n// - 100ms interval\n// - 5ms target\n// - drop batch size of 64 packets\n// - minbytes of 1500\n//\n// Default simulation time is 70 sec.  For single flow experiments, the flow is\n// started at simulation time 5 sec; if a second flow is used, it starts\n// at 15 sec.\n//\n// ping frequency is set at 100ms.\n//\n// A command-line option to enable a step-threshold CE threshold\n// from the CoDel queue model is provided.\n//\n// Measure:\n//  - ping RTT\n//  - TCP RTT estimate\n//  - TCP throughput\n//\n// IPv4 addressing\n// ----------------------------\n// pingServer       10.1.1.2 (ping source)\n// firstServer      10.1.2.2 (data sender)\n// secondServer     10.1.3.2 (data sender)\n// pingClient       192.168.1.2\n// firstClient      192.168.2.2\n// secondClient     192.168.3.2\n//\n// Program Options:\n// ---------------\n//    --firstTcpType:   first TCP type (cubic, dctcp, or reno) [cubic]\n//    --secondTcpType:  second TCP type (cubic, dctcp, or reno) []\n//    --queueType:      bottleneck queue type (fq, codel, pie, or red) [codel]\n//    --baseRtt:        base RTT [+80ms]\n//    --ceThreshold:    CoDel CE threshold (for DCTCP) [+1ms]\n//    --linkRate:       data rate of bottleneck link [50000000bps]\n//    --stopTime:       simulation stop time [+1.16667min]\n//    --queueUseEcn:    use ECN on queue [false]\n//    --enablePcap:     enable Pcap [false]\n//    --validate:       validation case to run []\n//\n// validation cases (and syntax of how to run):\n// ------------\n// Case 'dctcp-10ms':  DCTCP single flow, 10ms base RTT, 50 Mbps link, ECN enabled, CoDel:\n//     ./ns3 run 'tcp-validation --firstTcpType=dctcp --linkRate=50Mbps --baseRtt=10ms\n//     --queueUseEcn=1 --stopTime=15s --validate=1 --validation=dctcp-10ms'\n//    - Throughput between 48 Mbps and 49 Mbps for time greater than 5.6s\n//    - DCTCP alpha below 0.1 for time greater than 5.4s\n//    - DCTCP alpha between 0.06 and 0.085 for time greater than 7s\n//\n// Case 'dctcp-80ms': DCTCP single flow, 80ms base RTT, 50 Mbps link, ECN enabled, CoDel:\n//     ./ns3 run 'tcp-validation --firstTcpType=dctcp --linkRate=50Mbps --baseRtt=80ms\n//     --queueUseEcn=1 --stopTime=40s --validate=1 --validation=dctcp-80ms'\n//    - Throughput less than 20 Mbps for time less than 14s\n//    - Throughput less than 48 Mbps for time less than 30s\n//    - Throughput between 47.5 Mbps and 48.5 for time greater than 32s\n//    - DCTCP alpha above 0.1 for time less than 7.5\n//    - DCTCP alpha below 0.01 for time greater than 11 and less than 30\n//    - DCTCP alpha between 0.015 and 0.025 for time greater than 34\n//\n// Case 'cubic-50ms-no-ecn': CUBIC single flow, 50ms base RTT, 50 Mbps link, ECN disabled, CoDel:\n//     ./ns3 run 'tcp-validation --firstTcpType=cubic --linkRate=50Mbps --baseRtt=50ms\n//     --queueUseEcn=0 --stopTime=20s --validate=1 --validation=cubic-50ms-no-ecn'\n//    - Maximum value of cwnd is 511 segments at 5.4593 seconds\n//    - cwnd decreases to 173 segments at 5.80304 seconds\n//    - cwnd reaches another local maxima around 14.2815 seconds of 236 segments\n//    - cwnd reaches a second maximum around 18.048 seconds of 234 segments\n//\n// Case 'cubic-50ms-ecn': CUBIC single flow, 50ms base RTT, 50 Mbps link, ECN enabled, CoDel:\n//     ./ns3 run 'tcp-validation --firstTcpType=cubic --linkRate=50Mbps --baseRtt=50ms\n//     --queueUseEcn=0 --stopTime=20s --validate=1 --validation=cubic-50ms-no-ecn'\n//    - Maximum value of cwnd is 511 segments at 5.4593 seconds\n//    - cwnd decreases to 173 segments at 5.7939 seconds\n//    - cwnd reaches another local maxima around 14.3477 seconds of 236 segments\n//    - cwnd reaches a second maximum around 18.064 seconds of 234 segments\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpValidation\");\n\n// These variables are declared outside of main() so that they can\n// be used in trace sinks.\nuint32_t g_firstBytesReceived = 0;  //!< First received packet size.\nuint32_t g_secondBytesReceived = 0; //!< Second received packet size.\nuint32_t g_marksObserved = 0;       //!< Number of marked packets observed.\nuint32_t g_dropsObserved = 0;       //!< Number of dropped packets observed.\nstd::string g_validate = \"\";        //!< Empty string disables validation.\nbool g_validationFailed = false;    //!< True if validation failed.\n\n/**\n * Trace first congestion window.\n *\n * \\param ofStream Output filestream.\n * \\param oldCwnd Old value.\n * \\param newCwnd new value.\n */\nvoid\nTraceFirstCwnd(std::ofstream* ofStream, uint32_t oldCwnd, uint32_t newCwnd)\n{\n    // TCP segment size is configured below to be 1448 bytes\n    // so that we can report cwnd in units of segments\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << static_cast<double>(newCwnd) / 1448\n                  << std::endl;\n    }\n    // Validation checks; both the ECN enabled and disabled cases are similar\n    if (g_validate == \"cubic-50ms-no-ecn\" || g_validate == \"cubic-50ms-ecn\")\n    {\n        double now = Simulator::Now().GetSeconds();\n        double cwnd = static_cast<double>(newCwnd) / 1448;\n        if ((now > 5.43) && (now < 5.465) && (cwnd < 500))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" cwnd \" << cwnd << \" (expected >= 500)\");\n            g_validationFailed = true;\n        }\n        else if ((now > 5.795) && (now < 6) && (cwnd > 190))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" cwnd \" << cwnd << \" (expected <= 190)\");\n            g_validationFailed = true;\n        }\n        else if ((now > 14) && (now < 14.197) && (cwnd < 224))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" cwnd \" << cwnd << \" (expected >= 224)\");\n            g_validationFailed = true;\n        }\n        else if ((now > 17) && (now < 18.026) && (cwnd < 212))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" cwnd \" << cwnd << \" (expected >= 212)\");\n            g_validationFailed = true;\n        }\n    }\n}\n\n/**\n * Trace first TcpDctcp.\n *\n * \\param ofStream Output filestream.\n * \\param bytesMarked Bytes marked.\n * \\param bytesAcked Bytes ACKed.\n * \\param alpha Alpha.\n */\nvoid\nTraceFirstDctcp(std::ofstream* ofStream, uint32_t bytesMarked, uint32_t bytesAcked, double alpha)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << alpha << std::endl;\n    }\n    // Validation checks\n    if (g_validate == \"dctcp-80ms\")\n    {\n        double now = Simulator::Now().GetSeconds();\n        if ((now < 7.5) && (alpha < 0.1))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" alpha \" << alpha << \" (expected >= 0.1)\");\n            g_validationFailed = true;\n        }\n        else if ((now > 11) && (now < 30) && (alpha > 0.01))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" alpha \" << alpha << \" (expected <= 0.01)\");\n            g_validationFailed = true;\n        }\n        else if ((now > 34) && (alpha < 0.015) && (alpha > 0.025))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" alpha \" << alpha\n                               << \" (expected 0.015 <= alpha <= 0.025)\");\n            g_validationFailed = true;\n        }\n    }\n    else if (g_validate == \"dctcp-10ms\")\n    {\n        double now = Simulator::Now().GetSeconds();\n        if ((now > 5.6) && (alpha > 0.1))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" alpha \" << alpha << \" (expected <= 0.1)\");\n            g_validationFailed = true;\n        }\n        if ((now > 7) && ((alpha > 0.09) || (alpha < 0.055)))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" alpha \" << alpha\n                               << \" (expected 0.09 <= alpha <= 0.055)\");\n            g_validationFailed = true;\n        }\n    }\n}\n\n/**\n * Trace first RTT.\n *\n * \\param ofStream Output filestream.\n * \\param oldRtt Old value.\n * \\param newRtt New value.\n */\nvoid\nTraceFirstRtt(std::ofstream* ofStream, Time oldRtt, Time newRtt)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << newRtt.GetSeconds() * 1000\n                  << std::endl;\n    }\n}\n\n/**\n * Trace second congestion window.\n *\n * \\param ofStream Output filestream.\n * \\param oldCwnd Old value.\n * \\param newCwnd new value.\n */\nvoid\nTraceSecondCwnd(std::ofstream* ofStream, uint32_t oldCwnd, uint32_t newCwnd)\n{\n    // TCP segment size is configured below to be 1448 bytes\n    // so that we can report cwnd in units of segments\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << static_cast<double>(newCwnd) / 1448\n                  << std::endl;\n    }\n}\n\n/**\n * Trace second RTT.\n *\n * \\param ofStream Output filestream.\n * \\param oldRtt Old value.\n * \\param newRtt New value.\n */\nvoid\nTraceSecondRtt(std::ofstream* ofStream, Time oldRtt, Time newRtt)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << newRtt.GetSeconds() * 1000\n                  << std::endl;\n    }\n}\n\n/**\n * Trace second TcpDctcp.\n *\n * \\param ofStream Output filestream.\n * \\param bytesMarked Bytes marked.\n * \\param bytesAcked Bytes ACKed.\n * \\param alpha Alpha.\n */\nvoid\nTraceSecondDctcp(std::ofstream* ofStream, uint32_t bytesMarked, uint32_t bytesAcked, double alpha)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << alpha << std::endl;\n    }\n}\n\n/**\n * Trace ping RTT.\n *\n * \\param ofStream Output filestream.\n * \\param rtt RTT value.\n */\nvoid\nTracePingRtt(std::ofstream* ofStream, uint16_t, Time rtt)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << rtt.GetSeconds() * 1000 << std::endl;\n    }\n}\n\n/**\n * Trace first Rx.\n *\n * \\param packet The packet.\n * \\param address The sender address.\n */\nvoid\nTraceFirstRx(Ptr<const Packet> packet, const Address& address)\n{\n    g_firstBytesReceived += packet->GetSize();\n}\n\n/**\n * Trace second Rx.\n *\n * \\param packet The packet.\n * \\param address The sender address.\n */\nvoid\nTraceSecondRx(Ptr<const Packet> packet, const Address& address)\n{\n    g_secondBytesReceived += packet->GetSize();\n}\n\n/**\n * Trace queue drop.\n *\n * \\param ofStream Output filestream.\n * \\param item The dropped QueueDiscItem.\n */\nvoid\nTraceQueueDrop(std::ofstream* ofStream, Ptr<const QueueDiscItem> item)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << std::hex << item->Hash() << std::endl;\n    }\n    g_dropsObserved++;\n}\n\n/**\n * Trace queue marks.\n *\n * \\param ofStream Output filestream.\n * \\param item The marked QueueDiscItem.\n * \\param reason The reason.\n */\nvoid\nTraceQueueMark(std::ofstream* ofStream, Ptr<const QueueDiscItem> item, const char* reason)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << std::hex << item->Hash() << std::endl;\n    }\n    g_marksObserved++;\n}\n\n/**\n * Trace queue length.\n *\n * \\param ofStream Output filestream.\n * \\param queueLinkRate Queue link rate.\n * \\param oldVal Old value.\n * \\param newVal New value.\n */\nvoid\nTraceQueueLength(std::ofstream* ofStream, DataRate queueLinkRate, uint32_t oldVal, uint32_t newVal)\n{\n    // output in units of ms\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << std::fixed\n                  << static_cast<double>(newVal * 8) / (queueLinkRate.GetBitRate() / 1000)\n                  << std::endl;\n    }\n}\n\n/**\n * Trace marks frequency.\n *\n * \\param ofStream Output filestream.\n * \\param marksSamplingInterval The mark sampling interval.\n */\nvoid\nTraceMarksFrequency(std::ofstream* ofStream, Time marksSamplingInterval)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << g_marksObserved << std::endl;\n    }\n    g_marksObserved = 0;\n    Simulator::Schedule(marksSamplingInterval,\n                        &TraceMarksFrequency,\n                        ofStream,\n                        marksSamplingInterval);\n}\n\n/**\n * Trace the first throughput.\n *\n * \\param ofStream Output filestream.\n * \\param throughputInterval The throughput interval.\n */\nvoid\nTraceFirstThroughput(std::ofstream* ofStream, Time throughputInterval)\n{\n    double throughput = g_firstBytesReceived * 8 / throughputInterval.GetSeconds() / 1e6;\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \" << throughput << std::endl;\n    }\n    g_firstBytesReceived = 0;\n    Simulator::Schedule(throughputInterval, &TraceFirstThroughput, ofStream, throughputInterval);\n    if (g_validate == \"dctcp-80ms\")\n    {\n        double now = Simulator::Now().GetSeconds();\n        if ((now < 14) && (throughput > 20))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" throughput \" << throughput\n                               << \" (expected <= 20)\");\n            g_validationFailed = true;\n        }\n        if ((now < 30) && (throughput > 48))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" throughput \" << throughput\n                               << \" (expected <= 48)\");\n            g_validationFailed = true;\n        }\n        if ((now > 32) && ((throughput < 47.5) || (throughput > 48.5)))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" throughput \" << throughput\n                               << \" (expected 47.5 <= throughput <= 48.5)\");\n            g_validationFailed = true;\n        }\n    }\n    else if (g_validate == \"dctcp-10ms\")\n    {\n        double now = Simulator::Now().GetSeconds();\n        if ((now > 5.6) && ((throughput < 48) || (throughput > 49)))\n        {\n            NS_LOG_WARN(\"now \" << Now().As(Time::S) << \" throughput \" << throughput\n                               << \" (expected 48 <= throughput <= 49)\");\n            g_validationFailed = true;\n        }\n    }\n}\n\n/**\n * Trace the second throughput.\n *\n * \\param ofStream Output filestream.\n * \\param throughputInterval The throughput interval.\n */\nvoid\nTraceSecondThroughput(std::ofstream* ofStream, Time throughputInterval)\n{\n    if (g_validate.empty())\n    {\n        *ofStream << Simulator::Now().GetSeconds() << \" \"\n                  << g_secondBytesReceived * 8 / throughputInterval.GetSeconds() / 1e6 << std::endl;\n    }\n    g_secondBytesReceived = 0;\n    Simulator::Schedule(throughputInterval, &TraceSecondThroughput, ofStream, throughputInterval);\n}\n\n/**\n * Schedule trace connection.\n *\n * \\param ofStream Output filestream.\n */\nvoid\nScheduleFirstTcpCwndTraceConnection(std::ofstream* ofStream)\n{\n    Config::ConnectWithoutContextFailSafe(\n        \"/NodeList/1/$ns3::TcpL4Protocol/SocketList/0/CongestionWindow\",\n        MakeBoundCallback(&TraceFirstCwnd, ofStream));\n}\n\n/**\n * Schedule trace connection.\n *\n * \\param ofStream Output filestream.\n */\nvoid\nScheduleFirstTcpRttTraceConnection(std::ofstream* ofStream)\n{\n    Config::ConnectWithoutContextFailSafe(\"/NodeList/1/$ns3::TcpL4Protocol/SocketList/0/RTT\",\n                                          MakeBoundCallback(&TraceFirstRtt, ofStream));\n}\n\n/**\n * Schedule trace connection.\n *\n * \\param ofStream Output filestream.\n */\nvoid\nScheduleFirstDctcpTraceConnection(std::ofstream* ofStream)\n{\n    Config::ConnectWithoutContextFailSafe(\"/NodeList/1/$ns3::TcpL4Protocol/SocketList/0/\"\n                                          \"CongestionOps/$ns3::TcpDctcp/CongestionEstimate\",\n                                          MakeBoundCallback(&TraceFirstDctcp, ofStream));\n}\n\n/**\n * Schedule trace connection.\n *\n * \\param ofStream Output filestream.\n */\nvoid\nScheduleSecondDctcpTraceConnection(std::ofstream* ofStream)\n{\n    Config::ConnectWithoutContextFailSafe(\"/NodeList/2/$ns3::TcpL4Protocol/SocketList/0/\"\n                                          \"CongestionOps/$ns3::TcpDctcp/CongestionEstimate\",\n                                          MakeBoundCallback(&TraceSecondDctcp, ofStream));\n}\n\n/**\n * Schedule trace connection.\n */\nvoid\nScheduleFirstPacketSinkConnection()\n{\n    Config::ConnectWithoutContextFailSafe(\"/NodeList/6/ApplicationList/*/$ns3::PacketSink/Rx\",\n                                          MakeCallback(&TraceFirstRx));\n}\n\n/**\n * Schedule trace connection.\n *\n * \\param ofStream Output filestream.\n */\nvoid\nScheduleSecondTcpCwndTraceConnection(std::ofstream* ofStream)\n{\n    Config::ConnectWithoutContext(\"/NodeList/2/$ns3::TcpL4Protocol/SocketList/0/CongestionWindow\",\n                                  MakeBoundCallback(&TraceSecondCwnd, ofStream));\n}\n\n/**\n * Schedule trace connection.\n *\n * \\param ofStream Output filestream.\n */\nvoid\nScheduleSecondTcpRttTraceConnection(std::ofstream* ofStream)\n{\n    Config::ConnectWithoutContext(\"/NodeList/2/$ns3::TcpL4Protocol/SocketList/0/RTT\",\n                                  MakeBoundCallback(&TraceSecondRtt, ofStream));\n}\n\n/**\n * Schedule trace connection.\n */\nvoid\nScheduleSecondPacketSinkConnection()\n{\n    Config::ConnectWithoutContext(\"/NodeList/7/ApplicationList/*/$ns3::PacketSink/Rx\",\n                                  MakeCallback(&TraceSecondRx));\n}\n\nint\nmain(int argc, char* argv[])\n{\n    ////////////////////////////////////////////////////////////\n    // variables not configured at command line               //\n    ////////////////////////////////////////////////////////////\n    uint32_t pingSize = 100; // bytes\n    bool enableSecondTcp = false;\n    bool enableLogging = false;\n    Time pingInterval = MilliSeconds(100);\n    Time marksSamplingInterval = MilliSeconds(100);\n    Time throughputSamplingInterval = MilliSeconds(200);\n    std::string pingTraceFile = \"tcp-validation-ping.dat\";\n    std::string firstTcpRttTraceFile = \"tcp-validation-first-tcp-rtt.dat\";\n    std::string firstTcpCwndTraceFile = \"tcp-validation-first-tcp-cwnd.dat\";\n    std::string firstDctcpTraceFile = \"tcp-validation-first-dctcp-alpha.dat\";\n    std::string firstTcpThroughputTraceFile = \"tcp-validation-first-tcp-throughput.dat\";\n    std::string secondTcpRttTraceFile = \"tcp-validation-second-tcp-rtt.dat\";\n    std::string secondTcpCwndTraceFile = \"tcp-validation-second-tcp-cwnd.dat\";\n    std::string secondTcpThroughputTraceFile = \"tcp-validation-second-tcp-throughput.dat\";\n    std::string secondDctcpTraceFile = \"tcp-validation-second-dctcp-alpha.dat\";\n    std::string queueMarkTraceFile = \"tcp-validation-queue-mark.dat\";\n    std::string queueDropTraceFile = \"tcp-validation-queue-drop.dat\";\n    std::string queueMarksFrequencyTraceFile = \"tcp-validation-queue-marks-frequency.dat\";\n    std::string queueLengthTraceFile = \"tcp-validation-queue-length.dat\";\n\n    ////////////////////////////////////////////////////////////\n    // variables configured at command line                   //\n    ////////////////////////////////////////////////////////////\n    std::string firstTcpType = \"cubic\";\n    std::string secondTcpType = \"\";\n    std::string queueType = \"codel\";\n    Time stopTime = Seconds(70);\n    Time baseRtt = MilliSeconds(80);\n    DataRate linkRate(\"50Mbps\");\n    bool queueUseEcn = false;\n    Time ceThreshold = MilliSeconds(1);\n    bool enablePcap = false;\n\n    ////////////////////////////////////////////////////////////\n    // Override ns-3 defaults                                 //\n    ////////////////////////////////////////////////////////////\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(1448));\n    // Increase default buffer sizes to improve throughput over long delay paths\n    // Config::SetDefault (\"ns3::TcpSocket::SndBufSize\",UintegerValue (8192000));\n    // Config::SetDefault (\"ns3::TcpSocket::RcvBufSize\",UintegerValue (8192000));\n    Config::SetDefault(\"ns3::TcpSocket::SndBufSize\", UintegerValue(32768000));\n    Config::SetDefault(\"ns3::TcpSocket::RcvBufSize\", UintegerValue(32768000));\n    Config::SetDefault(\"ns3::TcpSocket::InitialCwnd\", UintegerValue(10));\n    Config::SetDefault(\"ns3::TcpL4Protocol::RecoveryType\",\n                       TypeIdValue(TcpPrrRecovery::GetTypeId()));\n    // Validation criteria were written for TCP Cubic without Reno-friendly behavior, so disable it\n    // for these tests\n    Config::SetDefault(\"ns3::TcpCubic::TcpFriendliness\", BooleanValue(false));\n\n    ////////////////////////////////////////////////////////////\n    // command-line argument parsing                          //\n    ////////////////////////////////////////////////////////////\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"firstTcpType\", \"first TCP type (cubic, dctcp, or reno)\", firstTcpType);\n    cmd.AddValue(\"secondTcpType\", \"second TCP type (cubic, dctcp, or reno)\", secondTcpType);\n    cmd.AddValue(\"queueType\", \"bottleneck queue type (fq, codel, pie, or red)\", queueType);\n    cmd.AddValue(\"baseRtt\", \"base RTT\", baseRtt);\n    cmd.AddValue(\"ceThreshold\", \"CoDel CE threshold (for DCTCP)\", ceThreshold);\n    cmd.AddValue(\"linkRate\", \"data rate of bottleneck link\", linkRate);\n    cmd.AddValue(\"stopTime\", \"simulation stop time\", stopTime);\n    cmd.AddValue(\"queueUseEcn\", \"use ECN on queue\", queueUseEcn);\n    cmd.AddValue(\"enablePcap\", \"enable Pcap\", enablePcap);\n    cmd.AddValue(\"validate\", \"validation case to run\", g_validate);\n    cmd.Parse(argc, argv);\n\n    // If validation is selected, perform some configuration checks\n    if (!g_validate.empty())\n    {\n        NS_ABORT_MSG_UNLESS(g_validate == \"dctcp-10ms\" || g_validate == \"dctcp-80ms\" ||\n                                g_validate == \"cubic-50ms-no-ecn\" || g_validate == \"cubic-50ms-ecn\",\n                            \"Unknown test\");\n        if (g_validate == \"dctcp-10ms\" || g_validate == \"dctcp-80ms\")\n        {\n            NS_ABORT_MSG_UNLESS(firstTcpType == \"dctcp\", \"Incorrect TCP\");\n            NS_ABORT_MSG_UNLESS(secondTcpType.empty(), \"Incorrect TCP\");\n            NS_ABORT_MSG_UNLESS(linkRate == DataRate(\"50Mbps\"), \"Incorrect data rate\");\n            NS_ABORT_MSG_UNLESS(queueUseEcn == true, \"Incorrect ECN configuration\");\n            NS_ABORT_MSG_UNLESS(stopTime >= Seconds(15), \"Incorrect stopTime\");\n            if (g_validate == \"dctcp-10ms\")\n            {\n                NS_ABORT_MSG_UNLESS(baseRtt == MilliSeconds(10), \"Incorrect RTT\");\n            }\n            else if (g_validate == \"dctcp-80ms\")\n            {\n                NS_ABORT_MSG_UNLESS(baseRtt == MilliSeconds(80), \"Incorrect RTT\");\n            }\n        }\n        else if (g_validate == \"cubic-50ms-no-ecn\" || g_validate == \"cubic-50ms-ecn\")\n        {\n            NS_ABORT_MSG_UNLESS(firstTcpType == \"cubic\", \"Incorrect TCP\");\n            NS_ABORT_MSG_UNLESS(secondTcpType.empty(), \"Incorrect TCP\");\n            NS_ABORT_MSG_UNLESS(baseRtt == MilliSeconds(50), \"Incorrect RTT\");\n            NS_ABORT_MSG_UNLESS(linkRate == DataRate(\"50Mbps\"), \"Incorrect data rate\");\n            NS_ABORT_MSG_UNLESS(stopTime >= Seconds(20), \"Incorrect stopTime\");\n            if (g_validate == \"cubic-50ms-no-ecn\")\n            {\n                NS_ABORT_MSG_UNLESS(queueUseEcn == false, \"Incorrect ECN configuration\");\n            }\n            else if (g_validate == \"cubic-50ms-ecn\")\n            {\n                NS_ABORT_MSG_UNLESS(queueUseEcn == true, \"Incorrect ECN configuration\");\n            }\n        }\n    }\n\n    if (enableLogging)\n    {\n        LogComponentEnable(\n            \"TcpSocketBase\",\n            (LogLevel)(LOG_PREFIX_FUNC | LOG_PREFIX_NODE | LOG_PREFIX_TIME | LOG_LEVEL_ALL));\n        LogComponentEnable(\n            \"TcpDctcp\",\n            (LogLevel)(LOG_PREFIX_FUNC | LOG_PREFIX_NODE | LOG_PREFIX_TIME | LOG_LEVEL_ALL));\n    }\n\n    Time oneWayDelay = baseRtt / 2;\n\n    TypeId firstTcpTypeId;\n    if (firstTcpType == \"reno\")\n    {\n        firstTcpTypeId = TcpLinuxReno::GetTypeId();\n    }\n    else if (firstTcpType == \"cubic\")\n    {\n        firstTcpTypeId = TcpCubic::GetTypeId();\n    }\n    else if (firstTcpType == \"dctcp\")\n    {\n        firstTcpTypeId = TcpDctcp::GetTypeId();\n        Config::SetDefault(\"ns3::CoDelQueueDisc::CeThreshold\", TimeValue(ceThreshold));\n        Config::SetDefault(\"ns3::FqCoDelQueueDisc::CeThreshold\", TimeValue(ceThreshold));\n        if (!queueUseEcn)\n        {\n            std::cout << \"Warning: using DCTCP with queue ECN disabled\" << std::endl;\n        }\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Fatal error:  tcp unsupported\");\n    }\n    TypeId secondTcpTypeId;\n    if (secondTcpType == \"reno\")\n    {\n        enableSecondTcp = true;\n        secondTcpTypeId = TcpLinuxReno::GetTypeId();\n    }\n    else if (secondTcpType == \"cubic\")\n    {\n        enableSecondTcp = true;\n        secondTcpTypeId = TcpCubic::GetTypeId();\n    }\n    else if (secondTcpType == \"dctcp\")\n    {\n        enableSecondTcp = true;\n        secondTcpTypeId = TcpDctcp::GetTypeId();\n    }\n    else if (secondTcpType.empty())\n    {\n        enableSecondTcp = false;\n        NS_LOG_DEBUG(\"No second TCP selected\");\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Fatal error:  tcp unsupported\");\n    }\n    TypeId queueTypeId;\n    if (queueType == \"fq\")\n    {\n        queueTypeId = FqCoDelQueueDisc::GetTypeId();\n    }\n    else if (queueType == \"codel\")\n    {\n        queueTypeId = CoDelQueueDisc::GetTypeId();\n    }\n    else if (queueType == \"pie\")\n    {\n        queueTypeId = PieQueueDisc::GetTypeId();\n    }\n    else if (queueType == \"red\")\n    {\n        queueTypeId = RedQueueDisc::GetTypeId();\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Fatal error:  queueType unsupported\");\n    }\n\n    if (queueUseEcn)\n    {\n        Config::SetDefault(\"ns3::CoDelQueueDisc::UseEcn\", BooleanValue(true));\n        Config::SetDefault(\"ns3::FqCoDelQueueDisc::UseEcn\", BooleanValue(true));\n        Config::SetDefault(\"ns3::PieQueueDisc::UseEcn\", BooleanValue(true));\n        Config::SetDefault(\"ns3::RedQueueDisc::UseEcn\", BooleanValue(true));\n    }\n    // Enable TCP to use ECN regardless\n    Config::SetDefault(\"ns3::TcpSocketBase::UseEcn\", StringValue(\"On\"));\n\n    // Report on configuration\n    if (enableSecondTcp)\n    {\n        NS_LOG_DEBUG(\"first TCP: \" << firstTcpTypeId.GetName()\n                                   << \"; second TCP: \" << secondTcpTypeId.GetName()\n                                   << \"; queue: \" << queueTypeId.GetName()\n                                   << \"; ceThreshold: \" << ceThreshold.GetSeconds() * 1000 << \"ms\");\n    }\n    else\n    {\n        NS_LOG_DEBUG(\"first TCP: \" << firstTcpTypeId.GetName()\n                                   << \"; queue: \" << queueTypeId.GetName()\n                                   << \"; ceThreshold: \" << ceThreshold.GetSeconds() * 1000 << \"ms\");\n    }\n\n    // Write traces only if we are not in validation mode (g_validate == \"\")\n    std::ofstream pingOfStream;\n    std::ofstream firstTcpRttOfStream;\n    std::ofstream firstTcpCwndOfStream;\n    std::ofstream firstTcpThroughputOfStream;\n    std::ofstream firstTcpDctcpOfStream;\n    std::ofstream secondTcpRttOfStream;\n    std::ofstream secondTcpCwndOfStream;\n    std::ofstream secondTcpThroughputOfStream;\n    std::ofstream secondTcpDctcpOfStream;\n    std::ofstream queueDropOfStream;\n    std::ofstream queueMarkOfStream;\n    std::ofstream queueMarksFrequencyOfStream;\n    std::ofstream queueLengthOfStream;\n    if (g_validate.empty())\n    {\n        pingOfStream.open(pingTraceFile, std::ofstream::out);\n        firstTcpRttOfStream.open(firstTcpRttTraceFile, std::ofstream::out);\n        firstTcpCwndOfStream.open(firstTcpCwndTraceFile, std::ofstream::out);\n        firstTcpThroughputOfStream.open(firstTcpThroughputTraceFile, std::ofstream::out);\n        if (firstTcpType == \"dctcp\")\n        {\n            firstTcpDctcpOfStream.open(firstDctcpTraceFile, std::ofstream::out);\n        }\n        if (enableSecondTcp)\n        {\n            secondTcpRttOfStream.open(secondTcpRttTraceFile, std::ofstream::out);\n            secondTcpCwndOfStream.open(secondTcpCwndTraceFile, std::ofstream::out);\n            secondTcpThroughputOfStream.open(secondTcpThroughputTraceFile, std::ofstream::out);\n            if (secondTcpType == \"dctcp\")\n            {\n                secondTcpDctcpOfStream.open(secondDctcpTraceFile, std::ofstream::out);\n            }\n        }\n        queueDropOfStream.open(queueDropTraceFile, std::ofstream::out);\n        queueMarkOfStream.open(queueMarkTraceFile, std::ofstream::out);\n        queueMarksFrequencyOfStream.open(queueMarksFrequencyTraceFile, std::ofstream::out);\n        queueLengthOfStream.open(queueLengthTraceFile, std::ofstream::out);\n    }\n\n    ////////////////////////////////////////////////////////////\n    // scenario setup                                         //\n    ////////////////////////////////////////////////////////////\n    Ptr<Node> pingServer = CreateObject<Node>();\n    Ptr<Node> firstServer = CreateObject<Node>();\n    Ptr<Node> secondServer = CreateObject<Node>();\n    Ptr<Node> wanRouter = CreateObject<Node>();\n    Ptr<Node> lanRouter = CreateObject<Node>();\n    Ptr<Node> pingClient = CreateObject<Node>();\n    Ptr<Node> firstClient = CreateObject<Node>();\n    Ptr<Node> secondClient = CreateObject<Node>();\n\n    // Device containers\n    NetDeviceContainer pingServerDevices;\n    NetDeviceContainer firstServerDevices;\n    NetDeviceContainer secondServerDevices;\n    NetDeviceContainer wanLanDevices;\n    NetDeviceContainer pingClientDevices;\n    NetDeviceContainer firstClientDevices;\n    NetDeviceContainer secondClientDevices;\n\n    PointToPointHelper p2p;\n    p2p.SetQueue(\"ns3::DropTailQueue\", \"MaxSize\", QueueSizeValue(QueueSize(\"3p\")));\n    p2p.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(\"1000Mbps\")));\n    // Add delay only on the WAN links\n    p2p.SetChannelAttribute(\"Delay\", TimeValue(MicroSeconds(1)));\n    pingServerDevices = p2p.Install(wanRouter, pingServer);\n    firstServerDevices = p2p.Install(wanRouter, firstServer);\n    secondServerDevices = p2p.Install(wanRouter, secondServer);\n    p2p.SetChannelAttribute(\"Delay\", TimeValue(oneWayDelay));\n    wanLanDevices = p2p.Install(wanRouter, lanRouter);\n    p2p.SetQueue(\"ns3::DropTailQueue\", \"MaxSize\", QueueSizeValue(QueueSize(\"3p\")));\n    p2p.SetChannelAttribute(\"Delay\", TimeValue(MicroSeconds(1)));\n    pingClientDevices = p2p.Install(lanRouter, pingClient);\n    firstClientDevices = p2p.Install(lanRouter, firstClient);\n    secondClientDevices = p2p.Install(lanRouter, secondClient);\n\n    // Limit the bandwidth on the wanRouter->lanRouter interface\n    Ptr<PointToPointNetDevice> p = wanLanDevices.Get(0)->GetObject<PointToPointNetDevice>();\n    p->SetAttribute(\"DataRate\", DataRateValue(linkRate));\n\n    InternetStackHelper stackHelper;\n    stackHelper.Install(pingServer);\n    Ptr<TcpL4Protocol> proto;\n    stackHelper.Install(firstServer);\n    proto = firstServer->GetObject<TcpL4Protocol>();\n    proto->SetAttribute(\"SocketType\", TypeIdValue(firstTcpTypeId));\n    stackHelper.Install(secondServer);\n    stackHelper.Install(wanRouter);\n    stackHelper.Install(lanRouter);\n    stackHelper.Install(pingClient);\n\n    stackHelper.Install(firstClient);\n    // Set the per-node TCP type here\n    proto = firstClient->GetObject<TcpL4Protocol>();\n    proto->SetAttribute(\"SocketType\", TypeIdValue(firstTcpTypeId));\n    stackHelper.Install(secondClient);\n\n    if (enableSecondTcp)\n    {\n        proto = secondClient->GetObject<TcpL4Protocol>();\n        proto->SetAttribute(\"SocketType\", TypeIdValue(secondTcpTypeId));\n        proto = secondServer->GetObject<TcpL4Protocol>();\n        proto->SetAttribute(\"SocketType\", TypeIdValue(secondTcpTypeId));\n    }\n\n    // InternetStackHelper will install a base TrafficControlLayer on the node,\n    // but the Ipv4AddressHelper below will install the default FqCoDelQueueDisc\n    // on all single device nodes.  The below code overrides the configuration\n    // that is normally done by the Ipv4AddressHelper::Install() method by\n    // instead explicitly configuring the queue discs we want on each device.\n    TrafficControlHelper tchFq;\n    tchFq.SetRootQueueDisc(\"ns3::FqCoDelQueueDisc\");\n    tchFq.SetQueueLimits(\"ns3::DynamicQueueLimits\", \"HoldTime\", StringValue(\"1ms\"));\n    tchFq.Install(pingServerDevices);\n    tchFq.Install(firstServerDevices);\n    tchFq.Install(secondServerDevices);\n    tchFq.Install(wanLanDevices.Get(1));\n    tchFq.Install(pingClientDevices);\n    tchFq.Install(firstClientDevices);\n    tchFq.Install(secondClientDevices);\n    // Install queue for bottleneck link\n    TrafficControlHelper tchBottleneck;\n    tchBottleneck.SetRootQueueDisc(queueTypeId.GetName());\n    tchBottleneck.SetQueueLimits(\"ns3::DynamicQueueLimits\", \"HoldTime\", StringValue(\"1ms\"));\n    tchBottleneck.Install(wanLanDevices.Get(0));\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer pingServerIfaces = ipv4.Assign(pingServerDevices);\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer firstServerIfaces = ipv4.Assign(firstServerDevices);\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer secondServerIfaces = ipv4.Assign(secondServerDevices);\n    ipv4.SetBase(\"172.16.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer wanLanIfaces = ipv4.Assign(wanLanDevices);\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer pingClientIfaces = ipv4.Assign(pingClientDevices);\n    ipv4.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer firstClientIfaces = ipv4.Assign(firstClientDevices);\n    ipv4.SetBase(\"192.168.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer secondClientIfaces = ipv4.Assign(secondClientDevices);\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    ////////////////////////////////////////////////////////////\n    // application setup                                      //\n    ////////////////////////////////////////////////////////////\n    PingHelper pingHelper(Ipv4Address(\"192.168.1.2\"));\n    pingHelper.SetAttribute(\"Interval\", TimeValue(pingInterval));\n    pingHelper.SetAttribute(\"Size\", UintegerValue(pingSize));\n    pingHelper.SetAttribute(\"VerboseMode\", EnumValue(Ping::VerboseMode::SILENT));\n    ApplicationContainer pingContainer = pingHelper.Install(pingServer);\n    Ptr<Ping> ping = pingContainer.Get(0)->GetObject<Ping>();\n    ping->TraceConnectWithoutContext(\"Rtt\", MakeBoundCallback(&TracePingRtt, &pingOfStream));\n    pingContainer.Start(Seconds(1));\n    pingContainer.Stop(stopTime - Seconds(1));\n\n    ApplicationContainer firstApp;\n    uint16_t firstPort = 5000;\n    BulkSendHelper tcp(\"ns3::TcpSocketFactory\", Address());\n    // set to large value:  e.g. 1000 Mb/s for 60 seconds = 7500000000 bytes\n    tcp.SetAttribute(\"MaxBytes\", UintegerValue(7500000000));\n    // Configure first TCP client/server pair\n    InetSocketAddress firstDestAddress(firstClientIfaces.GetAddress(1), firstPort);\n    tcp.SetAttribute(\"Remote\", AddressValue(firstDestAddress));\n    firstApp = tcp.Install(firstServer);\n    firstApp.Start(Seconds(5));\n    firstApp.Stop(stopTime - Seconds(1));\n\n    Address firstSinkAddress(InetSocketAddress(Ipv4Address::GetAny(), firstPort));\n    ApplicationContainer firstSinkApp;\n    PacketSinkHelper firstSinkHelper(\"ns3::TcpSocketFactory\", firstSinkAddress);\n    firstSinkApp = firstSinkHelper.Install(firstClient);\n    firstSinkApp.Start(Seconds(5));\n    firstSinkApp.Stop(stopTime - MilliSeconds(500));\n\n    // Configure second TCP client/server pair\n    if (enableSecondTcp)\n    {\n        BulkSendHelper tcp(\"ns3::TcpSocketFactory\", Address());\n        uint16_t secondPort = 5000;\n        ApplicationContainer secondApp;\n        InetSocketAddress secondDestAddress(secondClientIfaces.GetAddress(1), secondPort);\n        tcp.SetAttribute(\"Remote\", AddressValue(secondDestAddress));\n        secondApp = tcp.Install(secondServer);\n        secondApp.Start(Seconds(15));\n        secondApp.Stop(stopTime - Seconds(1));\n\n        Address secondSinkAddress(InetSocketAddress(Ipv4Address::GetAny(), secondPort));\n        PacketSinkHelper secondSinkHelper(\"ns3::TcpSocketFactory\", secondSinkAddress);\n        ApplicationContainer secondSinkApp;\n        secondSinkApp = secondSinkHelper.Install(secondClient);\n        secondSinkApp.Start(Seconds(15));\n        secondSinkApp.Stop(stopTime - MilliSeconds(500));\n    }\n\n    // Setup traces that can be hooked now\n    Ptr<TrafficControlLayer> tc;\n    Ptr<QueueDisc> qd;\n    // Trace drops and marks for bottleneck\n    tc = wanLanDevices.Get(0)->GetNode()->GetObject<TrafficControlLayer>();\n    qd = tc->GetRootQueueDiscOnDevice(wanLanDevices.Get(0));\n    qd->TraceConnectWithoutContext(\"Drop\", MakeBoundCallback(&TraceQueueDrop, &queueDropOfStream));\n    qd->TraceConnectWithoutContext(\"Mark\", MakeBoundCallback(&TraceQueueMark, &queueMarkOfStream));\n    qd->TraceConnectWithoutContext(\n        \"BytesInQueue\",\n        MakeBoundCallback(&TraceQueueLength, &queueLengthOfStream, linkRate));\n\n    // Setup scheduled traces; TCP traces must be hooked after socket creation\n    Simulator::Schedule(Seconds(5) + MilliSeconds(100),\n                        &ScheduleFirstTcpRttTraceConnection,\n                        &firstTcpRttOfStream);\n    Simulator::Schedule(Seconds(5) + MilliSeconds(100),\n                        &ScheduleFirstTcpCwndTraceConnection,\n                        &firstTcpCwndOfStream);\n    Simulator::Schedule(Seconds(5) + MilliSeconds(100), &ScheduleFirstPacketSinkConnection);\n    if (firstTcpType == \"dctcp\")\n    {\n        Simulator::Schedule(Seconds(5) + MilliSeconds(100),\n                            &ScheduleFirstDctcpTraceConnection,\n                            &firstTcpDctcpOfStream);\n    }\n    Simulator::Schedule(throughputSamplingInterval,\n                        &TraceFirstThroughput,\n                        &firstTcpThroughputOfStream,\n                        throughputSamplingInterval);\n    if (enableSecondTcp)\n    {\n        // Setup scheduled traces; TCP traces must be hooked after socket creation\n        Simulator::Schedule(Seconds(15) + MilliSeconds(100),\n                            &ScheduleSecondTcpRttTraceConnection,\n                            &secondTcpRttOfStream);\n        Simulator::Schedule(Seconds(15) + MilliSeconds(100),\n                            &ScheduleSecondTcpCwndTraceConnection,\n                            &secondTcpCwndOfStream);\n        Simulator::Schedule(Seconds(15) + MilliSeconds(100), &ScheduleSecondPacketSinkConnection);\n        Simulator::Schedule(throughputSamplingInterval,\n                            &TraceSecondThroughput,\n                            &secondTcpThroughputOfStream,\n                            throughputSamplingInterval);\n        if (secondTcpType == \"dctcp\")\n        {\n            Simulator::Schedule(Seconds(15) + MilliSeconds(100),\n                                &ScheduleSecondDctcpTraceConnection,\n                                &secondTcpDctcpOfStream);\n        }\n    }\n    Simulator::Schedule(marksSamplingInterval,\n                        &TraceMarksFrequency,\n                        &queueMarksFrequencyOfStream,\n                        marksSamplingInterval);\n\n    if (enablePcap)\n    {\n        p2p.EnablePcapAll(\"tcp-validation\", false);\n    }\n\n    Simulator::Stop(stopTime);\n    Simulator::Run();\n    Simulator::Destroy();\n\n    if (g_validate.empty())\n    {\n        pingOfStream.close();\n        firstTcpCwndOfStream.close();\n        firstTcpRttOfStream.close();\n        if (firstTcpType == \"dctcp\")\n        {\n            firstTcpDctcpOfStream.close();\n        }\n        firstTcpThroughputOfStream.close();\n        if (enableSecondTcp)\n        {\n            secondTcpCwndOfStream.close();\n            secondTcpRttOfStream.close();\n            secondTcpThroughputOfStream.close();\n            if (secondTcpType == \"dctcp\")\n            {\n                secondTcpDctcpOfStream.close();\n            }\n        }\n        queueDropOfStream.close();\n        queueMarkOfStream.close();\n        queueMarksFrequencyOfStream.close();\n        queueLengthOfStream.close();\n    }\n\n    if (g_validationFailed)\n    {\n        NS_FATAL_ERROR(\"Validation failed\");\n    }\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ code implementation for the TCP Westwood(+) protocol in ns-3. The code should import necessary ns-3 modules like applications-module, core-module, and internet-module, among others. It should define congestion window, slow start threshold, RTT, and RTO tracing mechanisms using maps and output streams, connecting them to relevant TCP properties. Include functions to trace and log TCP performance metrics such as congestion window, slow start threshold, RTT, RTO, and in-flight bytes. Ensure the code includes commands for setting simulation parameters like bandwidth, delay, packet error rate, and TCP variant selection, with appropriate helper functions to configure the network topology, install applications, and set up tracing for multiple flows."}, {"role": "assistant", "content": "/*\n * \"TCP Westwood(+) Protocol Implementation in ns-3\"\n * Siddharth Gangadhar, Trúc Anh Ngọc Nguyễn , Greeshma Umapathi, and James P.G. Sterbenz,\n * ICST SIMUTools Workshop on ns-3 (WNS3), Cannes, France, March 2013\n */\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/enum.h\"\n#include \"ns3/error-model.h\"\n#include \"ns3/event-id.h\"\n#include \"ns3/flow-monitor-helper.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/tcp-header.h\"\n#include \"ns3/traffic-control-module.h\"\n#include \"ns3/udp-header.h\"\n\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpVariantsComparison\");\n\nstatic std::map<uint32_t, bool> firstCwnd;                      //!< First congestion window.\nstatic std::map<uint32_t, bool> firstSshThr;                    //!< First SlowStart threshold.\nstatic std::map<uint32_t, bool> firstRtt;                       //!< First RTT.\nstatic std::map<uint32_t, bool> firstRto;                       //!< First RTO.\nstatic std::map<uint32_t, Ptr<OutputStreamWrapper>> cWndStream; //!< Congstion window output stream.\nstatic std::map<uint32_t, Ptr<OutputStreamWrapper>>\n    ssThreshStream; //!< SlowStart threshold output stream.\nstatic std::map<uint32_t, Ptr<OutputStreamWrapper>> rttStream;      //!< RTT output stream.\nstatic std::map<uint32_t, Ptr<OutputStreamWrapper>> rtoStream;      //!< RTO output stream.\nstatic std::map<uint32_t, Ptr<OutputStreamWrapper>> nextTxStream;   //!< Next TX output stream.\nstatic std::map<uint32_t, Ptr<OutputStreamWrapper>> nextRxStream;   //!< Next RX output stream.\nstatic std::map<uint32_t, Ptr<OutputStreamWrapper>> inFlightStream; //!< In flight output stream.\nstatic std::map<uint32_t, uint32_t> cWndValue;                      //!< congestion window value.\nstatic std::map<uint32_t, uint32_t> ssThreshValue;                  //!< SlowStart threshold value.\n\n/**\n * Get the Node Id From Context.\n *\n * \\param context The context.\n * \\return the node ID.\n */\nstatic uint32_t\nGetNodeIdFromContext(std::string context)\n{\n    const std::size_t n1 = context.find_first_of('/', 1);\n    const std::size_t n2 = context.find_first_of('/', n1 + 1);\n    return std::stoul(context.substr(n1 + 1, n2 - n1 - 1));\n}\n\n/**\n * Congestion window tracer.\n *\n * \\param context The context.\n * \\param oldval Old value.\n * \\param newval New value.\n */\nstatic void\nCwndTracer(std::string context, uint32_t oldval, uint32_t newval)\n{\n    uint32_t nodeId = GetNodeIdFromContext(context);\n\n    if (firstCwnd[nodeId])\n    {\n        *cWndStream[nodeId]->GetStream() << \"0.0 \" << oldval << std::endl;\n        firstCwnd[nodeId] = false;\n    }\n    *cWndStream[nodeId]->GetStream() << Simulator::Now().GetSeconds() << \" \" << newval << std::endl;\n    cWndValue[nodeId] = newval;\n\n    if (!firstSshThr[nodeId])\n    {\n        *ssThreshStream[nodeId]->GetStream()\n            << Simulator::Now().GetSeconds() << \" \" << ssThreshValue[nodeId] << std::endl;\n    }\n}\n\n/**\n * Slow start threshold tracer.\n *\n * \\param context The context.\n * \\param oldval Old value.\n * \\param newval New value.\n */\nstatic void\nSsThreshTracer(std::string context, uint32_t oldval, uint32_t newval)\n{\n    uint32_t nodeId = GetNodeIdFromContext(context);\n\n    if (firstSshThr[nodeId])\n    {\n        *ssThreshStream[nodeId]->GetStream() << \"0.0 \" << oldval << std::endl;\n        firstSshThr[nodeId] = false;\n    }\n    *ssThreshStream[nodeId]->GetStream()\n        << Simulator::Now().GetSeconds() << \" \" << newval << std::endl;\n    ssThreshValue[nodeId] = newval;\n\n    if (!firstCwnd[nodeId])\n    {\n        *cWndStream[nodeId]->GetStream()\n            << Simulator::Now().GetSeconds() << \" \" << cWndValue[nodeId] << std::endl;\n    }\n}\n\n/**\n * RTT tracer.\n *\n * \\param context The context.\n * \\param oldval Old value.\n * \\param newval New value.\n */\nstatic void\nRttTracer(std::string context, Time oldval, Time newval)\n{\n    uint32_t nodeId = GetNodeIdFromContext(context);\n\n    if (firstRtt[nodeId])\n    {\n        *rttStream[nodeId]->GetStream() << \"0.0 \" << oldval.GetSeconds() << std::endl;\n        firstRtt[nodeId] = false;\n    }\n    *rttStream[nodeId]->GetStream()\n        << Simulator::Now().GetSeconds() << \" \" << newval.GetSeconds() << std::endl;\n}\n\n/**\n * RTO tracer.\n *\n * \\param context The context.\n * \\param oldval Old value.\n * \\param newval New value.\n */\nstatic void\nRtoTracer(std::string context, Time oldval, Time newval)\n{\n    uint32_t nodeId = GetNodeIdFromContext(context);\n\n    if (firstRto[nodeId])\n    {\n        *rtoStream[nodeId]->GetStream() << \"0.0 \" << oldval.GetSeconds() << std::endl;\n        firstRto[nodeId] = false;\n    }\n    *rtoStream[nodeId]->GetStream()\n        << Simulator::Now().GetSeconds() << \" \" << newval.GetSeconds() << std::endl;\n}\n\n/**\n * Next TX tracer.\n *\n * \\param context The context.\n * \\param old Old sequence number.\n * \\param nextTx Next sequence number.\n */\nstatic void\nNextTxTracer(std::string context, SequenceNumber32 old [[maybe_unused]], SequenceNumber32 nextTx)\n{\n    uint32_t nodeId = GetNodeIdFromContext(context);\n\n    *nextTxStream[nodeId]->GetStream()\n        << Simulator::Now().GetSeconds() << \" \" << nextTx << std::endl;\n}\n\n/**\n * In-flight tracer.\n *\n * \\param context The context.\n * \\param old Old value.\n * \\param inFlight In flight value.\n */\nstatic void\nInFlightTracer(std::string context, uint32_t old [[maybe_unused]], uint32_t inFlight)\n{\n    uint32_t nodeId = GetNodeIdFromContext(context);\n\n    *inFlightStream[nodeId]->GetStream()\n        << Simulator::Now().GetSeconds() << \" \" << inFlight << std::endl;\n}\n\n/**\n * Next RX tracer.\n *\n * \\param context The context.\n * \\param old Old sequence number.\n * \\param nextRx Next sequence number.\n */\nstatic void\nNextRxTracer(std::string context, SequenceNumber32 old [[maybe_unused]], SequenceNumber32 nextRx)\n{\n    uint32_t nodeId = GetNodeIdFromContext(context);\n\n    *nextRxStream[nodeId]->GetStream()\n        << Simulator::Now().GetSeconds() << \" \" << nextRx << std::endl;\n}\n\n/**\n * Congestion window trace connection.\n *\n * \\param cwnd_tr_file_name Congestion window trace file name.\n * \\param nodeId Node ID.\n */\nstatic void\nTraceCwnd(std::string cwnd_tr_file_name, uint32_t nodeId)\n{\n    AsciiTraceHelper ascii;\n    cWndStream[nodeId] = ascii.CreateFileStream(cwnd_tr_file_name);\n    Config::Connect(\"/NodeList/\" + std::to_string(nodeId) +\n                        \"/$ns3::TcpL4Protocol/SocketList/0/CongestionWindow\",\n                    MakeCallback(&CwndTracer));\n}\n\n/**\n * Slow start threshold trace connection.\n *\n * \\param ssthresh_tr_file_name Slow start threshold trace file name.\n * \\param nodeId Node ID.\n */\nstatic void\nTraceSsThresh(std::string ssthresh_tr_file_name, uint32_t nodeId)\n{\n    AsciiTraceHelper ascii;\n    ssThreshStream[nodeId] = ascii.CreateFileStream(ssthresh_tr_file_name);\n    Config::Connect(\"/NodeList/\" + std::to_string(nodeId) +\n                        \"/$ns3::TcpL4Protocol/SocketList/0/SlowStartThreshold\",\n                    MakeCallback(&SsThreshTracer));\n}\n\n/**\n * RTT trace connection.\n *\n * \\param rtt_tr_file_name RTT trace file name.\n * \\param nodeId Node ID.\n */\nstatic void\nTraceRtt(std::string rtt_tr_file_name, uint32_t nodeId)\n{\n    AsciiTraceHelper ascii;\n    rttStream[nodeId] = ascii.CreateFileStream(rtt_tr_file_name);\n    Config::Connect(\"/NodeList/\" + std::to_string(nodeId) + \"/$ns3::TcpL4Protocol/SocketList/0/RTT\",\n                    MakeCallback(&RttTracer));\n}\n\n/**\n * RTO trace connection.\n *\n * \\param rto_tr_file_name RTO trace file name.\n * \\param nodeId Node ID.\n */\nstatic void\nTraceRto(std::string rto_tr_file_name, uint32_t nodeId)\n{\n    AsciiTraceHelper ascii;\n    rtoStream[nodeId] = ascii.CreateFileStream(rto_tr_file_name);\n    Config::Connect(\"/NodeList/\" + std::to_string(nodeId) + \"/$ns3::TcpL4Protocol/SocketList/0/RTO\",\n                    MakeCallback(&RtoTracer));\n}\n\n/**\n * Next TX trace connection.\n *\n * \\param next_tx_seq_file_name Next TX trace file name.\n * \\param nodeId Node ID.\n */\nstatic void\nTraceNextTx(std::string& next_tx_seq_file_name, uint32_t nodeId)\n{\n    AsciiTraceHelper ascii;\n    nextTxStream[nodeId] = ascii.CreateFileStream(next_tx_seq_file_name);\n    Config::Connect(\"/NodeList/\" + std::to_string(nodeId) +\n                        \"/$ns3::TcpL4Protocol/SocketList/0/NextTxSequence\",\n                    MakeCallback(&NextTxTracer));\n}\n\n/**\n * In flight trace connection.\n *\n * \\param in_flight_file_name In flight trace file name.\n * \\param nodeId Node ID.\n */\nstatic void\nTraceInFlight(std::string& in_flight_file_name, uint32_t nodeId)\n{\n    AsciiTraceHelper ascii;\n    inFlightStream[nodeId] = ascii.CreateFileStream(in_flight_file_name);\n    Config::Connect(\"/NodeList/\" + std::to_string(nodeId) +\n                        \"/$ns3::TcpL4Protocol/SocketList/0/BytesInFlight\",\n                    MakeCallback(&InFlightTracer));\n}\n\n/**\n * Next RX trace connection.\n *\n * \\param next_rx_seq_file_name Next RX trace file name.\n * \\param nodeId Node ID.\n */\nstatic void\nTraceNextRx(std::string& next_rx_seq_file_name, uint32_t nodeId)\n{\n    AsciiTraceHelper ascii;\n    nextRxStream[nodeId] = ascii.CreateFileStream(next_rx_seq_file_name);\n    Config::Connect(\"/NodeList/\" + std::to_string(nodeId) +\n                        \"/$ns3::TcpL4Protocol/SocketList/1/RxBuffer/NextRxSequence\",\n                    MakeCallback(&NextRxTracer));\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string transport_prot = \"TcpWestwoodPlus\";\n    double error_p = 0.0;\n    std::string bandwidth = \"2Mbps\";\n    std::string delay = \"0.01ms\";\n    std::string access_bandwidth = \"10Mbps\";\n    std::string access_delay = \"45ms\";\n    bool tracing = false;\n    std::string prefix_file_name = \"TcpVariantsComparison\";\n    uint64_t data_mbytes = 0;\n    uint32_t mtu_bytes = 400;\n    uint16_t num_flows = 1;\n    double duration = 100.0;\n    uint32_t run = 0;\n    bool flow_monitor = false;\n    bool pcap = false;\n    bool sack = true;\n    std::string queue_disc_type = \"ns3::PfifoFastQueueDisc\";\n    std::string recovery = \"ns3::TcpClassicRecovery\";\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"transport_prot\",\n                 \"Transport protocol to use: TcpNewReno, TcpLinuxReno, \"\n                 \"TcpHybla, TcpHighSpeed, TcpHtcp, TcpVegas, TcpScalable, TcpVeno, \"\n                 \"TcpBic, TcpYeah, TcpIllinois, TcpWestwoodPlus, TcpLedbat, \"\n                 \"TcpLp, TcpDctcp, TcpCubic, TcpBbr\",\n                 transport_prot);\n    cmd.AddValue(\"error_p\", \"Packet error rate\", error_p);\n    cmd.AddValue(\"bandwidth\", \"Bottleneck bandwidth\", bandwidth);\n    cmd.AddValue(\"delay\", \"Bottleneck delay\", delay);\n    cmd.AddValue(\"access_bandwidth\", \"Access link bandwidth\", access_bandwidth);\n    cmd.AddValue(\"access_delay\", \"Access link delay\", access_delay);\n    cmd.AddValue(\"tracing\", \"Flag to enable/disable tracing\", tracing);\n    cmd.AddValue(\"prefix_name\", \"Prefix of output trace file\", prefix_file_name);\n    cmd.AddValue(\"data\", \"Number of Megabytes of data to transmit\", data_mbytes);\n    cmd.AddValue(\"mtu\", \"Size of IP packets to send in bytes\", mtu_bytes);\n    cmd.AddValue(\"num_flows\", \"Number of flows\", num_flows);\n    cmd.AddValue(\"duration\", \"Time to allow flows to run in seconds\", duration);\n    cmd.AddValue(\"run\", \"Run index (for setting repeatable seeds)\", run);\n    cmd.AddValue(\"flow_monitor\", \"Enable flow monitor\", flow_monitor);\n    cmd.AddValue(\"pcap_tracing\", \"Enable or disable PCAP tracing\", pcap);\n    cmd.AddValue(\"queue_disc_type\",\n                 \"Queue disc type for gateway (e.g. ns3::CoDelQueueDisc)\",\n                 queue_disc_type);\n    cmd.AddValue(\"sack\", \"Enable or disable SACK option\", sack);\n    cmd.AddValue(\"recovery\", \"Recovery algorithm type to use (e.g., ns3::TcpPrrRecovery\", recovery);\n    cmd.Parse(argc, argv);\n\n    transport_prot = std::string(\"ns3::\") + transport_prot;\n\n    SeedManager::SetSeed(1);\n    SeedManager::SetRun(run);\n\n    // User may find it convenient to enable logging\n    // LogComponentEnable(\"TcpVariantsComparison\", LOG_LEVEL_ALL);\n    // LogComponentEnable(\"BulkSendApplication\", LOG_LEVEL_INFO);\n    // LogComponentEnable(\"PfifoFastQueueDisc\", LOG_LEVEL_ALL);\n\n    // Calculate the ADU size\n    Header* temp_header = new Ipv4Header();\n    uint32_t ip_header = temp_header->GetSerializedSize();\n    NS_LOG_LOGIC(\"IP Header size is: \" << ip_header);\n    delete temp_header;\n    temp_header = new TcpHeader();\n    uint32_t tcp_header = temp_header->GetSerializedSize();\n    NS_LOG_LOGIC(\"TCP Header size is: \" << tcp_header);\n    delete temp_header;\n    uint32_t tcp_adu_size = mtu_bytes - 20 - (ip_header + tcp_header);\n    NS_LOG_LOGIC(\"TCP ADU size is: \" << tcp_adu_size);\n\n    // Set the simulation start and stop time\n    double start_time = 0.1;\n    double stop_time = start_time + duration;\n\n    // 2 MB of TCP buffer\n    Config::SetDefault(\"ns3::TcpSocket::RcvBufSize\", UintegerValue(1 << 21));\n    Config::SetDefault(\"ns3::TcpSocket::SndBufSize\", UintegerValue(1 << 21));\n    Config::SetDefault(\"ns3::TcpSocketBase::Sack\", BooleanValue(sack));\n\n    Config::SetDefault(\"ns3::TcpL4Protocol::RecoveryType\",\n                       TypeIdValue(TypeId::LookupByName(recovery)));\n    // Select TCP variant\n    TypeId tcpTid;\n    NS_ABORT_MSG_UNLESS(TypeId::LookupByNameFailSafe(transport_prot, &tcpTid),\n                        \"TypeId \" << transport_prot << \" not found\");\n    Config::SetDefault(\"ns3::TcpL4Protocol::SocketType\",\n                       TypeIdValue(TypeId::LookupByName(transport_prot)));\n\n    // Create gateways, sources, and sinks\n    NodeContainer gateways;\n    gateways.Create(1);\n    NodeContainer sources;\n    sources.Create(num_flows);\n    NodeContainer sinks;\n    sinks.Create(num_flows);\n\n    // Configure the error model\n    // Here we use RateErrorModel with packet error rate\n    Ptr<UniformRandomVariable> uv = CreateObject<UniformRandomVariable>();\n    uv->SetStream(50);\n    RateErrorModel error_model;\n    error_model.SetRandomVariable(uv);\n    error_model.SetUnit(RateErrorModel::ERROR_UNIT_PACKET);\n    error_model.SetRate(error_p);\n\n    PointToPointHelper UnReLink;\n    UnReLink.SetDeviceAttribute(\"DataRate\", StringValue(bandwidth));\n    UnReLink.SetChannelAttribute(\"Delay\", StringValue(delay));\n    UnReLink.SetDeviceAttribute(\"ReceiveErrorModel\", PointerValue(&error_model));\n\n    InternetStackHelper stack;\n    stack.InstallAll();\n\n    TrafficControlHelper tchPfifo;\n    tchPfifo.SetRootQueueDisc(\"ns3::PfifoFastQueueDisc\");\n\n    TrafficControlHelper tchCoDel;\n    tchCoDel.SetRootQueueDisc(\"ns3::CoDelQueueDisc\");\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n\n    // Configure the sources and sinks net devices\n    // and the channels between the sources/sinks and the gateways\n    PointToPointHelper LocalLink;\n    LocalLink.SetDeviceAttribute(\"DataRate\", StringValue(access_bandwidth));\n    LocalLink.SetChannelAttribute(\"Delay\", StringValue(access_delay));\n\n    Ipv4InterfaceContainer sink_interfaces;\n\n    DataRate access_b(access_bandwidth);\n    DataRate bottle_b(bandwidth);\n    Time access_d(access_delay);\n    Time bottle_d(delay);\n\n    uint32_t size = static_cast<uint32_t>((std::min(access_b, bottle_b).GetBitRate() / 8) *\n                                          ((access_d + bottle_d) * 2).GetSeconds());\n\n    Config::SetDefault(\"ns3::PfifoFastQueueDisc::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, size / mtu_bytes)));\n    Config::SetDefault(\"ns3::CoDelQueueDisc::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::BYTES, size)));\n\n    for (uint32_t i = 0; i < num_flows; i++)\n    {\n        NetDeviceContainer devices;\n        devices = LocalLink.Install(sources.Get(i), gateways.Get(0));\n        tchPfifo.Install(devices);\n        address.NewNetwork();\n        Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n        devices = UnReLink.Install(gateways.Get(0), sinks.Get(i));\n        if (queue_disc_type == \"ns3::PfifoFastQueueDisc\")\n        {\n            tchPfifo.Install(devices);\n        }\n        else if (queue_disc_type == \"ns3::CoDelQueueDisc\")\n        {\n            tchCoDel.Install(devices);\n        }\n        else\n        {\n            NS_FATAL_ERROR(\"Queue not recognized. Allowed values are ns3::CoDelQueueDisc or \"\n                           \"ns3::PfifoFastQueueDisc\");\n        }\n        address.NewNetwork();\n        interfaces = address.Assign(devices);\n        sink_interfaces.Add(interfaces.Get(1));\n    }\n\n    NS_LOG_INFO(\"Initialize Global Routing.\");\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    uint16_t port = 50000;\n    Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n\n    for (uint32_t i = 0; i < sources.GetN(); i++)\n    {\n        AddressValue remoteAddress(InetSocketAddress(sink_interfaces.GetAddress(i, 0), port));\n        Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(tcp_adu_size));\n        BulkSendHelper ftp(\"ns3::TcpSocketFactory\", Address());\n        ftp.SetAttribute(\"Remote\", remoteAddress);\n        ftp.SetAttribute(\"SendSize\", UintegerValue(tcp_adu_size));\n        ftp.SetAttribute(\"MaxBytes\", UintegerValue(data_mbytes * 1000000));\n\n        ApplicationContainer sourceApp = ftp.Install(sources.Get(i));\n        sourceApp.Start(Seconds(start_time * i));\n        sourceApp.Stop(Seconds(stop_time - 3));\n\n        sinkHelper.SetAttribute(\"Protocol\", TypeIdValue(TcpSocketFactory::GetTypeId()));\n        ApplicationContainer sinkApp = sinkHelper.Install(sinks.Get(i));\n        sinkApp.Start(Seconds(start_time * i));\n        sinkApp.Stop(Seconds(stop_time));\n    }\n\n    // Set up tracing if enabled\n    if (tracing)\n    {\n        std::ofstream ascii;\n        Ptr<OutputStreamWrapper> ascii_wrap;\n        ascii.open(prefix_file_name + \"-ascii\");\n        ascii_wrap = new OutputStreamWrapper(prefix_file_name + \"-ascii\", std::ios::out);\n        stack.EnableAsciiIpv4All(ascii_wrap);\n\n        for (uint16_t index = 0; index < num_flows; index++)\n        {\n            std::string flowString;\n            if (num_flows > 1)\n            {\n                flowString = \"-flow\" + std::to_string(index);\n            }\n\n            firstCwnd[index + 1] = true;\n            firstSshThr[index + 1] = true;\n            firstRtt[index + 1] = true;\n            firstRto[index + 1] = true;\n\n            Simulator::Schedule(Seconds(start_time * index + 0.00001),\n                                &TraceCwnd,\n                                prefix_file_name + flowString + \"-cwnd.data\",\n                                index + 1);\n            Simulator::Schedule(Seconds(start_time * index + 0.00001),\n                                &TraceSsThresh,\n                                prefix_file_name + flowString + \"-ssth.data\",\n                                index + 1);\n            Simulator::Schedule(Seconds(start_time * index + 0.00001),\n                                &TraceRtt,\n                                prefix_file_name + flowString + \"-rtt.data\",\n                                index + 1);\n            Simulator::Schedule(Seconds(start_time * index + 0.00001),\n                                &TraceRto,\n                                prefix_file_name + flowString + \"-rto.data\",\n                                index + 1);\n            Simulator::Schedule(Seconds(start_time * index + 0.00001),\n                                &TraceNextTx,\n                                prefix_file_name + flowString + \"-next-tx.data\",\n                                index + 1);\n            Simulator::Schedule(Seconds(start_time * index + 0.00001),\n                                &TraceInFlight,\n                                prefix_file_name + flowString + \"-inflight.data\",\n                                index + 1);\n            Simulator::Schedule(Seconds(start_time * index + 0.1),\n                                &TraceNextRx,\n                                prefix_file_name + flowString + \"-next-rx.data\",\n                                num_flows + index + 1);\n        }\n    }\n\n    if (pcap)\n    {\n        UnReLink.EnablePcapAll(prefix_file_name, true);\n        LocalLink.EnablePcapAll(prefix_file_name, true);\n    }\n\n    // Flow monitor\n    FlowMonitorHelper flowHelper;\n    if (flow_monitor)\n    {\n        flowHelper.InstallAll();\n    }\n\n    Simulator::Stop(Seconds(stop_time));\n    Simulator::Run();\n\n    if (flow_monitor)\n    {\n        flowHelper.SerializeToXmlFile(prefix_file_name + \".flowmonitor\", true, true);\n    }\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite C++ code for a network simulation using ns-3 that builds a dumbbell topology with 7 senders and 1 receiver. The script should simulate both TCP and UDP traffic over a Point-to-Point link with different queue disciplines (COBALT and CoDel). Implement a congestion window trace for TCP and a queue size trace for each queue disc, saving the results in separate files. Ensure the simulation stops after a specified time and use helper classes for devices, links, and addressing. The code should include necessary ns-3 modules and implement the `experiment` function to run the simulation twice with the different queue discs."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/tcp-header.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <fstream>\n#include <string>\n\n// Dumbbell topology with 7 senders and 1 receiver\n// is used for this example. On successful completion,\n// the Congestion window and Queue size traces get stored\n// in MixTraffic/ directory, inside cwndTraces and\n// queueTraces sub-directories, respectively.\n\nusing namespace ns3;\n\nstd::string dir = \"MixTraffic/\";\n\nvoid\nCheckQueueSize(Ptr<QueueDisc> queue, std::string queue_disc_type)\n{\n    double qSize = queue->GetCurrentSize().GetValue();\n    // check queue size every 1/10 of a second\n    Simulator::Schedule(Seconds(0.1), &CheckQueueSize, queue, queue_disc_type);\n\n    std::ofstream fPlotQueue(dir + queue_disc_type + \"/queueTraces/queue.plotme\",\n                             std::ios::out | std::ios::app);\n    fPlotQueue << Simulator::Now().GetSeconds() << \" \" << qSize << std::endl;\n    fPlotQueue.close();\n}\n\nstatic void\nCwndTrace(Ptr<OutputStreamWrapper> stream, uint32_t oldCwnd, uint32_t newCwnd)\n{\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << newCwnd / 1446.0 << std::endl;\n}\n\nstatic void\nTraceCwnd(std::string queue_disc_type)\n{\n    for (uint8_t i = 0; i < 5; i++)\n    {\n        AsciiTraceHelper asciiTraceHelper;\n        Ptr<OutputStreamWrapper> stream = asciiTraceHelper.CreateFileStream(\n            dir + queue_disc_type + \"/cwndTraces/S1-\" + std::to_string(i + 1) + \".plotme\");\n        Config::ConnectWithoutContext(\"/NodeList/\" + std::to_string(i) +\n                                          \"/$ns3::TcpL4Protocol/SocketList/0/CongestionWindow\",\n                                      MakeBoundCallback(&CwndTrace, stream));\n    }\n}\n\nvoid\nexperiment(std::string queue_disc_type)\n{\n    // Set the simulation stop time in seconds\n    double stopTime = 101;\n    std::string queue_disc = std::string(\"ns3::\") + queue_disc_type;\n\n    std::string bottleneckBandwidth = \"10Mbps\";\n    std::string bottleneckDelay = \"50ms\";\n\n    std::string accessBandwidth = \"10Mbps\";\n    std::string accessDelay = \"5ms\";\n\n    // Create sender\n    NodeContainer tcpSender;\n    tcpSender.Create(5);\n\n    NodeContainer udpSender;\n    udpSender.Create(2);\n\n    // Create gateway\n    NodeContainer gateway;\n    gateway.Create(2);\n\n    // Create sink\n    NodeContainer sink;\n    sink.Create(1);\n\n    Config::SetDefault(\"ns3::TcpSocket::SndBufSize\", UintegerValue(1 << 20));\n    Config::SetDefault(\"ns3::TcpSocket::RcvBufSize\", UintegerValue(1 << 20));\n    Config::SetDefault(\"ns3::TcpSocket::DelAckTimeout\", TimeValue(Seconds(0)));\n    Config::SetDefault(\"ns3::TcpSocket::InitialCwnd\", UintegerValue(1));\n    Config::SetDefault(\"ns3::TcpSocketBase::LimitedTransmit\", BooleanValue(false));\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(1446));\n    Config::SetDefault(\"ns3::TcpSocketBase::WindowScaling\", BooleanValue(true));\n    Config::SetDefault(queue_disc + \"::MaxSize\", QueueSizeValue(QueueSize(\"200p\")));\n\n    InternetStackHelper internet;\n    internet.InstallAll();\n\n    TrafficControlHelper tchPfifo;\n    uint16_t handle = tchPfifo.SetRootQueueDisc(\"ns3::PfifoFastQueueDisc\");\n    tchPfifo.AddInternalQueues(handle, 3, \"ns3::DropTailQueue\", \"MaxSize\", StringValue(\"1000p\"));\n\n    TrafficControlHelper tch;\n    tch.SetRootQueueDisc(queue_disc);\n\n    PointToPointHelper accessLink;\n    accessLink.SetDeviceAttribute(\"DataRate\", StringValue(accessBandwidth));\n    accessLink.SetChannelAttribute(\"Delay\", StringValue(accessDelay));\n\n    // Configure the senders and sinks net devices\n    // and the channels between the senders/sinks and the gateways\n    NetDeviceContainer devices[5];\n    for (uint8_t i = 0; i < 5; i++)\n    {\n        devices[i] = accessLink.Install(tcpSender.Get(i), gateway.Get(0));\n        tchPfifo.Install(devices[i]);\n    }\n\n    NetDeviceContainer devices_sink;\n    devices_sink = accessLink.Install(gateway.Get(1), sink.Get(0));\n    tchPfifo.Install(devices_sink);\n\n    PointToPointHelper bottleneckLink;\n    bottleneckLink.SetDeviceAttribute(\"DataRate\", StringValue(bottleneckBandwidth));\n    bottleneckLink.SetChannelAttribute(\"Delay\", StringValue(bottleneckDelay));\n\n    NetDeviceContainer devices_gateway;\n    devices_gateway = bottleneckLink.Install(gateway.Get(0), gateway.Get(1));\n    // Install QueueDisc at gateway\n    QueueDiscContainer queueDiscs = tch.Install(devices_gateway);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer interfaces[5];\n    Ipv4InterfaceContainer interfaces_sink;\n    Ipv4InterfaceContainer interfaces_gateway;\n    Ipv4InterfaceContainer udpinterfaces[2];\n\n    NetDeviceContainer udpdevices[2];\n\n    for (uint8_t i = 0; i < 5; i++)\n    {\n        address.NewNetwork();\n        interfaces[i] = address.Assign(devices[i]);\n    }\n\n    for (uint8_t i = 0; i < 2; i++)\n    {\n        udpdevices[i] = accessLink.Install(udpSender.Get(i), gateway.Get(0));\n        address.NewNetwork();\n        udpinterfaces[i] = address.Assign(udpdevices[i]);\n    }\n\n    address.NewNetwork();\n    interfaces_gateway = address.Assign(devices_gateway);\n\n    address.NewNetwork();\n    interfaces_sink = address.Assign(devices_sink);\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    uint16_t port = 50000;\n    uint16_t port1 = 50001;\n    Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    Address sinkLocalAddress1(InetSocketAddress(Ipv4Address::GetAny(), port1));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n    PacketSinkHelper sinkHelper1(\"ns3::UdpSocketFactory\", sinkLocalAddress1);\n\n    AddressValue remoteAddress(InetSocketAddress(interfaces_sink.GetAddress(1), port));\n    AddressValue remoteAddress1(InetSocketAddress(interfaces_sink.GetAddress(1), port1));\n\n    BulkSendHelper ftp(\"ns3::TcpSocketFactory\", Address());\n    ftp.SetAttribute(\"Remote\", remoteAddress);\n    ftp.SetAttribute(\"SendSize\", UintegerValue(1000));\n\n    ApplicationContainer sourceApp = ftp.Install(tcpSender);\n    sourceApp.Start(Seconds(0));\n    sourceApp.Stop(Seconds(stopTime - 1));\n\n    sinkHelper.SetAttribute(\"Protocol\", TypeIdValue(TcpSocketFactory::GetTypeId()));\n    ApplicationContainer sinkApp = sinkHelper.Install(sink);\n    sinkApp.Start(Seconds(0));\n    sinkApp.Stop(Seconds(stopTime));\n\n    OnOffHelper clientHelper6(\"ns3::UdpSocketFactory\", Address());\n    clientHelper6.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper6.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientHelper6.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"10Mb/s\")));\n    clientHelper6.SetAttribute(\"PacketSize\", UintegerValue(1000));\n\n    ApplicationContainer clientApps6;\n    clientHelper6.SetAttribute(\"Remote\", remoteAddress1);\n    clientApps6.Add(clientHelper6.Install(udpSender.Get(0)));\n    clientApps6.Start(Seconds(0));\n    clientApps6.Stop(Seconds(stopTime - 1));\n\n    OnOffHelper clientHelper7(\"ns3::UdpSocketFactory\", Address());\n    clientHelper7.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper7.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    clientHelper7.SetAttribute(\"DataRate\", DataRateValue(DataRate(\"10Mb/s\")));\n    clientHelper7.SetAttribute(\"PacketSize\", UintegerValue(1000));\n\n    ApplicationContainer clientApps7;\n    clientHelper7.SetAttribute(\"Remote\", remoteAddress1);\n    clientApps7.Add(clientHelper7.Install(udpSender.Get(1)));\n    clientApps7.Start(Seconds(0));\n    clientApps7.Stop(Seconds(stopTime - 1));\n\n    sinkHelper1.SetAttribute(\"Protocol\", TypeIdValue(UdpSocketFactory::GetTypeId()));\n    ApplicationContainer sinkApp1 = sinkHelper1.Install(sink);\n    sinkApp1.Start(Seconds(0));\n    sinkApp1.Stop(Seconds(stopTime));\n\n    Ptr<QueueDisc> queue = queueDiscs.Get(0);\n    Simulator::ScheduleNow(&CheckQueueSize, queue, queue_disc_type);\n\n    std::string dirToSave = \"mkdir -p \" + dir + queue_disc_type;\n    if (system((dirToSave + \"/cwndTraces/\").c_str()) == -1 ||\n        system((dirToSave + \"/queueTraces/\").c_str()) == -1)\n    {\n        exit(1);\n    }\n\n    Simulator::Schedule(Seconds(0.1), &TraceCwnd, queue_disc_type);\n\n    Simulator::Stop(Seconds(stopTime));\n    Simulator::Run();\n    Simulator::Destroy();\n}\n\nint\nmain(int argc, char** argv)\n{\n    std::cout << \"Simulation with COBALT QueueDisc: Start\\n\" << std::flush;\n    experiment(\"CobaltQueueDisc\");\n    std::cout << \"Simulation with COBALT QueueDisc: End\\n\" << std::flush;\n    std::cout << \"------------------------------------------------\\n\";\n    std::cout << \"Simulation with CoDel QueueDisc: Start\\n\";\n    experiment(\"CoDelQueueDisc\");\n    std::cout << \"Simulation with CoDel QueueDisc: End\\n\";\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the NS-3 library to simulate a network topology with three nodes, where n1 and n3 are connected to n2 through point-to-point links. Configure the access link between n1 and n2 with 100 Mbps bandwidth and 0.1 ms delay, while the bottleneck link between n2 and n3 has adjustable bandwidth and delay parameters. Implement several queue disc types, including PfifoFast, ARED, CoDel, FqCoDel, and PIE, for traffic control on the bottleneck link, and allow the option to enable Byte Queue Limits (BQL). Generate bidirectional TCP flows between n1 and n3, and monitor the goodput. Additionally, n1 should ping n3 to measure RTT. Output trace files for queue limits, bytes in the queue, goodput, and flow statistics."}, {"role": "assistant", "content": "// This example serves as a benchmark for all the queue discs (with BQL enabled or not)\n//\n// Network topology\n//\n//                192.168.1.0                             192.168.2.0\n// n1 ------------------------------------ n2 ----------------------------------- n3\n//   point-to-point (access link)                point-to-point (bottleneck link)\n//   100 Mbps, 0.1 ms                            bandwidth [10 Mbps], delay [5 ms]\n//   qdiscs PfifoFast with capacity              qdiscs queueDiscType in {PfifoFast, ARED, CoDel,\n//   FqCoDel, PIE} [PfifoFast] of 1000 packets                             with capacity of\n//   queueDiscSize packets [1000] netdevices queues with size of 100 packets  netdevices queues with\n//   size of netdevicesQueueSize packets [100] without BQL                                 bql BQL\n//   [false]\n//   *** fixed configuration ***\n//\n// Two TCP flows are generated: one from n1 to n3 and the other from n3 to n1.\n// Additionally, n1 pings n3, so that the RTT can be measured.\n//\n// The output will consist of a number of ping Rtt such as:\n//\n//    /NodeList/0/ApplicationList/2/$ns3::Ping/Rtt=111 ms\n//    /NodeList/0/ApplicationList/2/$ns3::Ping/Rtt=111 ms\n//    /NodeList/0/ApplicationList/2/$ns3::Ping/Rtt=110 ms\n//    /NodeList/0/ApplicationList/2/$ns3::Ping/Rtt=111 ms\n//    /NodeList/0/ApplicationList/2/$ns3::Ping/Rtt=111 ms\n//    /NodeList/0/ApplicationList/2/$ns3::Ping/Rtt=112 ms\n//    /NodeList/0/ApplicationList/2/$ns3::Ping/Rtt=111 ms\n//\n// The files output will consist of a trace file with bytes in queue and of a trace file for limits\n// (when BQL is enabled) both for bottleneck NetDevice on n2, two files with upload and download\n// goodput for flows configuration and a file with flow monitor stats.\n//\n// If you use an AQM as queue disc on the bottleneck netdevices, you can observe that the ping Rtt\n// decrease. A further decrease can be observed when you enable BQL.\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"BenchmarkQueueDiscs\");\n\n/**\n * Print the queue limits.\n *\n * \\param stream The output stream.\n * \\param oldVal Old value.\n * \\param newVal New value.\n */\nvoid\nLimitsTrace(Ptr<OutputStreamWrapper> stream, uint32_t oldVal, uint32_t newVal)\n{\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << newVal << std::endl;\n}\n\n/**\n * Print the bytes in the queue.\n *\n * \\param stream The output stream.\n * \\param oldVal Old value.\n * \\param newVal New value.\n */\nvoid\nBytesInQueueTrace(Ptr<OutputStreamWrapper> stream, uint32_t oldVal, uint32_t newVal)\n{\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << newVal << std::endl;\n}\n\n/**\n * Sample and print the queue goodput.\n *\n * \\param app The Tx app.\n * \\param stream The output stream.\n * \\param period The sampling period.\n */\nstatic void\nGoodputSampling(ApplicationContainer app, Ptr<OutputStreamWrapper> stream, float period)\n{\n    Simulator::Schedule(Seconds(period), &GoodputSampling, app, stream, period);\n    double goodput;\n    uint64_t totalPackets = DynamicCast<PacketSink>(app.Get(0))->GetTotalRx();\n    goodput = totalPackets * 8 / (Simulator::Now().GetSeconds() * 1024); // Kbit/s\n    *stream->GetStream() << Simulator::Now().GetSeconds() << \" \" << goodput << std::endl;\n}\n\n/**\n * Print the ping RTT.\n *\n * \\param context The context.\n * \\param rtt The RTT.\n */\nstatic void\nPingRtt(std::string context, uint16_t, Time rtt)\n{\n    std::cout << context << \"=\" << rtt.GetMilliSeconds() << \" ms\" << std::endl;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string bandwidth = \"10Mbps\";\n    std::string delay = \"5ms\";\n    std::string queueDiscType = \"PfifoFast\";\n    uint32_t queueDiscSize = 1000;\n    uint32_t netdevicesQueueSize = 50;\n    bool bql = false;\n\n    std::string flowsDatarate = \"20Mbps\";\n    uint32_t flowsPacketsSize = 1000;\n\n    float startTime = 0.1F; // in s\n    float simDuration = 60;\n    float samplingPeriod = 1;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"bandwidth\", \"Bottleneck bandwidth\", bandwidth);\n    cmd.AddValue(\"delay\", \"Bottleneck delay\", delay);\n    cmd.AddValue(\"queueDiscType\",\n                 \"Bottleneck queue disc type in {PfifoFast, ARED, CoDel, FqCoDel, PIE, prio}\",\n                 queueDiscType);\n    cmd.AddValue(\"queueDiscSize\", \"Bottleneck queue disc size in packets\", queueDiscSize);\n    cmd.AddValue(\"netdevicesQueueSize\",\n                 \"Bottleneck netdevices queue size in packets\",\n                 netdevicesQueueSize);\n    cmd.AddValue(\"bql\", \"Enable byte queue limits on bottleneck netdevices\", bql);\n    cmd.AddValue(\"flowsDatarate\", \"Upload and download flows datarate\", flowsDatarate);\n    cmd.AddValue(\"flowsPacketsSize\", \"Upload and download flows packets sizes\", flowsPacketsSize);\n    cmd.AddValue(\"startTime\", \"Simulation start time\", startTime);\n    cmd.AddValue(\"simDuration\", \"Simulation duration in seconds\", simDuration);\n    cmd.AddValue(\"samplingPeriod\", \"Goodput sampling period in seconds\", samplingPeriod);\n    cmd.Parse(argc, argv);\n\n    float stopTime = startTime + simDuration;\n\n    // Create nodes\n    NodeContainer n1;\n    NodeContainer n2;\n    NodeContainer n3;\n    n1.Create(1);\n    n2.Create(1);\n    n3.Create(1);\n\n    // Create and configure access link and bottleneck link\n    PointToPointHelper accessLink;\n    accessLink.SetDeviceAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    accessLink.SetChannelAttribute(\"Delay\", StringValue(\"0.1ms\"));\n    accessLink.SetQueue(\"ns3::DropTailQueue\", \"MaxSize\", StringValue(\"100p\"));\n\n    PointToPointHelper bottleneckLink;\n    bottleneckLink.SetDeviceAttribute(\"DataRate\", StringValue(bandwidth));\n    bottleneckLink.SetChannelAttribute(\"Delay\", StringValue(delay));\n    bottleneckLink.SetQueue(\"ns3::DropTailQueue\",\n                            \"MaxSize\",\n                            StringValue(std::to_string(netdevicesQueueSize) + \"p\"));\n\n    InternetStackHelper stack;\n    stack.InstallAll();\n\n    // Access link traffic control configuration\n    TrafficControlHelper tchPfifoFastAccess;\n    tchPfifoFastAccess.SetRootQueueDisc(\"ns3::PfifoFastQueueDisc\", \"MaxSize\", StringValue(\"1000p\"));\n\n    // Bottleneck link traffic control configuration\n    TrafficControlHelper tchBottleneck;\n\n    if (queueDiscType == \"PfifoFast\")\n    {\n        tchBottleneck.SetRootQueueDisc(\n            \"ns3::PfifoFastQueueDisc\",\n            \"MaxSize\",\n            QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, queueDiscSize)));\n    }\n    else if (queueDiscType == \"ARED\")\n    {\n        tchBottleneck.SetRootQueueDisc(\"ns3::RedQueueDisc\");\n        Config::SetDefault(\"ns3::RedQueueDisc::ARED\", BooleanValue(true));\n        Config::SetDefault(\"ns3::RedQueueDisc::MaxSize\",\n                           QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, queueDiscSize)));\n    }\n    else if (queueDiscType == \"CoDel\")\n    {\n        tchBottleneck.SetRootQueueDisc(\"ns3::CoDelQueueDisc\");\n        Config::SetDefault(\"ns3::CoDelQueueDisc::MaxSize\",\n                           QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, queueDiscSize)));\n    }\n    else if (queueDiscType == \"FqCoDel\")\n    {\n        tchBottleneck.SetRootQueueDisc(\"ns3::FqCoDelQueueDisc\");\n        Config::SetDefault(\"ns3::FqCoDelQueueDisc::MaxSize\",\n                           QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, queueDiscSize)));\n    }\n    else if (queueDiscType == \"PIE\")\n    {\n        tchBottleneck.SetRootQueueDisc(\"ns3::PieQueueDisc\");\n        Config::SetDefault(\"ns3::PieQueueDisc::MaxSize\",\n                           QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, queueDiscSize)));\n    }\n    else if (queueDiscType == \"prio\")\n    {\n        uint16_t handle =\n            tchBottleneck.SetRootQueueDisc(\"ns3::PrioQueueDisc\",\n                                           \"Priomap\",\n                                           StringValue(\"0 1 0 1 0 1 0 1 0 1 0 1 0 1 0 1\"));\n        TrafficControlHelper::ClassIdList cid =\n            tchBottleneck.AddQueueDiscClasses(handle, 2, \"ns3::QueueDiscClass\");\n        tchBottleneck.AddChildQueueDisc(handle, cid[0], \"ns3::FifoQueueDisc\");\n        tchBottleneck.AddChildQueueDisc(handle, cid[1], \"ns3::RedQueueDisc\");\n    }\n    else\n    {\n        NS_ABORT_MSG(\"--queueDiscType not valid\");\n    }\n\n    if (bql)\n    {\n        tchBottleneck.SetQueueLimits(\"ns3::DynamicQueueLimits\");\n    }\n\n    NetDeviceContainer devicesAccessLink = accessLink.Install(n1.Get(0), n2.Get(0));\n    tchPfifoFastAccess.Install(devicesAccessLink);\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n    address.NewNetwork();\n    Ipv4InterfaceContainer interfacesAccess = address.Assign(devicesAccessLink);\n\n    NetDeviceContainer devicesBottleneckLink = bottleneckLink.Install(n2.Get(0), n3.Get(0));\n    QueueDiscContainer qdiscs;\n    qdiscs = tchBottleneck.Install(devicesBottleneckLink);\n\n    address.NewNetwork();\n    Ipv4InterfaceContainer interfacesBottleneck = address.Assign(devicesBottleneckLink);\n\n    Ptr<NetDeviceQueueInterface> interface =\n        devicesBottleneckLink.Get(0)->GetObject<NetDeviceQueueInterface>();\n    Ptr<NetDeviceQueue> queueInterface = interface->GetTxQueue(0);\n    Ptr<DynamicQueueLimits> queueLimits =\n        StaticCast<DynamicQueueLimits>(queueInterface->GetQueueLimits());\n\n    AsciiTraceHelper ascii;\n    if (bql)\n    {\n        queueDiscType = queueDiscType + \"-bql\";\n        Ptr<OutputStreamWrapper> streamLimits =\n            ascii.CreateFileStream(queueDiscType + \"-limits.txt\");\n        queueLimits->TraceConnectWithoutContext(\"Limit\",\n                                                MakeBoundCallback(&LimitsTrace, streamLimits));\n    }\n    Ptr<Queue<Packet>> queue =\n        StaticCast<PointToPointNetDevice>(devicesBottleneckLink.Get(0))->GetQueue();\n    Ptr<OutputStreamWrapper> streamBytesInQueue =\n        ascii.CreateFileStream(queueDiscType + \"-bytesInQueue.txt\");\n    queue->TraceConnectWithoutContext(\"BytesInQueue\",\n                                      MakeBoundCallback(&BytesInQueueTrace, streamBytesInQueue));\n\n    Ipv4InterfaceContainer n1Interface;\n    n1Interface.Add(interfacesAccess.Get(0));\n\n    Ipv4InterfaceContainer n3Interface;\n    n3Interface.Add(interfacesBottleneck.Get(1));\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(flowsPacketsSize));\n\n    // Flows configuration\n    // Bidirectional TCP streams with ping like flent tcp_bidirectional test.\n    uint16_t port = 7;\n    ApplicationContainer uploadApp;\n    ApplicationContainer downloadApp;\n    ApplicationContainer sourceApps;\n    // Configure and install upload flow\n    Address addUp(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper sinkHelperUp(\"ns3::TcpSocketFactory\", addUp);\n    sinkHelperUp.SetAttribute(\"Protocol\", TypeIdValue(TcpSocketFactory::GetTypeId()));\n    uploadApp.Add(sinkHelperUp.Install(n3));\n\n    InetSocketAddress socketAddressUp = InetSocketAddress(n3Interface.GetAddress(0), port);\n    OnOffHelper onOffHelperUp(\"ns3::TcpSocketFactory\", Address());\n    onOffHelperUp.SetAttribute(\"Remote\", AddressValue(socketAddressUp));\n    onOffHelperUp.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffHelperUp.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    onOffHelperUp.SetAttribute(\"PacketSize\", UintegerValue(flowsPacketsSize));\n    onOffHelperUp.SetAttribute(\"DataRate\", StringValue(flowsDatarate));\n    sourceApps.Add(onOffHelperUp.Install(n1));\n\n    port = 8;\n    // Configure and install download flow\n    Address addDown(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper sinkHelperDown(\"ns3::TcpSocketFactory\", addDown);\n    sinkHelperDown.SetAttribute(\"Protocol\", TypeIdValue(TcpSocketFactory::GetTypeId()));\n    downloadApp.Add(sinkHelperDown.Install(n1));\n\n    InetSocketAddress socketAddressDown = InetSocketAddress(n1Interface.GetAddress(0), port);\n    OnOffHelper onOffHelperDown(\"ns3::TcpSocketFactory\", Address());\n    onOffHelperDown.SetAttribute(\"Remote\", AddressValue(socketAddressDown));\n    onOffHelperDown.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onOffHelperDown.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    onOffHelperDown.SetAttribute(\"PacketSize\", UintegerValue(flowsPacketsSize));\n    onOffHelperDown.SetAttribute(\"DataRate\", StringValue(flowsDatarate));\n    sourceApps.Add(onOffHelperDown.Install(n3));\n\n    // Configure and install ping\n    PingHelper ping(n3Interface.GetAddress(0));\n    ping.SetAttribute(\"VerboseMode\", EnumValue(Ping::VerboseMode::QUIET));\n    ping.Install(n1);\n\n    Config::Connect(\"/NodeList/*/ApplicationList/*/$ns3::Ping/Rtt\", MakeCallback(&PingRtt));\n\n    uploadApp.Start(Seconds(0));\n    uploadApp.Stop(Seconds(stopTime));\n    downloadApp.Start(Seconds(0));\n    downloadApp.Stop(Seconds(stopTime));\n\n    sourceApps.Start(Seconds(0 + 0.1));\n    sourceApps.Stop(Seconds(stopTime - 0.1));\n\n    Ptr<OutputStreamWrapper> uploadGoodputStream =\n        ascii.CreateFileStream(queueDiscType + \"-upGoodput.txt\");\n    Simulator::Schedule(Seconds(samplingPeriod),\n                        &GoodputSampling,\n                        uploadApp,\n                        uploadGoodputStream,\n                        samplingPeriod);\n    Ptr<OutputStreamWrapper> downloadGoodputStream =\n        ascii.CreateFileStream(queueDiscType + \"-downGoodput.txt\");\n    Simulator::Schedule(Seconds(samplingPeriod),\n                        &GoodputSampling,\n                        downloadApp,\n                        downloadGoodputStream,\n                        samplingPeriod);\n\n    // Flow monitor\n    Ptr<FlowMonitor> flowMonitor;\n    FlowMonitorHelper flowHelper;\n    flowMonitor = flowHelper.InstallAll();\n\n    accessLink.EnablePcapAll(\"queue\");\n\n    Simulator::Stop(Seconds(stopTime));\n    Simulator::Run();\n\n    flowMonitor->SerializeToXmlFile(queueDiscType + \"-flowMonitor.xml\", true, true);\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 network simulator that sets up a dumbbell topology with configurable parameters for the number of leaf nodes, queue types (either RED or Feng's Adaptive RED), and other network settings such as packet size and data rates. The program should use command-line arguments to adjust parameters like the number of packets allowed in the queue, packet size, data rate, and RED queue thresholds. Include default settings for RED queue parameters, link bandwidth, and delay, and install a TCP OnOff application on all right-side nodes with a uniform random variable for On/Off times. The simulation should display the final queue disc statistics and check for expected packet drops."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-layout-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <iomanip>\n#include <iostream>\n#include <map>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t nLeaf = 10;\n    uint32_t maxPackets = 100;\n    bool modeBytes = false;\n    uint32_t queueDiscLimitPackets = 1000;\n    double minTh = 5;\n    double maxTh = 15;\n    uint32_t pktSize = 512;\n    std::string appDataRate = \"10Mbps\";\n    std::string queueDiscType = \"RED\";\n    uint16_t port = 5001;\n    std::string bottleNeckLinkBw = \"1Mbps\";\n    std::string bottleNeckLinkDelay = \"50ms\";\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nLeaf\", \"Number of left and right side leaf nodes\", nLeaf);\n    cmd.AddValue(\"maxPackets\", \"Max Packets allowed in the device queue\", maxPackets);\n    cmd.AddValue(\"queueDiscLimitPackets\",\n                 \"Max Packets allowed in the queue disc\",\n                 queueDiscLimitPackets);\n    cmd.AddValue(\"queueDiscType\", \"Set Queue disc type to RED or FengAdaptive\", queueDiscType);\n    cmd.AddValue(\"appPktSize\", \"Set OnOff App Packet Size\", pktSize);\n    cmd.AddValue(\"appDataRate\", \"Set OnOff App DataRate\", appDataRate);\n    cmd.AddValue(\"modeBytes\", \"Set Queue disc mode to Packets (false) or bytes (true)\", modeBytes);\n\n    cmd.AddValue(\"redMinTh\", \"RED queue minimum threshold\", minTh);\n    cmd.AddValue(\"redMaxTh\", \"RED queue maximum threshold\", maxTh);\n    cmd.Parse(argc, argv);\n\n    if ((queueDiscType != \"RED\") && (queueDiscType != \"FengAdaptive\"))\n    {\n        std::cout\n            << \"Invalid queue disc type: Use --queueDiscType=RED or --queueDiscType=FengAdaptive\"\n            << std::endl;\n        exit(1);\n    }\n\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(pktSize));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(appDataRate));\n\n    Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, maxPackets)));\n\n    if (!modeBytes)\n    {\n        Config::SetDefault(\n            \"ns3::RedQueueDisc::MaxSize\",\n            QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, queueDiscLimitPackets)));\n    }\n    else\n    {\n        Config::SetDefault(\n            \"ns3::RedQueueDisc::MaxSize\",\n            QueueSizeValue(QueueSize(QueueSizeUnit::BYTES, queueDiscLimitPackets * pktSize)));\n        minTh *= pktSize;\n        maxTh *= pktSize;\n    }\n\n    Config::SetDefault(\"ns3::RedQueueDisc::MinTh\", DoubleValue(minTh));\n    Config::SetDefault(\"ns3::RedQueueDisc::MaxTh\", DoubleValue(maxTh));\n    Config::SetDefault(\"ns3::RedQueueDisc::LinkBandwidth\", StringValue(bottleNeckLinkBw));\n    Config::SetDefault(\"ns3::RedQueueDisc::LinkDelay\", StringValue(bottleNeckLinkDelay));\n    Config::SetDefault(\"ns3::RedQueueDisc::MeanPktSize\", UintegerValue(pktSize));\n\n    if (queueDiscType == \"FengAdaptive\")\n    {\n        // Turn on Feng's Adaptive RED\n        Config::SetDefault(\"ns3::RedQueueDisc::FengAdaptive\", BooleanValue(true));\n    }\n\n    // Create the point-to-point link helpers\n    PointToPointHelper bottleNeckLink;\n    bottleNeckLink.SetDeviceAttribute(\"DataRate\", StringValue(bottleNeckLinkBw));\n    bottleNeckLink.SetChannelAttribute(\"Delay\", StringValue(bottleNeckLinkDelay));\n\n    PointToPointHelper pointToPointLeaf;\n    pointToPointLeaf.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPointLeaf.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    PointToPointDumbbellHelper d(nLeaf, pointToPointLeaf, nLeaf, pointToPointLeaf, bottleNeckLink);\n\n    // Install Stack\n    InternetStackHelper stack;\n    for (uint32_t i = 0; i < d.LeftCount(); ++i)\n    {\n        stack.Install(d.GetLeft(i));\n    }\n    for (uint32_t i = 0; i < d.RightCount(); ++i)\n    {\n        stack.Install(d.GetRight(i));\n    }\n\n    stack.Install(d.GetLeft());\n    stack.Install(d.GetRight());\n    TrafficControlHelper tchBottleneck;\n    QueueDiscContainer queueDiscs;\n    tchBottleneck.SetRootQueueDisc(\"ns3::RedQueueDisc\");\n    tchBottleneck.Install(d.GetLeft()->GetDevice(0));\n    queueDiscs = tchBottleneck.Install(d.GetRight()->GetDevice(0));\n\n    // Assign IP Addresses\n    d.AssignIpv4Addresses(Ipv4AddressHelper(\"10.1.1.0\", \"255.255.255.0\"),\n                          Ipv4AddressHelper(\"10.2.1.0\", \"255.255.255.0\"),\n                          Ipv4AddressHelper(\"10.3.1.0\", \"255.255.255.0\"));\n\n    // Install on/off app on all right side nodes\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", Address());\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::UniformRandomVariable[Min=0.|Max=1.]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::UniformRandomVariable[Min=0.|Max=1.]\"));\n    Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n    ApplicationContainer sinkApps;\n    for (uint32_t i = 0; i < d.LeftCount(); ++i)\n    {\n        sinkApps.Add(packetSinkHelper.Install(d.GetLeft(i)));\n    }\n    sinkApps.Start(Seconds(0.0));\n    sinkApps.Stop(Seconds(30.0));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < d.RightCount(); ++i)\n    {\n        // Create an on/off app sending packets to the left side\n        AddressValue remoteAddress(InetSocketAddress(d.GetLeftIpv4Address(i), port));\n        clientHelper.SetAttribute(\"Remote\", remoteAddress);\n        clientApps.Add(clientHelper.Install(d.GetRight(i)));\n    }\n    clientApps.Start(Seconds(1.0)); // Start 1 second after sink\n    clientApps.Stop(Seconds(15.0)); // Stop before the sink\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    std::cout << \"Running the simulation\" << std::endl;\n    Simulator::Run();\n\n    QueueDisc::Stats st = queueDiscs.Get(0)->GetStats();\n\n    if (st.GetNDroppedPackets(RedQueueDisc::UNFORCED_DROP) == 0)\n    {\n        std::cout << \"There should be some unforced drops\" << std::endl;\n        exit(1);\n    }\n\n    if (st.GetNDroppedPackets(QueueDisc::INTERNAL_QUEUE_DROP) != 0)\n    {\n        std::cout << \"There should be zero drops due to queue full\" << std::endl;\n        exit(1);\n    }\n\n    std::cout << \"*** Stats from the bottleneck queue disc ***\" << std::endl;\n    std::cout << st << std::endl;\n    std::cout << \"Destroying the simulation\" << std::endl;\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a ring topology network using ns3 where four nodes are connected in a circular manner with point-to-point links between adjacent nodes. Assign IP addresses within the 192.9.39.0/24 network, and use the UDP Echo Client-Server application for communication. Each node should act as both a client and a server at least once, but only one pair of client-server applications should run at any given time. Ensure that each client sends exactly 4 packets, with a transmission interval of 1 second, and configure the server to respond to the client's requests. Additionally, configure the link data rate to 5Mbps and a delay of 2ms."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RingTopologyExample\");\n\nint main(int argc, char* argv[])\n{\n    // Parse command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    // Set time resolution to nanoseconds\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create four nodes for the ring topology\n    NodeContainer ring;\n    ring.Create(4);\n\n    // Configure point-to-point links with 5Mbps data rate and 2ms delay\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create devices for each pair of adjacent nodes in the ring\n    NetDeviceContainer device1, device2, device3, device4;\n    device1.Add(pointToPoint.Install(ring.Get(0), ring.Get(1)));\n    device2.Add(pointToPoint.Install(ring.Get(1), ring.Get(2)));\n    device3.Add(pointToPoint.Install(ring.Get(2), ring.Get(3)));\n    device4.Add(pointToPoint.Install(ring.Get(3), ring.Get(0)));\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper stack;\n    stack.Install(ring);\n\n    // Assign IP addresses for each point-to-point link\n    Ipv4AddressHelper address1, address2, address3, address4;\n    address1.SetBase(\"192.9.39.0\", \"255.255.255.252\");  // Subnet for node 0-1 link\n    address2.SetBase(\"192.9.39.4\", \"255.255.255.252\");  // Subnet for node 1-2 link\n    address3.SetBase(\"192.9.39.8\", \"255.255.255.252\");  // Subnet for node 2-3 link\n    address4.SetBase(\"192.9.39.12\", \"255.255.255.252\"); // Subnet for node 3-0 link\n\n    // Assign IP addresses to each device's interface\n    Ipv4InterfaceContainer interface1, interface2, interface3, interface4;\n    interface1 = address1.Assign(device1);\n    interface2 = address2.Assign(device2);\n    interface3 = address3.Assign(device3);\n    interface4 = address4.Assign(device4);\n\n    // Create a UDP echo server on each node in sequence\n    UdpEchoServerHelper echoServer(9);  // All servers listen on port 9\n\n    // Configure server on node 1 and client on node 0\n    ApplicationContainer serverApps10 = echoServer.Install(ring.Get(1));\n    serverApps10.Start(Seconds(1.0));\n    serverApps10.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient10(interface1.GetAddress(1), 9); // Node 1 as server\n    echoClient10.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient10.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient10.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp10 = echoClient10.Install(ring.Get(0)); // Node 0 as client\n    clientApp10.Start(Seconds(2.0));\n    clientApp10.Stop(Seconds(10.0));\n\n    // Configure server on node 2 and client on node 1\n    ApplicationContainer serverApps21 = echoServer.Install(ring.Get(2));\n    serverApps21.Start(Seconds(11.0));\n    serverApps21.Stop(Seconds(20.0));\n\n    UdpEchoClientHelper echoClient21(interface2.GetAddress(1), 9); // Node 2 as server\n    echoClient21.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient21.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient21.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp21 = echoClient21.Install(ring.Get(1)); // Node 1 as client\n    clientApp21.Start(Seconds(12.0));\n    clientApp21.Stop(Seconds(20.0));\n\n    // Configure server on node 3 and client on node 2\n    ApplicationContainer serverApps32 = echoServer.Install(ring.Get(3));\n    serverApps32.Start(Seconds(21.0));\n    serverApps32.Stop(Seconds(30.0));\n\n    UdpEchoClientHelper echoClient32(interface3.GetAddress(1), 9); // Node 3 as server\n    echoClient32.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient32.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient32.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp32 = echoClient32.Install(ring.Get(2)); // Node 2 as client\n    clientApp32.Start(Seconds(22.0));\n    clientApp32.Stop(Seconds(30.0));\n\n    // Configure server on node 0 and client on node 3\n    ApplicationContainer serverApps03 = echoServer.Install(ring.Get(0));\n    serverApps03.Start(Seconds(31.0));\n    serverApps03.Stop(Seconds(40.0));\n\n    UdpEchoClientHelper echoClient03(interface4.GetAddress(1), 9); // Node 0 as server\n    echoClient03.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient03.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient03.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp03 = echoClient03.Install(ring.Get(3)); // Node 3 as client\n    clientApp03.Start(Seconds(32.0));\n    clientApp03.Stop(Seconds(40.0));\n\n    // Enable NetAnim animation output\n    AnimationInterface anim(\"RingTopologyExample.xml\");\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 that sets up a dumbbell network topology with configurable leaf nodes and queue types, supporting either RED or NLRED queue disciplines. The program should accept command-line arguments to adjust settings such as the number of leaf nodes, queue disc limits, packet size, data rates, and RED queue thresholds. Implement the ability to toggle between packet-based and byte-based queue modes. The OnOff application should be installed on right-side nodes, with random On/Off periods, and the program should display statistics about packet drops in the queue. Ensure appropriate handling of errors and conditions in the queue disc statistics."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-layout-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n#include <iomanip>\n#include <iostream>\n#include <map>\n\nusing namespace ns3;\n\nint\nmain(int argc, char* argv[])\n{\n    uint32_t nLeaf = 10;\n    uint32_t maxPackets = 100;\n    bool modeBytes = false;\n    uint32_t queueDiscLimitPackets = 1000;\n    double minTh = 5;\n    double maxTh = 15;\n    uint32_t pktSize = 512;\n    std::string appDataRate = \"10Mbps\";\n    std::string queueDiscType = \"RED\";\n    uint16_t port = 5001;\n    std::string bottleNeckLinkBw = \"1Mbps\";\n    std::string bottleNeckLinkDelay = \"50ms\";\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"nLeaf\", \"Number of left and right side leaf nodes\", nLeaf);\n    cmd.AddValue(\"maxPackets\", \"Max Packets allowed in the device queue\", maxPackets);\n    cmd.AddValue(\"queueDiscLimitPackets\",\n                 \"Max Packets allowed in the queue disc\",\n                 queueDiscLimitPackets);\n    cmd.AddValue(\"queueDiscType\", \"Set Queue disc type to RED or NLRED\", queueDiscType);\n    cmd.AddValue(\"appPktSize\", \"Set OnOff App Packet Size\", pktSize);\n    cmd.AddValue(\"appDataRate\", \"Set OnOff App DataRate\", appDataRate);\n    cmd.AddValue(\"modeBytes\", \"Set Queue disc mode to Packets (false) or bytes (true)\", modeBytes);\n\n    cmd.AddValue(\"redMinTh\", \"RED queue minimum threshold\", minTh);\n    cmd.AddValue(\"redMaxTh\", \"RED queue maximum threshold\", maxTh);\n    cmd.Parse(argc, argv);\n\n    if ((queueDiscType != \"RED\") && (queueDiscType != \"NLRED\"))\n    {\n        std::cout << \"Invalid queue disc type: Use --queueDiscType=RED or --queueDiscType=NLRED\"\n                  << std::endl;\n        exit(1);\n    }\n\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(pktSize));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(appDataRate));\n\n    Config::SetDefault(\"ns3::DropTailQueue<Packet>::MaxSize\",\n                       QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, maxPackets)));\n\n    if (!modeBytes)\n    {\n        Config::SetDefault(\n            \"ns3::RedQueueDisc::MaxSize\",\n            QueueSizeValue(QueueSize(QueueSizeUnit::PACKETS, queueDiscLimitPackets)));\n    }\n    else\n    {\n        Config::SetDefault(\n            \"ns3::RedQueueDisc::MaxSize\",\n            QueueSizeValue(QueueSize(QueueSizeUnit::BYTES, queueDiscLimitPackets * pktSize)));\n        minTh *= pktSize;\n        maxTh *= pktSize;\n    }\n\n    Config::SetDefault(\"ns3::RedQueueDisc::MinTh\", DoubleValue(minTh));\n    Config::SetDefault(\"ns3::RedQueueDisc::MaxTh\", DoubleValue(maxTh));\n    Config::SetDefault(\"ns3::RedQueueDisc::LinkBandwidth\", StringValue(bottleNeckLinkBw));\n    Config::SetDefault(\"ns3::RedQueueDisc::LinkDelay\", StringValue(bottleNeckLinkDelay));\n    Config::SetDefault(\"ns3::RedQueueDisc::MeanPktSize\", UintegerValue(pktSize));\n\n    if (queueDiscType == \"NLRED\")\n    {\n        // Turn on NLRED\n        Config::SetDefault(\"ns3::RedQueueDisc::NLRED\", BooleanValue(true));\n    }\n\n    // Create the point-to-point link helpers\n    PointToPointHelper bottleNeckLink;\n    bottleNeckLink.SetDeviceAttribute(\"DataRate\", StringValue(bottleNeckLinkBw));\n    bottleNeckLink.SetChannelAttribute(\"Delay\", StringValue(bottleNeckLinkDelay));\n\n    PointToPointHelper pointToPointLeaf;\n    pointToPointLeaf.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPointLeaf.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    PointToPointDumbbellHelper d(nLeaf, pointToPointLeaf, nLeaf, pointToPointLeaf, bottleNeckLink);\n\n    // Install Stack\n    InternetStackHelper stack;\n    for (uint32_t i = 0; i < d.LeftCount(); ++i)\n    {\n        stack.Install(d.GetLeft(i));\n    }\n    for (uint32_t i = 0; i < d.RightCount(); ++i)\n    {\n        stack.Install(d.GetRight(i));\n    }\n\n    stack.Install(d.GetLeft());\n    stack.Install(d.GetRight());\n    TrafficControlHelper tchBottleneck;\n    QueueDiscContainer queueDiscs;\n    tchBottleneck.SetRootQueueDisc(\"ns3::RedQueueDisc\");\n    tchBottleneck.Install(d.GetLeft()->GetDevice(0));\n    queueDiscs = tchBottleneck.Install(d.GetRight()->GetDevice(0));\n\n    // Assign IP Addresses\n    d.AssignIpv4Addresses(Ipv4AddressHelper(\"10.1.1.0\", \"255.255.255.0\"),\n                          Ipv4AddressHelper(\"10.2.1.0\", \"255.255.255.0\"),\n                          Ipv4AddressHelper(\"10.3.1.0\", \"255.255.255.0\"));\n\n    // Install on/off app on all right side nodes\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", Address());\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::UniformRandomVariable[Min=0.|Max=1.]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::UniformRandomVariable[Min=0.|Max=1.]\"));\n    Address sinkLocalAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", sinkLocalAddress);\n    ApplicationContainer sinkApps;\n    for (uint32_t i = 0; i < d.LeftCount(); ++i)\n    {\n        sinkApps.Add(packetSinkHelper.Install(d.GetLeft(i)));\n    }\n    sinkApps.Start(Seconds(0.0));\n    sinkApps.Stop(Seconds(30.0));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < d.RightCount(); ++i)\n    {\n        // Create an on/off app sending packets to the left side\n        AddressValue remoteAddress(InetSocketAddress(d.GetLeftIpv4Address(i), port));\n        clientHelper.SetAttribute(\"Remote\", remoteAddress);\n        clientApps.Add(clientHelper.Install(d.GetRight(i)));\n    }\n    clientApps.Start(Seconds(1.0)); // Start 1 second after sink\n    clientApps.Stop(Seconds(15.0)); // Stop before the sink\n\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    std::cout << \"Running the simulation\" << std::endl;\n    Simulator::Run();\n\n    QueueDisc::Stats st = queueDiscs.Get(0)->GetStats();\n\n    if (st.GetNDroppedPackets(RedQueueDisc::UNFORCED_DROP) == 0)\n    {\n        std::cout << \"There should be some unforced drops\" << std::endl;\n        exit(1);\n    }\n\n    if (st.GetNDroppedPackets(QueueDisc::INTERNAL_QUEUE_DROP) != 0)\n    {\n        std::cout << \"There should be zero drops due to queue full\" << std::endl;\n        exit(1);\n    }\n\n    std::cout << \"*** Stats from the bottleneck queue disc ***\" << std::endl;\n    std::cout << st << std::endl;\n    std::cout << \"Destroying the simulation\" << std::endl;\n\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a program in ns-3 that simulates a three-router network scenario using global routing. The topology includes three nodes: A, B, and C. Node A has a /32 IP address (a.a.a.a/32), node B connects to both A and C through point-to-point links with subnets x.x.x.0/30 and y.y.y.0/30, and node C has a /32 IP address (c.c.c.c/32). Establish point-to-point links between A and B, and between B and C, each with a data rate of 5 Mbps and 2 ms delay. Add CsmaNetDevices to nodes A and C, assigning /32 IP addresses (172.16.1.1 and 192.168.1.1) to their interfaces. Set up UDP traffic from A to C, with a sending application on A and a packet sink on C, using a constant rate. Enable tracing and packet capturing for analysis."}, {"role": "assistant", "content": "// Test program for this 3-router scenario, using global routing\n//\n// (a.a.a.a/32)A<--x.x.x.0/30-->B<--y.y.y.0/30-->C(c.c.c.c/32)\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-net-device.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"GlobalRouterSlash32Test\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Ptr<Node> nA = CreateObject<Node>();\n    Ptr<Node> nB = CreateObject<Node>();\n    Ptr<Node> nC = CreateObject<Node>();\n\n    NodeContainer c = NodeContainer(nA, nB, nC);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // Point-to-point links\n    NodeContainer nAnB = NodeContainer(nA, nB);\n    NodeContainer nBnC = NodeContainer(nB, nC);\n\n    // We create the channels first without any IP addressing information\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer dAdB = p2p.Install(nAnB);\n\n    NetDeviceContainer dBdC = p2p.Install(nBnC);\n\n    Ptr<CsmaNetDevice> deviceA = CreateObject<CsmaNetDevice>();\n    deviceA->SetAddress(Mac48Address::Allocate());\n    nA->AddDevice(deviceA);\n    deviceA->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    Ptr<CsmaNetDevice> deviceC = CreateObject<CsmaNetDevice>();\n    deviceC->SetAddress(Mac48Address::Allocate());\n    nC->AddDevice(deviceC);\n    deviceC->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    // Later, we add IP addresses.\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iAiB = ipv4.Assign(dAdB);\n\n    ipv4.SetBase(\"10.1.1.4\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iBiC = ipv4.Assign(dBdC);\n\n    Ptr<Ipv4> ipv4A = nA->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4C = nC->GetObject<Ipv4>();\n\n    int32_t ifIndexA = ipv4A->AddInterface(deviceA);\n    int32_t ifIndexC = ipv4C->AddInterface(deviceC);\n\n    Ipv4InterfaceAddress ifInAddrA =\n        Ipv4InterfaceAddress(Ipv4Address(\"172.16.1.1\"), Ipv4Mask(\"255.255.255.255\"));\n    ipv4A->AddAddress(ifIndexA, ifInAddrA);\n    ipv4A->SetMetric(ifIndexA, 1);\n    ipv4A->SetUp(ifIndexA);\n\n    Ipv4InterfaceAddress ifInAddrC =\n        Ipv4InterfaceAddress(Ipv4Address(\"192.168.1.1\"), Ipv4Mask(\"255.255.255.255\"));\n    ipv4C->AddAddress(ifIndexC, ifInAddrC);\n    ipv4C->SetMetric(ifIndexC, 1);\n    ipv4C->SetUp(ifIndexC);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(ifInAddrC.GetLocal(), port)));\n    onoff.SetConstantRate(DataRate(6000));\n    ApplicationContainer apps = onoff.Install(nA);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(nC);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"global-routing-slash32.tr\"));\n    p2p.EnablePcapAll(\"global-routing-slash32\");\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulator that creates a network topology with two L2 LANs, each with multiple interconnected L2 switches, connected by a WAN link. Name the two LANs \"top\" (192.168.1/24) and \"bottom\" (192.168.2/24), and assign each LAN its own router to act as a gateway to the WAN. Configure UDP echo clients and servers on both LANs to test connectivity. In the top LAN, connect node t2 (UDP echo client) through multiple switches to router tr, and node t3 (UDP echo server) through a single switch. In the bottom LAN, connect node b2 (UDP echo server) through multiple switches to router br, and node b3 (UDP echo client) through a single switch. Ensure the simulation can use both 100Mbit and 10Mbit Ethernet CSMA links for LAN connections, configurable via command-line arguments, and model the WAN using a point-to-point link with configurable rate and delay. Use this to test a patch that fixes global-router-interface support for bridging across multiple switches"}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/bridge-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <fstream>\n#include <iostream>\n\nusing namespace ns3;\n\n// ########################################################################\n// Main routine\n// ########################################################################\nNS_LOG_COMPONENT_DEFINE(\"GlobalRoutingMultiSwitchPlusRouter\");\n\n#define vssearch(loc, vec) std::find((vec).begin(), (vec).end(), (loc)) != (vec).end()\n\nint\nmain(int argc, char* argv[])\n{\n    // ----------------------------------------------------------------------\n    // Default values for command line arguments\n    // ----------------------------------------------------------------------\n    bool verbose = true;\n\n    int simDurationSeconds = 60;\n\n    bool enableUdpMultiSW = true;\n    bool enableUdpSingleSW = true;\n\n    std::string pcapLocations = \"\";\n    uint32_t snapLen = PcapFile::SNAPLEN_DEFAULT;\n\n    std::string csmaXLinkDataRate = \"100Mbps\";\n    std::string csmaXLinkDelay = \"500ns\";\n\n    std::string csmaYLinkDataRate = \"10Mbps\";\n    std::string csmaYLinkDelay = \"500ns\";\n\n    std::string p2pLinkDataRate = \"5Mbps\";\n    std::string p2pLinkDelay = \"50ms\";\n\n    uint16_t udpEchoPort = 9; // The well-known UDP echo port\n\n    // ----------------------------------------------------------------------\n    // Create command line options and get them\n    // ----------------------------------------------------------------------\n    CommandLine cmd(__FILE__);\n\n    cmd.Usage(\"NOTE: valid --pcap arguments are: 't2,t3,b2,b3,trlan,trwan,brlan,brwan'\");\n\n    cmd.AddValue(\"verbose\", \"Enable printing informational messages\", verbose);\n\n    cmd.AddValue(\"duration\", \"Duration of simulation.\", simDurationSeconds);\n\n    cmd.AddValue(\"udpMultiSW\", \"Enable udp over multi-switch links\", enableUdpMultiSW);\n    cmd.AddValue(\"udpSingleSW\", \"Enable udp over single-switch links\", enableUdpSingleSW);\n\n    cmd.AddValue(\"pcap\", \"Comma separated list of PCAP Locations to tap\", pcapLocations);\n    cmd.AddValue(\"snapLen\", \"PCAP packet capture length\", snapLen);\n\n    cmd.AddValue(\"csmaXRate\", \"CSMA X Link data rate\", csmaXLinkDataRate);\n    cmd.AddValue(\"csmaXDelay\", \"CSMA X Link delay\", csmaXLinkDelay);\n\n    cmd.AddValue(\"csmaYRate\", \"CSMA Y Link data rate\", csmaYLinkDataRate);\n    cmd.AddValue(\"csmaYDelay\", \"CSMA Y Link delay\", csmaYLinkDelay);\n\n    cmd.AddValue(\"p2pRate\", \"P2P Link data rate\", p2pLinkDataRate);\n    cmd.AddValue(\"p2pDelay\", \"P2P Link delay\", p2pLinkDelay);\n\n    cmd.Parse(argc, argv);\n\n    // --------------------------------------------------------------------\n    // Users may find it convenient to turn on explicit debugging\n    // for selected modules; the below lines suggest how to do this\n    // --------------------------------------------------------------------\n    if (verbose)\n    {\n        LogComponentEnable(\"GlobalRoutingMultiSwitchPlusRouter\", LOG_LEVEL_INFO);\n    }\n\n    // ======================================================================\n    // Define the list of valid PCAP taps\n    // ----------------------------------------------------------------------\n    const std::vector<std::string> pcapTaps{\n        \"t2\",    // multi-switch  UDP echo client\n        \"t3\",    // single-switch UDP echo server\n        \"b2\",    // multi-switch  UDP echo server\n        \"b3\",    // single-switch UDP echo client\n        \"trlan\", // top router    LAN side\n        \"trwan\", // top router    WAN side\n        \"brlan\", // bottom router LAN side\n        \"brwan\", // bottom router WAN side\n    };\n\n    // ----------------------------------------------------------------------\n    // Parse the pcapLocations string into pcapLocationVec\n    // ----------------------------------------------------------------------\n    std::vector<std::string> pcapLocationVec;\n    if (!pcapLocations.empty())\n    {\n        std::stringstream sStream(pcapLocations);\n\n        while (sStream.good())\n        {\n            std::string substr;\n            getline(sStream, substr, ',');\n            if (vssearch(substr, pcapTaps))\n            {\n                pcapLocationVec.push_back(substr);\n            }\n            else\n            {\n                NS_LOG_ERROR(\"WARNING: Unrecognized PCAP location: <\" + substr + \">\");\n            }\n        }\n\n        for (auto ploc = pcapLocationVec.begin(); ploc != pcapLocationVec.end(); ++ploc)\n        {\n            NS_LOG_INFO(\"PCAP capture at: <\" + *ploc + \">\");\n        }\n    }\n\n    // ======================================================================\n    // Set some simulator-wide values\n    // ======================================================================\n\n    // ----------------------------------------------------------------------\n    // Set PCAP packet capture maximum packet length\n    // ----------------------------------------------------------------------\n    if (snapLen != PcapFile::SNAPLEN_DEFAULT)\n    {\n        Config::SetDefault(\"ns3::PcapFileWrapper::CaptureSize\", UintegerValue(snapLen));\n    }\n\n    // ======================================================================\n    // Create the nodes & links required for the topology shown in comments above.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"INFO: Create nodes.\");   // - - - - - - - - - - - - - - - -\n                                          // Node IP     : Description\n                                          // - - - - - - - - - - - - - - - -\n    Ptr<Node> t2 = CreateObject<Node>();  // 192.168.1.2 : Top multi-switch udp echo client\n    Ptr<Node> t3 = CreateObject<Node>();  // 192.168.1.3 : Top single-switch   udp echo server\n                                          //             :\n    Ptr<Node> ts1 = CreateObject<Node>(); // <no IP>     : Top switch #1 (bridge)\n    Ptr<Node> ts2 = CreateObject<Node>(); // <no IP>     : Top switch #2 (bridge)\n    Ptr<Node> ts3 = CreateObject<Node>(); // <no IP>     : Top switch #3 (bridge)\n    Ptr<Node> ts4 = CreateObject<Node>(); // <no IP>     : Top switch #4 (bridge)\n                                          //             :\n    Ptr<Node> tr = CreateObject<Node>();  // 192.168.1.1 : Router connecting top LAN & WAN\n                                          // 76.1.1.1    :\n                                          //             :\n    Ptr<Node> br = CreateObject<Node>();  // 76.1.1.2    : Router connecting WAN & bottom LANs\n                                          // 192.168.2.1 :\n                                          //             :\n    Ptr<Node> bs1 = CreateObject<Node>(); // <no IP>     : Bottom switch #1 (bridge)\n    Ptr<Node> bs2 = CreateObject<Node>(); // <no IP>     : Bottom switch #2 (bridge)\n    Ptr<Node> bs3 = CreateObject<Node>(); // <no IP>     : Bottom switch #3 (bridge)\n    Ptr<Node> bs4 = CreateObject<Node>(); // <no IP>     : Bottom switch #4 (bridge)\n    Ptr<Node> bs5 = CreateObject<Node>(); // <no IP>     : Bottom switch #5 (bridge)\n                                          //             :\n    Ptr<Node> b2 = CreateObject<Node>();  // 192.168.2.2 : Bottom multi-switch udp echo server\n\n    Ptr<Node> b3 = CreateObject<Node>(); // 192.168.2.3 : Bottom single-switch   udp echo client\n                                         // - - - - - - - - - - - - - - - -\n\n    // ----------------------------------------------------------------------\n    // Give the nodes names\n    // ----------------------------------------------------------------------\n    Names::Add(\"t2\", t2);\n    Names::Add(\"t3\", t3);\n    Names::Add(\"ts1\", ts1);\n    Names::Add(\"ts2\", ts2);\n    Names::Add(\"ts3\", ts3);\n    Names::Add(\"ts4\", ts4);\n    Names::Add(\"tr\", tr);\n    Names::Add(\"br\", br);\n    Names::Add(\"bs1\", bs1);\n    Names::Add(\"bs2\", bs2);\n    Names::Add(\"bs3\", bs3);\n    Names::Add(\"bs4\", bs4);\n    Names::Add(\"bs5\", bs5);\n    Names::Add(\"b2\", b2);\n    Names::Add(\"b3\", b3);\n\n    // ======================================================================\n    // Create CSMA links to use for connecting LAN nodes together\n    // ----------------------------------------------------------------------\n\n    // ----------------------------------------\n    // CSMA [X]\n    // ----------------------------------------\n    NS_LOG_INFO(\"L2: Create a \" << csmaXLinkDataRate << \" \" << csmaXLinkDelay\n                                << \" CSMA link for csmaX for LANs.\");\n    CsmaHelper csmaX;\n    csmaX.SetChannelAttribute(\"DataRate\", StringValue(csmaXLinkDataRate));\n    csmaX.SetChannelAttribute(\"Delay\", StringValue(csmaXLinkDelay));\n\n    // ----------------------------------------\n    // CSMA [Y]\n    // ----------------------------------------\n    NS_LOG_INFO(\"L2: Create a \" << csmaYLinkDataRate << \" \" << csmaYLinkDelay\n                                << \" CSMA link for csmaY for LANs.\");\n    CsmaHelper csmaY;\n    csmaY.SetChannelAttribute(\"DataRate\", StringValue(csmaYLinkDataRate));\n    csmaY.SetChannelAttribute(\"Delay\", StringValue(csmaYLinkDelay));\n\n    // ----------------------------------------------------------------------\n    // Now, connect the top LAN nodes together with csma links.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Connect nodes on top LAN together with half-duplex CSMA links.\");\n\n    // Multi-switch top LAN chain: t2-ts4-ts3-ts2-ts1-tr\n    NetDeviceContainer link_t2_ts4 = csmaX.Install(NodeContainer(t2, ts4));\n    NetDeviceContainer link_ts4_ts3 = csmaY.Install(NodeContainer(ts4, ts3));\n    NetDeviceContainer link_ts3_ts2 = csmaX.Install(NodeContainer(ts3, ts2));\n    NetDeviceContainer link_ts2_ts1 = csmaY.Install(NodeContainer(ts2, ts1));\n\n    // Single-switch top LAN link: t3-ts1-tr\n    NetDeviceContainer link_t3_ts1 = csmaX.Install(NodeContainer(t3, ts1));\n\n    // Common link for top LAN between ts1 and tr (for t2 and t3 to get to tr)\n    NetDeviceContainer link_tr_ts1 = csmaY.Install(NodeContainer(tr, ts1));\n\n    // ----------------------------------------------------------------------\n    // And repeat above steps to connect the bottom LAN nodes together\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Connect nodes on bottom LAN together with half-duplex CSMA links.\");\n\n    // Multi-switch bottom LAN chain: b2-bs5-bs4-bs3-bs2-bs1-br\n    NetDeviceContainer link_b2_bs5 = csmaY.Install(NodeContainer(b2, bs5));\n    NetDeviceContainer link_bs5_bs4 = csmaX.Install(NodeContainer(bs5, bs4));\n    NetDeviceContainer link_bs4_bs3 = csmaY.Install(NodeContainer(bs4, bs3));\n    NetDeviceContainer link_bs3_bs2 = csmaX.Install(NodeContainer(bs3, bs2));\n    NetDeviceContainer link_bs2_bs1 = csmaY.Install(NodeContainer(bs2, bs1));\n\n    // Single-switch bottom LAN link: b3-bs1-br\n    NetDeviceContainer link_b3_bs1 = csmaY.Install(NodeContainer(b3, bs1));\n\n    // Common link for bottom LAN between bs1 and br (for b2 and b3 to get to br)\n    NetDeviceContainer link_br_bs1 = csmaX.Install(NodeContainer(br, bs1));\n\n    // ======================================================================\n    // Create a point-to-point link for connecting WAN nodes together\n    // (this type of link is full-duplex)\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Create a \" << p2pLinkDataRate << \" \" << p2pLinkDelay\n                                << \" Point-to-Point link for the WAN.\");\n\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(p2pLinkDataRate));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(p2pLinkDelay));\n\n    // ----------------------------------------------------------------------\n    // Now, connect top router to bottom router with a p2p WAN link\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L2: Connect the routers together with the Point-to-Point WAN link.\");\n\n    NetDeviceContainer link_tr_br;\n    link_tr_br = p2p.Install(NodeContainer(tr, br));\n\n    // ======================================================================\n    // Manually create the list of NetDevices for each switch\n    // ----------------------------------------------------------------------\n\n    // Top Switch 4 NetDevices\n    NetDeviceContainer ts4nd;\n    ts4nd.Add(link_t2_ts4.Get(1));\n    ts4nd.Add(link_ts4_ts3.Get(0));\n\n    // Top Switch 3 NetDevices\n    NetDeviceContainer ts3nd;\n    ts3nd.Add(link_ts4_ts3.Get(1));\n    ts3nd.Add(link_ts3_ts2.Get(0));\n\n    // Top Switch 2 NetDevices\n    NetDeviceContainer ts2nd;\n    ts2nd.Add(link_ts3_ts2.Get(1));\n    ts2nd.Add(link_ts2_ts1.Get(0));\n\n    // Top Switch 1 NetDevices\n    NetDeviceContainer ts1nd;\n    ts1nd.Add(link_ts2_ts1.Get(1));\n    ts1nd.Add(link_t3_ts1.Get(1));\n    ts1nd.Add(link_tr_ts1.Get(1));\n\n    // Bottom Switch 1 NetDevices\n    NetDeviceContainer bs1nd;\n    bs1nd.Add(link_br_bs1.Get(1));\n    bs1nd.Add(link_bs2_bs1.Get(1));\n    bs1nd.Add(link_b3_bs1.Get(1));\n\n    // Bottom Switch 2 NetDevices\n    NetDeviceContainer bs2nd;\n    bs2nd.Add(link_bs2_bs1.Get(0));\n    bs2nd.Add(link_bs3_bs2.Get(1));\n\n    // Bottom Switch 3 NetDevices\n    NetDeviceContainer bs3nd;\n    bs3nd.Add(link_bs3_bs2.Get(0));\n    bs3nd.Add(link_bs4_bs3.Get(1));\n\n    // Bottom Switch 4 NetDevices\n    NetDeviceContainer bs4nd;\n    bs4nd.Add(link_bs4_bs3.Get(0));\n    bs4nd.Add(link_bs5_bs4.Get(1));\n\n    // Bottom Switch 5 NetDevices\n    NetDeviceContainer bs5nd;\n    bs5nd.Add(link_bs5_bs4.Get(0));\n    bs5nd.Add(link_b2_bs5.Get(1));\n\n    // ======================================================================\n    // Install bridging code on each switch\n    // ----------------------------------------------------------------------\n    BridgeHelper bridge;\n\n    bridge.Install(ts1, ts1nd);\n    bridge.Install(ts2, ts2nd);\n    bridge.Install(ts3, ts3nd);\n    bridge.Install(ts4, ts4nd);\n\n    bridge.Install(bs1, bs1nd);\n    bridge.Install(bs2, bs2nd);\n    bridge.Install(bs3, bs3nd);\n    bridge.Install(bs4, bs4nd);\n    bridge.Install(bs5, bs5nd);\n\n    // ======================================================================\n    // Install the L3 internet stack  (TCP/IP)\n    // ----------------------------------------------------------------------\n    InternetStackHelper ns3IpStack;\n\n    // ----------------------------------------------------------------------\n    // Install the L3 internet stack on UDP endpoints\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Install the ns3 IP stack on udp client and server nodes.\");\n    NodeContainer endpointNodes(t2, t3, b2, b3);\n    ns3IpStack.Install(endpointNodes);\n\n    // ----------------------------------------------------------------------\n    // Install the L3 internet stack on routers.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Install the ns3 IP stack on routers.\");\n    NodeContainer routerNodes(tr, br);\n    ns3IpStack.Install(routerNodes);\n\n    // ======================================================================\n    // Assign top LAN IP addresses\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Assign top LAN IP Addresses.\");\n\n    NetDeviceContainer topLanIpDevices;      // - - - - - -- - - - - - -\n    topLanIpDevices.Add(link_tr_ts1.Get(0)); // NOTE: order matters here\n    topLanIpDevices.Add(link_t2_ts4.Get(0)); //       for IP address\n    topLanIpDevices.Add(link_t3_ts1.Get(0)); //       assignment\n                                             // - - - - - -- - - - - - -\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    ipv4.Assign(topLanIpDevices);\n\n    // ----------------------------------------------------------------------\n    // Assign bottom LAN IP addresses\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Assign bottom LAN IP Addresses.\");\n\n    NetDeviceContainer botLanIpDevices;      // - - - - - -- - - - - - -\n    botLanIpDevices.Add(link_br_bs1.Get(0)); // NOTE: order matters here\n    botLanIpDevices.Add(link_b2_bs5.Get(0)); //       for IP address\n    botLanIpDevices.Add(link_b3_bs1.Get(0)); //       assignment\n                                             // - - - - - -- - - - - - -\n\n    ipv4.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    ipv4.Assign(botLanIpDevices);\n\n    // ----------------------------------------------------------------------\n    // Assign WAN IP addresses\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Assign WAN IP Addresses.\");\n\n    ipv4.SetBase(\"76.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(link_tr_br);\n\n    // ======================================================================\n    // Calculate and populate routing tables\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"L3: Populate routing tables.\");\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // ======================================================================\n    // Multi-Switch UDP traffic generation\n    // ----------------------------------------------------------------------\n    ApplicationContainer apps;\n\n    if (enableUdpMultiSW)\n    {\n        // ------------------------------------------------------------------\n        // Install multi-switch UDP echo server on b2\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Multi-Switch UDP server (on node b2 of bottom LAN)\");\n\n        UdpEchoServerHelper server(udpEchoPort);\n\n        ApplicationContainer serverApp = server.Install(b2);\n        serverApp.Start(Seconds(0.5));\n        serverApp.Stop(Seconds(simDurationSeconds));\n\n        // ------------------------------------------------------------------\n        // Install multi-switch UDP echo client on t2\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Multi-Switch UDP client (on node t2 of top LAN)\");\n\n        Time interPacketInterval = Seconds(0.005);\n        uint32_t packetSize = 1000;\n        uint32_t maxPacketCount = (simDurationSeconds - 2.0) / 0.005;\n\n        UdpEchoClientHelper client(Ipv4Address(\"192.168.2.2\"), udpEchoPort);\n\n        client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n        client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n        client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n        ApplicationContainer clientApp = client.Install(t2);\n        clientApp.Start(Seconds(0.5));\n        clientApp.Stop(Seconds(simDurationSeconds));\n    }\n\n    // ======================================================================\n    // Single-Switch UDP traffic generation\n    // ----------------------------------------------------------------------\n    if (enableUdpSingleSW)\n    {\n        // ------------------------------------------------------------------\n        // Install single-switch UDP echo server on t3\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Single-Switch UDP server (on node t3 of top LAN)\");\n\n        UdpEchoServerHelper server(udpEchoPort);\n\n        ApplicationContainer serverApp = server.Install(t3);\n        serverApp.Start(Seconds(0.5));\n        serverApp.Stop(Seconds(simDurationSeconds));\n\n        // ------------------------------------------------------------------\n        // Install single-switch UDP echo client on b3\n        // ------------------------------------------------------------------\n        NS_LOG_INFO(\"APP: Single-Switch UDP client (on node b3 bottom LAN)\");\n\n        Time interPacketInterval = Seconds(0.005);\n        uint32_t packetSize = 1000;\n        uint32_t maxPacketCount = (simDurationSeconds - 2.0) / 0.005;\n\n        UdpEchoClientHelper client(Ipv4Address(\"192.168.1.3\"), udpEchoPort);\n\n        client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n        client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n        client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n\n        ApplicationContainer clientApp = client.Install(b3);\n        clientApp.Start(Seconds(0.5));\n        clientApp.Stop(Seconds(simDurationSeconds));\n    }\n\n    // ======================================================================\n    // Print routing tables at T=0.1\n    // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    // NOTE: Node 0 and Node 13 must have non-empty tables (except for local\n    //       loopback and local LAN) if routing is operating correctly.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"Set up to print routing tables at T=0.1s\");\n\n    Ptr<OutputStreamWrapper> routingStream =\n        Create<OutputStreamWrapper>(\"global-routing-multi-switch-plus-router.routes\",\n                                    std::ios::out);\n\n    Ipv4RoutingHelper::PrintRoutingTableAllAt(Seconds(0.1), routingStream);\n\n    // ======================================================================\n    // Configure PCAP traces\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"Configure PCAP Tracing (if any configured).\");\n\n    // - - - - - - - - - - - - - -\n    // multi-switch UDP echo client\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"t2\", pcapLocationVec))\n    {\n        csmaX.EnablePcap(\"t2.pcap\", topLanIpDevices.Get(1), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // multi-switch UDP echo server\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"b2\", pcapLocationVec))\n    {\n        csmaY.EnablePcap(\"b2.pcap\", botLanIpDevices.Get(1), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // single-switch UDP echo client\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"b3\", pcapLocationVec))\n    {\n        csmaY.EnablePcap(\"b3.pcap\", botLanIpDevices.Get(2), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // single-switch UDP echo server\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"t3\", pcapLocationVec))\n    {\n        csmaX.EnablePcap(\"t3.pcap\", topLanIpDevices.Get(2), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // top router, LAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"trlan\", pcapLocationVec))\n    {\n        csmaY.EnablePcap(\"trlan.pcap\", topLanIpDevices.Get(0), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // bottom router, LAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"brlan\", pcapLocationVec))\n    {\n        csmaX.EnablePcap(\"brlan.pcap\", botLanIpDevices.Get(0), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // top router, WAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"trwan\", pcapLocationVec))\n    {\n        p2p.EnablePcap(\"trwan.pcap\", link_tr_br.Get(0), true, true);\n    }\n\n    // - - - - - - - - - - - - - -\n    // bottom router, WAN side\n    // - - - - - - - - - - - - - -\n    if (vssearch(\"brwan\", pcapLocationVec))\n    {\n        p2p.EnablePcap(\"brwan.pcap\", link_tr_br.Get(1), true, true);\n    }\n\n    // ======================================================================\n    // Now, do the actual simulation.\n    // ----------------------------------------------------------------------\n    NS_LOG_INFO(\"Run Simulation for \" << simDurationSeconds << \" seconds.\");\n\n    Simulator::Stop(Seconds(simDurationSeconds));\n    Simulator::Run();\n\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulator that sets up a three-router network topology where routers A, B, and C are interconnected by point-to-point links. The topology is as follows: router A has an IP address in the range a.a.a.a/32, router B connects A and C over subnet x.x.x.0/30 and y.y.y.0/30, and router C has an IP address in the range c.c.c.c/32. Install an OnOff UDP application on router A to send datagrams to router C, and set up a packet sink on router C to receive the traffic. Use the Ipv4GlobalRoutingHelper to populate routing tables, configure packet tracing, and run the simulation for 10 seconds."}, {"role": "assistant", "content": "// Test program for this 3-router scenario, using global routing\n//\n// (a.a.a.a/32)A<--x.x.x.0/30-->B<--y.y.y.0/30-->C(c.c.c.c/32)\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-net-device.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"GlobalRouterSlash32Test\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Ptr<Node> nA = CreateObject<Node>();\n    Ptr<Node> nB = CreateObject<Node>();\n    Ptr<Node> nC = CreateObject<Node>();\n\n    NodeContainer c = NodeContainer(nA, nB, nC);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // Point-to-point links\n    NodeContainer nAnB = NodeContainer(nA, nB);\n    NodeContainer nBnC = NodeContainer(nB, nC);\n\n    // We create the channels first without any IP addressing information\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer dAdB = p2p.Install(nAnB);\n\n    NetDeviceContainer dBdC = p2p.Install(nBnC);\n\n    Ptr<CsmaNetDevice> deviceA = CreateObject<CsmaNetDevice>();\n    deviceA->SetAddress(Mac48Address::Allocate());\n    nA->AddDevice(deviceA);\n    deviceA->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    Ptr<CsmaNetDevice> deviceC = CreateObject<CsmaNetDevice>();\n    deviceC->SetAddress(Mac48Address::Allocate());\n    nC->AddDevice(deviceC);\n    deviceC->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    // Later, we add IP addresses.\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iAiB = ipv4.Assign(dAdB);\n\n    ipv4.SetBase(\"10.1.1.4\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iBiC = ipv4.Assign(dBdC);\n\n    Ptr<Ipv4> ipv4A = nA->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4C = nC->GetObject<Ipv4>();\n\n    int32_t ifIndexA = ipv4A->AddInterface(deviceA);\n    int32_t ifIndexC = ipv4C->AddInterface(deviceC);\n\n    Ipv4InterfaceAddress ifInAddrA =\n        Ipv4InterfaceAddress(Ipv4Address(\"172.16.1.1\"), Ipv4Mask(\"255.255.255.255\"));\n    ipv4A->AddAddress(ifIndexA, ifInAddrA);\n    ipv4A->SetMetric(ifIndexA, 1);\n    ipv4A->SetUp(ifIndexA);\n\n    Ipv4InterfaceAddress ifInAddrC =\n        Ipv4InterfaceAddress(Ipv4Address(\"192.168.1.1\"), Ipv4Mask(\"255.255.255.255\"));\n    ipv4C->AddAddress(ifIndexC, ifInAddrC);\n    ipv4C->SetMetric(ifIndexC, 1);\n    ipv4C->SetUp(ifIndexC);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(ifInAddrC.GetLocal(), port)));\n    onoff.SetConstantRate(DataRate(6000));\n    ApplicationContainer apps = onoff.Install(nA);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(nC);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"global-routing-slash32.tr\"));\n    p2p.EnablePcapAll(\"global-routing-slash32\");\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 simulator to compare the performance of different MANET routing protocols (DSDV, AODV, OLSR, and DSR) under a typical random waypoint mobility model. The default simulation runs for 200 seconds with 50 nodes moving at 20 m/s in a 300x1500 meter area, using WiFi in ad-hoc mode with a transmission power of 7.5 dBm. The program allows modifying parameters such as protocol choice, node density, mobility, and transmission power. Additionally, it generates 10 UDP source/sink pairs with data transmission starting randomly between 50 and 51 seconds. The simulation outputs data reception statistics in a CSV file, with optional mobility tracing and flow monitoring."}, {"role": "assistant", "content": "/*\n * This example program allows one to run ns-3 DSDV, AODV, or OLSR under\n * a typical random waypoint mobility model.\n *\n * By default, the simulation runs for 200 simulated seconds, of which\n * the first 50 are used for start-up time.  The number of nodes is 50.\n * Nodes move according to RandomWaypointMobilityModel with a speed of\n * 20 m/s and no pause time within a 300x1500 m region.  The WiFi is\n * in ad hoc mode with a 2 Mb/s rate (802.11b) and a Friis loss model.\n * The transmit power is set to 7.5 dBm.\n *\n * It is possible to change the mobility and density of the network by\n * directly modifying the speed and the number of nodes.  It is also\n * possible to change the characteristics of the network by changing\n * the transmit power (as power increases, the impact of mobility\n * decreases and the effective density increases).\n *\n * By default, OLSR is used, but specifying a value of 2 for the protocol\n * will cause AODV to be used, and specifying a value of 3 will cause\n * DSDV to be used.\n *\n * By default, there are 10 source/sink data pairs sending UDP data\n * at an application rate of 2.048 Kb/s each.    This is typically done\n * at a rate of 4 64-byte packets per second.  Application data is\n * started at a random time between 50 and 51 seconds and continues\n * to the end of the simulation.\n *\n * The program outputs a few items:\n * - packet receptions are notified to stdout such as:\n *   <timestamp> <node-id> received one packet from <src-address>\n * - each second, the data reception statistics are tabulated and output\n *   to a comma-separated value (csv) file\n * - some tracing and flow monitor configuration that used to work is\n *   left commented inline in the program\n */\n\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/dsdv-module.h\"\n#include \"ns3/dsr-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/olsr-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <fstream>\n#include <iostream>\n\nusing namespace ns3;\nusing namespace dsr;\n\nNS_LOG_COMPONENT_DEFINE(\"manet-routing-compare\");\n\n/**\n * Routing experiment class.\n *\n * It handles the creation and run of an experiment.\n */\nclass RoutingExperiment\n{\n  public:\n    RoutingExperiment();\n    /**\n     * Run the experiment.\n     */\n    void Run();\n\n    /**\n     * Handles the command-line parameters.\n     * \\param argc The argument count.\n     * \\param argv The argument vector.\n     */\n    void CommandSetup(int argc, char** argv);\n\n  private:\n    /**\n     * Setup the receiving socket in a Sink Node.\n     * \\param addr The address of the node.\n     * \\param node The node pointer.\n     * \\return the socket.\n     */\n    Ptr<Socket> SetupPacketReceive(Ipv4Address addr, Ptr<Node> node);\n    /**\n     * Receive a packet.\n     * \\param socket The receiving socket.\n     */\n    void ReceivePacket(Ptr<Socket> socket);\n    /**\n     * Compute the throughput.\n     */\n    void CheckThroughput();\n\n    uint32_t port{9};            //!< Receiving port number.\n    uint32_t bytesTotal{0};      //!< Total received bytes.\n    uint32_t packetsReceived{0}; //!< Total received packets.\n\n    std::string m_CSVfileName{\"manet-routing.output.csv\"}; //!< CSV filename.\n    int m_nSinks{10};                                      //!< Number of sink nodes.\n    std::string m_protocolName{\"AODV\"};                    //!< Protocol name.\n    double m_txp{7.5};                                     //!< Tx power.\n    bool m_traceMobility{false};                           //!< Enable mobility tracing.\n    bool m_flowMonitor{false};                             //!< Enable FlowMonitor.\n};\n\nRoutingExperiment::RoutingExperiment()\n{\n}\n\nstatic inline std::string\nPrintReceivedPacket(Ptr<Socket> socket, Ptr<Packet> packet, Address senderAddress)\n{\n    std::ostringstream oss;\n\n    oss << Simulator::Now().GetSeconds() << \" \" << socket->GetNode()->GetId();\n\n    if (InetSocketAddress::IsMatchingType(senderAddress))\n    {\n        InetSocketAddress addr = InetSocketAddress::ConvertFrom(senderAddress);\n        oss << \" received one packet from \" << addr.GetIpv4();\n    }\n    else\n    {\n        oss << \" received one packet!\";\n    }\n    return oss.str();\n}\n\nvoid\nRoutingExperiment::ReceivePacket(Ptr<Socket> socket)\n{\n    Ptr<Packet> packet;\n    Address senderAddress;\n    while ((packet = socket->RecvFrom(senderAddress)))\n    {\n        bytesTotal += packet->GetSize();\n        packetsReceived += 1;\n        NS_LOG_UNCOND(PrintReceivedPacket(socket, packet, senderAddress));\n    }\n}\n\nvoid\nRoutingExperiment::CheckThroughput()\n{\n    double kbs = (bytesTotal * 8.0) / 1000;\n    bytesTotal = 0;\n\n    std::ofstream out(m_CSVfileName, std::ios::app);\n\n    out << (Simulator::Now()).GetSeconds() << \",\" << kbs << \",\" << packetsReceived << \",\"\n        << m_nSinks << \",\" << m_protocolName << \",\" << m_txp << \"\" << std::endl;\n\n    out.close();\n    packetsReceived = 0;\n    Simulator::Schedule(Seconds(1.0), &RoutingExperiment::CheckThroughput, this);\n}\n\nPtr<Socket>\nRoutingExperiment::SetupPacketReceive(Ipv4Address addr, Ptr<Node> node)\n{\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> sink = Socket::CreateSocket(node, tid);\n    InetSocketAddress local = InetSocketAddress(addr, port);\n    sink->Bind(local);\n    sink->SetRecvCallback(MakeCallback(&RoutingExperiment::ReceivePacket, this));\n\n    return sink;\n}\n\nvoid\nRoutingExperiment::CommandSetup(int argc, char** argv)\n{\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"CSVfileName\", \"The name of the CSV output file name\", m_CSVfileName);\n    cmd.AddValue(\"traceMobility\", \"Enable mobility tracing\", m_traceMobility);\n    cmd.AddValue(\"protocol\", \"Routing protocol (OLSR, AODV, DSDV, DSR)\", m_protocolName);\n    cmd.AddValue(\"flowMonitor\", \"enable FlowMonitor\", m_flowMonitor);\n    cmd.Parse(argc, argv);\n\n    std::vector<std::string> allowedProtocols{\"OLSR\", \"AODV\", \"DSDV\", \"DSR\"};\n\n    if (std::find(std::begin(allowedProtocols), std::end(allowedProtocols), m_protocolName) ==\n        std::end(allowedProtocols))\n    {\n        NS_FATAL_ERROR(\"No such protocol:\" << m_protocolName);\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    RoutingExperiment experiment;\n    experiment.CommandSetup(argc, argv);\n    experiment.Run();\n\n    return 0;\n}\n\nvoid\nRoutingExperiment::Run()\n{\n    Packet::EnablePrinting();\n\n    // blank out the last output file and write the column headers\n    std::ofstream out(m_CSVfileName);\n    out << \"SimulationSecond,\"\n        << \"ReceiveRate,\"\n        << \"PacketsReceived,\"\n        << \"NumberOfSinks,\"\n        << \"RoutingProtocol,\"\n        << \"TransmissionPower\" << std::endl;\n    out.close();\n\n    int nWifis = 50;\n\n    double TotalTime = 200.0;\n    std::string rate(\"2048bps\");\n    std::string phyMode(\"DsssRate11Mbps\");\n    std::string tr_name(\"manet-routing-compare\");\n    int nodeSpeed = 20; // in m/s\n    int nodePause = 0;  // in s\n\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", StringValue(\"64\"));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(rate));\n\n    // Set Non-unicastMode rate to unicast mode\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(phyMode));\n\n    NodeContainer adhocNodes;\n    adhocNodes.Create(nWifis);\n\n    // setting up wifi phy and channel using helpers\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Add a mac and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n\n    wifiPhy.Set(\"TxPowerStart\", DoubleValue(m_txp));\n    wifiPhy.Set(\"TxPowerEnd\", DoubleValue(m_txp));\n\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer adhocDevices = wifi.Install(wifiPhy, wifiMac, adhocNodes);\n\n    MobilityHelper mobilityAdhoc;\n    int64_t streamIndex = 0; // used to get consistent mobility across scenarios\n\n    ObjectFactory pos;\n    pos.SetTypeId(\"ns3::RandomRectanglePositionAllocator\");\n    pos.Set(\"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=300.0]\"));\n    pos.Set(\"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=1500.0]\"));\n\n    Ptr<PositionAllocator> taPositionAlloc = pos.Create()->GetObject<PositionAllocator>();\n    streamIndex += taPositionAlloc->AssignStreams(streamIndex);\n\n    std::stringstream ssSpeed;\n    ssSpeed << \"ns3::UniformRandomVariable[Min=0.0|Max=\" << nodeSpeed << \"]\";\n    std::stringstream ssPause;\n    ssPause << \"ns3::ConstantRandomVariable[Constant=\" << nodePause << \"]\";\n    mobilityAdhoc.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                                   \"Speed\",\n                                   StringValue(ssSpeed.str()),\n                                   \"Pause\",\n                                   StringValue(ssPause.str()),\n                                   \"PositionAllocator\",\n                                   PointerValue(taPositionAlloc));\n    mobilityAdhoc.SetPositionAllocator(taPositionAlloc);\n    mobilityAdhoc.Install(adhocNodes);\n    streamIndex += mobilityAdhoc.AssignStreams(adhocNodes, streamIndex);\n\n    AodvHelper aodv;\n    OlsrHelper olsr;\n    DsdvHelper dsdv;\n    DsrHelper dsr;\n    DsrMainHelper dsrMain;\n    Ipv4ListRoutingHelper list;\n    InternetStackHelper internet;\n\n    if (m_protocolName == \"OLSR\")\n    {\n        list.Add(olsr, 100);\n        internet.SetRoutingHelper(list);\n        internet.Install(adhocNodes);\n    }\n    else if (m_protocolName == \"AODV\")\n    {\n        list.Add(aodv, 100);\n        internet.SetRoutingHelper(list);\n        internet.Install(adhocNodes);\n    }\n    else if (m_protocolName == \"DSDV\")\n    {\n        list.Add(dsdv, 100);\n        internet.SetRoutingHelper(list);\n        internet.Install(adhocNodes);\n    }\n    else if (m_protocolName == \"DSR\")\n    {\n        internet.Install(adhocNodes);\n        dsrMain.Install(dsr, adhocNodes);\n        if (m_flowMonitor)\n        {\n            NS_FATAL_ERROR(\"Error: FlowMonitor does not work with DSR. Terminating.\");\n        }\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"No such protocol:\" << m_protocolName);\n    }\n\n    NS_LOG_INFO(\"assigning ip address\");\n\n    Ipv4AddressHelper addressAdhoc;\n    addressAdhoc.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer adhocInterfaces;\n    adhocInterfaces = addressAdhoc.Assign(adhocDevices);\n\n    OnOffHelper onoff1(\"ns3::UdpSocketFactory\", Address());\n    onoff1.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"));\n    onoff1.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0.0]\"));\n\n    for (int i = 0; i < m_nSinks; i++)\n    {\n        Ptr<Socket> sink = SetupPacketReceive(adhocInterfaces.GetAddress(i), adhocNodes.Get(i));\n\n        AddressValue remoteAddress(InetSocketAddress(adhocInterfaces.GetAddress(i), port));\n        onoff1.SetAttribute(\"Remote\", remoteAddress);\n\n        Ptr<UniformRandomVariable> var = CreateObject<UniformRandomVariable>();\n        ApplicationContainer temp = onoff1.Install(adhocNodes.Get(i + m_nSinks));\n        temp.Start(Seconds(var->GetValue(100.0, 101.0)));\n        temp.Stop(Seconds(TotalTime));\n    }\n\n    std::stringstream ss;\n    ss << nWifis;\n    std::string nodes = ss.str();\n\n    std::stringstream ss2;\n    ss2 << nodeSpeed;\n    std::string sNodeSpeed = ss2.str();\n\n    std::stringstream ss3;\n    ss3 << nodePause;\n    std::string sNodePause = ss3.str();\n\n    std::stringstream ss4;\n    ss4 << rate;\n    std::string sRate = ss4.str();\n\n    // NS_LOG_INFO(\"Configure Tracing.\");\n    // tr_name = tr_name + \"_\" + m_protocolName +\"_\" + nodes + \"nodes_\" + sNodeSpeed + \"speed_\" +\n    // sNodePause + \"pause_\" + sRate + \"rate\";\n\n    // AsciiTraceHelper ascii;\n    // Ptr<OutputStreamWrapper> osw = ascii.CreateFileStream(tr_name + \".tr\");\n    // wifiPhy.EnableAsciiAll(osw);\n    AsciiTraceHelper ascii;\n    MobilityHelper::EnableAsciiAll(ascii.CreateFileStream(tr_name + \".mob\"));\n\n    FlowMonitorHelper flowmonHelper;\n    Ptr<FlowMonitor> flowmon;\n    if (m_flowMonitor)\n    {\n        flowmon = flowmonHelper.InstallAll();\n    }\n\n    NS_LOG_INFO(\"Run Simulation.\");\n\n    CheckThroughput();\n\n    Simulator::Stop(Seconds(TotalTime));\n    Simulator::Run();\n\n    if (m_flowMonitor)\n    {\n        flowmon->SerializeToXmlFile(tr_name + \".flowmon\", false, false);\n    }\n\n    Simulator::Destroy();\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ script using the ns-3 simulation library to create a mixed point-to-point and CSMA/CD network topology. The network should include seven nodes, where n0 and n1 connect to n2 via point-to-point links, and n2, n3, n4, and n5 are connected through a shared CSMA/CD bus. Additionally, n5 and n6 are connected via a point-to-point link. Set up Constant Bit Rate (CBR) UDP traffic from n0 to n6, with packet sizes of 210 bytes and a data rate of 448 Kb/s. Enable tracing of queues and packet receptions to a trace file."}, {"role": "assistant", "content": "// This script exercises global routing code in a mixed point-to-point\n// and csma/cd environment\n//\n// Network topology\n//\n//  n0\n//     \\ p-p\n//      \\          (shared csma/cd)\n//       n2 -------------------------n3\n//      /            |        |\n//     / p-p        n4        n5 ---------- n6\n//   n1                             p-p\n//\n// - CBR/UDP flows from n0 to n6\n// - Tracing of queues and packet receptions to file \"mixed-global-routing.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MixedGlobalRoutingExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(210));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(\"448kb/s\"));\n\n    // Allow the user to override any of the defaults and the above\n    // Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer c;\n    c.Create(7);\n    NodeContainer n0n2 = NodeContainer(c.Get(0), c.Get(2));\n    NodeContainer n1n2 = NodeContainer(c.Get(1), c.Get(2));\n    NodeContainer n5n6 = NodeContainer(c.Get(5), c.Get(6));\n    NodeContainer n2345 = NodeContainer(c.Get(2), c.Get(3), c.Get(4), c.Get(5));\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // We create the channels first without any IP addressing information\n    NS_LOG_INFO(\"Create channels.\");\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d0d2 = p2p.Install(n0n2);\n\n    NetDeviceContainer d1d2 = p2p.Install(n1n2);\n\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1500kbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    NetDeviceContainer d5d6 = p2p.Install(n5n6);\n\n    // We create the channels first without any IP addressing information\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d2345 = csma.Install(n2345);\n\n    // Later, we add IP addresses.\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(d0d2);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    ipv4.Assign(d1d2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i5i6 = ipv4.Assign(d5d6);\n\n    ipv4.SetBase(\"10.250.1.0\", \"255.255.255.0\");\n    ipv4.Assign(d2345);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    NS_LOG_INFO(\"Create Applications.\");\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(i5i6.GetAddress(1), port));\n    onoff.SetConstantRate(DataRate(\"300bps\"));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(50));\n\n    ApplicationContainer apps = onoff.Install(c.Get(0));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    Ptr<OutputStreamWrapper> stream = ascii.CreateFileStream(\"mixed-global-routing.tr\");\n    p2p.EnableAsciiAll(stream);\n    csma.EnableAsciiAll(stream);\n\n    p2p.EnablePcapAll(\"mixed-global-routing\");\n    csma.EnablePcapAll(\"mixed-global-routing\", false);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulator to create a mixed point-to-point and CSMA/CD network. The topology should include seven nodes, where two point-to-point links connect nodes n0 to n2 and n1 to n2, while nodes n2, n3, n4, and n5 form a shared CSMA/CD segment. Another point-to-point link connects n5 and n6. Implement a CBR/UDP flow from n0 to n6, and configure the OnOff application to send UDP packets of 50 bytes at a rate of 300 bps. Trace the network queues and packet receptions to a file, and enable pcap tracing for all channels."}, {"role": "assistant", "content": "// This script exercises global routing code in a mixed point-to-point\n// and csma/cd environment\n//\n// Network topology\n//\n//  n0\n//     \\ p-p\n//      \\          (shared csma/cd)\n//       n2 -------------------------n3\n//      /            |        |\n//     / p-p        n4        n5 ---------- n6\n//   n1                             p-p\n//\n// - CBR/UDP flows from n0 to n6\n// - Tracing of queues and packet receptions to file \"mixed-global-routing.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MixedGlobalRoutingExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(210));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(\"448kb/s\"));\n\n    // Allow the user to override any of the defaults and the above\n    // Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer c;\n    c.Create(7);\n    NodeContainer n0n2 = NodeContainer(c.Get(0), c.Get(2));\n    NodeContainer n1n2 = NodeContainer(c.Get(1), c.Get(2));\n    NodeContainer n5n6 = NodeContainer(c.Get(5), c.Get(6));\n    NodeContainer n2345 = NodeContainer(c.Get(2), c.Get(3), c.Get(4), c.Get(5));\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // We create the channels first without any IP addressing information\n    NS_LOG_INFO(\"Create channels.\");\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d0d2 = p2p.Install(n0n2);\n\n    NetDeviceContainer d1d2 = p2p.Install(n1n2);\n\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1500kbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    NetDeviceContainer d5d6 = p2p.Install(n5n6);\n\n    // We create the channels first without any IP addressing information\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d2345 = csma.Install(n2345);\n\n    // Later, we add IP addresses.\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(d0d2);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    ipv4.Assign(d1d2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i5i6 = ipv4.Assign(d5d6);\n\n    ipv4.SetBase(\"10.250.1.0\", \"255.255.255.0\");\n    ipv4.Assign(d2345);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    NS_LOG_INFO(\"Create Applications.\");\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(i5i6.GetAddress(1), port));\n    onoff.SetConstantRate(DataRate(\"300bps\"));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(50));\n\n    ApplicationContainer apps = onoff.Install(c.Get(0));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    Ptr<OutputStreamWrapper> stream = ascii.CreateFileStream(\"mixed-global-routing.tr\");\n    p2p.EnableAsciiAll(stream);\n    csma.EnableAsciiAll(stream);\n\n    p2p.EnablePcapAll(\"mixed-global-routing\");\n    csma.EnablePcapAll(\"mixed-global-routing\", false);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ code that sets up a network topology with RIPng routing in an ns-3 simulation. The network should consist of nodes SRC, A, B, C, D, and DST. The connections are as follows: SRC connects to A, A connects to both B and C, B connects to both C and D, and D connects to DST. All links have a cost of 1, except the direct link from C to D, which has a cost of 10. The routers A and D have static addresses, and packets will be exchanged between SRC and DST. After 3 seconds, the topology is built, and ping responses are received. At 40 seconds, the link between B and D breaks, causing route failure, and recovery occurs after 44 seconds. Include Split Horizon options in the routing strategy and add pcap and ascii tracing to monitor the network behavior."}, {"role": "assistant", "content": "// Network topology\n//\n//    SRC\n//     |<=== source network\n//     A-----B\n//      \\   / \\   all networks have cost 1, except\n//       \\ /  |   for the direct link from C to D, which\n//        C  /    has cost 10\n//        | /\n//        |/\n//        D\n//        |<=== target network\n//       DST\n//\n//\n// A, B, C and D are RIPng routers.\n// A and D are configured with static addresses.\n// SRC and DST will exchange packets.\n//\n// After about 3 seconds, the topology is built, and Echo Reply will be received.\n// After 40 seconds, the link between B and D will break, causing a route failure.\n// After 44 seconds from the failure, the routers will recovery from the failure.\n// Split Horizoning should affect the recovery time, but it is not. See the manual\n// for an explanation of this effect.\n//\n// If \"showPings\" is enabled, the user will see:\n// 1) if the ping has been acknowledged\n// 2) if a Destination Unreachable has been received by the sender\n// 3) nothing, when the Echo Request has been received by the destination but\n//    the Echo Reply is unable to reach the sender.\n// Examining the .pcap files with Wireshark can confirm this effect.\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv6-routing-table-entry.h\"\n#include \"ns3/ipv6-static-routing-helper.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RipNgSimpleRouting\");\n\nvoid\nTearDownLink(Ptr<Node> nodeA, Ptr<Node> nodeB, uint32_t interfaceA, uint32_t interfaceB)\n{\n    nodeA->GetObject<Ipv6>()->SetDown(interfaceA);\n    nodeB->GetObject<Ipv6>()->SetDown(interfaceB);\n}\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n    bool printRoutingTables = false;\n    bool showPings = false;\n    std::string SplitHorizon(\"PoisonReverse\");\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.AddValue(\"printRoutingTables\",\n                 \"Print routing tables at 30, 60 and 90 seconds\",\n                 printRoutingTables);\n    cmd.AddValue(\"showPings\", \"Show Ping reception\", showPings);\n    cmd.AddValue(\"splitHorizonStrategy\",\n                 \"Split Horizon strategy to use (NoSplitHorizon, SplitHorizon, PoisonReverse)\",\n                 SplitHorizon);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnable(\"RipNgSimpleRouting\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"RipNg\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"Ipv6Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv6L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"NdiscCache\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ping\", LOG_LEVEL_ALL);\n    }\n\n    if (SplitHorizon == \"NoSplitHorizon\")\n    {\n        Config::SetDefault(\"ns3::RipNg::SplitHorizon\", EnumValue(RipNg::NO_SPLIT_HORIZON));\n    }\n    else if (SplitHorizon == \"SplitHorizon\")\n    {\n        Config::SetDefault(\"ns3::RipNg::SplitHorizon\", EnumValue(RipNg::SPLIT_HORIZON));\n    }\n    else\n    {\n        Config::SetDefault(\"ns3::RipNg::SplitHorizon\", EnumValue(RipNg::POISON_REVERSE));\n    }\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> src = CreateObject<Node>();\n    Names::Add(\"SrcNode\", src);\n    Ptr<Node> dst = CreateObject<Node>();\n    Names::Add(\"DstNode\", dst);\n    Ptr<Node> a = CreateObject<Node>();\n    Names::Add(\"RouterA\", a);\n    Ptr<Node> b = CreateObject<Node>();\n    Names::Add(\"RouterB\", b);\n    Ptr<Node> c = CreateObject<Node>();\n    Names::Add(\"RouterC\", c);\n    Ptr<Node> d = CreateObject<Node>();\n    Names::Add(\"RouterD\", d);\n    NodeContainer net1(src, a);\n    NodeContainer net2(a, b);\n    NodeContainer net3(a, c);\n    NodeContainer net4(b, c);\n    NodeContainer net5(c, d);\n    NodeContainer net6(b, d);\n    NodeContainer net7(d, dst);\n    NodeContainer routers(a, b, c, d);\n    NodeContainer nodes(src, dst);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer ndc1 = csma.Install(net1);\n    NetDeviceContainer ndc2 = csma.Install(net2);\n    NetDeviceContainer ndc3 = csma.Install(net3);\n    NetDeviceContainer ndc4 = csma.Install(net4);\n    NetDeviceContainer ndc5 = csma.Install(net5);\n    NetDeviceContainer ndc6 = csma.Install(net6);\n    NetDeviceContainer ndc7 = csma.Install(net7);\n\n    NS_LOG_INFO(\"Create IPv6 and routing\");\n    RipNgHelper ripNgRouting;\n\n    // Rule of thumb:\n    // Interfaces are added sequentially, starting from 0\n    // However, interface 0 is always the loopback...\n    ripNgRouting.ExcludeInterface(a, 1);\n    ripNgRouting.ExcludeInterface(d, 3);\n\n    ripNgRouting.SetInterfaceMetric(c, 3, 10);\n    ripNgRouting.SetInterfaceMetric(d, 1, 10);\n\n    Ipv6ListRoutingHelper listRH;\n    listRH.Add(ripNgRouting, 0);\n    Ipv6StaticRoutingHelper staticRh;\n    listRH.Add(staticRh, 5);\n\n    InternetStackHelper internetv6;\n    internetv6.SetIpv4StackInstall(false);\n    internetv6.SetRoutingHelper(listRH);\n    internetv6.Install(routers);\n\n    InternetStackHelper internetv6Nodes;\n    internetv6Nodes.SetIpv4StackInstall(false);\n    internetv6Nodes.Install(nodes);\n\n    // Assign addresses.\n    // The source and destination networks have global addresses\n    // The \"core\" network just needs link-local addresses for routing.\n    // We assign global addresses to the routers as well to receive\n    // ICMPv6 errors.\n    NS_LOG_INFO(\"Assign IPv6 Addresses.\");\n    Ipv6AddressHelper ipv6;\n\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic1 = ipv6.Assign(ndc1);\n    iic1.SetForwarding(1, true);\n    iic1.SetDefaultRouteInAllNodes(1);\n\n    ipv6.SetBase(Ipv6Address(\"2001:0:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic2 = ipv6.Assign(ndc2);\n    iic2.SetForwarding(0, true);\n    iic2.SetForwarding(1, true);\n\n    ipv6.SetBase(Ipv6Address(\"2001:0:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic3 = ipv6.Assign(ndc3);\n    iic3.SetForwarding(0, true);\n    iic3.SetForwarding(1, true);\n\n    ipv6.SetBase(Ipv6Address(\"2001:0:3::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic4 = ipv6.Assign(ndc4);\n    iic4.SetForwarding(0, true);\n    iic4.SetForwarding(1, true);\n\n    ipv6.SetBase(Ipv6Address(\"2001:0:4::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic5 = ipv6.Assign(ndc5);\n    iic5.SetForwarding(0, true);\n    iic5.SetForwarding(1, true);\n\n    ipv6.SetBase(Ipv6Address(\"2001:0:5::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic6 = ipv6.Assign(ndc6);\n    iic6.SetForwarding(0, true);\n    iic6.SetForwarding(1, true);\n\n    ipv6.SetBase(Ipv6Address(\"2001:2::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer iic7 = ipv6.Assign(ndc7);\n    iic7.SetForwarding(0, true);\n    iic7.SetDefaultRouteInAllNodes(0);\n\n    if (printRoutingTables)\n    {\n        Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);\n\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(30.0), a, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(30.0), b, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(30.0), c, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(30.0), d, routingStream);\n\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(60.0), a, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(60.0), b, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(60.0), c, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(60.0), d, routingStream);\n\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(90.0), a, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(90.0), b, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(90.0), c, routingStream);\n        Ipv6RoutingHelper::PrintRoutingTableAt(Seconds(90.0), d, routingStream);\n    }\n\n    NS_LOG_INFO(\"Create Applications.\");\n    uint32_t packetSize = 1024;\n    Time interPacketInterval = Seconds(1.0);\n    PingHelper ping(iic7.GetAddress(1, 1));\n\n    ping.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    if (showPings)\n    {\n        ping.SetAttribute(\"VerboseMode\", EnumValue(Ping::VerboseMode::VERBOSE));\n    }\n    ApplicationContainer apps = ping.Install(src);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(110.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"ripng-simple-routing.tr\"));\n    csma.EnablePcapAll(\"ripng-simple-routing\", true);\n\n    Simulator::Schedule(Seconds(40), &TearDownLink, b, d, 3, 2);\n\n    /* Now, do the actual simulation. */\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Stop(Seconds(120));\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 network simulation library that defines a simple RIP routing topology. The network consists of nodes SRC and DST, connected via four routers: A, B, C, and D. Configure each router and specify that all network links have a cost of 1, except for the link between routers C and D, which has a cost of 10. Enable split horizon routing with Poison Reverse and allow command-line arguments for verbosity, routing table printing, and ping visibility. The network should simulate link failure between routers B and D at 40 seconds, followed by recovery after 44 seconds. The program should print routing tables at regular intervals and optionally display ping results."}, {"role": "assistant", "content": "// Network topology\n//\n//    SRC\n//     |<=== source network\n//     A-----B\n//      \\   / \\   all networks have cost 1, except\n//       \\ /  |   for the direct link from C to D, which\n//        C  /    has cost 10\n//        | /\n//        |/\n//        D\n//        |<=== target network\n//       DST\n//\n//\n// A, B, C and D are RIPng routers.\n// A and D are configured with static addresses.\n// SRC and DST will exchange packets.\n//\n// After about 3 seconds, the topology is built, and Echo Reply will be received.\n// After 40 seconds, the link between B and D will break, causing a route failure.\n// After 44 seconds from the failure, the routers will recovery from the failure.\n// Split Horizoning should affect the recovery time, but it is not. See the manual\n// for an explanation of this effect.\n//\n// If \"showPings\" is enabled, the user will see:\n// 1) if the ping has been acknowledged\n// 2) if a Destination Unreachable has been received by the sender\n// 3) nothing, when the Echo Request has been received by the destination but\n//    the Echo Reply is unable to reach the sender.\n// Examining the .pcap files with Wireshark can confirm this effect.\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-apps-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-routing-table-entry.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RipSimpleRouting\");\n\nvoid\nTearDownLink(Ptr<Node> nodeA, Ptr<Node> nodeB, uint32_t interfaceA, uint32_t interfaceB)\n{\n    nodeA->GetObject<Ipv4>()->SetDown(interfaceA);\n    nodeB->GetObject<Ipv4>()->SetDown(interfaceB);\n}\n\nint\nmain(int argc, char** argv)\n{\n    bool verbose = false;\n    bool printRoutingTables = false;\n    bool showPings = false;\n    std::string SplitHorizon(\"PoisonReverse\");\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"verbose\", \"turn on log components\", verbose);\n    cmd.AddValue(\"printRoutingTables\",\n                 \"Print routing tables at 30, 60 and 90 seconds\",\n                 printRoutingTables);\n    cmd.AddValue(\"showPings\", \"Show Ping reception\", showPings);\n    cmd.AddValue(\"splitHorizonStrategy\",\n                 \"Split Horizon strategy to use (NoSplitHorizon, SplitHorizon, PoisonReverse)\",\n                 SplitHorizon);\n    cmd.Parse(argc, argv);\n\n    if (verbose)\n    {\n        LogComponentEnableAll(LogLevel(LOG_PREFIX_TIME | LOG_PREFIX_NODE));\n        LogComponentEnable(\"RipSimpleRouting\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"Rip\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv4Interface\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Icmpv4L4Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ipv4L3Protocol\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"ArpCache\", LOG_LEVEL_ALL);\n        LogComponentEnable(\"Ping\", LOG_LEVEL_ALL);\n    }\n\n    if (SplitHorizon == \"NoSplitHorizon\")\n    {\n        Config::SetDefault(\"ns3::Rip::SplitHorizon\", EnumValue(Rip::NO_SPLIT_HORIZON));\n    }\n    else if (SplitHorizon == \"SplitHorizon\")\n    {\n        Config::SetDefault(\"ns3::Rip::SplitHorizon\", EnumValue(Rip::SPLIT_HORIZON));\n    }\n    else\n    {\n        Config::SetDefault(\"ns3::Rip::SplitHorizon\", EnumValue(Rip::POISON_REVERSE));\n    }\n\n    NS_LOG_INFO(\"Create nodes.\");\n    Ptr<Node> src = CreateObject<Node>();\n    Names::Add(\"SrcNode\", src);\n    Ptr<Node> dst = CreateObject<Node>();\n    Names::Add(\"DstNode\", dst);\n    Ptr<Node> a = CreateObject<Node>();\n    Names::Add(\"RouterA\", a);\n    Ptr<Node> b = CreateObject<Node>();\n    Names::Add(\"RouterB\", b);\n    Ptr<Node> c = CreateObject<Node>();\n    Names::Add(\"RouterC\", c);\n    Ptr<Node> d = CreateObject<Node>();\n    Names::Add(\"RouterD\", d);\n    NodeContainer net1(src, a);\n    NodeContainer net2(a, b);\n    NodeContainer net3(a, c);\n    NodeContainer net4(b, c);\n    NodeContainer net5(c, d);\n    NodeContainer net6(b, d);\n    NodeContainer net7(d, dst);\n    NodeContainer routers(a, b, c, d);\n    NodeContainer nodes(src, dst);\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(5000000));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer ndc1 = csma.Install(net1);\n    NetDeviceContainer ndc2 = csma.Install(net2);\n    NetDeviceContainer ndc3 = csma.Install(net3);\n    NetDeviceContainer ndc4 = csma.Install(net4);\n    NetDeviceContainer ndc5 = csma.Install(net5);\n    NetDeviceContainer ndc6 = csma.Install(net6);\n    NetDeviceContainer ndc7 = csma.Install(net7);\n\n    NS_LOG_INFO(\"Create IPv4 and routing\");\n    RipHelper ripRouting;\n\n    // Rule of thumb:\n    // Interfaces are added sequentially, starting from 0\n    // However, interface 0 is always the loopback...\n    ripRouting.ExcludeInterface(a, 1);\n    ripRouting.ExcludeInterface(d, 3);\n\n    ripRouting.SetInterfaceMetric(c, 3, 10);\n    ripRouting.SetInterfaceMetric(d, 1, 10);\n\n    Ipv4ListRoutingHelper listRH;\n    listRH.Add(ripRouting, 0);\n    //  Ipv4StaticRoutingHelper staticRh;\n    //  listRH.Add (staticRh, 5);\n\n    InternetStackHelper internet;\n    internet.SetIpv6StackInstall(false);\n    internet.SetRoutingHelper(listRH);\n    internet.Install(routers);\n\n    InternetStackHelper internetNodes;\n    internetNodes.SetIpv6StackInstall(false);\n    internetNodes.Install(nodes);\n\n    // Assign addresses.\n    // The source and destination networks have global addresses\n    // The \"core\" network just needs link-local addresses for routing.\n    // We assign global addresses to the routers as well to receive\n    // ICMPv6 errors.\n    NS_LOG_INFO(\"Assign IPv4 Addresses.\");\n    Ipv4AddressHelper ipv4;\n\n    ipv4.SetBase(Ipv4Address(\"10.0.0.0\"), Ipv4Mask(\"255.255.255.0\"));\n    Ipv4InterfaceContainer iic1 = ipv4.Assign(ndc1);\n\n    ipv4.SetBase(Ipv4Address(\"10.0.1.0\"), Ipv4Mask(\"255.255.255.0\"));\n    Ipv4InterfaceContainer iic2 = ipv4.Assign(ndc2);\n\n    ipv4.SetBase(Ipv4Address(\"10.0.2.0\"), Ipv4Mask(\"255.255.255.0\"));\n    Ipv4InterfaceContainer iic3 = ipv4.Assign(ndc3);\n\n    ipv4.SetBase(Ipv4Address(\"10.0.3.0\"), Ipv4Mask(\"255.255.255.0\"));\n    Ipv4InterfaceContainer iic4 = ipv4.Assign(ndc4);\n\n    ipv4.SetBase(Ipv4Address(\"10.0.4.0\"), Ipv4Mask(\"255.255.255.0\"));\n    Ipv4InterfaceContainer iic5 = ipv4.Assign(ndc5);\n\n    ipv4.SetBase(Ipv4Address(\"10.0.5.0\"), Ipv4Mask(\"255.255.255.0\"));\n    Ipv4InterfaceContainer iic6 = ipv4.Assign(ndc6);\n\n    ipv4.SetBase(Ipv4Address(\"10.0.6.0\"), Ipv4Mask(\"255.255.255.0\"));\n    Ipv4InterfaceContainer iic7 = ipv4.Assign(ndc7);\n\n    Ptr<Ipv4StaticRouting> staticRouting;\n    staticRouting = Ipv4RoutingHelper::GetRouting<Ipv4StaticRouting>(\n        src->GetObject<Ipv4>()->GetRoutingProtocol());\n    staticRouting->SetDefaultRoute(\"10.0.0.2\", 1);\n    staticRouting = Ipv4RoutingHelper::GetRouting<Ipv4StaticRouting>(\n        dst->GetObject<Ipv4>()->GetRoutingProtocol());\n    staticRouting->SetDefaultRoute(\"10.0.6.1\", 1);\n\n    if (printRoutingTables)\n    {\n        Ptr<OutputStreamWrapper> routingStream = Create<OutputStreamWrapper>(&std::cout);\n\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(30.0), a, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(30.0), b, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(30.0), c, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(30.0), d, routingStream);\n\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(60.0), a, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(60.0), b, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(60.0), c, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(60.0), d, routingStream);\n\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(90.0), a, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(90.0), b, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(90.0), c, routingStream);\n        Ipv4RoutingHelper::PrintRoutingTableAt(Seconds(90.0), d, routingStream);\n    }\n\n    NS_LOG_INFO(\"Create Applications.\");\n    uint32_t packetSize = 1024;\n    Time interPacketInterval = Seconds(1.0);\n    PingHelper ping(Ipv4Address(\"10.0.6.2\"));\n\n    ping.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    ping.SetAttribute(\"Size\", UintegerValue(packetSize));\n    if (showPings)\n    {\n        ping.SetAttribute(\"VerboseMode\", EnumValue(Ping::VerboseMode::VERBOSE));\n    }\n    ApplicationContainer apps = ping.Install(src);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(110.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"rip-simple-routing.tr\"));\n    csma.EnablePcapAll(\"rip-simple-routing\", true);\n\n    Simulator::Schedule(Seconds(40), &TearDownLink, b, d, 3, 2);\n\n    /* Now, do the actual simulation. */\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Stop(Seconds(131.0));\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 simulation library to create a network topology with four nodes: n0, n1, n2, and n3. In this topology, n0 and n1 connect to n2 via point-to-point links with 5 Mbps bandwidth and 2 ms delay, while n1 and n3 are also connected via a higher-cost point-to-point link with 1.5 Mbps bandwidth and 100 ms delay. An alternate path exists between n2 and n3, which has a delay of 10 ms and 1.5 Mbps bandwidth. Set a configurable metric between n1 and n3, allowing for rerouting behavior. Enable tracing of queues and packet receptions to a file, and use UDP traffic from n3 to n1, logging simulation results."}, {"role": "assistant", "content": "//\n// Network topology\n//\n//  n0\n//     \\ 5 Mb/s, 2ms\n//      \\          1.5Mb/s, 10ms\n//       n2 ------------------------n3\n//      /                          /\n//     / 5 Mb/s, 2ms              /\n//   n1--------------------------\n//          1.5 Mb/s, 100ms\n//\n// this is a modification of simple-global-routing to allow for\n// a single hop but higher-cost path between n1 and n3\n//\n// - Tracing of queues and packet receptions to file \"simple-rerouting.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleAlternateRoutingExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Users may find it convenient to turn on explicit debugging\n    // for selected modules; the below lines suggest how to do this\n#if 0\n  LogComponentEnable (\"GlobalRoutingHelper\", LOG_LOGIC);\n  LogComponentEnable (\"GlobalRouter\", LOG_LOGIC);\n#endif\n\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(210));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(\"300b/s\"));\n\n    // The below metric, if set to 3 or higher, will cause packets between\n    // n1 and n3 to take the 2-hop route through n2\n\n    CommandLine cmd(__FILE__);\n    //\n    // Additionally, we plumb this metric into the default value / command\n    // line argument system as well, for exemplary purposes.  This means\n    // that it can be resettable at the command-line to the program,\n    // rather than recompiling\n    // e.g. ns3 --run \"simple-alternate-routing --AlternateCost=5\"\n    uint16_t sampleMetric = 1;\n    cmd.AddValue(\"AlternateCost\",\n                 \"This metric is used in the example script between n3 and n1 \",\n                 sampleMetric);\n\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    cmd.Parse(argc, argv);\n\n    // Here, we will explicitly create four nodes.  In more sophisticated\n    // topologies, we could configure a node factory.\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer c;\n    c.Create(4);\n    NodeContainer n0n2 = NodeContainer(c.Get(0), c.Get(2));\n    NodeContainer n1n2 = NodeContainer(c.Get(1), c.Get(2));\n    NodeContainer n3n2 = NodeContainer(c.Get(3), c.Get(2));\n    NodeContainer n1n3 = NodeContainer(c.Get(1), c.Get(3));\n\n    // We create the channels first without any IP addressing information\n    NS_LOG_INFO(\"Create channels.\");\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d0d2 = p2p.Install(n0n2);\n\n    NetDeviceContainer d1d2 = p2p.Install(n1n2);\n\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1500kbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    NetDeviceContainer d3d2 = p2p.Install(n3n2);\n\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"100ms\"));\n    NetDeviceContainer d1d3 = p2p.Install(n1n3);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // Later, we add IP addresses.  The middle two octets correspond to\n    // the channel number.\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    ipv4.Assign(d0d2);\n\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1i2 = ipv4.Assign(d1d2);\n\n    ipv4.SetBase(\"10.2.2.0\", \"255.255.255.0\");\n    ipv4.Assign(d3d2);\n\n    ipv4.SetBase(\"10.3.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1i3 = ipv4.Assign(d1d3);\n\n    i1i3.SetMetric(0, sampleMetric);\n    i1i3.SetMetric(1, sampleMetric);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams\n    NS_LOG_INFO(\"Create Application.\");\n    uint16_t port = 9; // Discard port (RFC 863)\n\n    // Create a flow from n3 to n1, starting at time 1.1 seconds\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(i1i2.GetAddress(0), port)));\n    onoff.SetConstantRate(DataRate(\"300b/s\"));\n\n    ApplicationContainer apps = onoff.Install(c.Get(3));\n    apps.Start(Seconds(1.1));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(c.Get(1));\n    apps.Start(Seconds(1.1));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"simple-alternate-routing.tr\"));\n    p2p.EnablePcapAll(\"simple-alternate-routing\");\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a network topology in ns3 using a star-shaped configuration where each node acts as both a client and a server, similar to a ring topology. Use point-to-point links for connectivity, with the network address 192.9.39.0/24. Each client should generate 4 packets, and only one client-server pair should communicate at a time, ensuring all packets are delivered to the server. The UDP echo server and client applications should be used, with nodes sending packets at specific intervals. The central node connects to all other nodes using point-to-point links. Provide a solution that configures the IP addresses, links, and applications accordingly, ensuring that the network is animated using NetAnim. Additionally, configure the link data rate to 5Mbps and a delay of 2ms."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"StarTopologyExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    NodeContainer starNodes;\n    starNodes.Create(4); // Create 4 nodes in a star topology\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer device1, device2, device3;\n    device1.Add(pointToPoint.Install(starNodes.Get(0), starNodes.Get(1)));\n    device2.Add(pointToPoint.Install(starNodes.Get(0), starNodes.Get(2)));\n    device3.Add(pointToPoint.Install(starNodes.Get(0), starNodes.Get(3)));\n\n    InternetStackHelper stack;\n    stack.Install(starNodes);\n\n    Ipv4AddressHelper address1, address2, address3;\n    address1.SetBase(\"192.9.39.0\", \"255.255.255.252\");\n    address2.SetBase(\"192.9.39.4\", \"255.255.255.252\");\n    address3.SetBase(\"192.9.39.8\", \"255.255.255.252\");\n\n    Ipv4InterfaceContainer interface1, interface2, interface3;\n    interface1 = address1.Assign(device1);\n    interface2 = address2.Assign(device2);\n    interface3 = address3.Assign(device3);\n\n    UdpEchoServerHelper echoServer(9);\n\n    // Server 0, Client 1\n    ApplicationContainer serverApps01 = echoServer.Install(starNodes.Get(0));\n    serverApps01.Start(Seconds(1.0));\n    serverApps01.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient01(interface1.GetAddress(0), 9);\n    echoClient01.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient01.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient01.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp01 = echoClient01.Install(starNodes.Get(1));\n    clientApp01.Start(Seconds(2.0));\n    clientApp01.Stop(Seconds(10.0));\n\n    // Server 1, Client 0\n    ApplicationContainer serverApps10 = echoServer.Install(starNodes.Get(1));\n    serverApps10.Start(Seconds(11.0));\n    serverApps10.Stop(Seconds(20.0));\n\n    UdpEchoClientHelper echoClient10(interface1.GetAddress(1), 9);\n    echoClient10.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient10.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient10.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp10 = echoClient10.Install(starNodes.Get(0));\n    clientApp10.Start(Seconds(12.0));\n    clientApp10.Stop(Seconds(20.0));\n\n    // Server 0, Client 2\n    ApplicationContainer serverApps02 = echoServer.Install(starNodes.Get(0));\n    serverApps02.Start(Seconds(21.0));\n    serverApps02.Stop(Seconds(30.0));\n\n    UdpEchoClientHelper echoClient02(interface2.GetAddress(0), 9);\n    echoClient02.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient02.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient02.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp02 = echoClient02.Install(starNodes.Get(2));\n    clientApp02.Start(Seconds(22.0));\n    clientApp02.Stop(Seconds(30.0));\n\n    // Server 2, Client 0\n    ApplicationContainer serverApps20 = echoServer.Install(starNodes.Get(2));\n    serverApps20.Start(Seconds(31.0));\n    serverApps20.Stop(Seconds(40.0));\n\n    UdpEchoClientHelper echoClient20(interface2.GetAddress(1), 9);\n    echoClient20.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient20.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient20.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp20 = echoClient20.Install(starNodes.Get(0));\n    clientApp20.Start(Seconds(32.0));\n    clientApp20.Stop(Seconds(40.0));\n\n    // Server 0, Client 3\n    ApplicationContainer serverApps03 = echoServer.Install(starNodes.Get(0));\n    serverApps03.Start(Seconds(41.0));\n    serverApps03.Stop(Seconds(50.0));\n\n    UdpEchoClientHelper echoClient03(interface3.GetAddress(0), 9);\n    echoClient03.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient03.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient03.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp03 = echoClient03.Install(starNodes.Get(3));\n    clientApp03.Start(Seconds(42.0));\n    clientApp03.Stop(Seconds(50.0));\n\n    // Server 3, Client 0\n    ApplicationContainer serverApps30 = echoServer.Install(starNodes.Get(3));\n    serverApps30.Start(Seconds(51.0));\n    serverApps30.Stop(Seconds(60.0));\n\n    UdpEchoClientHelper echoClient30(interface3.GetAddress(1), 9);\n    echoClient30.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient30.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient30.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp30 = echoClient30.Install(starNodes.Get(0));\n    clientApp30.Start(Seconds(52.0));\n    clientApp30.Stop(Seconds(60.0));\n\n    AnimationInterface anim(\"StarTopologyExample.xml\");\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 that sets up a point-to-point network with two nodes and demonstrates the usage of the Token Bucket Filter (TBF) queue discipline. The program should allow configuration of the TBF parameters, including the size of the first and second buckets, the token arrival rate, and the peak rate via command-line arguments. Implement tracing for the number of tokens in both buckets during the simulation. The simulation should also include a basic OnOff traffic generator sending packets between the nodes, and output the TBF queue statistics at the end of the simulation."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n// This simple example shows how to use TrafficControlHelper to install a\n// QueueDisc on a device.\n//\n// Network topology\n//\n//       10.1.1.0\n// n0 -------------- n1\n//    point-to-point\n//\n// The output will consist of all the traced changes in\n// the number of tokens in TBF's first and second buckets:\n//\n//    FirstBucketTokens 0 to x\n//    SecondBucketTokens 0 to x\n//    FirstBucketTokens x to 0\n//    SecondBucketTokens x to 0\n//\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TbfExample\");\n\nvoid\nFirstBucketTokensTrace(uint32_t oldValue, uint32_t newValue)\n{\n    std::cout << \"FirstBucketTokens \" << oldValue << \" to \" << newValue << std::endl;\n}\n\nvoid\nSecondBucketTokensTrace(uint32_t oldValue, uint32_t newValue)\n{\n    std::cout << \"SecondBucketTokens \" << oldValue << \" to \" << newValue << std::endl;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double simulationTime = 10; // seconds\n    uint32_t burst = 10000;\n    uint32_t mtu = 0;\n    DataRate rate = DataRate(\"1Mbps\");\n    DataRate peakRate = DataRate(\"0bps\");\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"burst\", \"Size of first bucket in bytes\", burst);\n    cmd.AddValue(\"mtu\", \"Size of second bucket in bytes\", mtu);\n    cmd.AddValue(\"rate\", \"Rate of tokens arriving in first bucket\", rate);\n    cmd.AddValue(\"peakRate\", \"Rate of tokens arriving in second bucket\", peakRate);\n\n    cmd.Parse(argc, argv);\n\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"2Mb/s\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"0ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    TrafficControlHelper tch;\n    tch.SetRootQueueDisc(\"ns3::TbfQueueDisc\",\n                         \"Burst\",\n                         UintegerValue(burst),\n                         \"Mtu\",\n                         UintegerValue(mtu),\n                         \"Rate\",\n                         DataRateValue(DataRate(rate)),\n                         \"PeakRate\",\n                         DataRateValue(DataRate(peakRate)));\n    QueueDiscContainer qdiscs = tch.Install(devices);\n\n    Ptr<QueueDisc> q = qdiscs.Get(1);\n    q->TraceConnectWithoutContext(\"TokensInFirstBucket\", MakeCallback(&FirstBucketTokensTrace));\n    q->TraceConnectWithoutContext(\"TokensInSecondBucket\", MakeCallback(&SecondBucketTokensTrace));\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Flow\n    uint16_t port = 7;\n    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", localAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(0));\n\n    sinkApp.Start(Seconds(0.0));\n    sinkApp.Stop(Seconds(simulationTime + 0.1));\n\n    uint32_t payloadSize = 1448;\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n\n    OnOffHelper onoff(\"ns3::TcpSocketFactory\", Ipv4Address::GetAny());\n    onoff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onoff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0.2]\"));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n    onoff.SetAttribute(\"DataRate\", StringValue(\"1.1Mb/s\")); // bit/s\n    ApplicationContainer apps;\n\n    InetSocketAddress rmt(interfaces.GetAddress(0), port);\n    onoff.SetAttribute(\"Remote\", AddressValue(rmt));\n    onoff.SetAttribute(\"Tos\", UintegerValue(0xb8));\n\n    apps.Add(onoff.Install(nodes.Get(1)));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(simulationTime + 0.1));\n\n    Simulator::Stop(Seconds(simulationTime + 5));\n    Simulator::Run();\n\n    Simulator::Destroy();\n\n    std::cout << std::endl << \"*** TC Layer statistics ***\" << std::endl;\n    std::cout << q->GetStats() << std::endl;\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ code that uses the ns-3 network simulator to demonstrate the use of TrafficControlHelper for installing a RedQueueDisc on a point-to-point link between two nodes. The simulation should track and print statistics about the queue lengths at the traffic control and device layers, as well as the sojourn time of packets. Additionally, configure TCP as the transport protocol, simulate packet transmission, and report flow statistics such as throughput, mean delay, and jitter using FlowMonitor."}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/traffic-control-module.h\"\n\n// This simple example shows how to use TrafficControlHelper to install a\n// QueueDisc on a device.\n//\n// The default QueueDisc is a pfifo_fast with a capacity of 1000 packets (as in\n// Linux). However, in this example, we install a RedQueueDisc with a capacity\n// of 10000 packets.\n//\n// Network topology\n//\n//       10.1.1.0\n// n0 -------------- n1\n//    point-to-point\n//\n// The output will consist of all the traced changes in the length of the RED\n// internal queue and in the length of the netdevice queue:\n//\n//    DevicePacketsInQueue 0 to 1\n//    TcPacketsInQueue 7 to 8\n//    TcPacketsInQueue 8 to 9\n//    DevicePacketsInQueue 1 to 0\n//    TcPacketsInQueue 9 to 8\n//\n// plus some statistics collected at the network layer (by the flow monitor)\n// and the application layer. Finally, the number of packets dropped by the\n// queuing discipline, the number of packets dropped by the netdevice and\n// the number of packets requeued by the queuing discipline are reported.\n//\n// If the size of the DropTail queue of the netdevice were increased from 1\n// to a large number (e.g. 1000), one would observe that the number of dropped\n// packets goes to zero, but the latency grows in an uncontrolled manner. This\n// is the so-called bufferbloat problem, and illustrates the importance of\n// having a small device queue, so that the standing queues build in the traffic\n// control layer where they can be managed by advanced queue discs rather than\n// in the device layer.\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TrafficControlExample\");\n\n/**\n * Number of packets in TX queue trace.\n *\n * \\param oldValue Old velue.\n * \\param newValue New value.\n */\nvoid\nTcPacketsInQueueTrace(uint32_t oldValue, uint32_t newValue)\n{\n    std::cout << \"TcPacketsInQueue \" << oldValue << \" to \" << newValue << std::endl;\n}\n\n/**\n * Packets in the device queue trace.\n *\n * \\param oldValue Old velue.\n * \\param newValue New value.\n */\nvoid\nDevicePacketsInQueueTrace(uint32_t oldValue, uint32_t newValue)\n{\n    std::cout << \"DevicePacketsInQueue \" << oldValue << \" to \" << newValue << std::endl;\n}\n\n/**\n * TC Soujoun time trace.\n *\n * \\param sojournTime The soujourn time.\n */\nvoid\nSojournTimeTrace(Time sojournTime)\n{\n    std::cout << \"Sojourn time \" << sojournTime.ToDouble(Time::MS) << \"ms\" << std::endl;\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double simulationTime = 10; // seconds\n    std::string transportProt = \"Tcp\";\n    std::string socketType;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"transportProt\", \"Transport protocol to use: Tcp, Udp\", transportProt);\n    cmd.Parse(argc, argv);\n\n    if (transportProt == \"Tcp\")\n    {\n        socketType = \"ns3::TcpSocketFactory\";\n    }\n    else\n    {\n        socketType = \"ns3::UdpSocketFactory\";\n    }\n\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    pointToPoint.SetQueue(\"ns3::DropTailQueue\", \"MaxSize\", StringValue(\"1p\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    TrafficControlHelper tch;\n    tch.SetRootQueueDisc(\"ns3::RedQueueDisc\");\n    QueueDiscContainer qdiscs = tch.Install(devices);\n\n    Ptr<QueueDisc> q = qdiscs.Get(1);\n    q->TraceConnectWithoutContext(\"PacketsInQueue\", MakeCallback(&TcPacketsInQueueTrace));\n    Config::ConnectWithoutContext(\n        \"/NodeList/1/$ns3::TrafficControlLayer/RootQueueDiscList/0/SojournTime\",\n        MakeCallback(&SojournTimeTrace));\n\n    Ptr<NetDevice> nd = devices.Get(1);\n    Ptr<PointToPointNetDevice> ptpnd = DynamicCast<PointToPointNetDevice>(nd);\n    Ptr<Queue<Packet>> queue = ptpnd->GetQueue();\n    queue->TraceConnectWithoutContext(\"PacketsInQueue\", MakeCallback(&DevicePacketsInQueueTrace));\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Flow\n    uint16_t port = 7;\n    Address localAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper packetSinkHelper(socketType, localAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(0));\n\n    sinkApp.Start(Seconds(0.0));\n    sinkApp.Stop(Seconds(simulationTime + 0.1));\n\n    uint32_t payloadSize = 1448;\n    Config::SetDefault(\"ns3::TcpSocket::SegmentSize\", UintegerValue(payloadSize));\n\n    OnOffHelper onoff(socketType, Ipv4Address::GetAny());\n    onoff.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onoff.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(payloadSize));\n    onoff.SetAttribute(\"DataRate\", StringValue(\"50Mbps\")); // bit/s\n    ApplicationContainer apps;\n\n    InetSocketAddress rmt(interfaces.GetAddress(0), port);\n    onoff.SetAttribute(\"Remote\", AddressValue(rmt));\n    onoff.SetAttribute(\"Tos\", UintegerValue(0xb8));\n    apps.Add(onoff.Install(nodes.Get(1)));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(simulationTime + 0.1));\n\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    Simulator::Stop(Seconds(simulationTime + 5));\n    Simulator::Run();\n\n    Ptr<Ipv4FlowClassifier> classifier = DynamicCast<Ipv4FlowClassifier>(flowmon.GetClassifier());\n    std::map<FlowId, FlowMonitor::FlowStats> stats = monitor->GetFlowStats();\n    std::cout << std::endl << \"*** Flow monitor statistics ***\" << std::endl;\n    std::cout << \"  Tx Packets/Bytes:   \" << stats[1].txPackets << \" / \" << stats[1].txBytes\n              << std::endl;\n    std::cout << \"  Offered Load: \"\n              << stats[1].txBytes * 8.0 /\n                     (stats[1].timeLastTxPacket.GetSeconds() -\n                      stats[1].timeFirstTxPacket.GetSeconds()) /\n                     1000000\n              << \" Mbps\" << std::endl;\n    std::cout << \"  Rx Packets/Bytes:   \" << stats[1].rxPackets << \" / \" << stats[1].rxBytes\n              << std::endl;\n    uint32_t packetsDroppedByQueueDisc = 0;\n    uint64_t bytesDroppedByQueueDisc = 0;\n    if (stats[1].packetsDropped.size() > Ipv4FlowProbe::DROP_QUEUE_DISC)\n    {\n        packetsDroppedByQueueDisc = stats[1].packetsDropped[Ipv4FlowProbe::DROP_QUEUE_DISC];\n        bytesDroppedByQueueDisc = stats[1].bytesDropped[Ipv4FlowProbe::DROP_QUEUE_DISC];\n    }\n    std::cout << \"  Packets/Bytes Dropped by Queue Disc:   \" << packetsDroppedByQueueDisc << \" / \"\n              << bytesDroppedByQueueDisc << std::endl;\n    uint32_t packetsDroppedByNetDevice = 0;\n    uint64_t bytesDroppedByNetDevice = 0;\n    if (stats[1].packetsDropped.size() > Ipv4FlowProbe::DROP_QUEUE)\n    {\n        packetsDroppedByNetDevice = stats[1].packetsDropped[Ipv4FlowProbe::DROP_QUEUE];\n        bytesDroppedByNetDevice = stats[1].bytesDropped[Ipv4FlowProbe::DROP_QUEUE];\n    }\n    std::cout << \"  Packets/Bytes Dropped by NetDevice:   \" << packetsDroppedByNetDevice << \" / \"\n              << bytesDroppedByNetDevice << std::endl;\n    std::cout << \"  Throughput: \"\n              << stats[1].rxBytes * 8.0 /\n                     (stats[1].timeLastRxPacket.GetSeconds() -\n                      stats[1].timeFirstRxPacket.GetSeconds()) /\n                     1000000\n              << \" Mbps\" << std::endl;\n    std::cout << \"  Mean delay:   \" << stats[1].delaySum.GetSeconds() / stats[1].rxPackets\n              << std::endl;\n    std::cout << \"  Mean jitter:   \" << stats[1].jitterSum.GetSeconds() / (stats[1].rxPackets - 1)\n              << std::endl;\n    auto dscpVec = classifier->GetDscpCounts(1);\n    for (auto p : dscpVec)\n    {\n        std::cout << \"  DSCP value:   0x\" << std::hex << static_cast<uint32_t>(p.first) << std::dec\n                  << \"  count:   \" << p.second << std::endl;\n    }\n\n    Simulator::Destroy();\n\n    std::cout << std::endl << \"*** Application statistics ***\" << std::endl;\n    double thr = 0;\n    uint64_t totalPacketsThr = DynamicCast<PacketSink>(sinkApp.Get(0))->GetTotalRx();\n    thr = totalPacketsThr * 8 / (simulationTime * 1000000.0); // Mbit/s\n    std::cout << \"  Rx Bytes: \" << totalPacketsThr << std::endl;\n    std::cout << \"  Average Goodput: \" << thr << \" Mbit/s\" << std::endl;\n    std::cout << std::endl << \"*** TC Layer statistics ***\" << std::endl;\n    std::cout << q->GetStats() << std::endl;\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 network simulator to create a local area network (LAN) connecting four nodes. Implement UDP communication where node n0 sends and receives UDP packets to and from node n1 using UdpEchoServer and UdpEchoClient applications. Configure a DropTail queue on the network and enable tracing of queue lengths and packet receptions, saving the results to a file named \"udp-echo.tr.\" Simulate this setup for 10 seconds, using either IPv4 or IPv6, based on user input."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1   n2   n3\n//       |     |    |    |\n//       =================\n//              LAN\n//\n// - UDP flows from n0 to n1 and back\n// - DropTail queues\n// - Tracing of queues and packet receptions to file \"udp-echo.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpEchoExample\");\n\nint\nmain(int argc, char* argv[])\n{\n//\n// Users may find it convenient to turn on explicit debugging\n// for selected modules; the below lines suggest how to do this\n//\n#if 0\n  LogComponentEnable (\"UdpEchoExample\", LOG_LEVEL_INFO);\n  LogComponentEnable (\"UdpEchoClientApplication\", LOG_LEVEL_ALL);\n  LogComponentEnable (\"UdpEchoServerApplication\", LOG_LEVEL_ALL);\n#endif\n    //\n    // Allow the user to override any of the defaults and the above Bind() at\n    // run-time, via command-line arguments\n    //\n    bool useV6 = false;\n    Address serverAddress;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"useIpv6\", \"Use Ipv6\", useV6);\n    cmd.Parse(argc, argv);\n    //\n    // Explicitly create the nodes required by the topology (shown above).\n    //\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer n;\n    n.Create(4);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    NS_LOG_INFO(\"Create channels.\");\n    //\n    // Explicitly create the channels required by the topology (shown above).\n    //\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    //\n    // We've got the \"hardware\" in place.  Now we need to add IP addresses.\n    //\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    if (!useV6)\n    {\n        Ipv4AddressHelper ipv4;\n        ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer i = ipv4.Assign(d);\n        serverAddress = Address(i.GetAddress(1));\n    }\n    else\n    {\n        Ipv6AddressHelper ipv6;\n        ipv6.SetBase(\"2001:0000:f00d:cafe::\", Ipv6Prefix(64));\n        Ipv6InterfaceContainer i6 = ipv6.Assign(d);\n        serverAddress = Address(i6.GetAddress(1, 1));\n    }\n\n    NS_LOG_INFO(\"Create Applications.\");\n    //\n    // Create a UdpEchoServer application on node one.\n    //\n    uint16_t port = 9; // well-known echo port number\n    UdpEchoServerHelper server(port);\n    ApplicationContainer apps = server.Install(n.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    //\n    // Create a UdpEchoClient application to send UDP datagrams from node zero to\n    // node one.\n    //\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 1;\n    Time interPacketInterval = Seconds(1.);\n    UdpEchoClientHelper client(serverAddress, port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n    apps = client.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n#if 0\n//\n// Users may find it convenient to initialize echo packets with actual data;\n// the below lines suggest how to do this\n//\n  client.SetFill (apps.Get (0), \"Hello World\");\n\n  client.SetFill (apps.Get (0), 0xa5, 1024);\n\n  uint8_t fill[] = { 0, 1, 2, 3, 4, 5, 6};\n  client.SetFill (apps.Get (0), fill, sizeof(fill), 1024);\n#endif\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"udp-echo.tr\"));\n    csma.EnablePcapAll(\"udp-echo\", false);\n\n    //\n    // Now, do the actual simulation.\n    //\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a C++ program using the ns-3 network simulator to create a simple LAN (CSMA) connecting two nodes, n0 and n1. Implement a UDP flow from n0 to n1, where packets of 1024 bytes are sent at 50 ms intervals, with a maximum of 320 packets transmitted or limited by simulation duration. Provide options to enable either IPv4 or IPv6 addressing, as well as to toggle logging of the simulation events. Simulate the network for 10 seconds, starting the client after a 2-second delay."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1\n//       |     |\n//       =======\n//         LAN (CSMA)\n//\n// - UDP flow from n0 to n1 of 1024 byte packets at intervals of 50 ms\n//   - maximum of 320 packets sent (or limited by simulation duration)\n//   - option to use IPv4 or IPv6 addressing\n//   - option to disable logging statements\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpClientServerExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Declare variables used in command-line arguments\n    bool useV6 = false;\n    bool logging = true;\n    Address serverAddress;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"useIpv6\", \"Use Ipv6\", useV6);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.Parse(argc, argv);\n\n    if (logging)\n    {\n        LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n    }\n\n    NS_LOG_INFO(\"Create nodes in above topology.\");\n    NodeContainer n;\n    n.Create(2);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    NS_LOG_INFO(\"Create channel between the two nodes.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    if (!useV6)\n    {\n        Ipv4AddressHelper ipv4;\n        ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer i = ipv4.Assign(d);\n        serverAddress = Address(i.GetAddress(1));\n    }\n    else\n    {\n        Ipv6AddressHelper ipv6;\n        ipv6.SetBase(\"2001:0000:f00d:cafe::\", Ipv6Prefix(64));\n        Ipv6InterfaceContainer i6 = ipv6.Assign(d);\n        serverAddress = Address(i6.GetAddress(1, 1));\n    }\n\n    NS_LOG_INFO(\"Create UdpServer application on node 1.\");\n    uint16_t port = 4000;\n    UdpServerHelper server(port);\n    ApplicationContainer apps = server.Install(n.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Create UdpClient application on node 0 to send to node 1.\");\n    uint32_t MaxPacketSize = 1024;\n    Time interPacketInterval = Seconds(0.05);\n    uint32_t maxPacketCount = 320;\n    UdpClientHelper client(serverAddress, port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    client.SetAttribute(\"PacketSize\", UintegerValue(MaxPacketSize));\n    apps = client.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 network simulator to build a simple LAN (CSMA) connecting two nodes, n0 and n1. Implement a UDP flow from n0 to n1, where packets are drawn from a trace file. Provide options for using either IPv4 or IPv6 addressing and for enabling or disabling logging of the simulation events. Configure a CSMA channel between the nodes with a data rate of 5 Mbps, a delay of 2 ms, and an MTU of 1500 bytes. Start the UDP server at 1 second and the client at 2 seconds, running the simulation for a total of 10 seconds."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1\n//       |     |\n//       =======\n//         LAN (CSMA)\n//\n// - UDP flow from n0 to n1 of packets drawn from a trace file\n//  -- option to use IPv4 or IPv6 addressing\n//  -- option to disable logging statements\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpTraceClientServerExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Declare variables used in command-line arguments\n    bool useV6 = false;\n    bool logging = true;\n    Address serverAddress;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"useIpv6\", \"Use Ipv6\", useV6);\n    cmd.AddValue(\"logging\", \"Enable logging\", logging);\n    cmd.Parse(argc, argv);\n\n    if (logging)\n    {\n        LogComponentEnable(\"UdpClient\", LOG_LEVEL_INFO);\n        LogComponentEnable(\"UdpServer\", LOG_LEVEL_INFO);\n    }\n\n    NS_LOG_INFO(\"Create nodes in above topology.\");\n    NodeContainer n;\n    n.Create(2);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    NS_LOG_INFO(\"Create channel between the two nodes.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1500));\n    NetDeviceContainer d = csma.Install(n);\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    if (!useV6)\n    {\n        Ipv4AddressHelper ipv4;\n        ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n        Ipv4InterfaceContainer i = ipv4.Assign(d);\n        serverAddress = Address(i.GetAddress(1));\n    }\n    else\n    {\n        Ipv6AddressHelper ipv6;\n        ipv6.SetBase(\"2001:0000:f00d:cafe::\", Ipv6Prefix(64));\n        Ipv6InterfaceContainer i6 = ipv6.Assign(d);\n        serverAddress = Address(i6.GetAddress(1, 1));\n    }\n\n    NS_LOG_INFO(\"Create UdpServer application on node 1.\");\n    uint16_t port = 4000;\n    UdpServerHelper server(port);\n    ApplicationContainer apps = server.Install(n.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Create UdpClient application on node 0 to send to node 1.\");\n    uint32_t MaxPacketSize = 1472; // Back off 20 (IP) + 8 (UDP) bytes from MTU\n    UdpTraceClientHelper client(serverAddress, port, \"\");\n    client.SetAttribute(\"MaxPacketSize\", UintegerValue(MaxPacketSize));\n    apps = client.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a code in C++ using the ns-3 simulation framework to model a vehicular environment, simulating the channel conditions and pathloss based on 3GPP TR 37.885 and TR 38.901 standards. The code should include the following elements: configure nodes to simulate vehicles, setup mobility models for urban and highway scenarios, assign antennas using uniform planar arrays, and calculate beamforming using DFT methods. The simulation should log average SNR and pathloss values over time and output these to a file, which can be used to generate figures representing the scenario."}, {"role": "assistant", "content": "/**\n * This is an example on how to configure the channel model classes to simulate\n * a vehicular environment.\n * The channel condition is determined using the model specified in [1], Table 6.2-1.\n * The pathloss is determined using the model specified in [1], Table 6.2.1-1.\n * The model for the fast fading is the one described in 3GPP TR 38.901 v15.0.0,\n * the model parameters are those specified in [1], Table 6.2.3-1.\n *\n * This example generates the output file 'example-output.txt'. Each row of the\n * file is organized as follows:\n * Time[s] TxPosX[m] TxPosY[m] RxPosX[m] RxPosY[m] ChannelState SNR[dB] Pathloss[dB]\n * We also provide a bash script which reads the output file and generates two\n * figures:\n * (i) map.gif, a GIF representing the simulation scenario and vehicle mobility;\n * (ii) snr.png, which represents the behavior of the SNR.\n *\n * [1] 3GPP TR 37.885, v15.3.0\n */\n\n#include \"ns3/buildings-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/spectrum-signal-parameters.h\"\n#include \"ns3/three-gpp-channel-model.h\"\n#include \"ns3/three-gpp-spectrum-propagation-loss-model.h\"\n#include \"ns3/three-gpp-v2v-propagation-loss-model.h\"\n#include \"ns3/uniform-planar-array.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ThreeGppV2vChannelExample\");\n\nstatic Ptr<ThreeGppPropagationLossModel>\n    m_propagationLossModel; //!< the PropagationLossModel object\nstatic Ptr<ThreeGppSpectrumPropagationLossModel>\n    m_spectrumLossModel;                       //!< the SpectrumPropagationLossModel object\nstatic Ptr<ChannelConditionModel> m_condModel; //!< the ChannelConditionModel object\n\n/*\n * \\brief A structure that holds the parameters for the ComputeSnr\n * function. In this way the problem with the limited\n * number of parameters of method Schedule is avoided.\n */\nstruct ComputeSnrParams\n{\n    Ptr<MobilityModel> txMob;               //!< the tx mobility model\n    Ptr<MobilityModel> rxMob;               //!< the rx mobility model\n    Ptr<SpectrumSignalParameters> txParams; //!< the params of the tx signal\n    double noiseFigure;                     //!< the noise figure in dB\n    Ptr<PhasedArrayModel> txAntenna;        //!< the tx antenna array\n    Ptr<PhasedArrayModel> rxAntenna;        //!< the rx antenna array\n};\n\n/**\n * Perform the beamforming using the DFT beamforming method\n * \\param thisDevice the device performing the beamforming\n * \\param thisAntenna the antenna object associated to thisDevice\n * \\param otherDevice the device towards which point the beam\n */\nstatic void\nDoBeamforming(Ptr<NetDevice> thisDevice,\n              Ptr<PhasedArrayModel> thisAntenna,\n              Ptr<NetDevice> otherDevice)\n{\n    PhasedArrayModel::ComplexVector antennaWeights;\n\n    // retrieve the position of the two devices\n    Vector aPos = thisDevice->GetNode()->GetObject<MobilityModel>()->GetPosition();\n    Vector bPos = otherDevice->GetNode()->GetObject<MobilityModel>()->GetPosition();\n\n    // compute the azimuth and the elevation angles\n    Angles completeAngle(bPos, aPos);\n\n    PhasedArrayModel::ComplexVector bf = thisAntenna->GetBeamformingVector(completeAngle);\n    thisAntenna->SetBeamformingVector(bf);\n}\n\n/**\n * Compute the average SNR\n * \\param params A structure that holds a bunch of parameters needed by ComputSnr function to\n * calculate the average SNR\n */\nstatic void\nComputeSnr(const ComputeSnrParams& params)\n{\n    // check the channel condition\n    Ptr<ChannelCondition> cond = m_condModel->GetChannelCondition(params.txMob, params.rxMob);\n\n    // apply the pathloss\n    double propagationGainDb = m_propagationLossModel->CalcRxPower(0, params.txMob, params.rxMob);\n    NS_LOG_DEBUG(\"Pathloss \" << -propagationGainDb << \" dB\");\n    double propagationGainLinear = std::pow(10.0, (propagationGainDb) / 10.0);\n    *(params.txParams->psd) *= propagationGainLinear;\n\n    // apply the fast fading and the beamforming gain\n    auto rxParams = m_spectrumLossModel->CalcRxPowerSpectralDensity(params.txParams,\n                                                                    params.txMob,\n                                                                    params.rxMob,\n                                                                    params.txAntenna,\n                                                                    params.rxAntenna);\n    Ptr<SpectrumValue> rxPsd = rxParams->psd;\n    NS_LOG_DEBUG(\"Average rx power \" << 10 * log10(Sum(*rxPsd) * 180e3) << \" dB\");\n\n    // create the noise psd\n    // taken from lte-spectrum-value-helper\n    const double kT_dBm_Hz = -174.0; // dBm/Hz\n    double kT_W_Hz = std::pow(10.0, (kT_dBm_Hz - 30) / 10.0);\n    double noiseFigureLinear = std::pow(10.0, params.noiseFigure / 10.0);\n    double noisePowerSpectralDensity = kT_W_Hz * noiseFigureLinear;\n    Ptr<SpectrumValue> noisePsd = Create<SpectrumValue>(params.txParams->psd->GetSpectrumModel());\n    (*noisePsd) = noisePowerSpectralDensity;\n\n    // compute the SNR\n    NS_LOG_DEBUG(\"Average SNR \" << 10 * log10(Sum(*rxPsd) / Sum(*noisePsd)) << \" dB\");\n\n    // print the SNR and pathloss values in the snr-trace.txt file\n    std::ofstream f;\n    f.open(\"example-output.txt\", std::ios::out | std::ios::app);\n    f << Simulator::Now().GetSeconds() << \" \" // time [s]\n      << params.txMob->GetPosition().x << \" \" << params.txMob->GetPosition().y << \" \"\n      << params.rxMob->GetPosition().x << \" \" << params.rxMob->GetPosition().y << \" \"\n      << cond->GetLosCondition() << \" \"                  // channel state\n      << 10 * log10(Sum(*rxPsd) / Sum(*noisePsd)) << \" \" // SNR [dB]\n      << -propagationGainDb << std::endl;                // pathloss [dB]\n    f.close();\n}\n\n/**\n * Generates a GNU-plottable file representing the buildings deployed in the\n * scenario\n * \\param filename the name of the output file\n */\nvoid\nPrintGnuplottableBuildingListToFile(std::string filename)\n{\n    std::ofstream outFile;\n    outFile.open(filename, std::ios_base::out | std::ios_base::trunc);\n    if (!outFile.is_open())\n    {\n        NS_LOG_ERROR(\"Can't open file \" << filename);\n        return;\n    }\n    uint32_t index = 0;\n    for (auto it = BuildingList::Begin(); it != BuildingList::End(); ++it)\n    {\n        ++index;\n        Box box = (*it)->GetBoundaries();\n        outFile << \"set object \" << index << \" rect from \" << box.xMin << \",\" << box.yMin << \" to \"\n                << box.xMax << \",\" << box.yMax << std::endl;\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double frequency = 28.0e9;          // operating frequency in Hz\n    double txPow_dbm = 30.0;            // tx power in dBm\n    double noiseFigure = 9.0;           // noise figure in dB\n    Time simTime = Seconds(40);         // simulation time\n    Time timeRes = MilliSeconds(10);    // time resolution\n    std::string scenario = \"V2V-Urban\"; // 3GPP propagation scenario, V2V-Urban or V2V-Highway\n    double vScatt = 0;                  // maximum speed of the vehicles in the scenario [m/s]\n    double subCarrierSpacing = 60e3;    // subcarrier spacing in kHz\n    uint32_t numRb = 275;               // number of resource blocks\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"frequency\", \"operating frequency in Hz\", frequency);\n    cmd.AddValue(\"txPow\", \"tx power in dBm\", txPow_dbm);\n    cmd.AddValue(\"noiseFigure\", \"noise figure in dB\", noiseFigure);\n    cmd.AddValue(\"scenario\", \"3GPP propagation scenario, V2V-Urban or V2V-Highway\", scenario);\n    cmd.Parse(argc, argv);\n\n    // create the nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // create the tx and rx devices\n    Ptr<SimpleNetDevice> txDev = CreateObject<SimpleNetDevice>();\n    Ptr<SimpleNetDevice> rxDev = CreateObject<SimpleNetDevice>();\n\n    // associate the nodes and the devices\n    nodes.Get(0)->AddDevice(txDev);\n    txDev->SetNode(nodes.Get(0));\n    nodes.Get(1)->AddDevice(rxDev);\n    rxDev->SetNode(nodes.Get(1));\n\n    // create the antenna objects and set their dimensions\n    Ptr<PhasedArrayModel> txAntenna =\n        CreateObjectWithAttributes<UniformPlanarArray>(\"NumColumns\",\n                                                       UintegerValue(2),\n                                                       \"NumRows\",\n                                                       UintegerValue(2),\n                                                       \"BearingAngle\",\n                                                       DoubleValue(-M_PI / 2));\n    Ptr<PhasedArrayModel> rxAntenna =\n        CreateObjectWithAttributes<UniformPlanarArray>(\"NumColumns\",\n                                                       UintegerValue(2),\n                                                       \"NumRows\",\n                                                       UintegerValue(2),\n                                                       \"BearingAngle\",\n                                                       DoubleValue(M_PI / 2));\n\n    Ptr<MobilityModel> txMob;\n    Ptr<MobilityModel> rxMob;\n    if (scenario == \"V2V-Urban\")\n    {\n        // 3GPP defines that the maximum speed in urban scenario is 60 km/h\n        vScatt = 60 / 3.6;\n\n        // create a grid of buildings\n        double buildingSizeX = 250 - 3.5 * 2 - 3; // m\n        double buildingSizeY = 433 - 3.5 * 2 - 3; // m\n        double streetWidth = 20;                  // m\n        double buildingHeight = 10;               // m\n        uint32_t numBuildingsX = 2;\n        uint32_t numBuildingsY = 2;\n        double maxAxisX = (buildingSizeX + streetWidth) * numBuildingsX;\n        double maxAxisY = (buildingSizeY + streetWidth) * numBuildingsY;\n\n        std::vector<Ptr<Building>> buildingVector;\n        for (uint32_t buildingIdX = 0; buildingIdX < numBuildingsX; ++buildingIdX)\n        {\n            for (uint32_t buildingIdY = 0; buildingIdY < numBuildingsY; ++buildingIdY)\n            {\n                Ptr<Building> building;\n                building = CreateObject<Building>();\n\n                building->SetBoundaries(\n                    Box(buildingIdX * (buildingSizeX + streetWidth),\n                        buildingIdX * (buildingSizeX + streetWidth) + buildingSizeX,\n                        buildingIdY * (buildingSizeY + streetWidth),\n                        buildingIdY * (buildingSizeY + streetWidth) + buildingSizeY,\n                        0.0,\n                        buildingHeight));\n                building->SetNRoomsX(1);\n                building->SetNRoomsY(1);\n                building->SetNFloors(1);\n                buildingVector.push_back(building);\n            }\n        }\n\n        // set the mobility model\n        double vTx = vScatt;\n        double vRx = vScatt / 2;\n        txMob = CreateObject<WaypointMobilityModel>();\n        rxMob = CreateObject<WaypointMobilityModel>();\n        Time nextWaypoint = Seconds(0.0);\n        txMob->GetObject<WaypointMobilityModel>()->AddWaypoint(\n            Waypoint(nextWaypoint, Vector(maxAxisX / 2 - streetWidth / 2, 1.0, 1.5)));\n        nextWaypoint += Seconds((maxAxisY - streetWidth) / 2 / vTx);\n        txMob->GetObject<WaypointMobilityModel>()->AddWaypoint(\n            Waypoint(nextWaypoint,\n                     Vector(maxAxisX / 2 - streetWidth / 2, maxAxisY / 2 - streetWidth / 2, 1.5)));\n        nextWaypoint += Seconds((maxAxisX - streetWidth) / 2 / vTx);\n        txMob->GetObject<WaypointMobilityModel>()->AddWaypoint(\n            Waypoint(nextWaypoint, Vector(0.0, maxAxisY / 2 - streetWidth / 2, 1.5)));\n        nextWaypoint = Seconds(0.0);\n        rxMob->GetObject<WaypointMobilityModel>()->AddWaypoint(\n            Waypoint(nextWaypoint, Vector(maxAxisX / 2 - streetWidth / 2, 0.0, 1.5)));\n        nextWaypoint += Seconds(maxAxisY / vRx);\n        rxMob->GetObject<WaypointMobilityModel>()->AddWaypoint(\n            Waypoint(nextWaypoint, Vector(maxAxisX / 2 - streetWidth / 2, maxAxisY, 1.5)));\n\n        nodes.Get(0)->AggregateObject(txMob);\n        nodes.Get(1)->AggregateObject(rxMob);\n\n        // create the channel condition model\n        m_condModel = CreateObject<ThreeGppV2vUrbanChannelConditionModel>();\n\n        // create the propagation loss model\n        m_propagationLossModel = CreateObject<ThreeGppV2vUrbanPropagationLossModel>();\n    }\n    else if (scenario == \"V2V-Highway\")\n    {\n        // Two vehicles are travelling one behid the other with constant velocity\n        // along the y axis. The distance between the two vehicles is 20 meters.\n\n        // 3GPP defines that the maximum speed in urban scenario is 140 km/h\n        vScatt = 140 / 3.6;\n        double vTx = vScatt;\n        double vRx = vScatt / 2;\n\n        txMob = CreateObject<ConstantVelocityMobilityModel>();\n        rxMob = CreateObject<ConstantVelocityMobilityModel>();\n        txMob->GetObject<ConstantVelocityMobilityModel>()->SetPosition(Vector(300.0, 20.0, 1.5));\n        txMob->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(0.0, vTx, 0.0));\n        rxMob->GetObject<ConstantVelocityMobilityModel>()->SetPosition(Vector(300.0, 0.0, 1.5));\n        rxMob->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(0.0, vRx, 0.0));\n\n        nodes.Get(0)->AggregateObject(txMob);\n        nodes.Get(1)->AggregateObject(rxMob);\n\n        // create the channel condition model\n        m_condModel = CreateObject<ThreeGppV2vHighwayChannelConditionModel>();\n\n        // create the propagation loss model\n        m_propagationLossModel = CreateObject<ThreeGppV2vHighwayPropagationLossModel>();\n    }\n    else\n    {\n        NS_FATAL_ERROR(\"Unknown scenario\");\n    }\n\n    m_condModel->SetAttribute(\"UpdatePeriod\", TimeValue(MilliSeconds(100)));\n\n    m_propagationLossModel->SetAttribute(\"Frequency\", DoubleValue(frequency));\n    m_propagationLossModel->SetAttribute(\"ShadowingEnabled\", BooleanValue(false));\n    m_propagationLossModel->SetAttribute(\"ChannelConditionModel\", PointerValue(m_condModel));\n\n    // create the channel model\n    Ptr<ThreeGppChannelModel> channelModel = CreateObject<ThreeGppChannelModel>();\n    channelModel->SetAttribute(\"Scenario\", StringValue(scenario));\n    channelModel->SetAttribute(\"Frequency\", DoubleValue(frequency));\n    channelModel->SetAttribute(\"ChannelConditionModel\", PointerValue(m_condModel));\n    channelModel->SetAttribute(\"vScatt\", DoubleValue(vScatt));\n\n    // create the spectrum propagation loss model\n    m_spectrumLossModel = CreateObjectWithAttributes<ThreeGppSpectrumPropagationLossModel>(\n        \"ChannelModel\",\n        PointerValue(channelModel));\n\n    BuildingsHelper::Install(nodes);\n\n    // set the beamforming vectors\n    DoBeamforming(txDev, txAntenna, rxDev);\n    DoBeamforming(rxDev, rxAntenna, txDev);\n\n    // create the tx power spectral density\n    Bands rbs;\n    double freqSubBand = frequency;\n    for (uint32_t n = 0; n < numRb; ++n)\n    {\n        BandInfo rb;\n        rb.fl = freqSubBand;\n        freqSubBand += subCarrierSpacing / 2;\n        rb.fc = freqSubBand;\n        freqSubBand += subCarrierSpacing / 2;\n        rb.fh = freqSubBand;\n        rbs.push_back(rb);\n    }\n    Ptr<SpectrumModel> spectrumModel = Create<SpectrumModel>(rbs);\n    Ptr<SpectrumValue> txPsd = Create<SpectrumValue>(spectrumModel);\n    Ptr<SpectrumSignalParameters> txParams = Create<SpectrumSignalParameters>();\n    double txPow_w = std::pow(10., (txPow_dbm - 30) / 10);\n    double txPowDens = (txPow_w / (numRb * subCarrierSpacing));\n    (*txPsd) = txPowDens;\n    txParams->psd = txPsd->Copy();\n\n    for (int i = 0; i < simTime / timeRes; i++)\n    {\n        ComputeSnrParams params{txMob, rxMob, txParams, noiseFigure, txAntenna, rxAntenna};\n        Simulator::Schedule(timeRes * i, &ComputeSnr, params);\n    }\n\n    // initialize the output file\n    std::ofstream f;\n    f.open(\"example-output.txt\", std::ios::out);\n    f << \"Time[s] TxPosX[m] TxPosY[m] RxPosX[m] RxPosY[m] ChannelState SNR[dB] Pathloss[dB]\"\n      << std::endl;\n    f.close();\n\n    // print the list of buildings to file\n    PrintGnuplottableBuildingListToFile(\"buildings.txt\");\n\n    Simulator::Run();\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate C++ code implementing a basic Wi-Fi sender and receiver application using the ns-3 simulator. The sender transmits a defined number of packets at regular intervals, while the receiver listens for these packets, calculates statistics like delay, and logs relevant information. The sender should utilize attributes such as packet size, destination address, port, and interval. The receiver should have attributes like the listening port and must handle incoming packets by tracing timestamps to calculate the delay. Both sender and receiver must be derived from the `Application` class and include necessary ns-3 modules."}, {"role": "assistant", "content": "#include \"wifi-example-apps.h\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/stats-module.h\"\n\n#include <ostream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WiFiDistanceApps\");\n\n// ==============================================\n// SENDER\n// ==============================================\n\nTypeId\nSender::GetTypeId()\n{\n    static TypeId tid = TypeId(\"Sender\")\n                            .SetParent<Application>()\n                            .AddConstructor<Sender>()\n                            .AddAttribute(\"PacketSize\",\n                                          \"The size of packets transmitted.\",\n                                          UintegerValue(64),\n                                          MakeUintegerAccessor(&Sender::m_packetSize),\n                                          MakeUintegerChecker<uint32_t>(1))\n                            .AddAttribute(\"Destination\",\n                                          \"Target host address.\",\n                                          Ipv4AddressValue(\"255.255.255.255\"),\n                                          MakeIpv4AddressAccessor(&Sender::m_destAddr),\n                                          MakeIpv4AddressChecker())\n                            .AddAttribute(\"Port\",\n                                          \"Destination app port.\",\n                                          UintegerValue(1603),\n                                          MakeUintegerAccessor(&Sender::m_destPort),\n                                          MakeUintegerChecker<uint32_t>())\n                            .AddAttribute(\"NumPackets\",\n                                          \"Total number of packets to send.\",\n                                          UintegerValue(30),\n                                          MakeUintegerAccessor(&Sender::m_nPackets),\n                                          MakeUintegerChecker<uint32_t>(1))\n                            .AddAttribute(\"Interval\",\n                                          \"Delay between transmissions.\",\n                                          StringValue(\"ns3::ConstantRandomVariable[Constant=0.5]\"),\n                                          MakePointerAccessor(&Sender::m_interval),\n                                          MakePointerChecker<RandomVariableStream>())\n                            .AddTraceSource(\"Tx\",\n                                            \"A new packet is created and is sent\",\n                                            MakeTraceSourceAccessor(&Sender::m_txTrace),\n                                            \"ns3::Packet::TracedCallback\");\n    return tid;\n}\n\nSender::Sender()\n{\n    NS_LOG_FUNCTION_NOARGS();\n    m_interval = CreateObject<ConstantRandomVariable>();\n}\n\nSender::~Sender()\n{\n    NS_LOG_FUNCTION_NOARGS();\n}\n\nvoid\nSender::DoDispose()\n{\n    NS_LOG_FUNCTION_NOARGS();\n\n    m_socket = nullptr;\n    // chain up\n    Application::DoDispose();\n}\n\nvoid\nSender::StartApplication()\n{\n    NS_LOG_FUNCTION_NOARGS();\n\n    if (!m_socket)\n    {\n        Ptr<SocketFactory> socketFactory =\n            GetNode()->GetObject<SocketFactory>(UdpSocketFactory::GetTypeId());\n        m_socket = socketFactory->CreateSocket();\n        m_socket->Bind();\n    }\n\n    m_count = 0;\n\n    Simulator::Cancel(m_sendEvent);\n    m_sendEvent = Simulator::ScheduleNow(&Sender::SendPacket, this);\n}\n\nvoid\nSender::StopApplication()\n{\n    NS_LOG_FUNCTION_NOARGS();\n    Simulator::Cancel(m_sendEvent);\n}\n\nvoid\nSender::SendPacket()\n{\n    // NS_LOG_FUNCTION_NOARGS();\n    NS_LOG_INFO(\"Sending packet at \" << Simulator::Now() << \" to \" << m_destAddr);\n\n    Ptr<Packet> packet = Create<Packet>(m_packetSize);\n\n    TimestampTag timestamp;\n    timestamp.SetTimestamp(Simulator::Now());\n    packet->AddByteTag(timestamp);\n\n    // Could connect the socket since the address never changes; using SendTo\n    // here simply because all of the standard apps do not.\n    m_socket->SendTo(packet, 0, InetSocketAddress(m_destAddr, m_destPort));\n\n    // Report the event to the trace.\n    m_txTrace(packet);\n\n    if (++m_count < m_nPackets)\n    {\n        m_sendEvent =\n            Simulator::Schedule(Seconds(m_interval->GetValue()), &Sender::SendPacket, this);\n    }\n}\n\n// ==============================================\n// RECEIVER\n// ==============================================\n\nTypeId\nReceiver::GetTypeId()\n{\n    static TypeId tid = TypeId(\"Receiver\")\n                            .SetParent<Application>()\n                            .AddConstructor<Receiver>()\n                            .AddAttribute(\"Port\",\n                                          \"Listening port.\",\n                                          UintegerValue(1603),\n                                          MakeUintegerAccessor(&Receiver::m_port),\n                                          MakeUintegerChecker<uint32_t>());\n    return tid;\n}\n\nReceiver::Receiver()\n{\n    NS_LOG_FUNCTION_NOARGS();\n}\n\nReceiver::~Receiver()\n{\n    NS_LOG_FUNCTION_NOARGS();\n}\n\nvoid\nReceiver::DoDispose()\n{\n    NS_LOG_FUNCTION_NOARGS();\n\n    m_socket = nullptr;\n    // chain up\n    Application::DoDispose();\n}\n\nvoid\nReceiver::StartApplication()\n{\n    NS_LOG_FUNCTION_NOARGS();\n\n    if (!m_socket)\n    {\n        Ptr<SocketFactory> socketFactory =\n            GetNode()->GetObject<SocketFactory>(UdpSocketFactory::GetTypeId());\n        m_socket = socketFactory->CreateSocket();\n        InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), m_port);\n        m_socket->Bind(local);\n    }\n\n    m_socket->SetRecvCallback(MakeCallback(&Receiver::Receive, this));\n}\n\nvoid\nReceiver::StopApplication()\n{\n    NS_LOG_FUNCTION_NOARGS();\n\n    if (m_socket)\n    {\n        m_socket->SetRecvCallback(MakeNullCallback<void, Ptr<Socket>>());\n    }\n}\n\nvoid\nReceiver::SetCounter(Ptr<CounterCalculator<>> calc)\n{\n    m_calc = calc;\n}\n\nvoid\nReceiver::SetDelayTracker(Ptr<TimeMinMaxAvgTotalCalculator> delay)\n{\n    m_delay = delay;\n}\n\nvoid\nReceiver::Receive(Ptr<Socket> socket)\n{\n    // NS_LOG_FUNCTION (this << socket << packet << from);\n\n    Ptr<Packet> packet;\n    Address from;\n    while ((packet = socket->RecvFrom(from)))\n    {\n        if (InetSocketAddress::IsMatchingType(from))\n        {\n            NS_LOG_INFO(\"Received \" << packet->GetSize() << \" bytes from \"\n                                    << InetSocketAddress::ConvertFrom(from).GetIpv4());\n        }\n\n        TimestampTag timestamp;\n        // Should never not be found since the sender is adding it, but\n        // you never know.\n        if (packet->FindFirstMatchingByteTag(timestamp))\n        {\n            Time tx = timestamp.GetTimestamp();\n\n            if (m_delay)\n            {\n                m_delay->Update(Simulator::Now() - tx);\n            }\n        }\n\n        if (m_calc)\n        {\n            m_calc->Update();\n        }\n    }\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate C++ code for an ns-3 simulation experiment that measures Wi-Fi performance based on the distance between two nodes. The program should include Wi-Fi configuration using Ad-hoc mode, mobility for node placement, and statistics collection such as packet transmission, reception, and delay tracking. Use the `DataCollector` class to gather experiment data and support both OMNeT and SQLite output formats. Create callbacks for packet transmission and reception, and define command-line arguments for experiment configuration, including distance, format, and run identifiers."}, {"role": "assistant", "content": "#include \"wifi-example-apps.h\"\n\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/stats-module.h\"\n#include \"ns3/wifi-module.h\"\n\n#include <ctime>\n#include <sstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WiFiDistanceExperiment\");\n\n/**\n * Function called when a packet is transmitted.\n *\n * \\param datac The counter of the number of transmitted packets.\n * \\param path The callback context.\n * \\param packet The transmitted packet.\n */\nvoid\nTxCallback(Ptr<CounterCalculator<uint32_t>> datac, std::string path, Ptr<const Packet> packet)\n{\n    NS_LOG_INFO(\"Sent frame counted in \" << datac->GetKey());\n    datac->Update();\n}\n\nint\nmain(int argc, char* argv[])\n{\n    double distance = 50.0;\n    std::string format(\"omnet\");\n\n    std::string experiment(\"wifi-distance-test\");\n    std::string strategy(\"wifi-default\");\n    std::string input;\n    std::string runID;\n\n    {\n        std::stringstream sstr;\n        sstr << \"run-\" << time(nullptr);\n        runID = sstr.str();\n    }\n\n    // Set up command line parameters used to control the experiment.\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"distance\", \"Distance apart to place nodes (in meters).\", distance);\n    cmd.AddValue(\"format\", \"Format to use for data output.\", format);\n    cmd.AddValue(\"experiment\", \"Identifier for experiment.\", experiment);\n    cmd.AddValue(\"strategy\", \"Identifier for strategy.\", strategy);\n    cmd.AddValue(\"run\", \"Identifier for run.\", runID);\n    cmd.Parse(argc, argv);\n\n    if (format != \"omnet\" && format != \"db\")\n    {\n        NS_LOG_ERROR(\"Unknown output format '\" << format << \"'\");\n        return -1;\n    }\n\n#ifndef HAVE_SQLITE3\n    if (format == \"db\")\n    {\n        NS_LOG_ERROR(\"sqlite support not compiled in.\");\n        return -1;\n    }\n#endif\n\n    {\n        std::stringstream sstr(\"\");\n        sstr << distance;\n        input = sstr.str();\n    }\n\n    //--------------------------------------------\n    //-- Create nodes and network stacks\n    //--------------------------------------------\n    NS_LOG_INFO(\"Creating nodes.\");\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    NS_LOG_INFO(\"Installing WiFi and Internet stack.\");\n    WifiHelper wifi;\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n    YansWifiPhyHelper wifiPhy;\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n    NetDeviceContainer nodeDevices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    InternetStackHelper internet;\n    internet.Install(nodes);\n    Ipv4AddressHelper ipAddrs;\n    ipAddrs.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n    ipAddrs.Assign(nodeDevices);\n\n    //--------------------------------------------\n    //-- Setup physical layout\n    //--------------------------------------------\n    NS_LOG_INFO(\"Installing static mobility; distance \" << distance << \" .\");\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(0.0, distance, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.Install(nodes);\n\n    //--------------------------------------------\n    //-- Create a custom traffic source and sink\n    //--------------------------------------------\n    NS_LOG_INFO(\"Create traffic source & sink.\");\n    Ptr<Node> appSource = NodeList::GetNode(0);\n    Ptr<Sender> sender = CreateObject<Sender>();\n    appSource->AddApplication(sender);\n    sender->SetStartTime(Seconds(1));\n\n    Ptr<Node> appSink = NodeList::GetNode(1);\n    Ptr<Receiver> receiver = CreateObject<Receiver>();\n    appSink->AddApplication(receiver);\n    receiver->SetStartTime(Seconds(0));\n\n    Config::Set(\"/NodeList/*/ApplicationList/*/$Sender/Destination\",\n                Ipv4AddressValue(\"192.168.0.2\"));\n\n    //--------------------------------------------\n    //-- Setup stats and data collection\n    //--------------------------------------------\n\n    // Create a DataCollector object to hold information about this run.\n    DataCollector data;\n    data.DescribeRun(experiment, strategy, input, runID);\n\n    // Add any information we wish to record about this run.\n    data.AddMetadata(\"author\", \"tjkopena\");\n\n    // Create a counter to track how many frames are generated.  Updates\n    // are triggered by the trace signal generated by the WiFi MAC model\n    // object.  Here we connect the counter to the signal via the simple\n    // TxCallback() glue function defined above.\n    Ptr<CounterCalculator<uint32_t>> totalTx = CreateObject<CounterCalculator<uint32_t>>();\n    totalTx->SetKey(\"wifi-tx-frames\");\n    totalTx->SetContext(\"node[0]\");\n    Config::Connect(\"/NodeList/0/DeviceList/*/$ns3::WifiNetDevice/Mac/MacTx\",\n                    MakeBoundCallback(&TxCallback, totalTx));\n    data.AddDataCalculator(totalTx);\n\n    // This is similar, but creates a counter to track how many frames\n    // are received.  Instead of our own glue function, this uses a\n    // method of an adapter class to connect a counter directly to the\n    // trace signal generated by the WiFi MAC.\n    Ptr<PacketCounterCalculator> totalRx = CreateObject<PacketCounterCalculator>();\n    totalRx->SetKey(\"wifi-rx-frames\");\n    totalRx->SetContext(\"node[1]\");\n    Config::Connect(\"/NodeList/1/DeviceList/*/$ns3::WifiNetDevice/Mac/MacRx\",\n                    MakeCallback(&PacketCounterCalculator::PacketUpdate, totalRx));\n    data.AddDataCalculator(totalRx);\n\n    // This counter tracks how many packets---as opposed to frames---are\n    // generated.  This is connected directly to a trace signal provided\n    // by our Sender class.\n    Ptr<PacketCounterCalculator> appTx = CreateObject<PacketCounterCalculator>();\n    appTx->SetKey(\"sender-tx-packets\");\n    appTx->SetContext(\"node[0]\");\n    Config::Connect(\"/NodeList/0/ApplicationList/*/$Sender/Tx\",\n                    MakeCallback(&PacketCounterCalculator::PacketUpdate, appTx));\n    data.AddDataCalculator(appTx);\n\n    // Here a counter for received packets is directly manipulated by\n    // one of the custom objects in our simulation, the Receiver\n    // Application.  The Receiver object is given a pointer to the\n    // counter and calls its Update() method whenever a packet arrives.\n    Ptr<CounterCalculator<>> appRx = CreateObject<CounterCalculator<>>();\n    appRx->SetKey(\"receiver-rx-packets\");\n    appRx->SetContext(\"node[1]\");\n    receiver->SetCounter(appRx);\n    data.AddDataCalculator(appRx);\n\n    // Just to show this is here...\n\n    /*\n    Ptr<MinMaxAvgTotalCalculator<uint32_t>> test =\n        CreateObject<MinMaxAvgTotalCalculator<uint32_t>>();\n    test->SetKey(\"test-dc\");\n    data.AddDataCalculator(test);\n\n    test->Update(4);\n    test->Update(8);\n    test->Update(24);\n    test->Update(12);\n    */\n\n    // This DataCalculator connects directly to the transmit trace\n    // provided by our Sender Application.  It records some basic\n    // statistics about the sizes of the packets received (min, max,\n    // avg, total # bytes), although in this scenario they're fixed.\n    Ptr<PacketSizeMinMaxAvgTotalCalculator> appTxPkts =\n        CreateObject<PacketSizeMinMaxAvgTotalCalculator>();\n    appTxPkts->SetKey(\"tx-pkt-size\");\n    appTxPkts->SetContext(\"node[0]\");\n    Config::Connect(\"/NodeList/0/ApplicationList/*/$Sender/Tx\",\n                    MakeCallback(&PacketSizeMinMaxAvgTotalCalculator::PacketUpdate, appTxPkts));\n    data.AddDataCalculator(appTxPkts);\n\n    // Here we directly manipulate another DataCollector tracking min,\n    // max, total, and average propagation delays.  Check out the Sender\n    // and Receiver classes to see how packets are tagged with\n    // timestamps to do this.\n    Ptr<TimeMinMaxAvgTotalCalculator> delayStat = CreateObject<TimeMinMaxAvgTotalCalculator>();\n    delayStat->SetKey(\"delay\");\n    delayStat->SetContext(\".\");\n    receiver->SetDelayTracker(delayStat);\n    data.AddDataCalculator(delayStat);\n\n    //--------------------------------------------\n    //-- Run the simulation\n    //--------------------------------------------\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n\n    //--------------------------------------------\n    //-- Generate statistics output.\n    //--------------------------------------------\n\n    // Pick an output writer based in the requested format.\n    Ptr<DataOutputInterface> output = nullptr;\n    if (format == \"omnet\")\n    {\n        NS_LOG_INFO(\"Creating omnet formatted data output.\");\n        output = CreateObject<OmnetDataOutput>();\n    }\n    else if (format == \"db\")\n    {\n#ifdef HAVE_SQLITE3\n        NS_LOG_INFO(\"Creating sqlite formatted data output.\");\n        output = CreateObject<SqliteDataOutput>();\n#endif\n    }\n    else\n    {\n        NS_LOG_ERROR(\"Unknown output format \" << format);\n    }\n\n    // Finally, have that writer interrogate the DataCollector and save\n    // the results.\n    if (output)\n    {\n        output->Output(data);\n    }\n\n    // Free any memory here at the end of this example.\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate C++ code for an ns-3 simulation that demonstrates energy consumption in a Wi-Fi network with two nodes. Configure nodes with basic energy sources and Wi-Fi radio energy models, and simulate packet transmission between them. Include functionality to track remaining energy and total energy consumed by the nodes, using trace sources. Use the UDP protocol to send and receive packets, and log the transmission details. Allow command-line configuration of parameters such as packet size, simulation start time, and node distance. Ensure the energy consumed remains within specified limits by the end of the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/energy-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-radio-energy-model-helper.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace ns3;\nusing namespace ns3::energy;\n\nNS_LOG_COMPONENT_DEFINE(\"EnergyExample\");\n\n/**\n * Print a received packet\n *\n * \\param from sender address\n * \\return a string with the details of the packet: dst {IP, port}, time.\n */\nstatic inline std::string\nPrintReceivedPacket(Address& from)\n{\n    InetSocketAddress iaddr = InetSocketAddress::ConvertFrom(from);\n\n    std::ostringstream oss;\n    oss << \"--\\nReceived one packet! Socket: \" << iaddr.GetIpv4() << \" port: \" << iaddr.GetPort()\n        << \" at time = \" << Simulator::Now().GetSeconds() << \"\\n--\";\n\n    return oss.str();\n}\n\n/**\n * \\param socket Pointer to socket.\n *\n * Packet receiving sink.\n */\nvoid\nReceivePacket(Ptr<Socket> socket)\n{\n    Ptr<Packet> packet;\n    Address from;\n    while ((packet = socket->RecvFrom(from)))\n    {\n        if (packet->GetSize() > 0)\n        {\n            NS_LOG_UNCOND(PrintReceivedPacket(from));\n        }\n    }\n}\n\n/**\n * \\param socket Pointer to socket.\n * \\param pktSize Packet size.\n * \\param n Pointer to node.\n * \\param pktCount Number of packets to generate.\n * \\param pktInterval Packet sending interval.\n *\n * Traffic generator.\n */\nstatic void\nGenerateTraffic(Ptr<Socket> socket,\n                uint32_t pktSize,\n                Ptr<Node> n,\n                uint32_t pktCount,\n                Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval,\n                            &GenerateTraffic,\n                            socket,\n                            pktSize,\n                            n,\n                            pktCount - 1,\n                            pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\n/**\n * Trace function for remaining energy at node.\n *\n * \\param oldValue Old value\n * \\param remainingEnergy New value\n */\nvoid\nRemainingEnergy(double oldValue, double remainingEnergy)\n{\n    NS_LOG_UNCOND(Simulator::Now().GetSeconds()\n                  << \"s Current remaining energy = \" << remainingEnergy << \"J\");\n}\n\n/**\n * \\brief Trace function for total energy consumption at node.\n *\n * \\param oldValue Old value\n * \\param totalEnergy New value\n */\nvoid\nTotalEnergy(double oldValue, double totalEnergy)\n{\n    NS_LOG_UNCOND(Simulator::Now().GetSeconds()\n                  << \"s Total energy consumed by radio = \" << totalEnergy << \"J\");\n}\n\nint\nmain(int argc, char* argv[])\n{\n    /*\n    LogComponentEnable (\"EnergySource\", LOG_LEVEL_DEBUG);\n    LogComponentEnable (\"BasicEnergySource\", LOG_LEVEL_DEBUG);\n    LogComponentEnable (\"DeviceEnergyModel\", LOG_LEVEL_DEBUG);\n    LogComponentEnable (\"WifiRadioEnergyModel\", LOG_LEVEL_DEBUG);\n     */\n\n    LogComponentEnable(\"EnergyExample\",\n                       LogLevel(LOG_PREFIX_TIME | LOG_PREFIX_NODE | LOG_LEVEL_INFO));\n\n    std::string phyMode(\"DsssRate1Mbps\");\n    double Prss = -80;          // dBm\n    uint32_t PpacketSize = 200; // bytes\n    bool verbose = false;\n\n    // simulation parameters\n    uint32_t numPackets = 10000; // number of packets to send\n    double interval = 1;         // seconds\n    double startTime = 0.0;      // seconds\n    double distanceToRx = 100.0; // meters\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"phyMode\", \"Wifi Phy mode\", phyMode);\n    cmd.AddValue(\"Prss\", \"Intended primary RSS (dBm)\", Prss);\n    cmd.AddValue(\"PpacketSize\", \"size of application packet sent\", PpacketSize);\n    cmd.AddValue(\"numPackets\", \"Total number of packets to send\", numPackets);\n    cmd.AddValue(\"startTime\", \"Simulation start time\", startTime);\n    cmd.AddValue(\"distanceToRx\", \"X-Axis distance between nodes\", distanceToRx);\n    cmd.AddValue(\"verbose\", \"Turn on all device log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    // Convert to time object\n    Time interPacketInterval = Seconds(interval);\n\n    // disable fragmentation for frames below 2200 bytes\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::FragmentationThreshold\",\n                       StringValue(\"2200\"));\n    // turn off RTS/CTS for frames below 2200 bytes\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"2200\"));\n    // Fix non-unicast data rate to be the same as that of unicast\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(phyMode));\n\n    NodeContainer c;\n    c.Create(2); // create 2 nodes\n    NodeContainer networkNodes;\n    networkNodes.Add(c.Get(0));\n    networkNodes.Add(c.Get(1));\n\n    // The below set of helpers will help us to put together the wifi NICs we want\n    WifiHelper wifi;\n    if (verbose)\n    {\n        WifiHelper::EnableLogComponents();\n    }\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    /** Wifi PHY **/\n    /***************************************************************************/\n    YansWifiPhyHelper wifiPhy;\n\n    /** wifi channel **/\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n\n    // create wifi channel\n    Ptr<YansWifiChannel> wifiChannelPtr = wifiChannel.Create();\n    wifiPhy.SetChannel(wifiChannelPtr);\n\n    /** MAC layer **/\n    // Add a MAC and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n    // Set it to ad-hoc mode\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    /** install PHY + MAC **/\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, networkNodes);\n\n    /** mobility **/\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(2 * distanceToRx, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    /** Energy Model **/\n    /***************************************************************************/\n    /* energy source */\n    BasicEnergySourceHelper basicSourceHelper;\n    // configure energy source\n    basicSourceHelper.Set(\"BasicEnergySourceInitialEnergyJ\", DoubleValue(0.1));\n    // install source\n    EnergySourceContainer sources = basicSourceHelper.Install(c);\n    /* device energy model */\n    WifiRadioEnergyModelHelper radioEnergyHelper;\n    // configure radio energy model\n    radioEnergyHelper.Set(\"TxCurrentA\", DoubleValue(0.0174));\n    // install device model\n    DeviceEnergyModelContainer deviceModels = radioEnergyHelper.Install(devices, sources);\n    /***************************************************************************/\n\n    /** Internet stack **/\n    InternetStackHelper internet;\n    internet.Install(networkNodes);\n\n    Ipv4AddressHelper ipv4;\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(networkNodes.Get(1), tid); // node 1, receiver\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 80);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    Ptr<Socket> source = Socket::CreateSocket(networkNodes.Get(0), tid); // node 0, sender\n    InetSocketAddress remote = InetSocketAddress(Ipv4Address::GetBroadcast(), 80);\n    source->SetAllowBroadcast(true);\n    source->Connect(remote);\n\n    /** connect trace sources **/\n    /***************************************************************************/\n    // all sources are connected to node 1\n    // energy source\n    Ptr<BasicEnergySource> basicSourcePtr = DynamicCast<BasicEnergySource>(sources.Get(1));\n    basicSourcePtr->TraceConnectWithoutContext(\"RemainingEnergy\", MakeCallback(&RemainingEnergy));\n    // device energy model\n    Ptr<DeviceEnergyModel> basicRadioModelPtr =\n        basicSourcePtr->FindDeviceEnergyModels(\"ns3::WifiRadioEnergyModel\").Get(0);\n    NS_ASSERT(basicRadioModelPtr);\n    basicRadioModelPtr->TraceConnectWithoutContext(\"TotalEnergyConsumption\",\n                                                   MakeCallback(&TotalEnergy));\n    /***************************************************************************/\n\n    /** simulation setup **/\n    // start traffic\n    Simulator::Schedule(Seconds(startTime),\n                        &GenerateTraffic,\n                        source,\n                        PpacketSize,\n                        networkNodes.Get(0),\n                        numPackets,\n                        interPacketInterval);\n\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    for (auto iter = deviceModels.Begin(); iter != deviceModels.End(); iter++)\n    {\n        double energyConsumed = (*iter)->GetTotalEnergyConsumption();\n        NS_LOG_UNCOND(\"End of simulation (\"\n                      << Simulator::Now().GetSeconds()\n                      << \"s) Total energy consumed by radio = \" << energyConsumed << \"J\");\n        NS_ASSERT(energyConsumed <= 0.1);\n    }\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ simulation script for NS-3 that models an energy-efficient wireless communication system with two nodes. One node transmits packets every second to the other node for 10 seconds. Both nodes are powered by a basic energy source, and each is connected to a basic energy harvester. The script should set the initial energy of each node to 1 joule, and the WiFi radio should consume energy for packet transmission and reception, with transmission and reception currents set to 0.0174A and 0.0197A, respectively. The harvester provides a random power between 0 and 0.1 watts, updated every second. Track and log energy consumption, harvested power, and residual energy for the receiver node during the simulation. Each packet takes 0.0023 seconds to transmit, and the simulation should print energy statistics upon completion."}, {"role": "assistant", "content": "/**\n * This example extends the energy model example by connecting a basic energy\n * harvester to the nodes.\n *\n * The example considers a simple communication link between a source and a\n * destination node, where the source node sends a packet to the destination\n * every 1 second. Each node is powered by a BasicEnergySource, which is recharged\n * by a BasicEnergyHarvester, and the WiFi radio consumes energy for the transmission/\n * reception of the packets.\n *\n * For the receiver node, the example prints the energy consumption of the WiFi radio,\n * the power harvested by the energy harvester and the residual energy in the\n * energy source.\n *\n * The nodes initial energy is set to 1.0 J, the transmission and reception entail a\n * current consumption of 0.0174 A and 0.0197 A, respectively (default values in\n * WifiRadioEnergyModel). The energy harvester provides an amount of power that varies\n * according to a random variable uniformly distributed in [0 0.1] W, and is updated\n * every 1 s. The energy source voltage is 3 V (default value in BasicEnergySource) and\n * the residual energy level is updated every 1 second (default value).\n *\n * The simulation start at time 0 and it is hard stopped at time 10 seconds. Given the\n * packet size and the distance between the nodes, each transmission lasts 0.0023s.\n * As a result, the destination node receives 10 messages.\n *\n */\n\n#include \"ns3/core-module.h\"\n#include \"ns3/energy-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-radio-energy-model-helper.h\"\n#include \"ns3/yans-wifi-helper.h\"\n\n#include <fstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace ns3;\nusing namespace ns3::energy;\n\nNS_LOG_COMPONENT_DEFINE(\"EnergyWithHarvestingExample\");\n\n/**\n * Print a received packet\n *\n * \\param from sender address\n * \\return a string with the details of the packet: dst {IP, port}, time.\n */\nstatic inline std::string\nPrintReceivedPacket(Address& from)\n{\n    InetSocketAddress iaddr = InetSocketAddress::ConvertFrom(from);\n\n    std::ostringstream oss;\n    oss << \"--\\nReceived one packet! Socket: \" << iaddr.GetIpv4() << \" port: \" << iaddr.GetPort()\n        << \" at time = \" << Simulator::Now().GetSeconds() << \"\\n--\";\n\n    return oss.str();\n}\n\n/**\n * \\param socket Pointer to socket.\n *\n * Packet receiving sink.\n */\nvoid\nReceivePacket(Ptr<Socket> socket)\n{\n    Ptr<Packet> packet;\n    Address from;\n    while ((packet = socket->RecvFrom(from)))\n    {\n        if (packet->GetSize() > 0)\n        {\n            NS_LOG_UNCOND(PrintReceivedPacket(from));\n        }\n    }\n}\n\n/**\n * \\param socket Pointer to socket.\n * \\param pktSize Packet size.\n * \\param n Pointer to node.\n * \\param pktCount Number of packets to generate.\n * \\param pktInterval Packet sending interval.\n *\n * Traffic generator.\n */\nstatic void\nGenerateTraffic(Ptr<Socket> socket,\n                uint32_t pktSize,\n                Ptr<Node> n,\n                uint32_t pktCount,\n                Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval,\n                            &GenerateTraffic,\n                            socket,\n                            pktSize,\n                            n,\n                            pktCount - 1,\n                            pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\n/**\n * Trace function for remaining energy at node.\n *\n * \\param oldValue Old value\n * \\param remainingEnergy New value\n */\nvoid\nRemainingEnergy(double oldValue, double remainingEnergy)\n{\n    NS_LOG_UNCOND(Simulator::Now().GetSeconds()\n                  << \"s Current remaining energy = \" << remainingEnergy << \"J\");\n}\n\n/**\n * Trace function for total energy consumption at node.\n *\n * \\param oldValue Old value\n * \\param totalEnergy New value\n */\nvoid\nTotalEnergy(double oldValue, double totalEnergy)\n{\n    NS_LOG_UNCOND(Simulator::Now().GetSeconds()\n                  << \"s Total energy consumed by radio = \" << totalEnergy << \"J\");\n}\n\n/**\n * Trace function for the power harvested by the energy harvester.\n *\n * \\param oldValue Old value\n * \\param harvestedPower New value\n */\nvoid\nHarvestedPower(double oldValue, double harvestedPower)\n{\n    NS_LOG_UNCOND(Simulator::Now().GetSeconds()\n                  << \"s Current harvested power = \" << harvestedPower << \" W\");\n}\n\n/**\n * Trace function for the total energy harvested by the node.\n *\n * \\param oldValue Old value\n * \\param totalEnergyHarvested New value\n */\nvoid\nTotalEnergyHarvested(double oldValue, double totalEnergyHarvested)\n{\n    NS_LOG_UNCOND(Simulator::Now().GetSeconds()\n                  << \"s Total energy harvested by harvester = \" << totalEnergyHarvested << \" J\");\n}\n\nint\nmain(int argc, char* argv[])\n{\n    std::string phyMode(\"DsssRate1Mbps\");\n    double Prss = -80;         // dBm\n    uint32_t PacketSize = 200; // bytes\n    bool verbose = false;\n\n    // simulation parameters\n    uint32_t numPackets = 10000; // number of packets to send\n    double interval = 1;         // seconds\n    double startTime = 0.0;      // seconds\n    double distanceToRx = 100.0; // meters\n\n    // Energy Harvester variables\n    double harvestingUpdateInterval = 1; // seconds\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"phyMode\", \"Wifi Phy mode\", phyMode);\n    cmd.AddValue(\"Prss\", \"Intended primary RSS (dBm)\", Prss);\n    cmd.AddValue(\"PacketSize\", \"size of application packet sent\", PacketSize);\n    cmd.AddValue(\"numPackets\", \"Total number of packets to send\", numPackets);\n    cmd.AddValue(\"startTime\", \"Simulation start time\", startTime);\n    cmd.AddValue(\"distanceToRx\", \"X-Axis distance between nodes\", distanceToRx);\n    cmd.AddValue(\"verbose\", \"Turn on all device log components\", verbose);\n    cmd.Parse(argc, argv);\n\n    // Convert to time object\n    Time interPacketInterval = Seconds(interval);\n\n    // disable fragmentation for frames below 2200 bytes\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::FragmentationThreshold\",\n                       StringValue(\"2200\"));\n    // turn off RTS/CTS for frames below 2200 bytes\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::RtsCtsThreshold\", StringValue(\"2200\"));\n    // Fix non-unicast data rate to be the same as that of unicast\n    Config::SetDefault(\"ns3::WifiRemoteStationManager::NonUnicastMode\", StringValue(phyMode));\n\n    NodeContainer c;\n    c.Create(2); // create 2 nodes\n    NodeContainer networkNodes;\n    networkNodes.Add(c.Get(0));\n    networkNodes.Add(c.Get(1));\n\n    // The below set of helpers will help us to put together the wifi NICs we want\n    WifiHelper wifi;\n    if (verbose)\n    {\n        WifiHelper::EnableLogComponents();\n    }\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    /** Wifi PHY **/\n    /***************************************************************************/\n    YansWifiPhyHelper wifiPhy;\n\n    /** wifi channel **/\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n\n    // create wifi channel\n    Ptr<YansWifiChannel> wifiChannelPtr = wifiChannel.Create();\n    wifiPhy.SetChannel(wifiChannelPtr);\n\n    /** MAC layer **/\n    // Add a MAC and disable rate control\n    WifiMacHelper wifiMac;\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\",\n                                 StringValue(phyMode),\n                                 \"ControlMode\",\n                                 StringValue(phyMode));\n    // Set it to ad-hoc mode\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    /** install PHY + MAC **/\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, networkNodes);\n\n    /** mobility **/\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(0.0, 0.0, 0.0));\n    positionAlloc->Add(Vector(2 * distanceToRx, 0.0, 0.0));\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(c);\n\n    /** Energy Model **/\n    /***************************************************************************/\n    /* energy source */\n    BasicEnergySourceHelper basicSourceHelper;\n    // configure energy source\n    basicSourceHelper.Set(\"BasicEnergySourceInitialEnergyJ\", DoubleValue(1.0));\n    // install source\n    EnergySourceContainer sources = basicSourceHelper.Install(c);\n    /* device energy model */\n    WifiRadioEnergyModelHelper radioEnergyHelper;\n    // configure radio energy model\n    radioEnergyHelper.Set(\"TxCurrentA\", DoubleValue(0.0174));\n    radioEnergyHelper.Set(\"RxCurrentA\", DoubleValue(0.0197));\n    // install device model\n    DeviceEnergyModelContainer deviceModels = radioEnergyHelper.Install(devices, sources);\n\n    /* energy harvester */\n    BasicEnergyHarvesterHelper basicHarvesterHelper;\n    // configure energy harvester\n    basicHarvesterHelper.Set(\"PeriodicHarvestedPowerUpdateInterval\",\n                             TimeValue(Seconds(harvestingUpdateInterval)));\n    basicHarvesterHelper.Set(\"HarvestablePower\",\n                             StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=0.1]\"));\n    // install harvester on all energy sources\n    EnergyHarvesterContainer harvesters = basicHarvesterHelper.Install(sources);\n    /***************************************************************************/\n\n    /** Internet stack **/\n    InternetStackHelper internet;\n    internet.Install(networkNodes);\n\n    Ipv4AddressHelper ipv4;\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(devices);\n\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(networkNodes.Get(1), tid); // node 1, Destination\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 80);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    Ptr<Socket> source = Socket::CreateSocket(networkNodes.Get(0), tid); // node 0, Source\n    InetSocketAddress remote = InetSocketAddress(Ipv4Address::GetBroadcast(), 80);\n    source->SetAllowBroadcast(true);\n    source->Connect(remote);\n\n    /** connect trace sources **/\n    /***************************************************************************/\n    // all traces are connected to node 1 (Destination)\n    // energy source\n    Ptr<BasicEnergySource> basicSourcePtr = DynamicCast<BasicEnergySource>(sources.Get(1));\n    basicSourcePtr->TraceConnectWithoutContext(\"RemainingEnergy\", MakeCallback(&RemainingEnergy));\n    // device energy model\n    Ptr<DeviceEnergyModel> basicRadioModelPtr =\n        basicSourcePtr->FindDeviceEnergyModels(\"ns3::WifiRadioEnergyModel\").Get(0);\n    NS_ASSERT(basicRadioModelPtr);\n    basicRadioModelPtr->TraceConnectWithoutContext(\"TotalEnergyConsumption\",\n                                                   MakeCallback(&TotalEnergy));\n    // energy harvester\n    Ptr<BasicEnergyHarvester> basicHarvesterPtr =\n        DynamicCast<BasicEnergyHarvester>(harvesters.Get(1));\n    basicHarvesterPtr->TraceConnectWithoutContext(\"HarvestedPower\", MakeCallback(&HarvestedPower));\n    basicHarvesterPtr->TraceConnectWithoutContext(\"TotalEnergyHarvested\",\n                                                  MakeCallback(&TotalEnergyHarvested));\n    /***************************************************************************/\n\n    /** simulation setup **/\n    // start traffic\n    Simulator::Schedule(Seconds(startTime),\n                        &GenerateTraffic,\n                        source,\n                        PacketSize,\n                        networkNodes.Get(0),\n                        numPackets,\n                        interPacketInterval);\n\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n\n    for (auto iter = deviceModels.Begin(); iter != deviceModels.End(); iter++)\n    {\n        double energyConsumed = (*iter)->GetTotalEnergyConsumption();\n        NS_LOG_UNCOND(\"End of simulation (\"\n                      << Simulator::Now().GetSeconds()\n                      << \"s) Total energy consumed by radio = \" << energyConsumed << \"J\");\n        NS_ASSERT(energyConsumed <= 1.0);\n    }\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns3 library to simulate a ring topology network. The network should consist of four nodes, where each node is connected to two other nodes, forming a ring. Use the UDP echo client-server application to simulate communication between the nodes. Each node should act as both a client and a server at least once, with only one pair of client-server applications running at a time. The clients should send a maximum of 4 packets with a defined transmission interval, and all packets should be successfully received by the respective server. Set the network address to 192.9.39.0/24, and use point-to-point links with a 5Mbps data rate and 2ms delay for the connections. Include necessary logging and NetAnim visualization for the simulation"}, {"role": "assistant", "content": "#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/netanim-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TREE_TOPOLOGY_EXAMPLE\");\n\nint main(int argc, char* argv[]) {\n    // Parse command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    // Set time resolution and enable logging for client-server applications\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create a node container with 4 nodes, representing a simple network\n    NodeContainer tree;\n    tree.Create(4);\n\n    // Define point-to-point link characteristics (5 Mbps data rate, 2 ms delay)\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create NetDevice containers to store the devices for each link\n    NetDeviceContainer device1, device2, device3;\n\n    // Install the point-to-point links between nodes (representing the tree structure)\n    device1.Add(pointToPoint.Install(tree.Get(0), tree.Get(1))); // Link between node 0 and node 1\n    device2.Add(pointToPoint.Install(tree.Get(0), tree.Get(2))); // Link between node 0 and node 2\n    device3.Add(pointToPoint.Install(tree.Get(1), tree.Get(3))); // Link between node 1 and node 3\n\n    // Install the internet stack on the nodes\n    InternetStackHelper stack;\n    stack.Install(tree);\n\n    // Set up IP address helpers for each interface\n    Ipv4AddressHelper address1, address2, address3;\n    address1.SetBase(\"192.9.39.0\", \"255.255.255.252\");\n    address2.SetBase(\"192.9.39.4\", \"255.255.255.252\");\n    address3.SetBase(\"192.9.39.8\", \"255.255.255.252\");\n\n    // Create interface containers and assign IP addresses to each link\n    Ipv4InterfaceContainer interface1, interface2, interface3;\n    interface1 = address1.Assign(device1);\n    interface2 = address2.Assign(device2);\n    interface3 = address3.Assign(device3);\n\n    // Setup UDP echo server on node 0\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps01;\n    serverApps01 = echoServer.Install(tree.Get(0)); // Install on node 0\n    serverApps01.Start(Seconds(1.0));\n    serverApps01.Stop(Seconds(10.0));\n\n    // Setup UDP echo client on node 1 to communicate with server on node 0\n    UdpEchoClientHelper echoClient01(interface1.GetAddress(0), 9); // Use address of node 0 as the server\n    echoClient01.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient01.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient01.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp01 = echoClient01.Install(tree.Get(1)); // Install client on node 1\n    clientApp01.Start(Seconds(2.0));\n    clientApp01.Stop(Seconds(10.0));\n\n    // Repeat the same for other client-server pairs\n\n    // Server on node 1 and client on node 0\n    ApplicationContainer serverApps10 = echoServer.Install(tree.Get(1)); // Server on node 1\n    serverApps10.Start(Seconds(11.0));\n    serverApps10.Stop(Seconds(20.0));\n\n    UdpEchoClientHelper echoClient10(interface1.GetAddress(1), 9); // Use address of node 1 as the server\n    echoClient10.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient10.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient10.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp10 = echoClient10.Install(tree.Get(0)); // Install client on node 0\n    clientApp10.Start(Seconds(12.0));\n    clientApp10.Stop(Seconds(20.0));\n\n    // Server on node 0 and client on node 2\n    ApplicationContainer serverApps02 = echoServer.Install(tree.Get(0)); // Server on node 0\n    serverApps02.Start(Seconds(21.0));\n    serverApps02.Stop(Seconds(30.0));\n\n    UdpEchoClientHelper echoClient02(interface2.GetAddress(0), 9); // Use address of node 0 as the server\n    echoClient02.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient02.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient02.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp02 = echoClient02.Install(tree.Get(2)); // Install client on node 2\n    clientApp02.Start(Seconds(22.0));\n    clientApp02.Stop(Seconds(30.0));\n\n    // Server on node 2 and client on node 0\n    ApplicationContainer serverApps20 = echoServer.Install(tree.Get(2)); // Server on node 2\n    serverApps20.Start(Seconds(31.0));\n    serverApps20.Stop(Seconds(40.0));\n\n    UdpEchoClientHelper echoClient20(interface2.GetAddress(1), 9); // Use address of node 2 as the server\n    echoClient20.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient20.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient20.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp20 = echoClient20.Install(tree.Get(0)); // Install client on node 0\n    clientApp20.Start(Seconds(32.0));\n    clientApp20.Stop(Seconds(40.0));\n\n    // Server on node 1 and client on node 3\n    ApplicationContainer serverApps13 = echoServer.Install(tree.Get(1)); // Server on node 1\n    serverApps13.Start(Seconds(41.0));\n    serverApps13.Stop(Seconds(50.0));\n\n    UdpEchoClientHelper echoClient13(interface3.GetAddress(0), 9); // Use address of node 1 as the server\n    echoClient13.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient13.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient13.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp13 = echoClient13.Install(tree.Get(3)); // Install client on node 3\n    clientApp13.Start(Seconds(42.0));\n    clientApp13.Stop(Seconds(50.0));\n\n    // Server on node 3 and client on node 1\n    ApplicationContainer serverApps31 = echoServer.Install(tree.Get(3)); // Server on node 3\n    serverApps31.Start(Seconds(51.0));\n    serverApps31.Stop(Seconds(60.0));\n\n    UdpEchoClientHelper echoClient31(interface3.GetAddress(1), 9); // Use address of node 3 as the server\n    echoClient31.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient31.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient31.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp31 = echoClient31.Install(tree.Get(1)); // Install client on node 1\n    clientApp31.Start(Seconds(52.0));\n    clientApp31.Stop(Seconds(60.0));\n\n    // Enable animation output to view the topology\n    AnimationInterface anim(\"Tree_Topology.xml\");\n\n    // Run the simulation and destroy after completion\n    Simulator::Run();\n    Simulator::Destroy();\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ script for an NS-3 network simulation where the topology consists of four nodes: n0, n1, n2, and n3. Nodes n0 and n1 are connected to n2 with point-to-point links (5 Mbps, 2 ms delay), and n3 is connected to n2 with a point-to-point link (1.5 Mbps, 10 ms delay). There are two CBR/UDP flows: one from n0 to n3 and another from n3 to n1. Additionally, an FTP/TCP flow runs from n0 to n3, starting at 1.2 seconds and stopping at 1.35 seconds. The UDP packet size is 210 bytes, with a transmission interval of 0.00375 seconds, resulting in a data rate of 448 Kbps. Implement DropTail queues, and trace both queue behaviors and packet receptions to the file 'simple-error-model.tr'. Add error models: a rate error model with a 0.001 packet error rate and a burst error model with a 0.01 error rate, along with a list error model that drops packets with UIDs 11 and 17"}, {"role": "assistant", "content": "// Network topology\n//\n//  n0\n//     \\ 5 Mb/s, 2ms\n//      \\          1.5Mb/s, 10ms\n//       n2 -------------------------n3\n//      /\n//     / 5 Mb/s, 2ms\n//   n1\n//\n// - all links are point-to-point links with indicated one-way BW/delay\n// - CBR/UDP flows from n0 to n3, and from n3 to n1\n// - FTP/TCP flow from n0 to n3, starting at time 1.2 to time 1.35 sec.\n// - UDP packet size of 210 bytes, with per-packet interval 0.00375 sec.\n//   (i.e., DataRate of 448,000 bps)\n// - DropTail queues\n// - Tracing of queues and packet receptions to file\n//   \"simple-error-model.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleErrorModelExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Users may find it convenient to turn on explicit debugging\n    // for selected modules; the below lines suggest how to do this\n#if 0\n  LogComponentEnable (\"SimplePointToPointExample\", LOG_LEVEL_INFO);\n#endif\n\n    // Set a few attributes\n    Config::SetDefault(\"ns3::RateErrorModel::ErrorRate\", DoubleValue(0.001));\n    Config::SetDefault(\"ns3::RateErrorModel::ErrorUnit\", StringValue(\"ERROR_UNIT_PACKET\"));\n\n    Config::SetDefault(\"ns3::BurstErrorModel::ErrorRate\", DoubleValue(0.01));\n    Config::SetDefault(\"ns3::BurstErrorModel::BurstSize\",\n                       StringValue(\"ns3::UniformRandomVariable[Min=1|Max=3]\"));\n\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", UintegerValue(210));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", DataRateValue(DataRate(\"448kb/s\")));\n\n    std::string errorModelType = \"ns3::RateErrorModel\";\n\n    // Allow the user to override any of the defaults and the above\n    // Bind()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"errorModelType\", \"TypeId of the error model to use\", errorModelType);\n    cmd.Parse(argc, argv);\n\n    // Here, we will explicitly create four nodes.  In more sophisticated\n    // topologies, we could configure a node factory.\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer c;\n    c.Create(4);\n    NodeContainer n0n2 = NodeContainer(c.Get(0), c.Get(2));\n    NodeContainer n1n2 = NodeContainer(c.Get(1), c.Get(2));\n    NodeContainer n3n2 = NodeContainer(c.Get(3), c.Get(2));\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // We create the channels first without any IP addressing information\n    NS_LOG_INFO(\"Create channels.\");\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    p2p.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    NetDeviceContainer d0d2 = p2p.Install(n0n2);\n\n    NetDeviceContainer d1d2 = p2p.Install(n1n2);\n\n    p2p.SetDeviceAttribute(\"DataRate\", DataRateValue(DataRate(1500000)));\n    p2p.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(10)));\n    NetDeviceContainer d3d2 = p2p.Install(n3n2);\n\n    // Later, we add IP addresses.\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(d0d2);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1i2 = ipv4.Assign(d1d2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i3i2 = ipv4.Assign(d3d2);\n\n    NS_LOG_INFO(\"Use global routing.\");\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    NS_LOG_INFO(\"Create Applications.\");\n    uint16_t port = 9; // Discard port (RFC 863)\n\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(i3i2.GetAddress(1), port)));\n    onoff.SetConstantRate(DataRate(\"448kb/s\"));\n    ApplicationContainer apps = onoff.Install(c.Get(0));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create an optional packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(c.Get(2));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a similar flow from n3 to n1, starting at time 1.1 seconds\n    onoff.SetAttribute(\"Remote\", AddressValue(InetSocketAddress(i1i2.GetAddress(0), port)));\n    apps = onoff.Install(c.Get(3));\n    apps.Start(Seconds(1.1));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    sink.SetAttribute(\"Local\", AddressValue(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(c.Get(1));\n    apps.Start(Seconds(1.1));\n    apps.Stop(Seconds(10.0));\n\n    //\n    // Error model\n    //\n    // Create an ErrorModel based on the implementation (constructor)\n    // specified by the default TypeId\n\n    ObjectFactory factory;\n    factory.SetTypeId(errorModelType);\n    Ptr<ErrorModel> em = factory.Create<ErrorModel>();\n    d3d2.Get(0)->SetAttribute(\"ReceiveErrorModel\", PointerValue(em));\n\n    // Now, let's use the ListErrorModel and explicitly force a loss\n    // of the packets with pkt-uids = 11 and 17 on node 2, device 0\n    std::list<uint64_t> sampleList;\n    sampleList.push_back(11);\n    sampleList.push_back(17);\n    // This time, we'll explicitly create the error model we want\n    Ptr<ListErrorModel> pem = CreateObject<ListErrorModel>();\n    pem->SetList(sampleList);\n    d0d2.Get(1)->SetAttribute(\"ReceiveErrorModel\", PointerValue(pem));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"simple-error-model.tr\"));\n    p2p.EnablePcapAll(\"simple-error-model\");\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a complete NS-3 simulation program for a multi-interface host with static routing. The network should include a source node, a destination node, and two routers, with two routes connecting the source to the destination through the routers. Configure the routes with different metrics to influence traffic routing. Ensure that the program sends UDP packets from the source to the destination, dynamically binding the socket to different interfaces on the source node. Additionally, implement callback functions to handle packet reception at both the source and destination, and log details of each received packet."}, {"role": "assistant", "content": "/* Test program for multi-interface host, static routing\n\n         Destination host (10.20.1.2)\n                 |\n                 | 10.20.1.0/24\n              DSTRTR\n  10.10.1.0/24 /   \\  10.10.2.0/24\n              / \\\n           Rtr1    Rtr2\n 10.1.1.0/24 |      | 10.1.2.0/24\n             |      /\n              \\    /\n             Source\n*/\n\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SocketBoundRoutingExample\");\n\nvoid SendStuff(Ptr<Socket> sock, Ipv4Address dstaddr, uint16_t port);\nvoid BindSock(Ptr<Socket> sock, Ptr<NetDevice> netdev);\nvoid srcSocketRecv(Ptr<Socket> socket);\nvoid dstSocketRecv(Ptr<Socket> socket);\n\nint\nmain(int argc, char* argv[])\n{\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Ptr<Node> nSrc = CreateObject<Node>();\n    Ptr<Node> nDst = CreateObject<Node>();\n    Ptr<Node> nRtr1 = CreateObject<Node>();\n    Ptr<Node> nRtr2 = CreateObject<Node>();\n    Ptr<Node> nDstRtr = CreateObject<Node>();\n\n    NodeContainer c = NodeContainer(nSrc, nDst, nRtr1, nRtr2, nDstRtr);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // Point-to-point links\n    NodeContainer nSrcnRtr1 = NodeContainer(nSrc, nRtr1);\n    NodeContainer nSrcnRtr2 = NodeContainer(nSrc, nRtr2);\n    NodeContainer nRtr1nDstRtr = NodeContainer(nRtr1, nDstRtr);\n    NodeContainer nRtr2nDstRtr = NodeContainer(nRtr2, nDstRtr);\n    NodeContainer nDstRtrnDst = NodeContainer(nDstRtr, nDst);\n\n    // We create the channels first without any IP addressing information\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer dSrcdRtr1 = p2p.Install(nSrcnRtr1);\n    NetDeviceContainer dSrcdRtr2 = p2p.Install(nSrcnRtr2);\n    NetDeviceContainer dRtr1dDstRtr = p2p.Install(nRtr1nDstRtr);\n    NetDeviceContainer dRtr2dDstRtr = p2p.Install(nRtr2nDstRtr);\n    NetDeviceContainer dDstRtrdDst = p2p.Install(nDstRtrnDst);\n\n    Ptr<NetDevice> SrcToRtr1 = dSrcdRtr1.Get(0);\n    Ptr<NetDevice> SrcToRtr2 = dSrcdRtr2.Get(0);\n\n    // Later, we add IP addresses.\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iSrciRtr1 = ipv4.Assign(dSrcdRtr1);\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iSrciRtr2 = ipv4.Assign(dSrcdRtr2);\n    ipv4.SetBase(\"10.10.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iRtr1iDstRtr = ipv4.Assign(dRtr1dDstRtr);\n    ipv4.SetBase(\"10.10.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iRtr2iDstRtr = ipv4.Assign(dRtr2dDstRtr);\n    ipv4.SetBase(\"10.20.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iDstRtrDst = ipv4.Assign(dDstRtrdDst);\n\n    Ptr<Ipv4> ipv4Src = nSrc->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4Rtr1 = nRtr1->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4Rtr2 = nRtr2->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4DstRtr = nDstRtr->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4Dst = nDst->GetObject<Ipv4>();\n\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> staticRoutingSrc = ipv4RoutingHelper.GetStaticRouting(ipv4Src);\n    Ptr<Ipv4StaticRouting> staticRoutingRtr1 = ipv4RoutingHelper.GetStaticRouting(ipv4Rtr1);\n    Ptr<Ipv4StaticRouting> staticRoutingRtr2 = ipv4RoutingHelper.GetStaticRouting(ipv4Rtr2);\n    Ptr<Ipv4StaticRouting> staticRoutingDstRtr = ipv4RoutingHelper.GetStaticRouting(ipv4DstRtr);\n    Ptr<Ipv4StaticRouting> staticRoutingDst = ipv4RoutingHelper.GetStaticRouting(ipv4Dst);\n\n    // Create static routes from Src to Dst\n    staticRoutingRtr1->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.10.1.2\"), 2);\n    staticRoutingRtr2->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.10.2.2\"), 2);\n\n    // Two routes to same destination - setting separate metrics.\n    // You can switch these to see how traffic gets diverted via different routes\n    staticRoutingSrc->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.1.1.2\"), 1, 5);\n    staticRoutingSrc->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.1.2.2\"), 2, 10);\n\n    // Creating static routes from DST to Source pointing to Rtr1 VIA Rtr2(!)\n    staticRoutingDst->AddHostRouteTo(Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.20.1.1\"), 1);\n    staticRoutingDstRtr->AddHostRouteTo(Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.10.2.1\"), 2);\n    staticRoutingRtr2->AddHostRouteTo(Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.1.2.1\"), 1);\n\n    // There are no apps that can utilize the Socket Option so doing the work directly..\n    // Taken from tcp-large-transfer example\n\n    Ptr<Socket> srcSocket =\n        Socket::CreateSocket(nSrc, TypeId::LookupByName(\"ns3::UdpSocketFactory\"));\n    srcSocket->Bind();\n    srcSocket->SetRecvCallback(MakeCallback(&srcSocketRecv));\n\n    Ptr<Socket> dstSocket =\n        Socket::CreateSocket(nDst, TypeId::LookupByName(\"ns3::UdpSocketFactory\"));\n    uint16_t dstport = 12345;\n    Ipv4Address dstaddr(\"10.20.1.2\");\n    InetSocketAddress dst = InetSocketAddress(dstaddr, dstport);\n    dstSocket->Bind(dst);\n    dstSocket->SetRecvCallback(MakeCallback(&dstSocketRecv));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"socket-bound-static-routing.tr\"));\n    p2p.EnablePcapAll(\"socket-bound-static-routing\");\n\n    LogComponentEnableAll(LOG_PREFIX_TIME);\n    LogComponentEnable(\"SocketBoundRoutingExample\", LOG_LEVEL_INFO);\n\n    // First packet as normal (goes via Rtr1)\n    Simulator::Schedule(Seconds(0.1), &SendStuff, srcSocket, dstaddr, dstport);\n    // Second via Rtr1 explicitly\n    Simulator::Schedule(Seconds(1.0), &BindSock, srcSocket, SrcToRtr1);\n    Simulator::Schedule(Seconds(1.1), &SendStuff, srcSocket, dstaddr, dstport);\n    // Third via Rtr2 explicitly\n    Simulator::Schedule(Seconds(2.0), &BindSock, srcSocket, SrcToRtr2);\n    Simulator::Schedule(Seconds(2.1), &SendStuff, srcSocket, dstaddr, dstport);\n    // Fourth again as normal (goes via Rtr1)\n    Simulator::Schedule(Seconds(3.0), &BindSock, srcSocket, Ptr<NetDevice>(nullptr));\n    Simulator::Schedule(Seconds(3.1), &SendStuff, srcSocket, dstaddr, dstport);\n    // If you uncomment what's below, it results in ASSERT failing since you can't\n    // bind to a socket not existing on a node\n    // Simulator::Schedule(Seconds(4.0),&BindSock, srcSocket, dDstRtrdDst.Get(0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}\n\nvoid\nSendStuff(Ptr<Socket> sock, Ipv4Address dstaddr, uint16_t port)\n{\n    Ptr<Packet> p = Create<Packet>();\n    p->AddPaddingAtEnd(100);\n    sock->SendTo(p, 0, InetSocketAddress(dstaddr, port));\n}\n\nvoid\nBindSock(Ptr<Socket> sock, Ptr<NetDevice> netdev)\n{\n    sock->BindToNetDevice(netdev);\n}\n\nvoid\nsrcSocketRecv(Ptr<Socket> socket)\n{\n    Address from;\n    Ptr<Packet> packet = socket->RecvFrom(from);\n    packet->RemoveAllPacketTags();\n    packet->RemoveAllByteTags();\n    NS_LOG_INFO(\"Source Received \" << packet->GetSize() << \" bytes from \"\n                                   << InetSocketAddress::ConvertFrom(from).GetIpv4());\n    if (socket->GetBoundNetDevice())\n    {\n        NS_LOG_INFO(\"Socket was bound\");\n    }\n    else\n    {\n        NS_LOG_INFO(\"Socket was not bound\");\n    }\n}\n\nvoid\ndstSocketRecv(Ptr<Socket> socket)\n{\n    Address from;\n    Ptr<Packet> packet = socket->RecvFrom(from);\n    packet->RemoveAllPacketTags();\n    packet->RemoveAllByteTags();\n    InetSocketAddress address = InetSocketAddress::ConvertFrom(from);\n    NS_LOG_INFO(\"Destination Received \" << packet->GetSize() << \" bytes from \"\n                                        << address.GetIpv4());\n    NS_LOG_INFO(\"Triggering packet back to source node's interface 1\");\n    SendStuff(socket, Ipv4Address(\"10.1.1.1\"), address.GetPort());\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library to simulate a multi-interface host with static routing. The network topology should include a source node connected to two routers (Rtr1 and Rtr2) through point-to-point links, and both routers connected to a destination router, which is further connected to a destination node. Assign unique subnets for each link, and use static routing to control the path traffic takes through the network. The simulation should use TCP sockets to send traffic from the source to the destination, specifying different paths explicitly for each transmission."}, {"role": "assistant", "content": "/* Test program for multi-interface host, static routing\n\n         Destination host (10.20.1.2)\n                 |\n                 | 10.20.1.0/24\n              DSTRTR\n  10.10.1.0/24 /   \\  10.10.2.0/24\n              / \\\n           Rtr1    Rtr2\n 10.1.1.0/24 |      | 10.1.2.0/24\n             |      /\n              \\    /\n             Source\n*/\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SocketBoundTcpRoutingExample\");\n\nstatic const uint32_t totalTxBytes = 20000;\nstatic uint32_t currentTxBytes = 0;\nstatic const uint32_t writeSize = 1040;\nuint8_t data[writeSize];\n\nvoid StartFlow(Ptr<Socket>, Ipv4Address, uint16_t);\nvoid WriteUntilBufferFull(Ptr<Socket>, uint32_t);\n\nvoid SendStuff(Ptr<Socket> sock, Ipv4Address dstaddr, uint16_t port);\nvoid BindSock(Ptr<Socket> sock, Ptr<NetDevice> netdev);\nvoid srcSocketRecv(Ptr<Socket> socket);\nvoid dstSocketRecv(Ptr<Socket> socket);\n\nint\nmain(int argc, char* argv[])\n{\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Ptr<Node> nSrc = CreateObject<Node>();\n    Ptr<Node> nDst = CreateObject<Node>();\n    Ptr<Node> nRtr1 = CreateObject<Node>();\n    Ptr<Node> nRtr2 = CreateObject<Node>();\n    Ptr<Node> nDstRtr = CreateObject<Node>();\n\n    NodeContainer c = NodeContainer(nSrc, nDst, nRtr1, nRtr2, nDstRtr);\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // Point-to-point links\n    NodeContainer nSrcnRtr1 = NodeContainer(nSrc, nRtr1);\n    NodeContainer nSrcnRtr2 = NodeContainer(nSrc, nRtr2);\n    NodeContainer nRtr1nDstRtr = NodeContainer(nRtr1, nDstRtr);\n    NodeContainer nRtr2nDstRtr = NodeContainer(nRtr2, nDstRtr);\n    NodeContainer nDstRtrnDst = NodeContainer(nDstRtr, nDst);\n\n    // We create the channels first without any IP addressing information\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer dSrcdRtr1 = p2p.Install(nSrcnRtr1);\n    NetDeviceContainer dSrcdRtr2 = p2p.Install(nSrcnRtr2);\n    NetDeviceContainer dRtr1dDstRtr = p2p.Install(nRtr1nDstRtr);\n    NetDeviceContainer dRtr2dDstRtr = p2p.Install(nRtr2nDstRtr);\n    NetDeviceContainer dDstRtrdDst = p2p.Install(nDstRtrnDst);\n\n    Ptr<NetDevice> SrcToRtr1 = dSrcdRtr1.Get(0);\n    Ptr<NetDevice> SrcToRtr2 = dSrcdRtr2.Get(0);\n\n    // Later, we add IP addresses.\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iSrciRtr1 = ipv4.Assign(dSrcdRtr1);\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iSrciRtr2 = ipv4.Assign(dSrcdRtr2);\n    ipv4.SetBase(\"10.10.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iRtr1iDstRtr = ipv4.Assign(dRtr1dDstRtr);\n    ipv4.SetBase(\"10.10.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iRtr2iDstRtr = ipv4.Assign(dRtr2dDstRtr);\n    ipv4.SetBase(\"10.20.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer iDstRtrDst = ipv4.Assign(dDstRtrdDst);\n\n    Ptr<Ipv4> ipv4Src = nSrc->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4Rtr1 = nRtr1->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4Rtr2 = nRtr2->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4DstRtr = nDstRtr->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4Dst = nDst->GetObject<Ipv4>();\n\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> staticRoutingSrc = ipv4RoutingHelper.GetStaticRouting(ipv4Src);\n    Ptr<Ipv4StaticRouting> staticRoutingRtr1 = ipv4RoutingHelper.GetStaticRouting(ipv4Rtr1);\n    Ptr<Ipv4StaticRouting> staticRoutingRtr2 = ipv4RoutingHelper.GetStaticRouting(ipv4Rtr2);\n    Ptr<Ipv4StaticRouting> staticRoutingDstRtr = ipv4RoutingHelper.GetStaticRouting(ipv4DstRtr);\n    Ptr<Ipv4StaticRouting> staticRoutingDst = ipv4RoutingHelper.GetStaticRouting(ipv4Dst);\n\n    // Create static routes from Src to Dst\n    staticRoutingRtr1->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.10.1.2\"), 2);\n    staticRoutingRtr2->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.10.2.2\"), 2);\n\n    // Two routes to same destination - setting separate metrics.\n    // You can switch these to see how traffic gets diverted via different routes\n    staticRoutingSrc->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.1.1.2\"), 1, 5);\n    staticRoutingSrc->AddHostRouteTo(Ipv4Address(\"10.20.1.2\"), Ipv4Address(\"10.1.2.2\"), 2, 10);\n\n    // Creating static routes from DST to Source pointing to Rtr1 VIA Rtr2(!)\n    staticRoutingDst->AddHostRouteTo(Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.20.1.1\"), 1);\n    staticRoutingDstRtr->AddHostRouteTo(Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.10.2.1\"), 2);\n    staticRoutingRtr2->AddHostRouteTo(Ipv4Address(\"10.1.1.1\"), Ipv4Address(\"10.1.2.1\"), 1);\n\n    staticRoutingDst->AddHostRouteTo(Ipv4Address(\"10.1.2.1\"), Ipv4Address(\"10.20.1.1\"), 1);\n    staticRoutingDstRtr->AddHostRouteTo(Ipv4Address(\"10.1.2.1\"), Ipv4Address(\"10.10.2.1\"), 2);\n    staticRoutingRtr2->AddHostRouteTo(Ipv4Address(\"10.1.2.1\"), Ipv4Address(\"10.1.2.1\"), 1);\n\n    // There are no apps that can utilize the Socket Option so doing the work directly..\n    // Taken from tcp-large-transfer example\n\n    Ptr<Socket> srcSocket1 =\n        Socket::CreateSocket(nSrc, TypeId::LookupByName(\"ns3::TcpSocketFactory\"));\n    Ptr<Socket> srcSocket2 =\n        Socket::CreateSocket(nSrc, TypeId::LookupByName(\"ns3::TcpSocketFactory\"));\n    Ptr<Socket> srcSocket3 =\n        Socket::CreateSocket(nSrc, TypeId::LookupByName(\"ns3::TcpSocketFactory\"));\n    Ptr<Socket> srcSocket4 =\n        Socket::CreateSocket(nSrc, TypeId::LookupByName(\"ns3::TcpSocketFactory\"));\n\n    uint16_t dstport = 12345;\n    Ipv4Address dstaddr(\"10.20.1.2\");\n\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(Ipv4Address::GetAny(), dstport));\n    ApplicationContainer apps = sink.Install(nDst);\n    apps.Start(Seconds(0.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"socket-bound-tcp-static-routing.tr\"));\n    p2p.EnablePcapAll(\"socket-bound-tcp-static-routing\");\n\n    LogComponentEnableAll(LOG_PREFIX_TIME);\n    LogComponentEnable(\"SocketBoundTcpRoutingExample\", LOG_LEVEL_INFO);\n\n    // First packet as normal (goes via Rtr1)\n    Simulator::Schedule(Seconds(0.1), &StartFlow, srcSocket1, dstaddr, dstport);\n    // Second via Rtr1 explicitly\n    Simulator::Schedule(Seconds(1.0), &BindSock, srcSocket2, SrcToRtr1);\n    Simulator::Schedule(Seconds(1.1), &StartFlow, srcSocket2, dstaddr, dstport);\n    // Third via Rtr2 explicitly\n    Simulator::Schedule(Seconds(2.0), &BindSock, srcSocket3, SrcToRtr2);\n    Simulator::Schedule(Seconds(2.1), &StartFlow, srcSocket3, dstaddr, dstport);\n    // Fourth again as normal (goes via Rtr1)\n    Simulator::Schedule(Seconds(3.0), &BindSock, srcSocket4, Ptr<NetDevice>(nullptr));\n    Simulator::Schedule(Seconds(3.1), &StartFlow, srcSocket4, dstaddr, dstport);\n    // If you uncomment what's below, it results in ASSERT failing since you can't\n    // bind to a socket not existing on a node\n    // Simulator::Schedule(Seconds(4.0),&BindSock, srcSocket, dDstRtrdDst.Get(0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}\n\nvoid\nBindSock(Ptr<Socket> sock, Ptr<NetDevice> netdev)\n{\n    sock->BindToNetDevice(netdev);\n}\n\nvoid\nStartFlow(Ptr<Socket> localSocket, Ipv4Address servAddress, uint16_t servPort)\n{\n    NS_LOG_INFO(\"Starting flow at time \" << Simulator::Now().GetSeconds());\n    currentTxBytes = 0;\n    localSocket->Bind();\n    localSocket->Connect(InetSocketAddress(servAddress, servPort)); // connect\n\n    // tell the tcp implementation to call WriteUntilBufferFull again\n    // if we blocked and new tx buffer space becomes available\n    localSocket->SetSendCallback(MakeCallback(&WriteUntilBufferFull));\n    WriteUntilBufferFull(localSocket, localSocket->GetTxAvailable());\n}\n\nvoid\nWriteUntilBufferFull(Ptr<Socket> localSocket, uint32_t txSpace)\n{\n    while (currentTxBytes < totalTxBytes && localSocket->GetTxAvailable() > 0)\n    {\n        uint32_t left = totalTxBytes - currentTxBytes;\n        uint32_t dataOffset = currentTxBytes % writeSize;\n        uint32_t toWrite = writeSize - dataOffset;\n        toWrite = std::min(toWrite, left);\n        toWrite = std::min(toWrite, localSocket->GetTxAvailable());\n        int amountSent = localSocket->Send(&data[dataOffset], toWrite, 0);\n        if (amountSent < 0)\n        {\n            // we will be called again when new tx space becomes available.\n            return;\n        }\n        currentTxBytes += amountSent;\n    }\n    localSocket->Close();\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library that simulates a basic LAN topology with two nodes (n0 and n1) connected via a CSMA link. The program should establish a UDP communication between the two nodes, with node n0 sending packets to node n1. The sender should have options to set IP_TOS and IP_TTL values for the packets, while the receiver should log received packets along with their TOS and TTL values. Include command-line parameters to configure packet size, number of packets, packet interval, and socket options such as TOS, TTL, RECVTOS, and RECVTTL."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0              n1\n//       |               |\n//       =================\n//              LAN\n//\n// - UDP flows from n0 to n1\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SocketOptionsIpv4\");\n\nvoid\nReceivePacket(Ptr<Socket> socket)\n{\n    NS_LOG_INFO(\"Received one packet!\");\n    Ptr<Packet> packet = socket->Recv();\n    SocketIpTosTag tosTag;\n    if (packet->RemovePacketTag(tosTag))\n    {\n        NS_LOG_INFO(\" TOS = \" << (uint32_t)tosTag.GetTos());\n    }\n    SocketIpTtlTag ttlTag;\n    if (packet->RemovePacketTag(ttlTag))\n    {\n        NS_LOG_INFO(\" TTL = \" << (uint32_t)ttlTag.GetTtl());\n    }\n}\n\nstatic void\nSendPacket(Ptr<Socket> socket, uint32_t pktSize, uint32_t pktCount, Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval, &SendPacket, socket, pktSize, pktCount - 1, pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    //\n    // Allow the user to override any of the defaults and the above Bind() at\n    // run-time, via command-line arguments\n    //\n    uint32_t packetSize = 1024;\n    uint32_t packetCount = 10;\n    double packetInterval = 1.0;\n\n    // Socket options for IPv4, currently TOS, TTL, RECVTOS, and RECVTTL\n    uint32_t ipTos = 0;\n    bool ipRecvTos = true;\n    uint32_t ipTtl = 0;\n    bool ipRecvTtl = true;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"PacketSize\", \"Packet size in bytes\", packetSize);\n    cmd.AddValue(\"PacketCount\", \"Number of packets to send\", packetCount);\n    cmd.AddValue(\"Interval\", \"Interval between packets\", packetInterval);\n    cmd.AddValue(\"IP_TOS\", \"IP_TOS\", ipTos);\n    cmd.AddValue(\"IP_RECVTOS\", \"IP_RECVTOS\", ipRecvTos);\n    cmd.AddValue(\"IP_TTL\", \"IP_TTL\", ipTtl);\n    cmd.AddValue(\"IP_RECVTTL\", \"IP_RECVTTL\", ipRecvTtl);\n    cmd.Parse(argc, argv);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer n;\n    n.Create(2);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    Address serverAddress;\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(d);\n    serverAddress = Address(i.GetAddress(1));\n\n    NS_LOG_INFO(\"Create sockets.\");\n    // Receiver socket on n1\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(n.Get(1), tid);\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), 4477);\n    recvSink->SetIpRecvTos(ipRecvTos);\n    recvSink->SetIpRecvTtl(ipRecvTtl);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Sender socket on n0\n    Ptr<Socket> source = Socket::CreateSocket(n.Get(0), tid);\n    InetSocketAddress remote = InetSocketAddress(i.GetAddress(1), 4477);\n\n    // Set socket options, it is also possible to set the options after the socket has been\n    // created/connected.\n    if (ipTos > 0)\n    {\n        source->SetIpTos(ipTos);\n    }\n\n    if (ipTtl > 0)\n    {\n        source->SetIpTtl(ipTtl);\n    }\n    source->Connect(remote);\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"socket-options-ipv4.tr\"));\n    csma.EnablePcapAll(\"socket-options-ipv4\", false);\n\n    // Schedule SendPacket\n    Time interPacketInterval = Seconds(packetInterval);\n    Simulator::ScheduleWithContext(source->GetNode()->GetId(),\n                                   Seconds(1.0),\n                                   &SendPacket,\n                                   source,\n                                   packetSize,\n                                   packetCount,\n                                   interPacketInterval);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library to simulate a simple LAN topology with two nodes (n0 and n1) connected via a CSMA link, where n0 sends UDP packets to n1 using IPv6. The receiver (n1) should log incoming packets, including the TCLASS and HOPLIMIT values. The sender (n0) should allow setting socket options for IPv6 TCLASS and HOPLIMIT, and the receiver should be able to process RECVTCLASS and RECVHOPLIMIT options. Include command-line parameters to configure the packet size, number of packets, interval, and IPv6 socket options."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0              n1\n//       |               |\n//       =================\n//              LAN\n//\n// - UDP flows from n0 to n1\n\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/network-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SocketOptionsIpv6\");\n\nvoid\nReceivePacket(Ptr<Socket> socket)\n{\n    NS_LOG_INFO(\"Received one packet!\");\n    Ptr<Packet> packet = socket->Recv();\n    SocketIpv6TclassTag tclassTag;\n    if (packet->RemovePacketTag(tclassTag))\n    {\n        NS_LOG_INFO(\" TCLASS = \" << (uint32_t)tclassTag.GetTclass());\n    }\n    SocketIpv6HopLimitTag hoplimitTag;\n    if (packet->RemovePacketTag(hoplimitTag))\n    {\n        NS_LOG_INFO(\" HOPLIMIT = \" << (uint32_t)hoplimitTag.GetHopLimit());\n    }\n}\n\nstatic void\nSendPacket(Ptr<Socket> socket, uint32_t pktSize, uint32_t pktCount, Time pktInterval)\n{\n    if (pktCount > 0)\n    {\n        socket->Send(Create<Packet>(pktSize));\n        Simulator::Schedule(pktInterval, &SendPacket, socket, pktSize, pktCount - 1, pktInterval);\n    }\n    else\n    {\n        socket->Close();\n    }\n}\n\nint\nmain(int argc, char* argv[])\n{\n    //\n    // Allow the user to override any of the defaults and the above Bind() at\n    // run-time, via command-line arguments\n    //\n    uint32_t packetSize = 1024;\n    uint32_t packetCount = 10;\n    double packetInterval = 1.0;\n\n    // Socket options for IPv6, currently TCLASS, HOPLIMIT, RECVTCLASS, and RECVHOPLIMIT\n    uint32_t ipv6Tclass = 0;\n    bool ipv6RecvTclass = true;\n    uint32_t ipv6Hoplimit = 0;\n    bool ipv6RecvHoplimit = true;\n\n    CommandLine cmd(__FILE__);\n    cmd.AddValue(\"PacketSize\", \"Packet size in bytes\", packetSize);\n    cmd.AddValue(\"PacketCount\", \"Number of packets to send\", packetCount);\n    cmd.AddValue(\"Interval\", \"Interval between packets\", packetInterval);\n    cmd.AddValue(\"IPV6_TCLASS\", \"IPV6_TCLASS\", ipv6Tclass);\n    cmd.AddValue(\"IPV6_RECVTCLASS\", \"IPV6_RECVTCLASS\", ipv6RecvTclass);\n    cmd.AddValue(\"IPV6_HOPLIMIT\", \"IPV6_HOPLIMIT\", ipv6Hoplimit);\n    cmd.AddValue(\"IPV6_RECVHOPLIMIT\", \"IPV6_RECVHOPLIMIT\", ipv6RecvHoplimit);\n    cmd.Parse(argc, argv);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer n;\n    n.Create(2);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    Address serverAddress;\n\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv6AddressHelper ipv6;\n    ipv6.SetBase(\"2001:0000:f00d:cafe::\", Ipv6Prefix(64));\n    Ipv6InterfaceContainer i6 = ipv6.Assign(d);\n    serverAddress = Address(i6.GetAddress(1, 1));\n\n    NS_LOG_INFO(\"Create sockets.\");\n    // Receiver socket on n1\n    TypeId tid = TypeId::LookupByName(\"ns3::UdpSocketFactory\");\n    Ptr<Socket> recvSink = Socket::CreateSocket(n.Get(1), tid);\n    Inet6SocketAddress local = Inet6SocketAddress(Ipv6Address::GetAny(), 4477);\n    recvSink->SetIpv6RecvTclass(ipv6RecvTclass);\n    recvSink->SetIpv6RecvHopLimit(ipv6RecvHoplimit);\n    recvSink->Bind(local);\n    recvSink->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Sender socket on n0\n    Ptr<Socket> source = Socket::CreateSocket(n.Get(0), tid);\n    Inet6SocketAddress remote = Inet6SocketAddress(i6.GetAddress(1, 1), 4477);\n    // Set socket options, it is also possible to set the options after the socket has been\n    // created/connected.\n    if (ipv6Tclass != 0)\n    {\n        source->SetIpv6Tclass(ipv6Tclass);\n    }\n\n    if (ipv6Hoplimit > 0)\n    {\n        source->SetIpv6HopLimit(ipv6Hoplimit);\n    }\n    source->Connect(remote);\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"socket-options-ipv6.tr\"));\n    csma.EnablePcapAll(\"socket-options-ipv6\", false);\n\n    // Schedule SendPacket\n    Time interPacketInterval = Seconds(packetInterval);\n    Simulator::ScheduleWithContext(source->GetNode()->GetId(),\n                                   Seconds(1.0),\n                                   &SendPacket,\n                                   source,\n                                   packetSize,\n                                   packetCount,\n                                   interPacketInterval);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a program in C++ using the ns-3 library that reads an upper triangular adjacency matrix from a file (e.g., `adjacency_matrix.txt`) and node coordinates from a file (e.g., `node_coordinates.txt`). The program should set up a wired network topology with point-to-point (P2P) links according to the adjacency matrix and establish constant bit rate (CBR) traffic flows between nodes. Each node should have a unique traffic flow towards every other node, except itself, resulting in `n*(n-1)` CBR flows, where `n` is the number of nodes. The network topology, CBR traffic, and positions of nodes should be visualized in NetAnim, and simulation outputs should be logged."}, {"role": "assistant", "content": "/*\n * This program reads an upper triangular adjacency matrix (e.g. adjacency_matrix.txt) and\n * node coordinates file (e.g. node_coordinates.txt). The program also set-ups a\n * wired network topology with P2P links according to the adjacency matrix with\n * nx(n-1) CBR traffic flows, in which n is the number of nodes in the adjacency matrix.\n */\n\n// ---------- Header Includes -------------------------------------------------\n#include \"ns3/applications-module.h\"\n#include \"ns3/assert.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/global-route-manager.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/netanim-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cstdlib>\n#include <fstream>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\nusing namespace ns3;\n\n// ---------- Prototypes ------------------------------------------------------\n\nstd::vector<std::vector<bool>> readNxNMatrix(std::string adj_mat_file_name);\nstd::vector<std::vector<double>> readCoordinatesFile(std::string node_coordinates_file_name);\nvoid printCoordinateArray(const char* description, std::vector<std::vector<double>> coord_array);\nvoid printMatrix(const char* description, std::vector<std::vector<bool>> array);\n\nNS_LOG_COMPONENT_DEFINE(\"GenericTopologyCreation\");\n\nint\nmain(int argc, char* argv[])\n{\n    // ---------- Simulation Variables ------------------------------------------\n\n    // Change the variables and file names only in this block!\n\n    double SimTime = 3.00;\n    double SinkStartTime = 1.0001;\n    double SinkStopTime = 2.90001;\n    double AppStartTime = 2.0001;\n    double AppStopTime = 2.80001;\n\n    std::string AppPacketRate(\"40Kbps\");\n    Config::SetDefault(\"ns3::OnOffApplication::PacketSize\", StringValue(\"1000\"));\n    Config::SetDefault(\"ns3::OnOffApplication::DataRate\", StringValue(AppPacketRate));\n    std::string LinkRate(\"10Mbps\");\n    std::string LinkDelay(\"2ms\");\n    //  DropTailQueue::MaxPackets affects the # of dropped packets, default value:100\n    //  Config::SetDefault (\"ns3::DropTailQueue::MaxPackets\", UintegerValue (1000));\n\n    srand((unsigned)time(nullptr)); // generate different seed each time\n\n    std::string tr_name(\"n-node-ppp.tr\");\n    std::string pcap_name(\"n-node-ppp\");\n    std::string flow_name(\"n-node-ppp.xml\");\n    std::string anim_name(\"n-node-ppp.anim.xml\");\n\n    std::string adj_mat_file_name(\"examples/matrix-topology/adjacency_matrix.txt\");\n    std::string node_coordinates_file_name(\"examples/matrix-topology/node_coordinates.txt\");\n\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    // ---------- End of Simulation Variables ----------------------------------\n\n    // ---------- Read Adjacency Matrix ----------------------------------------\n\n    std::vector<std::vector<bool>> Adj_Matrix;\n    Adj_Matrix = readNxNMatrix(adj_mat_file_name);\n\n    // Optionally display 2-dimensional adjacency matrix (Adj_Matrix) array\n    // printMatrix (adj_mat_file_name.c_str (),Adj_Matrix);\n\n    // ---------- End of Read Adjacency Matrix ---------------------------------\n\n    // ---------- Read Node Coordinates File -----------------------------------\n\n    std::vector<std::vector<double>> coord_array;\n    coord_array = readCoordinatesFile(node_coordinates_file_name);\n\n    // Optionally display node coordinates file\n    // printCoordinateArray (node_coordinates_file_name.c_str (),coord_array);\n\n    int n_nodes = coord_array.size();\n    int matrixDimension = Adj_Matrix.size();\n\n    if (matrixDimension != n_nodes)\n    {\n        NS_FATAL_ERROR(\"The number of lines in coordinate file is: \"\n                       << n_nodes << \" not equal to the number of nodes in adjacency matrix size \"\n                       << matrixDimension);\n    }\n\n    // ---------- End of Read Node Coordinates File ----------------------------\n\n    // ---------- Network Setup ------------------------------------------------\n\n    NS_LOG_INFO(\"Create Nodes.\");\n\n    NodeContainer nodes; // Declare nodes objects\n    nodes.Create(n_nodes);\n\n    NS_LOG_INFO(\"Create P2P Link Attributes.\");\n\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(LinkRate));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(LinkDelay));\n\n    NS_LOG_INFO(\"Install Internet Stack to Nodes.\");\n\n    InternetStackHelper internet;\n    internet.Install(NodeContainer::GetGlobal());\n\n    NS_LOG_INFO(\"Assign Addresses to Nodes.\");\n\n    Ipv4AddressHelper ipv4_n;\n    ipv4_n.SetBase(\"10.0.0.0\", \"255.255.255.252\");\n\n    NS_LOG_INFO(\"Create Links Between Nodes.\");\n\n    uint32_t linkCount = 0;\n\n    for (size_t i = 0; i < Adj_Matrix.size(); i++)\n    {\n        for (size_t j = 0; j < Adj_Matrix[i].size(); j++)\n        {\n            if (Adj_Matrix[i][j])\n            {\n                NodeContainer n_links = NodeContainer(nodes.Get(i), nodes.Get(j));\n                NetDeviceContainer n_devs = p2p.Install(n_links);\n                ipv4_n.Assign(n_devs);\n                ipv4_n.NewNetwork();\n                linkCount++;\n                NS_LOG_INFO(\"matrix element [\" << i << \"][\" << j << \"] is 1\");\n            }\n            else\n            {\n                NS_LOG_INFO(\"matrix element [\" << i << \"][\" << j << \"] is 0\");\n            }\n        }\n    }\n    NS_LOG_INFO(\"Number of links in the adjacency matrix is: \" << linkCount);\n    NS_LOG_INFO(\"Number of all nodes is: \" << nodes.GetN());\n\n    NS_LOG_INFO(\"Initialize Global Routing.\");\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // ---------- End of Network Set-up ----------------------------------------\n\n    // ---------- Allocate Node Positions --------------------------------------\n\n    NS_LOG_INFO(\"Allocate Positions to Nodes.\");\n\n    MobilityHelper mobility_n;\n    Ptr<ListPositionAllocator> positionAlloc_n = CreateObject<ListPositionAllocator>();\n\n    for (size_t m = 0; m < coord_array.size(); m++)\n    {\n        positionAlloc_n->Add(Vector(coord_array[m][0], coord_array[m][1], 0));\n        Ptr<Node> n0 = nodes.Get(m);\n        Ptr<ConstantPositionMobilityModel> nLoc = n0->GetObject<ConstantPositionMobilityModel>();\n        if (!nLoc)\n        {\n            nLoc = CreateObject<ConstantPositionMobilityModel>();\n            n0->AggregateObject(nLoc);\n        }\n        // y-coordinates are negated for correct display in NetAnim\n        // NetAnim's (0,0) reference coordinates are located on upper left corner\n        // by negating the y coordinates, we declare the reference (0,0) coordinate\n        // to the bottom left corner\n        Vector nVec(coord_array[m][0], -coord_array[m][1], 0);\n        nLoc->SetPosition(nVec);\n    }\n    mobility_n.SetPositionAllocator(positionAlloc_n);\n    mobility_n.Install(nodes);\n\n    // ---------- End of Allocate Node Positions -------------------------------\n\n    // ---------- Create n*(n-1) CBR Flows -------------------------------------\n\n    NS_LOG_INFO(\"Setup Packet Sinks.\");\n\n    uint16_t port = 9;\n\n    for (int i = 0; i < n_nodes; i++)\n    {\n        PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                              InetSocketAddress(Ipv4Address::GetAny(), port));\n        ApplicationContainer apps_sink =\n            sink.Install(nodes.Get(i)); // sink is installed on all nodes\n        apps_sink.Start(Seconds(SinkStartTime));\n        apps_sink.Stop(Seconds(SinkStopTime));\n    }\n\n    NS_LOG_INFO(\"Setup CBR Traffic Sources.\");\n\n    for (int i = 0; i < n_nodes; i++)\n    {\n        for (int j = 0; j < n_nodes; j++)\n        {\n            if (i != j)\n            {\n                // We needed to generate a random number (rn) to be used to eliminate\n                // the artificial congestion caused by sending the packets at the\n                // same time. This rn is added to AppStartTime to have the sources\n                // start at different time, however they will still send at the same rate.\n\n                Ptr<UniformRandomVariable> x = CreateObject<UniformRandomVariable>();\n                x->SetAttribute(\"Min\", DoubleValue(0));\n                x->SetAttribute(\"Max\", DoubleValue(1));\n                double rn = x->GetValue();\n                Ptr<Node> n = nodes.Get(j);\n                Ptr<Ipv4> ipv4 = n->GetObject<Ipv4>();\n                Ipv4InterfaceAddress ipv4_int_addr = ipv4->GetAddress(1, 0);\n                Ipv4Address ip_addr = ipv4_int_addr.GetLocal();\n                OnOffHelper onoff(\n                    \"ns3::UdpSocketFactory\",\n                    InetSocketAddress(ip_addr, port)); // traffic flows from node[i] to node[j]\n                onoff.SetConstantRate(DataRate(AppPacketRate));\n                ApplicationContainer apps =\n                    onoff.Install(nodes.Get(i)); // traffic sources are installed on all nodes\n                apps.Start(Seconds(AppStartTime + rn));\n                apps.Stop(Seconds(AppStopTime));\n            }\n        }\n    }\n\n    // ---------- End of Create n*(n-1) CBR Flows ------------------------------\n\n    // ---------- Simulation Monitoring ----------------------------------------\n\n    NS_LOG_INFO(\"Configure Tracing.\");\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(tr_name));\n    // p2p.EnablePcapAll(pcap_name);\n\n    // Ptr<FlowMonitor> flowmon;\n    // FlowMonitorHelper flowmonHelper;\n    // flowmon = flowmonHelper.InstallAll();\n\n    // Configure animator with default settings\n\n    AnimationInterface anim(anim_name);\n    NS_LOG_INFO(\"Run Simulation.\");\n\n    Simulator::Stop(Seconds(SimTime));\n    Simulator::Run();\n    // flowmon->SerializeToXmlFile(flow_name, true, true);\n    Simulator::Destroy();\n\n    // ---------- End of Simulation Monitoring ---------------------------------\n\n    return 0;\n}\n\n// ---------- Function Definitions -------------------------------------------\n\nstd::vector<std::vector<bool>>\nreadNxNMatrix(std::string adj_mat_file_name)\n{\n    std::ifstream adj_mat_file;\n    adj_mat_file.open(adj_mat_file_name, std::ios::in);\n    if (adj_mat_file.fail())\n    {\n        NS_FATAL_ERROR(\"File \" << adj_mat_file_name << \" not found\");\n    }\n    std::vector<std::vector<bool>> array;\n    int i = 0;\n    int n_nodes = 0;\n\n    while (!adj_mat_file.eof())\n    {\n        std::string line;\n        getline(adj_mat_file, line);\n        if (line.empty())\n        {\n            NS_LOG_WARN(\"WARNING: Ignoring blank row in the array: \" << i);\n            break;\n        }\n\n        std::istringstream iss(line);\n        bool element;\n        std::vector<bool> row;\n        int j = 0;\n\n        while (iss >> element)\n        {\n            row.push_back(element);\n            j++;\n        }\n\n        if (i == 0)\n        {\n            n_nodes = j;\n        }\n\n        if (j != n_nodes)\n        {\n            NS_LOG_ERROR(\"ERROR: Number of elements in line \"\n                         << i << \": \" << j\n                         << \" not equal to number of elements in line 0: \" << n_nodes);\n            NS_FATAL_ERROR(\"ERROR: The number of rows is not equal to the number of columns! in \"\n                           \"the adjacency matrix\");\n        }\n        else\n        {\n            array.push_back(row);\n        }\n        i++;\n    }\n\n    if (i != n_nodes)\n    {\n        NS_LOG_ERROR(\"There are \" << i << \" rows and \" << n_nodes << \" columns.\");\n        NS_FATAL_ERROR(\"ERROR: The number of rows is not equal to the number of columns! in the \"\n                       \"adjacency matrix\");\n    }\n\n    adj_mat_file.close();\n    return array;\n}\n\nstd::vector<std::vector<double>>\nreadCoordinatesFile(std::string node_coordinates_file_name)\n{\n    std::ifstream node_coordinates_file;\n    node_coordinates_file.open(node_coordinates_file_name, std::ios::in);\n    if (node_coordinates_file.fail())\n    {\n        NS_FATAL_ERROR(\"File \" << node_coordinates_file_name << \" not found\");\n    }\n    std::vector<std::vector<double>> coord_array;\n    int m = 0;\n\n    while (!node_coordinates_file.eof())\n    {\n        std::string line;\n        getline(node_coordinates_file, line);\n\n        if (line.empty())\n        {\n            NS_LOG_WARN(\"WARNING: Ignoring blank row: \" << m);\n            break;\n        }\n\n        std::istringstream iss(line);\n        double coordinate;\n        std::vector<double> row;\n        int n = 0;\n        while (iss >> coordinate)\n        {\n            row.push_back(coordinate);\n            n++;\n        }\n\n        if (n != 2)\n        {\n            NS_LOG_ERROR(\"ERROR: Number of elements at line#\"\n                         << m << \" is \" << n\n                         << \" which is not equal to 2 for node coordinates file\");\n            exit(1);\n        }\n\n        else\n        {\n            coord_array.push_back(row);\n        }\n        m++;\n    }\n    node_coordinates_file.close();\n    return coord_array;\n}\n\nvoid\nprintMatrix(const char* description, std::vector<std::vector<bool>> array)\n{\n    std::cout << \"**** Start \" << description << \"********\" << std::endl;\n    for (size_t m = 0; m < array.size(); m++)\n    {\n        for (size_t n = 0; n < array[m].size(); n++)\n        {\n            std::cout << array[m][n] << ' ';\n        }\n        std::cout << std::endl;\n    }\n    std::cout << \"**** End \" << description << \"********\" << std::endl;\n}\n\nvoid\nprintCoordinateArray(const char* description, std::vector<std::vector<double>> coord_array)\n{\n    std::cout << \"**** Start \" << description << \"********\" << std::endl;\n    for (size_t m = 0; m < coord_array.size(); m++)\n    {\n        for (size_t n = 0; n < coord_array[m].size(); n++)\n        {\n            std::cout << coord_array[m][n] << ' ';\n        }\n        std::cout << std::endl;\n    }\n    std::cout << \"**** End \" << description << \"********\" << std::endl;\n}\n\n// ---------- End of Function Definitions ------------------------------------"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using the ns-3 library to simulate a simple network topology with four nodes connected via a CSMA LAN. The program should establish a UDP echo server on node 1 and a UDP echo client on node 0, which sends datagrams to node 1 and receives responses. Set DropTail queues for the LAN and configure tracing of queue and packet reception events. The simulation should run in real-time mode, log tracing information to a file named \"udp-echo.tr\", and also generate pcap traces."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1   n2   n3\n//       |     |    |    |\n//       =================\n//              LAN\n//\n// - UDP flows from n0 to n1 and back\n// - DropTail queues\n// - Tracing of queues and packet receptions to file \"udp-echo.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\n#include <fstream>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"RealtimeUdpEchoExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    //\n    // Allow the user to override any of the defaults and the above Bind() at\n    // run-time, via command-line arguments\n    //\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    //\n    // But since this is a realtime script, don't allow the user to mess with\n    // that.\n    //\n    GlobalValue::Bind(\"SimulatorImplementationType\", StringValue(\"ns3::RealtimeSimulatorImpl\"));\n\n    //\n    // Explicitly create the nodes required by the topology (shown above).\n    //\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer n;\n    n.Create(4);\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    //\n    // Explicitly create the channels required by the topology (shown above).\n    //\n    NS_LOG_INFO(\"Create channels.\");\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    //\n    // We've got the \"hardware\" in place.  Now we need to add IP addresses.\n    //\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(d);\n\n    NS_LOG_INFO(\"Create Applications.\");\n\n    //\n    // Create a UdpEchoServer application on node one.\n    //\n    uint16_t port = 9; // well-known echo port number\n    UdpEchoServerHelper server(port);\n    ApplicationContainer apps = server.Install(n.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    //\n    // Create a UdpEchoClient application to send UDP datagrams from node zero to\n    // node one.\n    //\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 500;\n    Time interPacketInterval = Seconds(0.01);\n    UdpEchoClientHelper client(i.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n    apps = client.Install(n.Get(0));\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    csma.EnableAsciiAll(ascii.CreateFileStream(\"realtime-udp-echo.tr\"));\n    csma.EnablePcapAll(\"realtime-udp-echo\", false);\n\n    //\n    // Now, do the actual simulation.\n    //\n    Simulator::Stop(Seconds(11.0));\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a C++ program using the ns-3 library to demonstrate the use of the Object Names service with a network topology of four nodes connected by a CSMA LAN. Assign human-readable names to nodes and devices, such as \"client\" and \"server,\" and demonstrate renaming nodes in the name system. Configure attributes of CSMA devices using the Object Names service and mix object names and node attributes in the configuration system. Install a UDP echo server on the named \"server\" node and a UDP echo client on the named \"client\" node, with packet tracing enabled and the use of pcap files."}, {"role": "assistant", "content": "// Network topology\n//\n//       n0    n1   n2   n3\n//       |     |    |    |\n//       =================\n//              LAN\n//\n// This program demonstrates some basic use of the Object names capability\n//\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ObjectNamesExample\");\n\n/// Counter of the received bytes.\nuint32_t bytesReceived = 0;\n\n/**\n * Function called when a packet is received.\n *\n * \\param context The context.\n * \\param packet The received packet.\n */\nvoid\nRxEvent(std::string context, Ptr<const Packet> packet)\n{\n    std::cout << Simulator::Now().GetSeconds() << \"s \" << context << \" packet size \"\n              << packet->GetSize() << std::endl;\n    bytesReceived += packet->GetSize();\n}\n\nint\nmain(int argc, char* argv[])\n{\n    bool outputValidated = true;\n\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    NodeContainer n;\n    n.Create(4);\n\n    //\n    // We're going to use the zeroth node in the container as the client, and\n    // the first node as the server.  Add some \"human readable\" names for these\n    // nodes.  The names below will go into the name system as \"/Names/clientZero\"\n    // and \"/Names/server\", but note that the Add function assumes that if you\n    // omit the leading \"/Names/\" the remaining string is assumed to be rooted\n    // in the \"/Names\" namespace. The following calls,\n    //\n    //  Names::Add (\"clientZero\", n.Get (0));\n    //  Names::Add (\"/Names/clientZero\", n.Get (0));\n    //\n    // will produce identical results.\n    //\n    Names::Add(\"clientZero\", n.Get(0));\n    Names::Add(\"/Names/server\", n.Get(1));\n\n    //\n    // It is possible to rename a node that has been previously named.  This is\n    // useful in automatic name generation.  You can automatically generate node\n    // names such as, \"node-0\", \"node-1\", etc., and then go back and change\n    // the name of some distinguished node to another value --  \"access-point\"\n    // for example.  We illustrate this by just changing the client's name.\n    // As is typical of the object name service, you can either provide or elide\n    // the \"/Names\" prefix as you choose.\n    //\n    Names::Rename(\"clientZero\", \"client\");\n\n    InternetStackHelper internet;\n    internet.Install(n);\n\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(5000000)));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n    csma.SetDeviceAttribute(\"Mtu\", UintegerValue(1400));\n    NetDeviceContainer d = csma.Install(n);\n\n    //\n    // Add some human readable names for the devices we'll be interested in.\n    // We add the names to the name space \"under\" the nodes we created above.\n    // This has the effect of making \"/Names/client/eth0\" and \"/Names/server/eth0\".\n    // In this case, we again omit the \"/Names/\" prefix on one call to illustrate\n    // the shortcut.\n    //\n    Names::Add(\"/Names/client/eth0\", d.Get(0));\n    Names::Add(\"server/eth0\", d.Get(1));\n\n    //\n    // You can use the object names that you've assigned in calls to the Config\n    // system to set Object Attributes.  For example, you can set the Mtu\n    // Attribute of a Csma devices using the object naming service.  Note that\n    // in this case, the \"/Names\" prefix is always required since the _Config_\n    // system always expects to see a fully qualified path name.\n    //\n\n    Ptr<CsmaNetDevice> csmaNetDevice = d.Get(0)->GetObject<CsmaNetDevice>();\n    UintegerValue val;\n    csmaNetDevice->GetAttribute(\"Mtu\", val);\n    std::cout << \"MTU on device 0 before configuration is \" << val.Get() << std::endl;\n\n    Config::Set(\"/Names/client/eth0/Mtu\", UintegerValue(1234));\n\n    // Check the attribute again\n    csmaNetDevice->GetAttribute(\"Mtu\", val);\n    std::cout << \"MTU on device 0 after configuration is \" << val.Get() << std::endl;\n\n    if (val.Get() != 1234)\n    {\n        outputValidated = false;\n    }\n\n    //\n    // You can mix and match names and Attributes in calls to the Config system.\n    // For example, if \"eth0\" is a named object, you can get to its parent through\n    // a different namespace.  For example, you could use the NodeList namespace\n    // to get to the server node, and then continue seamlessly adding named objects\n    // in the path. This is not nearly as readable as the previous version, but it\n    // illustrates how you can mix and match object names and Attribute names.\n    // Note that the config path now begins with a path in the \"/NodeList\"\n    // namespace.\n    //\n    Config::Set(\"/NodeList/1/eth0/Mtu\", UintegerValue(1234));\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i = ipv4.Assign(d);\n\n    uint16_t port = 9;\n    UdpEchoServerHelper server(port);\n    //\n    // Install the UdpEchoServer application on the server node using its name\n    // directly.\n    //\n    ApplicationContainer apps = server.Install(\"/Names/server\");\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    uint32_t packetSize = 1024;\n    uint32_t maxPacketCount = 1;\n    Time interPacketInterval = Seconds(1.);\n    UdpEchoClientHelper client(i.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(maxPacketCount));\n    client.SetAttribute(\"Interval\", TimeValue(interPacketInterval));\n    client.SetAttribute(\"PacketSize\", UintegerValue(packetSize));\n    //\n    // Install the UdpEchoClient application on the server node using its name\n    // directly.\n    //\n    apps = client.Install(\"/Names/client\");\n    apps.Start(Seconds(2.0));\n    apps.Stop(Seconds(10.0));\n\n    //\n    // Use the Config system to connect a trace source using the object name\n    // service to specify the path.  Note that in this case, the \"/Names\"\n    // prefix is always required since the _Config_ system always expects to\n    // see a fully qualified path name\n    //\n    Config::Connect(\"/Names/client/eth0/MacRx\", MakeCallback(&RxEvent));\n\n    //\n    // Set up some pcap tracing on the CSMA devices.  The names of the trace\n    // files will automatically correspond to the object names if present.\n    // In this case, you will find trace files called:\n    //\n    //   object-names-client-eth0.pcap\n    //   object-names-server-eth0.pcap\n    //\n    // since those nodes and devices have had names associated with them.  You\n    // will also see:\n    //\n    //   object-names-2-1.pcap\n    //   object-names-3-1.pcap\n    //\n    // since nodes two and three have no associated names.\n    //\n    csma.EnablePcapAll(\"object-names\");\n\n    //\n    // We can also create a trace file with a name we completely control by\n    // overriding a couple of default parameters.\n    //\n    csma.EnablePcap(\"client-device.pcap\", d.Get(0), false, true);\n\n    std::cout << \"Running simulation...\" << std::endl;\n    Simulator::Run();\n    Simulator::Destroy();\n\n    // Expected to see ARP exchange and one packet\n    // 64 bytes (minimum Ethernet frame size) x 2, plus (1024 + 8 + 20 + 18)\n    if (bytesReceived != (64 + 64 + 1070))\n    {\n        outputValidated = false;\n    }\n\n    if (!outputValidated)\n    {\n        std::cerr << \"Program internal checking failed; returning with error\" << std::endl;\n        return 1;\n    }\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 that simulates global routing in a mixed point-to-point and CSMA/CD network. Set up a network with seven nodes, including both point-to-point and CSMA links. Implement two separate CBR/UDP traffic flows from node 1 to node 6, with the first starting on the point-to-point link at 1 second and the second at 11 seconds using the alternative point-to-point link. Simulate interface down and up events at various times, causing rerouting of traffic via alternative paths. Enable automatic response to interface events for global route recomputation, and trace packet receptions and queue activity to output files."}, {"role": "assistant", "content": "// This script exercises global routing code in a mixed point-to-point\n// and csma/cd environment.  We bring up and down interfaces and observe\n// the effect on global routing.  We explicitly enable the attribute\n// to respond to interface events, so that routes are recomputed\n// automatically.\n//\n// Network topology\n//\n//  n0\n//     \\ p-p\n//      \\          (shared csma/cd)\n//       n2 -------------------------n3\n//      /            |        |\n//     / p-p        n4        n5 ---------- n6\n//   n1                             p-p\n//   |                                      |\n//   ----------------------------------------\n//                p-p\n//\n// - at time 1 CBR/UDP flow from n1 to n6's IP address on the n5/n6 link\n// - at time 10, start similar flow from n1 to n6's address on the n1/n6 link\n//\n//  Order of events\n//  At pre-simulation time, configure global routes.  Shortest path from\n//  n1 to n6 is via the direct point-to-point link\n//  At time 1s, start CBR traffic flow from n1 to n6\n//  At time 2s, set the n1 point-to-point interface to down.  Packets\n//    will be diverted to the n1-n2-n5-n6 path\n//  At time 4s, re-enable the n1/n6 interface to up.  n1-n6 route restored.\n//  At time 6s, set the n6-n1 point-to-point Ipv4 interface to down (note, this\n//    keeps the point-to-point link \"up\" from n1's perspective).  Traffic will\n//    flow through the path n1-n2-n5-n6\n//  At time 8s, bring the interface back up.  Path n1-n6 is restored\n//  At time 10s, stop the first flow.\n//  At time 11s, start a new flow, but to n6's other IP address (the one\n//    on the n1/n6 p2p link)\n//  At time 12s, bring the n1 interface down between n1 and n6.  Packets\n//    will be diverted to the alternate path\n//  At time 14s, re-enable the n1/n6 interface to up.  This will change\n//    routing back to n1-n6 since the interface up notification will cause\n//    a new local interface route, at higher priority than global routing\n//  At time 16s, stop the second flow.\n\n// - Tracing of queues and packet receptions to file \"dynamic-global-routing.tr\"\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"DynamicGlobalRoutingExample\");\n\nint\nmain(int argc, char* argv[])\n{\n    // The below value configures the default behavior of global routing.\n    // By default, it is disabled.  To respond to interface events, set to true\n    Config::SetDefault(\"ns3::Ipv4GlobalRouting::RespondToInterfaceEvents\", BooleanValue(true));\n\n    // Allow the user to override any of the defaults and the above\n    // Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    NS_LOG_INFO(\"Create nodes.\");\n    NodeContainer c;\n    c.Create(7);\n    NodeContainer n0n2 = NodeContainer(c.Get(0), c.Get(2));\n    NodeContainer n1n2 = NodeContainer(c.Get(1), c.Get(2));\n    NodeContainer n5n6 = NodeContainer(c.Get(5), c.Get(6));\n    NodeContainer n1n6 = NodeContainer(c.Get(1), c.Get(6));\n    NodeContainer n2345 = NodeContainer(c.Get(2), c.Get(3), c.Get(4), c.Get(5));\n\n    InternetStackHelper internet;\n    internet.Install(c);\n\n    // We create the channels first without any IP addressing information\n    NS_LOG_INFO(\"Create channels.\");\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d0d2 = p2p.Install(n0n2);\n    NetDeviceContainer d1d6 = p2p.Install(n1n6);\n\n    NetDeviceContainer d1d2 = p2p.Install(n1n2);\n\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"1500kbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    NetDeviceContainer d5d6 = p2p.Install(n5n6);\n\n    // We create the channels first without any IP addressing information\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer d2345 = csma.Install(n2345);\n\n    // Later, we add IP addresses.\n    NS_LOG_INFO(\"Assign IP Addresses.\");\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ipv4.Assign(d0d2);\n\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    ipv4.Assign(d1d2);\n\n    ipv4.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i5i6 = ipv4.Assign(d5d6);\n\n    ipv4.SetBase(\"10.250.1.0\", \"255.255.255.0\");\n    ipv4.Assign(d2345);\n\n    ipv4.SetBase(\"172.16.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer i1i6 = ipv4.Assign(d1d6);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    NS_LOG_INFO(\"Create Applications.\");\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\", InetSocketAddress(i5i6.GetAddress(1), port));\n    onoff.SetConstantRate(DataRate(\"2kbps\"));\n    onoff.SetAttribute(\"PacketSize\", UintegerValue(50));\n\n    ApplicationContainer apps = onoff.Install(c.Get(1));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a second OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    OnOffHelper onoff2(\"ns3::UdpSocketFactory\", InetSocketAddress(i1i6.GetAddress(1), port));\n    onoff2.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    onoff2.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n    onoff2.SetAttribute(\"DataRate\", StringValue(\"2kbps\"));\n    onoff2.SetAttribute(\"PacketSize\", UintegerValue(50));\n\n    ApplicationContainer apps2 = onoff2.Install(c.Get(1));\n    apps2.Start(Seconds(11.0));\n    apps2.Stop(Seconds(16.0));\n\n    // Create an optional packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(c.Get(6));\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    PacketSinkHelper sink2(\"ns3::UdpSocketFactory\",\n                           Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps2 = sink2.Install(c.Get(6));\n    apps2.Start(Seconds(11.0));\n    apps2.Stop(Seconds(16.0));\n\n    AsciiTraceHelper ascii;\n    Ptr<OutputStreamWrapper> stream = ascii.CreateFileStream(\"dynamic-global-routing.tr\");\n    p2p.EnableAsciiAll(stream);\n    csma.EnableAsciiAll(stream);\n    internet.EnableAsciiIpv4All(stream);\n\n    p2p.EnablePcapAll(\"dynamic-global-routing\");\n    csma.EnablePcapAll(\"dynamic-global-routing\", false);\n\n    Ptr<Node> n1 = c.Get(1);\n    Ptr<Ipv4> ipv41 = n1->GetObject<Ipv4>();\n    // The first ifIndex is 0 for loopback, then the first p2p is numbered 1,\n    // then the next p2p is numbered 2\n    uint32_t ipv4ifIndex1 = 2;\n\n    Simulator::Schedule(Seconds(2), &Ipv4::SetDown, ipv41, ipv4ifIndex1);\n    Simulator::Schedule(Seconds(4), &Ipv4::SetUp, ipv41, ipv4ifIndex1);\n\n    Ptr<Node> n6 = c.Get(6);\n    Ptr<Ipv4> ipv46 = n6->GetObject<Ipv4>();\n    // The first ifIndex is 0 for loopback, then the first p2p is numbered 1,\n    // then the next p2p is numbered 2\n    uint32_t ipv4ifIndex6 = 2;\n    Simulator::Schedule(Seconds(6), &Ipv4::SetDown, ipv46, ipv4ifIndex6);\n    Simulator::Schedule(Seconds(8), &Ipv4::SetUp, ipv46, ipv4ifIndex6);\n\n    Simulator::Schedule(Seconds(12), &Ipv4::SetDown, ipv41, ipv4ifIndex1);\n    Simulator::Schedule(Seconds(14), &Ipv4::SetUp, ipv41, ipv4ifIndex1);\n\n    // Trace routing tables\n    Ptr<OutputStreamWrapper> routingStream =\n        Create<OutputStreamWrapper>(\"dynamic-global-routing.routes\", std::ios::out);\n    Ipv4RoutingHelper::PrintRoutingTableAllAt(Seconds(12), routingStream);\n\n    NS_LOG_INFO(\"Run Simulation.\");\n    Simulator::Run();\n    Simulator::Destroy();\n    NS_LOG_INFO(\"Done.\");\n\n    return 0;\n}"}]}
{"size": "Large", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a C++ program using ns-3 to simulate a simple three-router network with global routing. Set up a point-to-point network between three nodes (A, B, C), with node A having a /32 host route, node B handling transit routing, and node C having its own /32 host route. Assign point-to-point links between A-B and B-C, configure global and static routing for the network, and inject routes at node B. Implement an OnOff UDP application at node A to send traffic to node C, and include packet tracing and PCAP capturing functionality."}, {"role": "assistant", "content": "// Test program for this 3-router scenario, using global routing\n//\n// (a.a.a.a/32)A<--x.x.x.0/30-->B<--y.y.y.0/30-->C(c.c.c.c/32)\n\n#include \"ns3/applications-module.h\"\n#include \"ns3/core-module.h\"\n#include \"ns3/csma-net-device.h\"\n#include \"ns3/global-router-interface.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ipv4-global-routing-helper.h\"\n#include \"ns3/ipv4-global-routing.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/ipv4-list-routing.h\"\n#include \"ns3/ipv4-routing-table-entry.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/ipv4-static-routing.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\n#include <cassert>\n#include <fstream>\n#include <iostream>\n#include <string>\n\nusing namespace ns3;\nusing std::cout;\n\nNS_LOG_COMPONENT_DEFINE(\"GlobalRouterInjectionTest\");\n\nint\nmain(int argc, char* argv[])\n{\n    // Allow the user to override any of the defaults and the above\n    // DefaultValue::Bind ()s at run-time, via command-line arguments\n    CommandLine cmd(__FILE__);\n    cmd.Parse(argc, argv);\n\n    Ptr<Node> nA = CreateObject<Node>();\n    Ptr<Node> nB = CreateObject<Node>();\n    Ptr<Node> nC = CreateObject<Node>();\n\n    NodeContainer c = NodeContainer(nA, nB, nC);\n\n    InternetStackHelper internet;\n\n    // Point-to-point links\n    NodeContainer nAnB = NodeContainer(nA, nB);\n    NodeContainer nBnC = NodeContainer(nB, nC);\n\n    internet.Install(nAnB);\n    Ipv4ListRoutingHelper staticonly;\n    Ipv4ListRoutingHelper staticRouting;\n    staticonly.Add(staticRouting, 0);\n    internet.SetRoutingHelper(staticonly); // has effect on the next Install ()\n    internet.Install(NodeContainer(nC));\n\n    // We create the channels first without any IP addressing information\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer dAdB = p2p.Install(nAnB);\n\n    NetDeviceContainer dBdC = p2p.Install(nBnC);\n\n    Ptr<CsmaNetDevice> deviceA = CreateObject<CsmaNetDevice>();\n    deviceA->SetAddress(Mac48Address::Allocate());\n    nA->AddDevice(deviceA);\n    deviceA->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    Ptr<CsmaNetDevice> deviceC = CreateObject<CsmaNetDevice>();\n    deviceC->SetAddress(Mac48Address::Allocate());\n    nC->AddDevice(deviceC);\n    deviceC->SetQueue(CreateObject<DropTailQueue<Packet>>());\n\n    // Later, we add IP addresses.\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iAiB = ipv4.Assign(dAdB);\n\n    ipv4.SetBase(\"10.1.1.4\", \"255.255.255.252\");\n    Ipv4InterfaceContainer iBiC = ipv4.Assign(dBdC);\n\n    Ptr<Ipv4> ipv4A = nA->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4B = nB->GetObject<Ipv4>();\n    Ptr<Ipv4> ipv4C = nC->GetObject<Ipv4>();\n\n    int32_t ifIndexA = ipv4A->AddInterface(deviceA);\n    int32_t ifIndexC = ipv4C->AddInterface(deviceC);\n\n    Ipv4InterfaceAddress ifInAddrA =\n        Ipv4InterfaceAddress(Ipv4Address(\"172.16.1.1\"), Ipv4Mask(\"255.255.255.255\"));\n    ipv4A->AddAddress(ifIndexA, ifInAddrA);\n    ipv4A->SetMetric(ifIndexA, 1);\n    ipv4A->SetUp(ifIndexA);\n\n    Ipv4InterfaceAddress ifInAddrC =\n        Ipv4InterfaceAddress(Ipv4Address(\"192.168.1.1\"), Ipv4Mask(\"255.255.255.255\"));\n    ipv4C->AddAddress(ifIndexC, ifInAddrC);\n    ipv4C->SetMetric(ifIndexC, 1);\n    ipv4C->SetUp(ifIndexC);\n\n    // Create router nodes, initialize routing database and set up the routing\n    // tables in the nodes.\n\n    // Populate routing tables for nodes nA and nB\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n    // Inject global routes from Node B, including transit network...\n    Ptr<GlobalRouter> globalRouterB = nB->GetObject<GlobalRouter>();\n    globalRouterB->InjectRoute(\"10.1.1.4\", \"255.255.255.252\");\n    // ...and the host in network \"C\"\n    globalRouterB->InjectRoute(\"192.168.1.1\", \"255.255.255.255\");\n\n    Ipv4GlobalRoutingHelper::RecomputeRoutingTables();\n    // In addition, nB needs a static route to nC so it knows what to do with stuff\n    // going to 192.168.1.1\n    Ipv4StaticRoutingHelper ipv4RoutingHelper;\n    Ptr<Ipv4StaticRouting> staticRoutingB = ipv4RoutingHelper.GetStaticRouting(ipv4B);\n    staticRoutingB->AddHostRouteTo(Ipv4Address(\"192.168.1.1\"), Ipv4Address(\"10.1.1.6\"), 2);\n\n    // Create the OnOff application to send UDP datagrams of size\n    // 210 bytes at a rate of 448 Kb/s\n    uint16_t port = 9; // Discard port (RFC 863)\n    OnOffHelper onoff(\"ns3::UdpSocketFactory\",\n                      Address(InetSocketAddress(ifInAddrC.GetLocal(), port)));\n    onoff.SetConstantRate(DataRate(6000));\n    ApplicationContainer apps = onoff.Install(nA);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    // Create a packet sink to receive these packets\n    PacketSinkHelper sink(\"ns3::UdpSocketFactory\",\n                          Address(InetSocketAddress(Ipv4Address::GetAny(), port)));\n    apps = sink.Install(nC);\n    apps.Start(Seconds(1.0));\n    apps.Stop(Seconds(10.0));\n\n    AsciiTraceHelper ascii;\n    p2p.EnableAsciiAll(ascii.CreateFileStream(\"global-routing-injection32.tr\"));\n    p2p.EnablePcapAll(\"global-routing-injection32\");\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a simple NS-3 simulation in C++ where a client communicates with a server using UDP. The server should listen for incoming packets and log them, while the client should send a packet every second. Use NS-3’s UdpEchoClient and UdpEchoServer applications, set up a point-to-point connection, and configure basic logging. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging for debugging\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create two nodes (Client and Server)\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up the UDP Echo Server on node 1\n    uint16_t port = 9;  // UDP port number\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the UDP Echo Client on node 0\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1), port);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a client communicates with a server using a raw UDP socket. The client should send packets to the server at regular intervals, and the server should log the received packets. Set up a simple point-to-point network with an IP address configuration. Implement custom UDP socket applications for both client and server instead of using NS-3’s built-in UdpEchoClient and UdpEchoServer. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpSocketExample\");\n\n// Server function to receive packets\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a packet!\");\n    }\n}\n\n// Client function to send packets\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address dstAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(1024); // 1024-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(dstAddr, port));\n    Simulator::Schedule(Seconds(1.0), &SendPacket, socket, dstAddr, port); // Schedule next packet\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpSocketExample\", LOG_LEVEL_INFO);\n\n    // Create nodes (Client and Server)\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    uint16_t port = 8080; // UDP port\n\n    // Setup UDP Server\n    Ptr<Socket> serverSocket = Socket::CreateSocket(nodes.Get(1), UdpSocketFactory::GetTypeId());\n    InetSocketAddress local = InetSocketAddress(Ipv4Address::GetAny(), port);\n    serverSocket->Bind(local);\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client\n    Ptr<Socket> clientSocket = Socket::CreateSocket(nodes.Get(0), UdpSocketFactory::GetTypeId());\n    Simulator::Schedule(Seconds(2.0), &SendPacket, clientSocket, interfaces.GetAddress(1), port);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a client communicates with multiple servers using UDP. The client should send packets to two different servers at regular intervals. Each server should listen on a different port and log the received packets. Set up a simple point-to-point network where the client is connected to both servers via a switch (CSMA network). Implement custom UDP socket applications instead of using NS-3’s built-in UdpEchoClient and UdpEchoServer. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpMultiServerExample\");\n\n// Server function to receive packets\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a packet!\");\n    }\n}\n\n// Client function to send packets to a specific server\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address dstAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(512); // 512-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(dstAddr, port));\n    Simulator::Schedule(Seconds(1.0), &SendPacket, socket, dstAddr, port); // Schedule next packet\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpMultiServerExample\", LOG_LEVEL_INFO);\n\n    // Create nodes (1 Client + 2 Servers)\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Configure CSMA network (Ethernet-like)\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(5000)));\n\n    NetDeviceContainer devices = csma.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    uint16_t port1 = 8080; // Server 1 port\n    uint16_t port2 = 9090; // Server 2 port\n\n    // Setup UDP Server 1\n    Ptr<Socket> serverSocket1 = Socket::CreateSocket(nodes.Get(1), UdpSocketFactory::GetTypeId());\n    serverSocket1->Bind(InetSocketAddress(Ipv4Address::GetAny(), port1));\n    serverSocket1->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Server 2\n    Ptr<Socket> serverSocket2 = Socket::CreateSocket(nodes.Get(2), UdpSocketFactory::GetTypeId());\n    serverSocket2->Bind(InetSocketAddress(Ipv4Address::GetAny(), port2));\n    serverSocket2->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client\n    Ptr<Socket> clientSocket1 = Socket::CreateSocket(nodes.Get(0), UdpSocketFactory::GetTypeId());\n    Ptr<Socket> clientSocket2 = Socket::CreateSocket(nodes.Get(0), UdpSocketFactory::GetTypeId());\n\n    // Schedule packet sending to both servers\n    Simulator::Schedule(Seconds(2.0), &SendPacket, clientSocket1, interfaces.GetAddress(1), port1);\n    Simulator::Schedule(Seconds(2.5), &SendPacket, clientSocket2, interfaces.GetAddress(2), port2);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a UDP client communicates with a server over a wireless (Wi-Fi) network. The client should send packets to the server at regular intervals, and the server should log the received packets. Configure a Wi-Fi network using the infrastructure mode (where the client connects to an access point, and the server is also connected to the access point). Use custom UDP socket applications instead of NS-3’s built-in UdpEchoClient and UdpEchoServer. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpWifiExample\");\n\n// Server function to receive packets\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a packet over Wi-Fi!\");\n    }\n}\n\n// Client function to send packets\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address dstAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(512); // 512-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(dstAddr, port));\n    Simulator::Schedule(Seconds(1.0), &SendPacket, socket, dstAddr, port); // Schedule next packet\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpWifiExample\", LOG_LEVEL_INFO);\n\n    // Create nodes (1 AP, 1 Client, 1 Server)\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    NodeContainer wifiClientNode, wifiServerNode;\n    wifiClientNode.Create(1);\n    wifiServerNode.Create(1);\n\n    // Configure Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Configure Wi-Fi MAC (Infrastructure Mode)\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211g);\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Configure AP (Access Point)\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Configure Client and Server (Station Mode)\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer clientDevice = wifi.Install(phy, mac, wifiClientNode);\n    NetDeviceContainer serverDevice = wifi.Install(phy, mac, wifiServerNode);\n\n    // Set mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiClientNode);\n    mobility.Install(wifiServerNode);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiClientNode);\n    stack.Install(wifiServerNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n    Ipv4InterfaceContainer clientInterface = address.Assign(clientDevice);\n    Ipv4InterfaceContainer serverInterface = address.Assign(serverDevice);\n\n    uint16_t port = 8080; // UDP port\n\n    // Setup UDP Server\n    Ptr<Socket> serverSocket = Socket::CreateSocket(wifiServerNode.Get(0), UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client\n    Ptr<Socket> clientSocket = Socket::CreateSocket(wifiClientNode.Get(0), UdpSocketFactory::GetTypeId());\n    Simulator::Schedule(Seconds(2.0), &SendPacket, clientSocket, serverInterface.GetAddress(0), port);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a UDP client communicates with a server over an ad-hoc Wi-Fi network. The client should send packets to the server at regular intervals, and the server should log the received packets. Configure a Wi-Fi ad-hoc network where both the client and server communicate directly without an access point. Implement custom UDP socket applications instead of using NS-3’s built-in UdpEchoClient and UdpEchoServer. The simulation should run for 10 seconds"}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpAdhocWifiExample\");\n\n// Server function to receive packets\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a packet over Wi-Fi Ad-Hoc!\");\n    }\n}\n\n// Client function to send packets\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address dstAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(512); // 512-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(dstAddr, port));\n    Simulator::Schedule(Seconds(1.0), &SendPacket, socket, dstAddr, port); // Schedule next packet\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpAdhocWifiExample\", LOG_LEVEL_INFO);\n\n    // Create nodes (1 Client, 1 Server)\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Configure Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Configure Wi-Fi MAC (Ad-Hoc Mode)\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(phy, mac, wifiNodes);\n\n    // Set mobility model (nodes move randomly)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(wifiNodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    uint16_t port = 8080; // UDP port\n\n    // Setup UDP Server\n    Ptr<Socket> serverSocket = Socket::CreateSocket(wifiNodes.Get(1), UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client\n    Ptr<Socket> clientSocket = Socket::CreateSocket(wifiNodes.Get(0), UdpSocketFactory::GetTypeId());\n    Simulator::Schedule(Seconds(2.0), &SendPacket, clientSocket, interfaces.GetAddress(1), port);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(10.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where multiple mobile nodes communicate using UDP over a MANET (Mobile Ad-Hoc Network). The nodes should use the AODV routing protocol for dynamic path discovery. Each node should periodically send packets to a randomly chosen neighbor. The simulation should model node mobility using the RandomWaypoint model and run for 20 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n#include <cstdlib>\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpManetExample\");\n\n// Function to send UDP packets to a random neighbor\nvoid SendPacket(Ptr<Socket> socket, Ipv4InterfaceContainer &interfaces) {\n    int numNodes = interfaces.GetN();\n    int targetNode = rand() % numNodes; // Choose a random target node\n\n    Ipv4Address dstAddr = interfaces.GetAddress(targetNode);\n    Ptr<Packet> packet = Create<Packet>(512); // 512-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(dstAddr, 8080));\n\n    Simulator::Schedule(Seconds(2.0), &SendPacket, socket, interfaces); // Schedule next packet\n}\n\n// Function to receive packets\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Node received a packet in MANET!\");\n    }\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpManetExample\", LOG_LEVEL_INFO);\n\n    int numNodes = 10;\n    double simTime = 20.0;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(numNodes);\n\n    // Configure Wi-Fi (Ad-Hoc Mode)\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set up mobility (Random Waypoint Model)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=100]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=100]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", StringValue(\"ns3::UniformRandomVariable[Min=5.0|Max=10.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=2.0]\"));\n    mobility.Install(nodes);\n\n    // Install Internet stack with AODV\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Setup UDP sockets\n    for (int i = 0; i < numNodes; i++) {\n        Ptr<Socket> recvSocket = Socket::CreateSocket(nodes.Get(i), UdpSocketFactory::GetTypeId());\n        recvSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), 8080));\n        recvSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n        Ptr<Socket> sendSocket = Socket::CreateSocket(nodes.Get(i), UdpSocketFactory::GetTypeId());\n        Simulator::Schedule(Seconds(2.0 + i * 0.5), &SendPacket, sendSocket, interfaces);\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a group of nodes communicates using UDP over a VANET (Vehicular Ad-Hoc Network). The nodes should use the DSDV (Destination-Sequenced Distance-Vector) routing protocol for maintaining up-to-date routes. Vehicles should move along a highway using the WaypointMobilityModel, and each vehicle should periodically send UDP packets to a central roadside unit (RSU). The simulation should run for 30 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/dsdv-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpVANETExample\");\n\n// Function to send UDP packets from vehicles to the RSU\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address dstAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(512); // 512-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(dstAddr, port));\n    Simulator::Schedule(Seconds(1.5), &SendPacket, socket, dstAddr, port); // Schedule next packet\n}\n\n// Function to receive packets at the RSU\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"RSU received a packet from a vehicle!\");\n    }\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpVANETExample\", LOG_LEVEL_INFO);\n\n    int numVehicles = 10;\n    double simTime = 30.0;\n\n    // Create nodes (vehicles + 1 RSU)\n    NodeContainer vehicles;\n    vehicles.Create(numVehicles);\n\n    NodeContainer rsu;\n    rsu.Create(1);\n\n    // Configure Wi-Fi (Ad-Hoc Mode for VANET)\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211p); // 802.11p for vehicular communication\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer devices = wifi.Install(phy, mac, vehicles);\n    NetDeviceContainer rsuDevice = wifi.Install(phy, mac, rsu);\n\n    // Set up mobility (vehicles moving along a highway)\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    \n    for (int i = 0; i < numVehicles; i++) {\n        positionAlloc->Add(Vector(i * 20.0, 0.0, 0.0)); // Vehicles spaced 20m apart\n    }\n    positionAlloc->Add(Vector(100.0, 50.0, 0.0)); // RSU position\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::WaypointMobilityModel\");\n    mobility.Install(vehicles);\n    mobility.Install(rsu);\n\n    // Install Internet stack with DSDV routing\n    DsdvHelper dsdv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(dsdv);\n    internet.Install(vehicles);\n    internet.Install(rsu);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vehicleInterfaces = address.Assign(devices);\n    Ipv4InterfaceContainer rsuInterface = address.Assign(rsuDevice);\n\n    uint16_t port = 8080; // UDP port\n\n    // Setup UDP Server at RSU\n    Ptr<Socket> rsuSocket = Socket::CreateSocket(rsu.Get(0), UdpSocketFactory::GetTypeId());\n    rsuSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    rsuSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Clients in Vehicles\n    for (int i = 0; i < numVehicles; i++) {\n        Ptr<Socket> vehicleSocket = Socket::CreateSocket(vehicles.Get(i), UdpSocketFactory::GetTypeId());\n        Simulator::Schedule(Seconds(2.0 + i * 0.5), &SendPacket, vehicleSocket, rsuInterface.GetAddress(0), port);\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a sensor network communicates using UDP over a Wireless Sensor Network (WSN). The network consists of multiple sensor nodes that periodically send data to a central sink node. The nodes should use the OLSR (Optimized Link State Routing) protocol for efficient data routing. The simulation should include an energy model for sensor nodes and run for 50 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/olsr-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/energy-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpWSNExample\");\n\n// Function to send UDP packets from sensors to the sink\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address sinkAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(256); // 256-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(sinkAddr, port));\n    Simulator::Schedule(Seconds(2.0), &SendPacket, socket, sinkAddr, port); // Schedule next packet\n}\n\n// Function to receive packets at the sink node\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Sink node received a packet from a sensor!\");\n    }\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpWSNExample\", LOG_LEVEL_INFO);\n\n    int numSensors = 20;\n    double simTime = 50.0;\n\n    // Create nodes (sensor nodes + 1 sink)\n    NodeContainer sensors;\n    sensors.Create(numSensors);\n\n    NodeContainer sink;\n    sink.Create(1);\n\n    // Configure Wi-Fi (Ad-Hoc Mode for WSN)\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b); // 802.11b for low-power sensor communication\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer sensorDevices = wifi.Install(phy, mac, sensors);\n    NetDeviceContainer sinkDevice = wifi.Install(phy, mac, sink);\n\n    // Set up mobility (random sensor deployment)\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    \n    for (int i = 0; i < numSensors; i++) {\n        positionAlloc->Add(Vector(rand() % 100, rand() % 100, 0.0)); // Random deployment in 100x100m area\n    }\n    positionAlloc->Add(Vector(50.0, 50.0, 0.0)); // Sink at the center\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(sensors);\n    mobility.Install(sink);\n\n    // Install Energy Model\n    BasicEnergySourceHelper energySourceHelper;\n    energySourceHelper.Set(\"BasicEnergySourceInitialEnergyJ\", DoubleValue(10.0)); // 10 Joules per node\n    EnergySourceContainer energySources = energySourceHelper.Install(sensors);\n\n    WifiRadioEnergyModelHelper radioEnergyHelper;\n    radioEnergyHelper.Install(sensorDevices, energySources);\n\n    // Install Internet stack with OLSR routing\n    OlsrHelper olsr;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(olsr);\n    internet.Install(sensors);\n    internet.Install(sink);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.3.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer sensorInterfaces = address.Assign(sensorDevices);\n    Ipv4InterfaceContainer sinkInterface = address.Assign(sinkDevice);\n\n    uint16_t port = 9090; // UDP port\n\n    // Setup UDP Server at Sink Node\n    Ptr<Socket> sinkSocket = Socket::CreateSocket(sink.Get(0), UdpSocketFactory::GetTypeId());\n    sinkSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    sinkSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Clients in Sensor Nodes\n    for (int i = 0; i < numSensors; i++) {\n        Ptr<Socket> sensorSocket = Socket::CreateSocket(sensors.Get(i), UdpSocketFactory::GetTypeId());\n        Simulator::Schedule(Seconds(2.0 + i * 0.5), &SendPacket, sensorSocket, sinkInterface.GetAddress(0), port);\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where multiple drones (UAVs) communicate using UDP over a wireless network. The UAVs should follow a 3D mobility model and exchange data with a ground control station (GCS). Use the AODV (Ad hoc On-Demand Distance Vector) routing protocol to dynamically find routes between UAVs and the GCS. The simulation should run for 60 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpUAVNetwork\");\n\n// Function to send UDP packets from UAVs to the GCS\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address gcsAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(512); // 512-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(gcsAddr, port));\n    Simulator::Schedule(Seconds(2.0), &SendPacket, socket, gcsAddr, port); // Schedule next packet\n}\n\n// Function to receive packets at the GCS\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"GCS received a packet from a UAV!\");\n    }\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpUAVNetwork\", LOG_LEVEL_INFO);\n\n    int numUAVs = 5;\n    double simTime = 60.0;\n\n    // Create nodes (UAVs + 1 Ground Control Station)\n    NodeContainer uavs;\n    uavs.Create(numUAVs);\n\n    NodeContainer gcs;\n    gcs.Create(1);\n\n    // Configure Wi-Fi (Ad-Hoc Mode for UAV Network)\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a); // 802.11a for high-speed UAV communication\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer uavDevices = wifi.Install(phy, mac, uavs);\n    NetDeviceContainer gcsDevice = wifi.Install(phy, mac, gcs);\n\n    // Set up 3D mobility model for UAVs\n    MobilityHelper mobility;\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    \n    for (int i = 0; i < numUAVs; i++) {\n        positionAlloc->Add(Vector(i * 50.0, i * 50.0, 100.0 + i * 10.0)); // UAVs at different altitudes\n    }\n    positionAlloc->Add(Vector(250.0, 250.0, 0.0)); // GCS at ground level\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", StringValue(\"ns3::UniformRandomVariable[Min=10.0|Max=20.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"),\n                              \"PositionAllocator\", PointerValue(positionAlloc));\n    mobility.Install(uavs);\n    mobility.Install(gcs);\n\n    // Install Internet stack with AODV routing\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);\n    internet.Install(uavs);\n    internet.Install(gcs);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.4.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer uavInterfaces = address.Assign(uavDevices);\n    Ipv4InterfaceContainer gcsInterface = address.Assign(gcsDevice);\n\n    uint16_t port = 7070; // UDP port\n\n    // Setup UDP Server at GCS\n    Ptr<Socket> gcsSocket = Socket::CreateSocket(gcs.Get(0), UdpSocketFactory::GetTypeId());\n    gcsSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    gcsSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Clients in UAVs\n    for (int i = 0; i < numUAVs; i++) {\n        Ptr<Socket> uavSocket = Socket::CreateSocket(uavs.Get(i), UdpSocketFactory::GetTypeId());\n        Simulator::Schedule(Seconds(2.0 + i * 1.0), &SendPacket, uavSocket, gcsInterface.GetAddress(0), port);\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where vehicles in a VANET (Vehicular Ad Hoc Network) communicate using UDP over a Wi-Fi network. The vehicles should follow a realistic mobility model using the SUMO (Simulation of Urban MObility) tool and the ns-3 Mobility module. Use the DSR (Dynamic Source Routing) protocol to establish routes between vehicles dynamically. The simulation should run for 80 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/dsr-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpVANETExample\");\n\n// Function to send UDP packets from vehicles to the RSU\nvoid SendPacket(Ptr<Socket> socket, Ipv4Address rsuAddr, uint16_t port) {\n    Ptr<Packet> packet = Create<Packet>(256); // 256-byte packet\n    socket->SendTo(packet, 0, InetSocketAddress(rsuAddr, port));\n    Simulator::Schedule(Seconds(3.0), &SendPacket, socket, rsuAddr, port); // Schedule next packet\n}\n\n// Function to receive packets at the RSU\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"RSU received a packet from a vehicle!\");\n    }\n}\n\nint main(int argc, char *argv[]) {\n    LogComponentEnable(\"UdpVANETExample\", LOG_LEVEL_INFO);\n\n    int numVehicles = 10;\n    double simTime = 80.0;\n\n    // Create nodes (Vehicles + 1 Roadside Unit)\n    NodeContainer vehicles;\n    vehicles.Create(numVehicles);\n\n    NodeContainer rsu;\n    rsu.Create(1);\n\n    // Configure Wi-Fi (Ad-Hoc Mode for VANET)\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211p); // 802.11p for VANET communication\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n    NetDeviceContainer vehicleDevices = wifi.Install(phy, mac, vehicles);\n    NetDeviceContainer rsuDevice = wifi.Install(phy, mac, rsu);\n\n    // Set up mobility model for vehicles (simulate road movement)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::GaussMarkovMobilityModel\",\n                              \"Bounds\", BoxValue(Box(0, 500, 0, 500, 0, 0)),\n                              \"TimeStep\", TimeValue(Seconds(1.0)),\n                              \"Alpha\", DoubleValue(0.85),\n                              \"MeanVelocity\", StringValue(\"ns3::UniformRandomVariable[Min=10.0|Max=20.0]\"),\n                              \"MeanDirection\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=360]\"),\n                              \"MeanPitch\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    mobility.Install(vehicles);\n\n    Ptr<ListPositionAllocator> positionAlloc = CreateObject<ListPositionAllocator>();\n    positionAlloc->Add(Vector(250.0, 250.0, 0.0)); // RSU fixed at center\n\n    mobility.SetPositionAllocator(positionAlloc);\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(rsu);\n\n    // Install Internet stack with DSR routing\n    DsrMainHelper dsrMain;\n    DsrHelper dsr;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(dsr);\n    internet.Install(vehicles);\n    internet.Install(rsu);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.5.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer vehicleInterfaces = address.Assign(vehicleDevices);\n    Ipv4InterfaceContainer rsuInterface = address.Assign(rsuDevice);\n\n    uint16_t port = 8080; // UDP port\n\n    // Setup UDP Server at RSU\n    Ptr<Socket> rsuSocket = Socket::CreateSocket(rsu.Get(0), UdpSocketFactory::GetTypeId());\n    rsuSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    rsuSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Clients in Vehicles\n    for (int i = 0; i < numVehicles; i++) {\n        Ptr<Socket> vehicleSocket = Socket::CreateSocket(vehicles.Get(i), UdpSocketFactory::GetTypeId());\n        Simulator::Schedule(Seconds(2.0 + i * 1.0), &SendPacket, vehicleSocket, rsuInterface.GetAddress(0), port);\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(simTime));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite a minimal NS-3 simulation in C++ where two nodes communicate using UDP over a point-to-point link. The client should send a small UDP packet to the server, which will log the reception. Keep the simulation simple and short."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MinimalUdpExample\");\n\n// Function to receive packets at the server\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a packet!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"MinimalUdpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes (client and server)\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up a point-to-point connection\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    uint16_t port = 4000; // UDP port\n\n    // Setup UDP Server on node 1\n    Ptr<Socket> serverSocket = Socket::CreateSocket(nodes.Get(1), UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client on node 0\n    Ptr<Socket> clientSocket = Socket::CreateSocket(nodes.Get(0), UdpSocketFactory::GetTypeId());\n    Ptr<Packet> packet = Create<Packet>(128); // 128-byte packet\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, clientSocket, packet, 0, InetSocketAddress(interfaces.GetAddress(1), port));\n\n    // Run the simulation\n    Simulator::Stop(Seconds(2.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where multiple client nodes send UDP packets to a single server over a shared Wi-Fi network. The server should log the reception of packets. Keep the setup simple, with basic Wi-Fi configuration and no advanced mobility models."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpWifiExample\");\n\n// Function to receive packets at the server\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a packet!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"UdpWifiExample\", LOG_LEVEL_INFO);\n\n    int numClients = 3;\n    uint16_t port = 5000;\n\n    // Create nodes (clients + 1 server)\n    NodeContainer wifiNodes;\n    wifiNodes.Create(numClients + 1);\n\n    NodeContainer serverNode = wifiNodes.Get(numClients); // Last node is the server\n\n    // Set up Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"udp-wifi-network\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer clientDevices = wifi.Install(phy, mac, wifiNodes.Get(0, numClients));\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer serverDevice = wifi.Install(phy, mac, serverNode);\n\n    // Mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(clientDevices);\n    Ipv4InterfaceContainer serverInterface = address.Assign(serverDevice);\n\n    // Setup UDP Server\n    Ptr<Socket> serverSocket = Socket::CreateSocket(serverNode, UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Clients\n    for (int i = 0; i < numClients; i++) {\n        Ptr<Socket> clientSocket = Socket::CreateSocket(wifiNodes.Get(i), UdpSocketFactory::GetTypeId());\n        Ptr<Packet> packet = Create<Packet>(128); // 128-byte packet\n        Simulator::Schedule(Seconds(1.0 + i), &Socket::SendTo, clientSocket, packet, 0, InetSocketAddress(serverInterface.GetAddress(0), port));\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(5.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where two nodes communicate using TCP over a point-to-point link. The client should send a small amount of data to the server using a TCP socket. The server should log the reception. Keep the setup minimal and the simulation short."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MinimalTcpExample\");\n\nint main() {\n    LogComponentEnable(\"MinimalTcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes (client and server)\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up a point-to-point connection\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    uint16_t port = 5000; // TCP port\n\n    // Setup TCP Server on node 1\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = sink.Install(nodes.Get(1));\n    serverApp.Start(Seconds(0.0));\n    serverApp.Stop(Seconds(2.0));\n\n    // Setup TCP Client on node 0\n    OnOffHelper client(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    client.SetConstantRate(DataRate(\"1Mbps\"), 512); // Send 512-byte packets\n    ApplicationContainer clientApp = client.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(2.0));\n\n    // Run the simulation\n    Simulator::Stop(Seconds(2.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where multiple client nodes communicate with a single server using TCP over a shared Wi-Fi network. Each client should send a small amount of data to the server, which logs the reception. Keep the setup simple with basic Wi-Fi configuration and minimal mobility."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpWifiExample\");\n\nint main() {\n    LogComponentEnable(\"TcpWifiExample\", LOG_LEVEL_INFO);\n\n    int numClients = 3;\n    uint16_t port = 5000;\n\n    // Create nodes (clients + 1 server)\n    NodeContainer wifiNodes;\n    wifiNodes.Create(numClients + 1);\n\n    NodeContainer serverNode = wifiNodes.Get(numClients); // Last node is the server\n\n    // Set up Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"tcp-wifi-network\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer clientDevices = wifi.Install(phy, mac, wifiNodes.Get(0, numClients));\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer serverDevice = wifi.Install(phy, mac, serverNode);\n\n    // Mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(clientDevices);\n    Ipv4InterfaceContainer serverInterface = address.Assign(serverDevice);\n\n    // Setup TCP Server\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = sink.Install(serverNode);\n    serverApp.Start(Seconds(0.0));\n    serverApp.Stop(Seconds(5.0));\n\n    // Setup TCP Clients\n    for (int i = 0; i < numClients; i++) {\n        OnOffHelper client(\"ns3::TcpSocketFactory\", InetSocketAddress(serverInterface.GetAddress(0), port));\n        client.SetConstantRate(DataRate(\"1Mbps\"), 512); // Send 512-byte packets\n        ApplicationContainer clientApp = client.Install(wifiNodes.Get(i));\n        clientApp.Start(Seconds(1.0 + i));\n        clientApp.Stop(Seconds(5.0));\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(5.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a single node broadcasts UDP packets to multiple receiver nodes over a Wi-Fi network. The receivers should log when they receive a packet. Keep the setup simple, with basic Wi-Fi configuration and no mobility."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpBroadcastExample\");\n\n// Function to log received packets\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Receiver received a broadcast packet!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"UdpBroadcastExample\", LOG_LEVEL_INFO);\n\n    int numReceivers = 3;\n    uint16_t port = 4000;\n\n    // Create nodes (1 sender + multiple receivers)\n    NodeContainer wifiNodes;\n    wifiNodes.Create(numReceivers + 1);\n\n    NodeContainer senderNode = wifiNodes.Get(0); // First node is the sender\n\n    // Set up Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"udp-broadcast-network\");\n    mac.SetType(\"ns3::AdhocWifiMac\"); // Ad hoc mode for broadcasting\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, wifiNodes);\n\n    // Mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Setup UDP Broadcast Sender\n    Ptr<Socket> senderSocket = Socket::CreateSocket(senderNode, UdpSocketFactory::GetTypeId());\n    Ipv4Address broadcastAddress(\"192.168.1.255\"); // Broadcast address\n    InetSocketAddress remote = InetSocketAddress(broadcastAddress, port);\n\n    // Schedule broadcast packet transmission\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, senderSocket, Create<Packet>(128), 0, remote);\n\n    // Setup Receivers\n    for (int i = 1; i <= numReceivers; i++) {\n        Ptr<Socket> receiverSocket = Socket::CreateSocket(wifiNodes.Get(i), UdpSocketFactory::GetTypeId());\n        receiverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n        receiverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(2.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a node acts as a relay between a client and a server using a simple UDP forwarding mechanism. The client sends a UDP message to the relay, and the relay forwards it to the server. The server logs received messages. Keep the setup minimal with point-to-point links."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpRelayExample\");\n\n// Relay function: Forward received packets to the server\nvoid RelayPacket(Ptr<Socket> relaySocket, Address serverAddress) {\n    Ptr<Packet> packet;\n    while ((packet = relaySocket->Recv())) {\n        NS_LOG_INFO(\"Relay received a packet, forwarding to server...\");\n        relaySocket->SendTo(packet, 0, serverAddress);\n    }\n}\n\nint main() {\n    LogComponentEnable(\"UdpRelayExample\", LOG_LEVEL_INFO);\n\n    uint16_t clientPort = 4000, serverPort = 5000;\n\n    // Create nodes (client, relay, server)\n    NodeContainer nodes;\n    nodes.Create(3);\n    NodeContainer client = NodeContainer(nodes.Get(0));\n    NodeContainer relay = NodeContainer(nodes.Get(1));\n    NodeContainer server = NodeContainer(nodes.Get(2));\n\n    // Create point-to-point links\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer clientToRelay = pointToPoint.Install(client.Get(0), relay.Get(0));\n    NetDeviceContainer relayToServer = pointToPoint.Install(relay.Get(0), server.Get(0));\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer clientIface = address.Assign(clientToRelay);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer serverIface = address.Assign(relayToServer);\n\n    // Setup UDP Server\n    Ptr<Socket> serverSocket = Socket::CreateSocket(server.Get(0), UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), serverPort));\n    serverSocket->SetRecvCallback([](Ptr<Socket> socket) {\n        while (socket->Recv()) {\n            NS_LOG_INFO(\"Server received a forwarded packet!\");\n        }\n    });\n\n    // Setup UDP Relay\n    Ptr<Socket> relaySocket = Socket::CreateSocket(relay.Get(0), UdpSocketFactory::GetTypeId());\n    relaySocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), clientPort));\n    relaySocket->SetRecvCallback(MakeBoundCallback(&RelayPacket, relaySocket, InetSocketAddress(serverIface.GetAddress(1), serverPort)));\n\n    // Setup UDP Client\n    Ptr<Socket> clientSocket = Socket::CreateSocket(client.Get(0), UdpSocketFactory::GetTypeId());\n    InetSocketAddress relayAddress(clientIface.GetAddress(1), clientPort);\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, clientSocket, Create<Packet>(128), 0, relayAddress);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(3.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a sensor node periodically transmits data using UDP to a sink node over a wireless LoRaWAN network. The sink node logs the received data. Keep the setup minimal, with a single sensor node and one sink."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lorawan-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LoRaSensorExample\");\n\n// Function to log received packets\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Sink received data from sensor!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"LoRaSensorExample\", LOG_LEVEL_INFO);\n\n    uint16_t port = 6000;\n\n    // Create nodes (sensor and sink)\n    NodeContainer nodes;\n    nodes.Create(2);\n    Ptr<Node> sensor = nodes.Get(0);\n    Ptr<Node> sink = nodes.Get(1);\n\n    // LoRaWAN setup\n    LoraHelper lora;\n    LoraPhyHelper phy = LoraPhyHelper::Default();\n    LorawanMacHelper mac;\n    LorawanHelper lorawan;\n    \n    NetDeviceContainer devices = lorawan.Install(lora, phy, mac, nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Setup UDP Sink (Receiver)\n    Ptr<Socket> sinkSocket = Socket::CreateSocket(sink, UdpSocketFactory::GetTypeId());\n    sinkSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    sinkSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Sensor (Sender)\n    Ptr<Socket> sensorSocket = Socket::CreateSocket(sensor, UdpSocketFactory::GetTypeId());\n    InetSocketAddress sinkAddress(interfaces.GetAddress(1), port);\n\n    // Send periodic packets (every 5 seconds)\n    for (double time = 1.0; time <= 10.0; time += 5.0) {\n        Simulator::Schedule(Seconds(time), &Socket::SendTo, sensorSocket, Create<Packet>(64), 0, sinkAddress);\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(12.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a Wi-Fi client sends UDP packets to a Wi-Fi access point (AP). The AP acts as a server and logs the received packets. Keep the setup minimal, with one client and one AP using the default 802.11n standard."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpClientServer\");\n\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"AP received a UDP packet!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"WifiUdpClientServer\", LOG_LEVEL_INFO);\n\n    uint16_t port = 5000;\n\n    // Create nodes (client and access point)\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n    Ptr<Node> client = wifiNodes.Get(0);\n    Ptr<Node> ap = wifiNodes.Get(1);\n\n    // Set up Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"wifi-network\");\n\n    // Configure AP\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(wifiPhy, wifiMac, ap);\n\n    // Configure Client\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer clientDevice = wifi.Install(wifiPhy, wifiMac, client);\n\n    // Mobility (static positions)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(NetDeviceContainer(clientDevice, apDevice));\n\n    // Setup UDP Server (AP)\n    Ptr<Socket> apSocket = Socket::CreateSocket(ap, UdpSocketFactory::GetTypeId());\n    apSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    apSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client\n    Ptr<Socket> clientSocket = Socket::CreateSocket(client, UdpSocketFactory::GetTypeId());\n    InetSocketAddress apAddress(interfaces.GetAddress(1), port);\n\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, clientSocket, Create<Packet>(64), 0, apAddress);\n    Simulator::Schedule(Seconds(2.0), &Socket::SendTo, clientSocket, Create<Packet>(64), 0, apAddress);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(3.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a network of three nodes is connected using a CSMA (Ethernet) network. One node acts as a UDP client, another as a UDP server, and the third acts as a passive relay node (forwarding traffic). The client sends data to the server via the relay node. The server logs the received packets"}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CsmaUdpRelayExample\");\n\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a UDP packet!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"CsmaUdpRelayExample\", LOG_LEVEL_INFO);\n\n    uint16_t port = 4000;\n\n    // Create nodes (client, relay, server)\n    NodeContainer nodes;\n    nodes.Create(3);\n    Ptr<Node> client = nodes.Get(0);\n    Ptr<Node> relay = nodes.Get(1);\n    Ptr<Node> server = nodes.Get(2);\n\n    // Setup CSMA network\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices = csma.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Setup UDP Server (Server Node)\n    Ptr<Socket> serverSocket = Socket::CreateSocket(server, UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client (Client Node)\n    Ptr<Socket> clientSocket = Socket::CreateSocket(client, UdpSocketFactory::GetTypeId());\n    InetSocketAddress serverAddress(interfaces.GetAddress(2), port);\n\n    // Send packets at scheduled times\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, clientSocket, Create<Packet>(128), 0, serverAddress);\n    Simulator::Schedule(Seconds(2.0), &Socket::SendTo, clientSocket, Create<Packet>(128), 0, serverAddress);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(3.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a mobile node communicates with a static node using an Ad-hoc Wi-Fi (802.11s) network. The mobile node moves in a straight line while sending UDP packets to the static node, which logs the received data."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocWifiUdpExample\");\n\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Server received a UDP packet!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"AdhocWifiUdpExample\", LOG_LEVEL_INFO);\n\n    uint16_t port = 5001;\n\n    // Create nodes (mobile client and static server)\n    NodeContainer nodes;\n    nodes.Create(2);\n    Ptr<Node> mobileNode = nodes.Get(0);\n    Ptr<Node> staticNode = nodes.Get(1);\n\n    // Configure Ad-hoc Wi-Fi (802.11s)\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211s);\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Mobility model (mobile node moves, static node stays)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\", \"Position\", Vector3DValue(Vector3D(0, 0, 0)));\n    mobility.Install(staticNode);\n\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(mobileNode);\n    mobileNode->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(5.0, 0.0, 0.0)); // Moves at 5 m/s\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Setup UDP Server (Static Node)\n    Ptr<Socket> serverSocket = Socket::CreateSocket(staticNode, UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Client (Mobile Node)\n    Ptr<Socket> clientSocket = Socket::CreateSocket(mobileNode, UdpSocketFactory::GetTypeId());\n    InetSocketAddress serverAddress(interfaces.GetAddress(1), port);\n\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, clientSocket, Create<Packet>(128), 0, serverAddress);\n    Simulator::Schedule(Seconds(2.0), &Socket::SendTo, clientSocket, Create<Packet>(128), 0, serverAddress);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(5.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a TCP client and TCP server communicate over a Point-to-Point (P2P) network with an intermediate router node. The client sends TCP packets to the server, and the server acknowledges the packets."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpRoutedExample\");\n\nint main() {\n    LogComponentEnable(\"TcpRoutedExample\", LOG_LEVEL_INFO);\n\n    // Create nodes (Client, Router, Server)\n    NodeContainer clientRouter, routerServer;\n    clientRouter.Create(2); // Client and Router\n    routerServer.Add(clientRouter.Get(1)); // Reuse Router node\n    routerServer.Create(1); // Server\n\n    // Setup Point-to-Point links\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer clientRouterDevices = p2p.Install(clientRouter);\n    NetDeviceContainer routerServerDevices = p2p.Install(routerServer);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(clientRouter);\n    internet.Install(routerServer.Get(1)); // Server\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer clientRouterInterfaces = address.Assign(clientRouterDevices);\n\n    address.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer routerServerInterfaces = address.Assign(routerServerDevices);\n\n    // Set up routing\n    Ipv4GlobalRoutingHelper::PopulateRoutingTables();\n\n    // Setup TCP Server (Server Node)\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(routerServerInterfaces.GetAddress(1), port));\n\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = sinkHelper.Install(routerServer.Get(1));\n    serverApp.Start(Seconds(0.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup TCP Client (Client Node)\n    BulkSendHelper clientHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    clientHelper.SetAttribute(\"MaxBytes\", UintegerValue(1024)); // Send 1024 bytes\n\n    ApplicationContainer clientApp = clientHelper.Install(clientRouter.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a sender transmits packets over a wireless (Wi-Fi) network to multiple receivers using multicast communication. The sender should send UDP packets, and the receivers should log the received packets."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpMulticastExample\");\n\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"Receiver received a UDP multicast packet!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"WifiUdpMulticastExample\", LOG_LEVEL_INFO);\n\n    uint16_t port = 5000;\n    Ipv4Address multicastGroup(\"225.1.2.3\");\n\n    // Create nodes (1 sender, 2 receivers)\n    NodeContainer nodes;\n    nodes.Create(3);\n    Ptr<Node> sender = nodes.Get(0);\n    Ptr<Node> receiver1 = nodes.Get(1);\n    Ptr<Node> receiver2 = nodes.Get(2);\n\n    // Setup Wi-Fi Network\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211a);\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\"); // Ad-hoc network\n\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Mobility model (static nodes)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Setup Multicast Routing\n    Ipv4StaticRoutingHelper multicastRouting;\n    Ptr<Ipv4StaticRouting> receiver1Routing = multicastRouting.GetStaticRouting(receiver1->GetObject<Ipv4>());\n    receiver1Routing->AddMulticastRoute(interfaces.GetAddress(0), multicastGroup, 1);\n\n    Ptr<Ipv4StaticRouting> receiver2Routing = multicastRouting.GetStaticRouting(receiver2->GetObject<Ipv4>());\n    receiver2Routing->AddMulticastRoute(interfaces.GetAddress(0), multicastGroup, 1);\n\n    // Setup UDP Receiver (Multicast Group Members)\n    Ptr<Socket> receiverSocket1 = Socket::CreateSocket(receiver1, UdpSocketFactory::GetTypeId());\n    receiverSocket1->Bind(InetSocketAddress(multicastGroup, port));\n    receiverSocket1->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    Ptr<Socket> receiverSocket2 = Socket::CreateSocket(receiver2, UdpSocketFactory::GetTypeId());\n    receiverSocket2->Bind(InetSocketAddress(multicastGroup, port));\n    receiverSocket2->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Sender\n    Ptr<Socket> senderSocket = Socket::CreateSocket(sender, UdpSocketFactory::GetTypeId());\n    InetSocketAddress multicastAddr(multicastGroup, port);\n    multicastAddr.SetTos(0xb8); // Best-effort traffic\n\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, senderSocket, Create<Packet>(128), 0, multicastAddr);\n    Simulator::Schedule(Seconds(2.0), &Socket::SendTo, senderSocket, Create<Packet>(128), 0, multicastAddr);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(5.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where a vehicle (moving node) communicates with a Roadside Unit (RSU) using a Vehicular Ad-hoc Network (VANET) over a Wi-Fi 802.11p (WAVE) connection. The vehicle should periodically send UDP packets to the RSU."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wave-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"VANET_80211p_Example\");\n\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"RSU received a UDP packet from the vehicle!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"VANET_80211p_Example\", LOG_LEVEL_INFO);\n\n    uint16_t port = 4000;\n\n    // Create nodes (1 Vehicle, 1 RSU)\n    NodeContainer nodes;\n    nodes.Create(2);\n    Ptr<Node> vehicle = nodes.Get(0);\n    Ptr<Node> rsu = nodes.Get(1);\n\n    // Setup 802.11p (WAVE) for VANET communication\n    YansWifiChannelHelper waveChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wavePhy = YansWifiPhyHelper::Default();\n    wavePhy.SetChannel(waveChannel.Create());\n\n    QosWaveMacHelper waveMac = QosWaveMacHelper::Default();\n    WaveHelper wave;\n    NetDeviceContainer devices = wave.Install(wavePhy, waveMac, nodes);\n\n    // Mobility model (Vehicle moves, RSU is static)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(rsu);\n\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(vehicle);\n    vehicle->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(10.0, 0.0, 0.0)); // Vehicle moves at 10 m/s\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Setup UDP Receiver (RSU)\n    Ptr<Socket> rsuSocket = Socket::CreateSocket(rsu, UdpSocketFactory::GetTypeId());\n    rsuSocket->Bind(InetSocketAddress(Ipv4Address::GetAny(), port));\n    rsuSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Sender (Vehicle)\n    Ptr<Socket> vehicleSocket = Socket::CreateSocket(vehicle, UdpSocketFactory::GetTypeId());\n    InetSocketAddress rsuAddress(interfaces.GetAddress(1), port);\n\n    Simulator::Schedule(Seconds(1.0), &Socket::SendTo, vehicleSocket, Create<Packet>(128), 0, rsuAddress);\n    Simulator::Schedule(Seconds(2.0), &Socket::SendTo, vehicleSocket, Create<Packet>(128), 0, rsuAddress);\n\n    // Run the simulation\n    Simulator::Stop(Seconds(5.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nWrite an NS-3 simulation in C++ where multiple IoT devices communicate with a central server using a Low-Power Wireless Personal Area Network (6LoWPAN) over IEEE 802.15.4. The IoT devices should send UDP packets to the server periodically."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/sixlowpan-module.h\"\n#include \"ns3/lr-wpan-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SixLowpanIoTExample\");\n\nvoid ReceivePacket(Ptr<Socket> socket) {\n    while (socket->Recv()) {\n        NS_LOG_INFO(\"IoT Server received a UDP packet from an IoT device!\");\n    }\n}\n\nint main() {\n    LogComponentEnable(\"SixLowpanIoTExample\", LOG_LEVEL_INFO);\n\n    uint16_t port = 5000;\n\n    // Create nodes (IoT Devices + Server)\n    NodeContainer nodes;\n    nodes.Create(4);  // 3 IoT devices + 1 server\n\n    Ptr<Node> server = nodes.Get(3);\n\n    // Setup IEEE 802.15.4 (Low-Power Wireless)\n    LrWpanHelper lrWpan;\n    NetDeviceContainer lrDevices = lrWpan.Install(nodes);\n\n    // Enable 6LoWPAN over IEEE 802.15.4\n    SixLowPanHelper sixlowpan;\n    NetDeviceContainer sixlowpanDevices = sixlowpan.Install(lrDevices);\n\n    // Mobility model (static nodes)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IPv6 addresses\n    Ipv6AddressHelper ipv6;\n    ipv6.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Prefix(64));\n    Ipv6InterfaceContainer interfaces = ipv6.Assign(sixlowpanDevices);\n\n    // Setup UDP Receiver (IoT Server)\n    Ptr<Socket> serverSocket = Socket::CreateSocket(server, UdpSocketFactory::GetTypeId());\n    serverSocket->Bind(Inet6SocketAddress(Ipv6Address::GetAny(), port));\n    serverSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Setup UDP Senders (IoT Devices)\n    for (uint32_t i = 0; i < 3; i++) {\n        Ptr<Socket> deviceSocket = Socket::CreateSocket(nodes.Get(i), UdpSocketFactory::GetTypeId());\n        Inet6SocketAddress serverAddress(interfaces.GetAddress(3, 1), port);\n\n        Simulator::Schedule(Seconds(1.0 + i), &Socket::SendTo, deviceSocket, Create<Packet>(64), 0, serverAddress);\n        Simulator::Schedule(Seconds(3.0 + i), &Socket::SendTo, deviceSocket, Create<Packet>(64), 0, serverAddress);\n    }\n\n    // Run the simulation\n    Simulator::Stop(Seconds(6.0));\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a simple NS-3 C++ program that demonstrates the creation of nodes. The program should create three nodes, assign them unique IDs, and print their count to verify successful creation. Keep it minimal and focused on node creation without additional networking components."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"NodeCreationExample\", LOG_LEVEL_INFO);\n\n    // Create a container to hold nodes\n    NodeContainer nodes;\n    \n    // Create 3 nodes\n    nodes.Create(3);\n\n    // Print node count\n    NS_LOG_INFO(\"Number of nodes created: \" << nodes.GetN());\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and assigns them unique node IDs. The program should iterate over the nodes and print their assigned node IDs. Keep it simple and avoid additional network configurations."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"NodeIDExample\", LOG_LEVEL_INFO);\n\n    // Create a NodeContainer and generate 5 nodes\n    NodeContainer nodes;\n    nodes.Create(5);\n\n    // Iterate through the nodes and print their IDs\n    for (uint32_t i = 0; i < nodes.GetN(); ++i) {\n        Ptr<Node> node = nodes.Get(i);\n        NS_LOG_INFO(\"Node \" << i << \" has ID: \" << node->GetId());\n    }\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and assigns them individual names using an Object Name Service (ONS). The program should then print the assigned names along with their unique node IDs. Keep the example simple and focus on node creation and naming."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/object.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"NodeNamingExample\", LOG_LEVEL_INFO);\n\n    // Create a NodeContainer and generate 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Assign names to each node using Object Name Service (ONS)\n    for (uint32_t i = 0; i < nodes.GetN(); ++i) {\n        std::ostringstream nodeName;\n        nodeName << \"Node-\" << i;\n        Names::Add(nodeName.str(), nodes.Get(i));\n\n        // Print assigned names and node IDs\n        NS_LOG_INFO(nodeName.str() << \" has ID: \" << nodes.Get(i)->GetId());\n    }\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and connects them using a Point-to-Point (P2P) link. The program should establish a basic network topology, assign unique node IDs, and print confirmation of the links established. Keep the example simple, focusing only on node creation and connectivity."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"NodeConnectionExample\", LOG_LEVEL_INFO);\n\n    // Create a container for two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Establish a Point-to-Point link between the nodes\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices = p2p.Install(nodes);\n\n    // Print confirmation of connection\n    NS_LOG_INFO(\"Created a Point-to-Point link between Node \" \n                << nodes.Get(0)->GetId() << \" and Node \" \n                << nodes.Get(1)->GetId());\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and assigns them IP addresses using an Internet Stack. The program should install the necessary network stack on each node, configure unique IP addresses, and print the assigned addresses. Keep the example simple, focusing only on node creation and IP configuration."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"NodeIPExample\", LOG_LEVEL_INFO);\n\n    // Create a container for 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Install the Internet stack on all nodes\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n\n    // Assign interfaces and print assigned IPs\n    Ipv4InterfaceContainer interfaces = address.Assign(nodes);\n    \n    for (uint32_t i = 0; i < nodes.GetN(); ++i) {\n        Ptr<Ipv4> ipv4 = nodes.Get(i)->GetObject<Ipv4>();\n        Ipv4Address ip = ipv4->GetAddress(1, 0);\n        NS_LOG_INFO(\"Node \" << i << \" assigned IP: \" << ip);\n    }\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and organizes them in a star topology. The program should assign a central node as the hub and connect peripheral nodes to it using Point-to-Point links. The program should then print confirmation of the established connections. Keep the example simple, focusing only on node creation and topology setup."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"StarTopologyExample\", LOG_LEVEL_INFO);\n\n    // Define the number of peripheral nodes\n    uint32_t numPeripheralNodes = 4;\n\n    // Create nodes: 1 central node + peripheral nodes\n    NodeContainer centralNode;\n    centralNode.Create(1);\n\n    NodeContainer peripheralNodes;\n    peripheralNodes.Create(numPeripheralNodes);\n\n    // Point-to-Point Helper\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create links from each peripheral node to the central node\n    for (uint32_t i = 0; i < numPeripheralNodes; ++i) {\n        NodeContainer link(centralNode.Get(0), peripheralNodes.Get(i));\n        NetDeviceContainer devices = p2p.Install(link);\n        NS_LOG_INFO(\"Connected Peripheral Node \" << i << \" to Central Node 0\");\n    }\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and organizes them in a linear topology. The program should connect each node sequentially using Point-to-Point links, forming a chain-like structure. The program should then print confirmation of the established connections. Keep the example simple, focusing only on node creation and topology setup."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"LinearTopologyExample\", LOG_LEVEL_INFO);\n\n    // Define the number of nodes in the chain\n    uint32_t numNodes = 5;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(numNodes);\n\n    // Point-to-Point Helper\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create links between consecutive nodes\n    for (uint32_t i = 0; i < numNodes - 1; ++i) {\n        NodeContainer link(nodes.Get(i), nodes.Get(i + 1));\n        NetDeviceContainer devices = p2p.Install(link);\n        NS_LOG_INFO(\"Connected Node \" << i << \" to Node \" << i + 1);\n    }\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and organizes them in a mesh topology. Each node should be connected to every other node using Point-to-Point links. The program should print confirmation of all established connections. Keep the example simple, focusing only on node creation and topology setup"}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"MeshTopologyExample\", LOG_LEVEL_INFO);\n\n    // Define the number of nodes in the mesh\n    uint32_t numNodes = 4;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(numNodes);\n\n    // Point-to-Point Helper\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create full mesh connections\n    for (uint32_t i = 0; i < numNodes; ++i) {\n        for (uint32_t j = i + 1; j < numNodes; ++j) {\n            NodeContainer link(nodes.Get(i), nodes.Get(j));\n            NetDeviceContainer devices = p2p.Install(link);\n            NS_LOG_INFO(\"Connected Node \" << i << \" to Node \" << j);\n        }\n    }\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and organizes them in a ring topology. The program should connect each node sequentially using Point-to-Point links and ensure that the last node connects back to the first node, forming a closed-loop structure. The program should then print confirmation of the established connections. Keep the example simple, focusing only on node creation and topology setup."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"RingTopologyExample\", LOG_LEVEL_INFO);\n\n    // Define the number of nodes in the ring\n    uint32_t numNodes = 4;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(numNodes);\n\n    // Point-to-Point Helper\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Create links between consecutive nodes\n    for (uint32_t i = 0; i < numNodes; ++i) {\n        uint32_t nextNode = (i + 1) % numNodes; // Connect last node to first\n        NodeContainer link(nodes.Get(i), nodes.Get(nextNode));\n        NetDeviceContainer devices = p2p.Install(link);\n        NS_LOG_INFO(\"Connected Node \" << i << \" to Node \" << nextNode);\n    }\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and organizes them in a tree topology. The program should have a single root node, a set of intermediate nodes, and leaf nodes, with each parent connecting to its children using Point-to-Point links. The program should then print confirmation of the established connections. Keep the example simple, focusing only on node creation and topology setup."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"TreeTopologyExample\", LOG_LEVEL_INFO);\n\n    // Define tree structure\n    uint32_t numLevels = 2;  // Number of levels in the tree\n    uint32_t branchingFactor = 2;  // Number of children per node\n    uint32_t numNodes = 1 + branchingFactor + (branchingFactor * branchingFactor); // Root + Level 1 + Level 2\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(numNodes);\n\n    // Point-to-Point Helper\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Connect root to first level nodes\n    uint32_t nodeIndex = 1;  // Start from the first child node\n    for (uint32_t i = 0; i < branchingFactor; ++i) {\n        NodeContainer link(nodes.Get(0), nodes.Get(nodeIndex));\n        p2p.Install(link);\n        NS_LOG_INFO(\"Connected Root Node 0 to Node \" << nodeIndex);\n        nodeIndex++;\n    }\n\n    // Connect first level nodes to second level nodes\n    uint32_t parentIndex = 1;\n    for (uint32_t i = 0; i < branchingFactor; ++i) {\n        for (uint32_t j = 0; j < branchingFactor; ++j) {\n            NodeContainer link(nodes.Get(parentIndex), nodes.Get(nodeIndex));\n            p2p.Install(link);\n            NS_LOG_INFO(\"Connected Node \" << parentIndex << \" to Node \" << nodeIndex);\n            nodeIndex++;\n        }\n        parentIndex++;\n    }\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ program that creates multiple nodes and organizes them in a bus topology. The program should connect all nodes sequentially to a shared channel using CSMA (Carrier Sense Multiple Access). The program should then print confirmation of the established connections. Keep the example simple, focusing only on node creation and topology setup."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/csma-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[]) {\n    // Enable logging\n    LogComponentEnable(\"BusTopologyExample\", LOG_LEVEL_INFO);\n\n    // Define the number of nodes in the bus topology\n    uint32_t numNodes = 5;\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(numNodes);\n\n    // CSMA Helper (Shared Medium)\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(5)));\n\n    // Install CSMA on all nodes\n    NetDeviceContainer devices = csma.Install(nodes);\n\n    // Log established connections\n    for (uint32_t i = 0; i < numNodes; ++i) {\n        NS_LOG_INFO(\"Node \" << i << \" connected to the shared CSMA channel.\");\n    }\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\n\"Generate a simple NS-3 C++ simulation script that sets up a basic point-to-point network with two nodes. The connection should have a bandwidth of 5 Mbps and a delay of 2 ms. Configure the nodes with an IPv4 address range of 192.168.1.0/24. One node should run a UDP echo server on port 9, while the other node should send a single packet of 1024 bytes to the server. The simulation should run for 10 seconds.\""}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple Wi-Fi network. The network should have one station (STA) and one access point (AP). Use the AARF Wi-Fi manager and configure the STA to associate with an SSID named 'ns3-wifi'. The nodes should be placed on a grid using a position allocator. Assign an IPv4 address range of 192.168.1.0/24. The AP should run a UDP echo server on port 9, and the STA should send a single packet of 1024 bytes. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    NodeContainer wifiStaNode, wifiApNode;\n    wifiStaNode.Create(1);\n    wifiApNode.Create(1);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNode);\n    mobility.Install(wifiApNode);\n\n    InternetStackHelper stack;\n    stack.Install(wifiStaNode);\n    stack.Install(wifiApNode);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer staInterface = address.Assign(staDevice);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(wifiApNode.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(apInterface.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(wifiStaNode.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple wired CSMA network with four nodes. The network should have a data rate of 100 Mbps and a propagation delay of 6560 nanoseconds. Assign an IPv4 address range of 192.168.1.0/24. The last node should act as a UDP echo server on port 9, while the first node should act as a client, sending two packets of 1024 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    NodeContainer csmaNodes;\n    csmaNodes.Create(4); // Create 4 nodes\n\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    NetDeviceContainer csmaDevices;\n    csmaDevices = csma.Install(csmaNodes);\n\n    InternetStackHelper stack;\n    stack.Install(csmaNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n\n    Ipv4InterfaceContainer interfaces = address.Assign(csmaDevices);\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(csmaNodes.Get(3)); // Server on last node\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(3), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(2));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(csmaNodes.Get(0)); // Client on first node\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for an LTE network with a single eNodeB and two UEs. The UEs should be assigned IPv4 addresses via an EPC core. The first UE should act as a UDP client sending two packets of 512 bytes each to the second UE, which should act as a UDP server on port 9. The nodes should be placed in a grid layout, and the simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    Ptr<Node> pgw = epcHelper->GetPgwNode();\n\n    NodeContainer ueNodes, enbNodes;\n    ueNodes.Create(2);  // Two UEs (User Devices)\n    enbNodes.Create(1); // One eNodeB (Base Station)\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(enbNodes);\n\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.Install(ueNodes);\n\n    NetDeviceContainer enbLteDevices = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueLteDevices = lteHelper->InstallUeDevice(ueNodes);\n\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n\n    Ipv4InterfaceContainer ueIpInterfaces = epcHelper->AssignUeIpv4Address(NetDeviceContainer(ueLteDevices));\n\n    lteHelper->Attach(ueLteDevices, enbLteDevices.Get(0));\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(ueNodes.Get(1)); // Second UE is the server\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(ueIpInterfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(2));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(ueNodes.Get(0)); // First UE is the client\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a VANET using Wi-Fi 802.11p (WAVE). Create three vehicles, each assigned a unique IP address in the 192.168.1.0/24 subnet. Use a constant velocity mobility model with vehicles moving at different speeds along the X-axis. The last vehicle should act as a UDP echo server on port 9, while the first vehicle should act as a client, sending three packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wave-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    NodeContainer vehicles;\n    vehicles.Create(3); // Create 3 vehicles (nodes)\n\n    YansWifiChannelHelper waveChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wavePhy = YansWifiPhyHelper::Default();\n    wavePhy.SetChannel(waveChannel.Create());\n\n    NqosWaveMacHelper waveMac = NqosWaveMacHelper::Default();\n    Wifi80211pHelper waveHelper = Wifi80211pHelper::Default();\n\n    NetDeviceContainer waveDevices = waveHelper.Install(wavePhy, waveMac, vehicles);\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(vehicles);\n\n    vehicles.Get(0)->GetObject<MobilityModel>()->SetPosition(Vector(0, 0, 0));\n    vehicles.Get(1)->GetObject<MobilityModel>()->SetPosition(Vector(50, 0, 0));\n    vehicles.Get(2)->GetObject<MobilityModel>()->SetPosition(Vector(100, 0, 0));\n\n    vehicles.Get(0)->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(10, 0, 0));\n    vehicles.Get(1)->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(15, 0, 0));\n    vehicles.Get(2)->GetObject<ConstantVelocityMobilityModel>()->SetVelocity(Vector(20, 0, 0));\n\n    InternetStackHelper internet;\n    internet.Install(vehicles);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(waveDevices);\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(vehicles.Get(2)); // Last vehicle is the server\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(2), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(3));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(vehicles.Get(0)); // First vehicle is the client\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a 5G NR (mmWave) network. The network should include a single gNB (base station) and two UEs (user devices). The gNB should be stationary, while the UEs should use a random walk mobility model. Assign IPv4 addresses in the 192.168.1.0/24 subnet. The second UE should act as a UDP echo server on port 9, while the first UE should act as a client, sending five packets of 1024 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/config-store-module.h\"\n#include \"ns3/mmwave-helper.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    Ptr<MmWaveHelper> mmwaveHelper = CreateObject<MmWaveHelper>();\n\n    NodeContainer gNbNodes, ueNodes;\n    gNbNodes.Create(1); // One gNB (Base Station)\n    ueNodes.Create(2);  // Two UEs (User Equipment)\n\n    MobilityHelper mobility;\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(gNbNodes);\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-10, 10, -10, 10)));\n    mobility.Install(ueNodes);\n\n    NetDeviceContainer gNbDevices = mmwaveHelper->InstallEnbDevice(gNbNodes);\n    NetDeviceContainer ueDevices = mmwaveHelper->InstallUeDevice(ueNodes);\n\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueInterfaces = address.Assign(ueDevices);\n\n    mmwaveHelper->Attach(ueDevices, gNbDevices.Get(0));\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(ueNodes.Get(1)); // Second UE as server\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(ueInterfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(ueNodes.Get(0)); // First UE as client\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Mobile Ad-Hoc Network (MANET) using the AODV routing protocol. The network should consist of five nodes, each assigned a unique IPv4 address in the 192.168.1.0/24 subnet. Nodes should move using a RandomWalk2dMobilityModel within a bounded area (-50,50,-50,50). The last node should act as a UDP echo server on port 9, while the first node should be a client sending three packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/aodv-helper.h\"\n#include \"ns3/olsr-helper.h\"\n#include \"ns3/ipv4-static-routing-helper.h\"\n#include \"ns3/ipv4-list-routing-helper.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    NodeContainer nodes;\n    nodes.Create(5); // Create 5 MANET nodes\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(nodes);\n\n    AodvHelper aodv;\n    Ipv4ListRoutingHelper list;\n    list.Add(aodv, 100);\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(list);\n    internet.Install(nodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(4)); // Last node as server\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(4), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(3));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0)); // First node as client\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Vehicular Ad-Hoc Network (VANET) using the IEEE 802.11p (WAVE) protocol. The network should consist of three vehicles, each with a unique IPv4 address in the 10.1.1.0/24 subnet. Vehicles should use the ConstantVelocityMobilityModel with speeds of 20 m/s, 15 m/s, and 25 m/s, respectively. The last vehicle should act as a UDP echo server on port 9, while the first vehicle should be a client sending five packets of 1024 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wave-helper.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    NodeContainer vehicles;\n    vehicles.Create(3); // Create 3 vehicles\n\n    YansWifiChannelHelper waveChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wavePhy = YansWifiPhyHelper::Default();\n    wavePhy.SetChannel(waveChannel.Create());\n\n    NqosWaveMacHelper waveMac = NqosWaveMacHelper::Default();\n    WaveHelper wave;\n    NetDeviceContainer devices = wave.Install(wavePhy, waveMac, vehicles);\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantVelocityMobilityModel\");\n    mobility.Install(vehicles);\n\n    Ptr<ConstantVelocityMobilityModel> mobility1 = vehicles.Get(0)->GetObject<ConstantVelocityMobilityModel>();\n    Ptr<ConstantVelocityMobilityModel> mobility2 = vehicles.Get(1)->GetObject<ConstantVelocityMobilityModel>();\n    Ptr<ConstantVelocityMobilityModel> mobility3 = vehicles.Get(2)->GetObject<ConstantVelocityMobilityModel>();\n\n    mobility1->SetVelocity(Vector(20, 0, 0)); // Vehicle 1 moves at 20 m/s\n    mobility2->SetVelocity(Vector(15, 0, 0)); // Vehicle 2 moves at 15 m/s\n    mobility3->SetVelocity(Vector(25, 0, 0)); // Vehicle 3 moves at 25 m/s\n\n    InternetStackHelper internet;\n    internet.Install(vehicles);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(vehicles.Get(2)); // Last vehicle as server\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(2), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = echoClient.Install(vehicles.Get(0)); // First vehicle as client\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Wi-Fi mesh network using the 802.11s mesh protocol. The network should consist of five nodes with unique IPv4 addresses in the 192.168.1.0/24 subnet. Nodes should use the RandomWalk2dMobilityModel within a bounded area (-50, 50, -50, 50). The last node should act as a UDP echo server on port 9, while the first node should be a client sending three packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    NodeContainer nodes;\n    nodes.Create(5); // Create 5 mesh nodes\n\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::StaWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(nodes);\n\n    MeshHelper mesh;\n    mesh.SetStackInstall(true);\n    mesh.Install(nodes);\n\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(4)); // Last node as server\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(4), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(3));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0)); // First node as client\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple LTE cellular network with a single cell. The network should consist of one eNodeB (base station) and one User Equipment (UE). The eNodeB and UE should have unique IPv4 addresses in the 10.1.1.0/24 subnet. The UE should move using the RandomWalk2dMobilityModel within a bounded area (-50, 50, -50, 50). A UDP echo server should run on the UE node on port 9, while the eNodeB node acts as the client sending ten packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create the nodes (eNodeB and UE)\n    NodeContainer enbNode;\n    enbNode.Create(1); // Create 1 eNodeB\n    NodeContainer ueNodes;\n    ueNodes.Create(1); // Create 1 UE\n\n    // Set up LTE helper and Internet stack\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<PointToPointEpcHelper> epcHelper = CreateObject<PointToPointEpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    internet.Install(enbNode);\n\n    // Set up mobility for eNodeB and UE\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(enbNode);\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(ueNodes);\n\n    // Install LTE devices (eNodeB and UE)\n    NetDeviceContainer enbDevs = lteHelper->InstallEnbDevice(enbNode);\n    NetDeviceContainer ueDevs = lteHelper->InstallUeDevice(ueNodes);\n\n    // Attach UE to the eNodeB\n    lteHelper->Attach(ueDevs.Get(0), enbDevs.Get(0));\n\n    // Set up IP addressing\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface = address.Assign(ueDevs);\n\n    // Set up a simple UDP echo server and client\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(ueNodes.Get(0)); // Install on the UE node\n    serverApps.Start(Seconds(2.0));\n    serverApps.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(ueIpIface.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(enbNode.Get(0)); // Install on the eNodeB node\n    clientApps.Start(Seconds(3.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a CSMA (Ethernet) wired network with four nodes. The nodes should be connected using a CSMA channel with a data rate of 100 Mbps and a propagation delay of 6560 nanoseconds. Each node should have a unique IPv4 address in the 192.168.1.0/24 subnet. The last node should run a UDP echo server on port 9, while the first node acts as a client sending five packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create nodes\n    NodeContainer csmaNodes;\n    csmaNodes.Create(4); // 4 devices connected via CSMA\n\n    // Set up CSMA channel\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install CSMA devices\n    NetDeviceContainer csmaDevices;\n    csmaDevices = csma.Install(csmaNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(csmaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer csmaInterfaces = address.Assign(csmaDevices);\n\n    // Set up UDP echo server on last node\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(csmaNodes.Get(3));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP echo client on first node\n    UdpEchoClientHelper echoClient(csmaInterfaces.GetAddress(3), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(csmaNodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Wi-Fi network in infrastructure mode. The network should have one access point (AP) and two station (STA) nodes using the 802.11n standard. The AP and STAs should have unique IPv4 addresses in the 192.168.1.0/24 subnet. The AP should run a UDP echo server on port 9, while one STA should act as a client sending five packets of 512 bytes each. The nodes should be placed in a grid layout, and the simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create nodes: one AP and two stations\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Configure Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n\n    // Set up Wi-Fi PHY and channel\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Configure MAC layer\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Configure station devices\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure access point (AP) device\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set mobility\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n    mobility.Install(wifiStaNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiApNode);\n    stack.Install(wifiStaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Set up UDP echo server on the AP\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(wifiApNode.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP echo client on one of the stations\n    UdpEchoClientHelper echoClient(apInterface.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(wifiStaNodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple Point-to-Point (P2P) network with two nodes. The nodes should be connected via a P2P link with a data rate of 5 Mbps and a propagation delay of 2 milliseconds. Each node should have a unique IPv4 address in the 10.1.1.0/24 subnet. The second node should run a UDP echo server on port 9, while the first node acts as a client sending five packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure Point-to-Point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install P2P devices on nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP echo server on the second node\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP echo client on the first node\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a three-node ad-hoc wireless network using the AODV routing protocol. The nodes should use the 802.11b Wi-Fi standard, be arranged in a linear layout with a 10-meter separation, and have unique IPv4 addresses in the 192.168.1.0/24 subnet. The last node should run a UDP echo server on port 9, while the first node should act as a client sending five packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ipv4-routing-helper.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create three nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Configure Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install Internet stack with AODV routing\n    AodvHelper aodv;\n    Ipv4ListRoutingHelper list;\n    list.Add(aodv, 10);\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(list);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP echo server on the last node\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(2));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP echo client on the first node\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(2), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a four-node wired LAN network using the CSMA protocol. The nodes should be connected via a CSMA switch with a data rate of 100 Mbps and a propagation delay of 6.56 microseconds. Each node should have a unique IPv4 address in the 192.168.1.0/24 subnet. The last node should run a UDP echo server on port 9, while the first node should act as a client sending ten packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create four nodes\n    NodeContainer nodes;\n    nodes.Create(4);\n\n    // Configure CSMA network\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install CSMA devices on nodes\n    NetDeviceContainer devices;\n    devices = csma.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP echo server on the last node\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(nodes.Get(3));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP echo client on the first node\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(3), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(nodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a wireless LAN (Wi-Fi) network using the 802.11n standard. The network should have three stations (STA) and one Access Point (AP). The AP should be configured with a fixed SSID 'ns3-wifi'. Each node should have a unique IPv4 address in the 192.168.1.0/24 subnet. One station should act as a UDP echo client sending five packets of 512 bytes each to the AP, which runs a UDP echo server on port 9. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create nodes (3 Stations + 1 Access Point)\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(3);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Configure Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Configure Wi-Fi helper\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Configure MAC for stations (STA)\n    WifiMacHelper macSta;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    macSta.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer staDevices;\n    staDevices = wifi.Install(phy, macSta, wifiStaNodes);\n\n    // Configure MAC for Access Point (AP)\n    WifiMacHelper macAp;\n    macAp.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, macAp, wifiApNode);\n\n    // Set mobility models\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Set up a UDP echo server on the AP\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(wifiApNode.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP echo client on one of the stations\n    UdpEchoClientHelper echoClient(apInterface.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(wifiStaNodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a wireless mesh network using the IEEE 802.11s standard. The network should consist of three mesh nodes configured with the ns-3 MeshHelper using the Dot11s stack. Nodes should be arranged in a grid layout with 5-meter spacing. Each node should have an IP address in the 10.1.1.0/24 subnet. The last node should act as a UDP echo server on port 9, while the first node should be a UDP echo client sending five packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create 3 mesh nodes\n    NodeContainer meshNodes;\n    meshNodes.Create(3);\n\n    // Configure mesh helper\n    MeshHelper mesh;\n    mesh.SetStackInstaller(\"ns3::Dot11sStack\");\n    mesh.SetSpreadInterfaceChannels(MeshHelper::SPREAD_CHANNELS);\n    mesh.SetMacType(\"ns3::MeshPointDevice\");\n    mesh.SetNumberOfInterfaces(1);\n\n    // Configure Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Install mesh devices on nodes\n    NetDeviceContainer meshDevices = mesh.Install(phy, meshNodes);\n\n    // Set mobility models (static grid layout)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(meshNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(meshNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer meshInterfaces = address.Assign(meshDevices);\n\n    // Set up a UDP echo server on the last node\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(meshNodes.Get(2));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP echo client on the first node\n    UdpEchoClientHelper echoClient(meshInterfaces.GetAddress(2), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(meshNodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple point-to-point network with two nodes connected via a wired link. The link should have a bandwidth of 10 Mbps and a delay of 2 milliseconds. The first node should act as a TCP BulkSend application transmitting unlimited data to the second node, which runs a TCP PacketSink application on port 9. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create 2 nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up a point-to-point connection\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP BulkSend application on Node 0\n    uint16_t port = 9;\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    source.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n    ApplicationContainer sourceApp = source.Install(nodes.Get(0));\n    sourceApp.Start(Seconds(1.0));\n    sourceApp.Stop(Seconds(10.0));\n\n    // Create a PacketSink application on Node 1 to receive the data\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sink.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a CSMA-based local area network with four nodes connected via a shared medium. The CSMA link should have a data rate of 100 Mbps and a delay of 1 millisecond. The third node should act as a UDP echo server on port 9, while the first node should be a UDP echo client sending five packets of 512 bytes each. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create 4 nodes\n    NodeContainer csmaNodes;\n    csmaNodes.Create(4);\n\n    // Set up a CSMA channel\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", StringValue(\"1ms\"));\n\n    // Install CSMA devices on nodes\n    NetDeviceContainer csmaDevices;\n    csmaDevices = csma.Install(csmaNodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(csmaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer csmaInterfaces = address.Assign(csmaDevices);\n\n    // Set up a UDP echo server on Node 3\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(csmaNodes.Get(3));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP echo client on Node 0\n    UdpEchoClientHelper echoClient(csmaInterfaces.GetAddress(3), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(csmaNodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Wi-Fi network with three station nodes (STAs) and one access point (AP) operating in infrastructure mode using the 802.11n standard. The STAs should have random mobility, while the AP remains stationary. Assign IP addresses in the 192.168.1.0/24 subnet. Configure a UDP echo server on the AP and a UDP echo client on one of the STAs to send five 512-byte packets at 1-second intervals. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create nodes: 3 Wi-Fi stations and 1 AP\n    NodeContainer wifiStaNodes, wifiApNode;\n    wifiStaNodes.Create(3);\n    wifiApNode.Create(1);\n\n    // Set up the Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up the Wi-Fi standard\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Configure MAC layer\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Configure STA (client) devices\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure AP (server) device\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set mobility model (stations move, AP is static)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(wifiStaNodes);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Create a UDP echo server on the AP\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApps = echoServer.Install(wifiApNode.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Create a UDP echo client on one of the stations\n    UdpEchoClientHelper echoClient(apInterface.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = echoClient.Install(wifiStaNodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Mobile Ad-Hoc Network (MANET) with 5 nodes using the AODV routing protocol. The nodes should move randomly within a 100x100 area using the Random Walk mobility model. Assign IP addresses in the 10.1.1.0/24 subnet. Create a UDP echo server on node 4 and a UDP echo client on node 0 to send five 512-byte packets at 1-second intervals. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create 5 nodes\n    NodeContainer nodes;\n    nodes.Create(5);\n\n    // Set up the mobility model for nodes (random walk)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(nodes);\n\n    // Install the AODV routing protocol on the nodes\n    AodvHelper aodv;\n    Ipv4ListRoutingHelper list;\n    list.Add(aodv, 10);\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(list);\n    internet.Install(nodes);\n\n    // Install the Internet stack on the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(nodes);\n\n    // Create a UDP application on node 0 (sender)\n    UdpEchoClientHelper client(interfaces.GetAddress(4), 9); // Node 4 as receiver\n    client.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    client.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp = client.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Create a UDP echo server on node 4 (receiver)\n    UdpEchoServerHelper server(9);\n    ApplicationContainer serverApp = server.Install(nodes.Get(4));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple LTE network with one evolved NodeB (eNB) and one User Equipment (UE). The eNB should be static, while the UE should move randomly within a 100x100 area using the Random Walk mobility model. Set the IP address for the UE and eNB. Create a Simplex UDP server on the eNB and a Simplex UDP client on the UE, where the UE sends five 512-byte packets at 1-second intervals to the eNB. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Create the eNB and UE nodes\n    NodeContainer eNBNode, ueNode;\n    eNBNode.Create(1);\n    ueNode.Create(1);\n\n    // Set up the mobility model (eNB is static, UE is moving)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(50.0),\n                                  \"DeltaY\", DoubleValue(50.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(eNBNode);\n\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(ueNode);\n\n    // Install LTE stack (eNB and UE)\n    LteHelper lteHelper;\n    InternetStackHelper internet;\n    lteHelper.Install(eNBNode);\n    lteHelper.Install(ueNode);\n\n    // Install IP stack for routing\n    Ipv4AddressHelper ipv4;\n    Ipv4InterfaceContainer ueIpIface, enbIpIface;\n    ueIpIface = lteHelper.AssignUeIpv4Address(ueNode.Get(0));\n    enbIpIface = lteHelper.AssignUeIpv4Address(eNBNode.Get(0));\n\n    // Create a Simplex UDP server on eNB (receiver)\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApps = udpServer.Install(eNBNode.Get(0));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Create a Simplex UDP client on UE (sender)\n    UdpClientHelper udpClient(enbIpIface.GetAddress(0), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApps = udpClient.Install(ueNode.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Wi-Fi network with one Access Point (AP) and three stations (STAs). The AP should be static, while the STAs should be placed in a grid layout. Use the IEEE 802.11n 5GHz standard for Wi-Fi. Set the IP address for the STAs and the AP. Create a Simplex UDP server on the AP and Simplex UDP clients on the STAs, where each STA sends five 512-byte packets at 1-second intervals to the AP. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n\n    // Set the number of stations\n    uint32_t numSta = 3;\n\n    // Create nodes: 1 AP and several STAs\n    NodeContainer apNode, staNodes;\n    apNode.Create(1);\n    staNodes.Create(numSta);\n\n    // Set up the Wi-Fi devices\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"wifi-network\");\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"BeaconInterval\", TimeValue(Seconds(2)));\n\n    WifiDeviceHelper wifiDevices;\n    wifiDevices.SetDeviceAttribute(\"WifiPhy\", PointerValue(&phy));\n    NetDeviceContainer apDevice = wifiDevices.Install(apNode);\n    NetDeviceContainer staDevices = wifiDevices.Install(staNodes);\n\n    // Set mobility model (static AP and random STAs)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(apNode);\n    mobility.Install(staNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(apNode);\n    internet.Install(staNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = ipv4.Assign(staDevices);\n    Ipv4InterfaceContainer apInterfaces = ipv4.Assign(apDevice);\n\n    // Create a Simplex UDP server on AP\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(apNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create Simplex UDP clients on STAs\n    UdpClientHelper udpClient(apInterfaces.GetAddress(0), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < numSta; i++)\n    {\n        clientApps.Add(udpClient.Install(staNodes.Get(i)));\n    }\n\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a 5G NR network with one gNodeB (5G base station) and one User Equipment (UE). The gNodeB should be static, while the UE should be placed randomly within a 100x100 area using the Random Walk mobility model. Set up the NR network with appropriate devices and assign IP addresses. Create a TCP server on the gNodeB and a TCP client on the UE. The UE should send five 512-byte packets at 1-second intervals to the gNodeB. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ndnSIM-module.h\"\n#include \"ns3/nr-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    // Set the simulation time resolution\n    Time::SetResolution(Time::NS);\n\n    // Create nodes: one gNB (evolved NodeB) and one UE (User Equipment)\n    NodeContainer gnbNode, ueNode;\n    gnbNode.Create(1);\n    ueNode.Create(1);\n\n    // Set up the mobility model (static gNB and random UE)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(50.0),\n                                  \"DeltaY\", DoubleValue(50.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(gnbNode);\n\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=100.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(ueNode);\n\n    // Set up the 5G NR module (gNB and UE)\n    NrHelper nrHelper;\n    Ptr<NrNetDevice> gnbDevice = nrHelper.Install(gnbNode.Get(0));\n    Ptr<NrNetDevice> ueDevice = nrHelper.Install(ueNode.Get(0));\n\n    // Install IP stack for routing\n    InternetStackHelper internet;\n    internet.Install(gnbNode);\n    internet.Install(ueNode);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface, gnbIpIface;\n    ueIpIface = ipv4.Assign(ueDevice->GetObject<NetDevice>());\n    gnbIpIface = ipv4.Assign(gnbDevice->GetObject<NetDevice>());\n\n    // Set up TCP server on the gNB\n    uint16_t port = 9;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(gnbNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on the UE\n    TcpClientHelper tcpClient(gnbIpIface.GetAddress(0), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp = tcpClient.Install(ueNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple LTE network with one eNodeB and one User Equipment (UE). The eNodeB should be static, while the UE should move randomly within a 50x50 area using the Random Walk mobility model. Set up a basic LTE communication system with IP address assignment and install applications for HTTP communication. The eNodeB should have a UDP server running on port 80, and the UE should act as an HTTP client, sending 5 packets at 1-second intervals. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time resolution\n    Time::SetResolution(Time::NS);\n\n    // Create nodes: one eNodeB and one UE\n    NodeContainer enbNode, ueNode;\n    enbNode.Create(1);\n    ueNode.Create(1);\n\n    // Set up the LTE helper\n    LteHelper lteHelper;\n    Ptr<NrCellularNetDevice> enbDevice = lteHelper.InstallEnbDevice(enbNode.Get(0));\n    Ptr<NrCellularNetDevice> ueDevice = lteHelper.InstallUeDevice(ueNode.Get(0));\n\n    // Install IP stack for routing\n    InternetStackHelper internet;\n    internet.Install(enbNode);\n    internet.Install(ueNode);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface, enbIpIface;\n    ueIpIface = ipv4.Assign(ueDevice->GetObject<NetDevice>());\n    enbIpIface = ipv4.Assign(enbDevice->GetObject<NetDevice>());\n\n    // Set up the HTTP server on the eNodeB\n    uint16_t port = 80;\n    UdpServerHelper httpServer(port);\n    ApplicationContainer serverApp = httpServer.Install(enbNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the HTTP client on the UE\n    UdpClientHelper httpClient(enbIpIface.GetAddress(0), port);\n    httpClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    httpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    httpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = httpClient.Install(ueNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set the mobility model for the eNodeB and UE\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(enbNode);\n\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 50, 0, 50)));\n    mobility.Install(ueNode);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a Wi-Fi network with one Access Point (AP) and three Client Stations (STA). The AP should be static, and the STAs should move randomly within a 50x50 area using the Random Walk mobility model. Set up the Wi-Fi devices with a common SSID and assign IP addresses. The AP should have a UDP server running on port 9, and the STAs should act as UDP clients, sending 5 packets at 1-second intervals. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    // Set the simulation time resolution\n    Time::SetResolution(Time::NS);\n\n    // Create nodes: one Access Point (AP) and three Client Stations (STA)\n    NodeContainer apNode, staNodes;\n    apNode.Create(1);\n    staNodes.Create(3);\n\n    // Set up the Wi-Fi helper\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    // Install Wi-Fi devices on the AP and STAs\n    NetDeviceContainer apDevice, staDevices;\n    apDevice = wifiHelper.Install(phy, mac, apNode);\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    staDevices = wifiHelper.Install(phy, mac, staNodes);\n\n    // Install IP stack for routing\n    InternetStackHelper internet;\n    internet.Install(apNode);\n    internet.Install(staNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apIpIface, staIpIface;\n    apIpIface = ipv4.Assign(apDevice);\n    staIpIface = ipv4.Assign(staDevices);\n\n    // Set up a UDP server on the Access Point (AP)\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(apNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP clients on the Stations (STA)\n    UdpClientHelper udpClient(apIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < 3; ++i)\n    {\n        clientApps.Add(udpClient.Install(staNodes.Get(i)));\n    }\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Set mobility model for AP and STAs\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(apNode);\n\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 50, 0, 50)));\n    mobility.Install(staNodes);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a simple 5G NR network with one gNodeB (5G base station) and two UEs. The UEs should be using a random walk mobility model within a 50x50 area. Set up the network devices, assign IP addresses, and configure TCP communication. The first UE will act as a TCP client, sending packets to a server running on the second UE. The simulation should run for 10 seconds, and the server should be listening on port 8080."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ue-phy-simulator.h\"\n#include \"ns3/gnb-phy-simulator.h\"\n#include \"ns3/nr-module.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time resolution\n    Time::SetResolution(Time::NS);\n\n    // Create nodes: one gNodeB and two UEs\n    NodeContainer gnbNode, ueNodes;\n    gnbNode.Create(1);\n    ueNodes.Create(2);\n\n    // Set up the 5G NR Helper\n    NrHelper nrHelper;\n    Ptr<NrNetDevice> gnbDevice = nrHelper.InstallGnbDevice(gnbNode.Get(0));\n    Ptr<NrNetDevice> ueDevice1 = nrHelper.InstallUeDevice(ueNodes.Get(0));\n    Ptr<NrNetDevice> ueDevice2 = nrHelper.InstallUeDevice(ueNodes.Get(1));\n\n    // Install IP stack for routing\n    InternetStackHelper internet;\n    internet.Install(gnbNode);\n    internet.Install(ueNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer gnbIpIface, ueIpIface;\n    gnbIpIface = ipv4.Assign(gnbDevice);\n    ueIpIface = ipv4.Assign(ueDevice1);\n    ipv4.SetBase(\"10.0.1.0\", \"255.255.255.0\");\n    ipv4.Assign(ueDevice2);\n\n    // Set up the TCP server on UE1 (client side)\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(ueNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the TCP client on UE2 (server side)\n    TcpClientHelper tcpClient(gnbIpIface.GetAddress(0), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = tcpClient.Install(ueNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set mobility model for gNodeB and UEs\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(gnbNode);\n\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 50, 0, 50)));\n    mobility.Install(ueNodes);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for an LTE network with one eNodeB (LTE base station) and three UEs. The eNodeB should have a UDP server running on port 9, and the UEs should act as UDP clients, sending 10 packets at 1-second intervals. The simulation should run for 10 seconds, and the UEs should move randomly in a 50x50 area using the random walk mobility model."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nint main(int argc, char *argv[])\n{\n    // Set simulation time resolution\n    Time::SetResolution(Time::NS);\n\n    // Create nodes: one eNodeB and three UEs\n    NodeContainer eNodeBNode, ueNodes;\n    eNodeBNode.Create(1);\n    ueNodes.Create(3);\n\n    // Set up LTE helper\n    LteHelper lteHelper;\n    Ptr<LteEnbNetDevice> enbDevice = lteHelper.InstallEnbDevice(eNodeBNode.Get(0));\n    Ptr<LteUeNetDevice> ueDevice1 = lteHelper.InstallUeDevice(ueNodes.Get(0));\n    Ptr<LteUeNetDevice> ueDevice2 = lteHelper.InstallUeDevice(ueNodes.Get(1));\n    Ptr<LteUeNetDevice> ueDevice3 = lteHelper.InstallUeDevice(ueNodes.Get(2));\n\n    // Install IP stack for routing\n    InternetStackHelper internet;\n    internet.Install(eNodeBNode);\n    internet.Install(ueNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer enbIpIface, ueIpIface;\n    enbIpIface = ipv4.Assign(enbDevice);\n    ueIpIface = ipv4.Assign(ueDevice1);\n    ipv4.SetBase(\"10.0.1.0\", \"255.255.255.0\");\n    ipv4.Assign(ueDevice2);\n    ipv4.SetBase(\"10.0.2.0\", \"255.255.255.0\");\n    ipv4.Assign(ueDevice3);\n\n    // Set up the UDP server on eNodeB\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(eNodeBNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP clients on the UEs\n    UdpClientHelper udpClient(enbIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps;\n    clientApps.Add(udpClient.Install(ueNodes.Get(0)));\n    clientApps.Add(udpClient.Install(ueNodes.Get(1)));\n    clientApps.Add(udpClient.Install(ueNodes.Get(2)));\n\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Set mobility model for eNodeB and UEs\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(eNodeBNode);\n\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0.0|Max=50.0]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 50, 0, 50)));\n    mobility.Install(ueNodes);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a CSMA (Ethernet-based) network with four nodes. The first node should act as a TCP server on port 8080, while the other three nodes should be TCP clients sending data to the server at 5 Mbps. The CSMA network should have a 100 Mbps data rate with a propagation delay of 6560 ns. The simulation should run for 10 seconds, and packet capture (PCAP) should be enabled for analysis."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CsmaTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"CsmaTcpExample\", LOG_LEVEL_INFO);\n\n    // Create CSMA nodes\n    NodeContainer csmaNodes;\n    csmaNodes.Create(4);\n\n    // Set up CSMA channel\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install CSMA devices on nodes\n    NetDeviceContainer csmaDevices;\n    csmaDevices = csma.Install(csmaNodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(csmaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer csmaInterfaces = address.Assign(csmaDevices);\n\n    // Set up a TCP server on node 0\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(csmaInterfaces.GetAddress(0), port));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = sinkHelper.Install(csmaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP clients on nodes 1, 2, and 3\n    OnOffHelper clientHelper(\"ns3::TcpSocketFactory\", serverAddress);\n    clientHelper.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    clientHelper.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    clientHelper.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    clientHelper.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 1; i < 4; ++i)\n    {\n        clientApps.Add(clientHelper.Install(csmaNodes.Get(i)));\n    }\n\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable tracing\n    csma.EnablePcap(\"csma-tcp\", csmaDevices.Get(1), true);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation script for a WiFi network with one access point (AP) and three station (STA) nodes. The AP should act as a UDP server on port 4000, while the station nodes should be UDP clients sending packets at 512 bytes every 10ms. The network should use 802.11g WiFi, and the STAs should have random mobility within a 50x50 area. The simulation should last 10 seconds, with PCAP tracing enabled for the AP."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WiFiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"WiFiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: 1 Access Point (AP) and 3 Stations (STA)\n    NodeContainer wifiStaNodes, wifiApNode;\n    wifiStaNodes.Create(3);\n    wifiApNode.Create(1);\n\n    // Set up WiFi PHY and MAC layer\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211g);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Set up STAs (Stations)\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Set up AP (Access Point)\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set mobility for AP and STAs\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(wifiStaNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Set up a UDP server on the Access Point\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP clients on the stations\n    UdpClientHelper udpClient(apInterface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps;\n    for (uint32_t i = 0; i < wifiStaNodes.GetN(); ++i)\n    {\n        clientApps.Add(udpClient.Install(wifiStaNodes.Get(i)));\n    }\n\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Enable packet capture for analysis\n    phy.EnablePcap(\"wifi-udp\", apDevice.Get(0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a point-to-point network with two nodes. The link should have a data rate of 5 Mbps and a delay of 2 ms. One node should act as a TCP bulk sender, and the other should act as a TCP sink on port 9. The simulation should run for 10 seconds, with PCAP tracing enabled."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"TcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure a Point-to-Point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a TCP sink on Node 1\n    uint16_t port = 9;\n    Address sinkAddress(InetSocketAddress(interfaces.GetAddress(1), port));\n    PacketSinkHelper packetSinkHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    ApplicationContainer sinkApp = packetSinkHelper.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(0.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Set up a TCP bulk sender on Node 0\n    BulkSendHelper bulkSendHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    bulkSendHelper.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n\n    ApplicationContainer sourceApp = bulkSendHelper.Install(nodes.Get(0));\n    sourceApp.Start(Seconds(1.0));\n    sourceApp.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing for debugging\n    pointToPoint.EnablePcapAll(\"tcp-p2p\");\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating an LTE network with one eNodeB and three UE nodes. The UE nodes should be mobile within a 100x100 area, while the eNodeB remains stationary. UE 0 should act as a UDP server on port 5000, while UE 1 should be a UDP client sending 512-byte packets every 10ms. The LTE network should assign IP addresses to the UEs, and PCAP tracing should be enabled. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteBasicSimulation\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"LteBasicSimulation\", LOG_LEVEL_INFO);\n\n    // Create LTE eNodeB and UE nodes\n    NodeContainer ueNodes, enbNode;\n    ueNodes.Create(3);\n    enbNode.Create(1);\n\n    // Set up mobility models\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(enbNode);\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-100, 100, -100, 100)));\n    mobility.Install(ueNodes);\n\n    // Install LTE module\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    NetDeviceContainer enbDevice = lteHelper->InstallEnbDevice(enbNode);\n    NetDeviceContainer ueDevices = lteHelper->InstallUeDevice(ueNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n\n    // Assign IP addresses\n    Ipv4InterfaceContainer ueInterfaces = lteHelper->AssignUeIpv4Address(NetDeviceContainer(ueDevices));\n\n    // Attach UE nodes to eNodeB\n    for (uint32_t i = 0; i < ueNodes.GetN(); ++i)\n    {\n        lteHelper->Attach(ueDevices.Get(i), enbDevice.Get(0));\n    }\n\n    // Set up a UDP server on UE 0\n    uint16_t port = 5000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ueNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up a UDP client on UE 1 sending to UE 0\n    UdpClientHelper udpClient(ueInterfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = udpClient.Install(ueNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing\n    lteHelper->EnablePcapAll(\"lte-basic\");\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a Mobile Ad Hoc Network (MANET) with five nodes using AODV routing. The nodes should move randomly using the RandomWaypointMobilityModel with a speed of 5 m/s and a pause time of 2 seconds. The network should use 802.11b WiFi for communication. Node 0 should be a UDP client sending 512-byte packets every 50ms to Node 4, which acts as a UDP server on port 4000. The simulation should run for 20 seconds, with PCAP tracing enabled."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ManetAodvExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"ManetAodvExample\", LOG_LEVEL_INFO);\n\n    // Create 5 mobile nodes\n    NodeContainer nodes;\n    nodes.Create(5);\n\n    // Configure WiFi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", StringValue(\"ns3::ConstantRandomVariable[Constant=5.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=2.0]\"),\n                              \"PositionAllocator\", StringValue(\"ns3::GridPositionAllocator\"));\n    mobility.Install(nodes);\n\n    // Install Internet stack with AODV routing\n    AodvHelper aodv;\n    Ipv4StaticRoutingHelper staticRouting;\n    Ipv4ListRoutingHelper list;\n    list.Add(staticRouting, 0);\n    list.Add(aodv, 10);\n\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(list);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a UDP server on Node 4\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(4));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Set up a UDP client on Node 0 sending to Node 4\n    UdpClientHelper udpClient(interfaces.GetAddress(4), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(50)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(20.0));\n\n    // Enable PCAP tracing\n    wifiPhy.EnablePcap(\"manet-aodv\", devices);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a 5G NR network with one gNB (base station) and two UE nodes using the mmWave module. The UEs should move randomly within a 50x50 area, while the gNB remains stationary. One UE should act as a UDP server on port 5001, while the other should be a UDP client, sending 1024-byte packets every 10ms. The simulation should run for 10 seconds, with PCAP tracing enabled."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-helper.h\"\n#include \"ns3/mmwave-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"NrMmWaveExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"NrMmWaveExample\", LOG_LEVEL_INFO);\n\n    // Create gNB (base station) and UE nodes\n    NodeContainer ueNodes, gnbNode;\n    ueNodes.Create(2);\n    gnbNode.Create(1);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(gnbNode);\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(ueNodes);\n\n    // Install NR mmWave module\n    Ptr<MmWaveHelper> mmWaveHelper = CreateObject<MmWaveHelper>();\n    NetDeviceContainer gnbDevice = mmWaveHelper->InstallGnbDevice(gnbNode);\n    NetDeviceContainer ueDevices = mmWaveHelper->InstallUeDevice(ueNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n\n    // Assign IP addresses\n    Ipv4InterfaceContainer ueInterfaces = mmWaveHelper->AssignUeIpv4Address(NetDeviceContainer(ueDevices));\n\n    // Attach UE nodes to gNB\n    for (uint32_t i = 0; i < ueNodes.GetN(); ++i)\n    {\n        mmWaveHelper->Attach(ueDevices.Get(i), gnbDevice.Get(0));\n    }\n\n    // Set up UDP traffic\n    uint16_t port = 5001;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ueNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    UdpClientHelper udpClient(ueInterfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(ueNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing\n    mmWaveHelper->EnablePcapAll(\"nr-mmwave\");\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a Wi-Fi 802.11ac network with one Access Point (AP) and two Wi-Fi stations (STAs). The AP is stationary, while the STAs move randomly within a 50x50 area. One STA acts as a TCP server on port 5000, while the other acts as a TCP client, sending 1024-byte packets at 100Mbps. The simulation should run for 10 seconds, with PCAP tracing enabled."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"WifiTcpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: 1 AP + 2 Stations (STAs)\n    NodeContainer wifiStaNodes, wifiApNode;\n    wifiStaNodes.Create(2);\n    wifiApNode.Create(1);\n\n    // Configure Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Configure Wi-Fi standard\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211ac);\n    wifi.SetRemoteStationManager(\"ns3::ConstantRateWifiManager\",\n                                 \"DataMode\", StringValue(\"VhtMcs9\"),\n                                 \"ControlMode\", StringValue(\"VhtMcs0\"));\n\n    // Configure MAC layer\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-80211ac\");\n\n    // Configure STA devices\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure AP device\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Setup mobility\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(wifiStaNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(wifiStaNodes);\n    internet.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = ipv4.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = ipv4.Assign(apDevice);\n\n    // Setup TCP server on STA 1\n    uint16_t port = 5000;\n    PacketSinkHelper tcpServer(\"ns3::TcpSocketFactory\",\n                               InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = tcpServer.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup TCP client on STA 2\n    OnOffHelper tcpClient(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(staInterfaces.GetAddress(0), port));\n    tcpClient.SetAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(wifiStaNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing\n    phy.EnablePcapAll(\"wifi-tcp\");\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a Point-to-Point (P2P) network with two nodes connected by a 10Mbps link with a 2ms delay. Node 1 should act as a TCP server on port 5000, while Node 0 should act as a TCP client sending 1024-byte packets at 5Mbps. The simulation should run for 10 seconds, with PCAP tracing enabled."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"P2PTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"P2PTcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure Point-to-Point (P2P) link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install P2P devices\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Setup TCP server on Node 1\n    uint16_t port = 5000;\n    PacketSinkHelper tcpServer(\"ns3::TcpSocketFactory\",\n                               InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup TCP client on Node 0\n    OnOffHelper tcpClient(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(interfaces.GetAddress(1), port));\n    tcpClient.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing\n    pointToPoint.EnablePcapAll(\"p2p-tcp\");\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating an LTE network with one eNodeB (base station) and one UE (User Equipment). The UE should be randomly moving within a 100x100 area, while the eNodeB remains stationary. The UE should act as a UDP server on port 5000, and the eNodeB should act as a UDP client sending 1024-byte packets every 200ms. The simulation should run for 10 seconds, with LTE PHY, MAC, and RLC tracing enabled."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteBasicExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"LteBasicExample\", LOG_LEVEL_INFO);\n\n    // Create LTE components: eNodeB and UE\n    NodeContainer ueNode, enbNode;\n    ueNode.Create(1);\n    enbNode.Create(1);\n\n    // Configure LTE module\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n\n    // Install LTE devices on UE and eNodeB\n    NetDeviceContainer enbDevice = lteHelper->InstallEnbDevice(enbNode);\n    NetDeviceContainer ueDevice = lteHelper->InstallUeDevice(ueNode);\n\n    // Configure mobility for eNodeB (fixed) and UE (mobile)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(enbNode);\n\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-100, 100, -100, 100)));\n    mobility.Install(ueNode);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(ueNode);\n\n    // Assign IP addresses\n    Ipv4InterfaceContainer ueIpIface = lteHelper->AssignUeIpv4Address(NetDeviceContainer(ueDevice));\n\n    // Attach UE to eNodeB\n    lteHelper->Attach(ueDevice, enbDevice.Get(0));\n\n    // Setup UDP server on UE\n    uint16_t port = 5000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ueNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup UDP client on eNodeB\n    UdpClientHelper udpClient(ueIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(200)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(enbNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable PCAP tracing\n    lteHelper->EnablePhyTraces();\n    lteHelper->EnableMacTraces();\n    lteHelper->EnableRlcTraces();\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a Mobile Ad Hoc Network (MANET) with 10 nodes using AODV routing protocol. The nodes should move randomly within a 500m x 500m area at 5 m/s, with a 2-second pause time. The network should use WiFi (802.11b, Ad Hoc mode). One node should act as a UDP server on port 4000, while another node should act as a UDP client sending 1024-byte packets every second. The simulation should run for 20 seconds, with PCAP tracing enabled."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ManetAodvExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"ManetAodvExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(10);\n\n    // Configure WiFi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Install devices\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Configure mobility\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"Speed\", StringValue(\"ns3::ConstantRandomVariable[Constant=5.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=2.0]\"),\n                              \"PositionAllocator\", StringValue(\"ns3::RandomRectanglePositionAllocator[MinX=0.0|MinY=0.0|MaxX=500.0|MaxY=500.0]\"));\n    mobility.Install(nodes);\n\n    // Install Internet stack with AODV\n    AodvHelper aodv;\n    InternetStackHelper internet;\n    internet.SetRoutingHelper(aodv);\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on last node\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(9));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Set up UDP client on first node\n    UdpClientHelper udpClient(interfaces.GetAddress(9), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(50));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(20.0));\n\n    // Enable tracing\n    phy.EnablePcap(\"manet-aodv\", devices);\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a 5G NR (New Radio) network with one gNB (base station) and one UE (user equipment). The gNB serves as the base station and the UE sends 512-byte UDP packets to the gNB every 500ms. The simulation should run for 10 seconds. The 5G NR module should be used for the radio access network, and the Evolved Packet Core (EPC) should be implemented for packet forwarding. Set up mobility so the gNB is stationary, and the UE sends data while moving."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/epc-helper.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/nr-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Nr5GExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"Nr5GExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: gNB (Base Station) and UE (User Equipment)\n    NodeContainer gNbNode, ueNode;\n    gNbNode.Create(1);\n    ueNode.Create(1);\n\n    // Create EPC (Evolved Packet Core) helper and install it\n    Ptr<EpcHelper> epcHelper = CreateObject<EpcHelper>();\n    Ptr<NrHelper> nrHelper = CreateObject<NrHelper>();\n\n    // Install NR stack\n    nrHelper->Install(gNbNode);\n    nrHelper->Install(ueNode);\n\n    // Setup mobility for gNB and UE\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(gNbNode);\n    mobility.Install(ueNode);\n\n    // Install Internet Stack (IP) on UE\n    InternetStackHelper internet;\n    internet.Install(ueNode);\n\n    // Setup UE and gNB network interface\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpInterface = ipv4.Assign(ueNode);\n\n    // Configure and install applications\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(gNbNode);\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Setup UDP client on UE to send data to gNB\n    UdpClientHelper udpClient(ueIpInterface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(500)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp = udpClient.Install(ueNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a TCP connection between two nodes over a point-to-point link. The first node should act as the TCP client, and the second node should act as the TCP server. The client should send UDP packets to the server with a packet size of 1024 bytes, a maximum of 100 packets, and an interval of 100ms. The link should have a data rate of 5 Mbps and a delay of 2ms. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpConnectionExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set default values for command line arguments\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"TcpConnectionExample\", LOG_LEVEL_INFO);\n\n    // Create the nodes\n    NodeContainer nodes;\n    nodes.Create(2); // Create two nodes\n\n    // Set up point-to-point link between the two nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack on the nodes\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up the TCP server on the second node\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1)); // Second node as server\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the TCP client on the first node\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port); // Connecting to the second node\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0)); // First node as client\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Wi-Fi mesh network using Ad-Hoc mode with 5 nodes. Each node should communicate with the others using UDP packets. Set up a UDP server on the last node and a UDP client on the first node. The Wi-Fi nodes should use the AarfWifiManager for station management and have random mobility. The UDP client sends packets to the UDP server with a packet size of 1024 bytes, a maximum of 100 packets, and an interval of 100ms. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiMeshUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set default values for command line arguments\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"WifiMeshUdpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the Wi-Fi mesh network\n    NodeContainer wifiNodes;\n    wifiNodes.Create(5); // Create 5 Wi-Fi nodes\n\n    // Set up Wi-Fi Mesh Helper\n    WifiMeshHelper wifiMesh;\n    wifiMesh.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up Wi-Fi MAC and PHY attributes\n    MeshHelper meshHelper;\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns3-mesh-ssid\");\n    wifiMac.SetType(\"ns3::AdhocWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer meshDevices = wifiMesh.Install(wifiPhy, wifiMac, wifiNodes);\n\n    // Set up mobility model for the nodes\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack on the nodes\n    InternetStackHelper internet;\n    internet.Install(wifiNodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(meshDevices);\n\n    // Set up the UDP server on the last node (destination)\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiNodes.Get(4)); // Last node\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the first node (source)\n    UdpClientHelper udpClient(interfaces.GetAddress(4), port); // Sending to last node\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(wifiNodes.Get(0)); // First node\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate an LTE network with one eNodeB (base station) and one UE (user equipment). The eNodeB and UE should communicate using the LTE interface. Set up a UDP server on the UE and a UDP client on the eNodeB, with a data transfer interval of 100ms and a packet size of 1024 bytes. The simulation should run for 10 seconds. The eNodeB should be stationary, and the UE should have random mobility."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/epc-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set default values for command line arguments\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"LteUdpExample\", LOG_LEVEL_INFO);\n\n    // Create the nodes\n    NodeContainer ueNodes, enbNodes;\n    enbNodes.Create(1); // One eNodeB\n    ueNodes.Create(1);  // One UE\n\n    // Set up LTE helper and EPC helper\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<EpcHelper> epcHelper = CreateObject<EpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(enbNodes); // eNodeB position\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\");\n    mobility.Install(ueNodes); // UE position\n\n    // Install LTE devices\n    NetDeviceContainer enbDevs = lteHelper->InstallEnbDevice(enbNodes);\n    NetDeviceContainer ueDevs = lteHelper->InstallUeDevice(ueNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    internet.Install(enbNodes);\n\n    // Assign IP addresses to UE and eNodeB devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface = ipv4.Assign(ueDevs);\n\n    // Attach the UE to the eNodeB\n    lteHelper->Attach(ueDevs.Get(0), enbDevs.Get(0));\n\n    // Set up the UDP server on the UE (acting as the receiver)\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ueNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the eNodeB (acting as the sender)\n    UdpClientHelper udpClient(ueIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(enbNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Wi-Fi network with one Access Point (AP) and three Stations (STAs). A UDP server should be installed on the Access Point, and a UDP client should be installed on one of the stations. The stations should have random mobility while the Access Point remains stationary. The simulation should run for 10 seconds, and the Wi-Fi protocol should be used with AarfWifiManager. The link should have a constant position for the AP and random walk mobility for the STAs. The UDP client sends packets to the UDP server during the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"WifiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: one AP and three STAs\n    NodeContainer wifiNodes;\n    wifiNodes.Create(4); // 1 AP and 3 STAs\n\n    // Set up Wi-Fi Helper\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up Wi-Fi MAC and PHY attributes\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns3-ssid\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices = wifi.Install(wifiPhy, wifiMac, wifiNodes.Get(1, 2, 3));\n\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(wifiPhy, wifiMac, wifiNodes.Get(0));\n\n    // Set up mobility model for AP and STAs\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes.Get(0)); // AP position\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\");\n    mobility.Install(wifiNodes.Get(1, 2, 3)); // STA positions\n\n    // Install Internet stack on all nodes\n    InternetStackHelper internet;\n    internet.Install(wifiNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = ipv4.Assign(apDevice);\n\n    // Set up UDP server on the Access Point\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiNodes.Get(0)); // AP as server\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on one of the STAs\n    UdpClientHelper udpClient(apInterface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(wifiNodes.Get(1)); // STA as client\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a TCP connection between two nodes over a Point-to-Point link. Use the TCP NewReno protocol for the connection. The script should measure the network throughput using a FlowMonitor and capture the FlowMonitor output in an XML file. The link between the nodes should have a 5Mbps data rate and 2ms delay. The simulation should run for 10 seconds, and the TCP server should be installed on Node 1, while the TCP client should be installed on Node 0."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpConnectionExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"TcpConnectionExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Point-to-Point link between nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack on nodes\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up TCP server on Node 1\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1)); // Node 1 as server\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on Node 0\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0)); // Node 0 as client\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up FlowMonitor to track throughput\n    FlowMonitorHelper flowMonitorHelper;\n    Ptr<FlowMonitor> flowMonitor = flowMonitorHelper.InstallAll();\n\n    // Run simulation\n    Simulator::Run();\n\n    // Display FlowMonitor results\n    flowMonitor->CheckForLostPackets();\n    flowMonitor->SerializeToXmlFile(\"tcp_connection_flowmonitor.xml\", true, true);\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a mobile LTE network with two eNodeBs (base stations) and one user equipment (UE). The UE performs TCP data transfer while moving between the two eNodeBs. The simulation should demonstrate handover as the UE moves, and it should run for 10 seconds with a UDP server on the first eNodeB and a UDP client on the UE. The mobility of the UE should be modeled with a random walk between the eNodeBs. The LTE stack should be installed, and the handover should occur during the data transfer."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/epc-helper.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"LteTcpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: two eNodeBs (base stations) and one UE (user equipment)\n    NodeContainer eNodeBs, ueNodes;\n    eNodeBs.Create(2);\n    ueNodes.Create(1);\n\n    // Create EPC helper and LTE helper\n    Ptr<EpcHelper> epcHelper = CreateObject<EpcHelper>();\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n\n    // Install LTE stack\n    lteHelper->Install(eNodeBs);\n    lteHelper->Install(ueNodes);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(eNodeBs);\n\n    // Set mobility for UE to move between eNodeBs\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\");\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(50.0),\n                                  \"DeltaY\", DoubleValue(50.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.Install(ueNodes);\n\n    // Install Internet stack on UE\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n\n    // Assign IP addresses to the LTE interfaces\n    Ipv4InterfaceContainer ueIpIface = epcHelper->AssignUeIpv4Address(DevicesContainer(ueNodes));\n\n    // Install applications on UE and eNodeB\n    uint16_t port = 8080;\n    ApplicationContainer serverApp;\n    UdpServerHelper udpServer(port);\n    serverApp = udpServer.Install(eNodeBs.Get(0)); // eNodeB 1 as server\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    UdpClientHelper udpClient(ueIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp = udpClient.Install(ueNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Handover between two eNodeBs during the simulation\n    lteHelper->ActivateHandover(ueNodes.Get(0), eNodeBs.Get(0), eNodeBs.Get(1));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a Wi-Fi network with two nodes. The first node (Node A) sends 128-byte UDP packets to the second node (Node B) every 100ms. The simulation should run for 10 seconds. Use 802.11 Wi-Fi communication and set up the nodes with constant position mobility. Enable PCAP tracing for Wi-Fi communication, and install an UDP server on Node B and a UDP client on Node A."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"WifiExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Setup Wi-Fi helper\n    WifiHelper wifiHelper;\n    wifiHelper.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Setup Wi-Fi PHY and MAC layers\n    YansWifiPhyHelper wifiPhyHelper = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannelHelper = YansWifiChannelHelper::Default();\n    wifiPhyHelper.SetChannel(wifiChannelHelper.Create());\n\n    WifiMacHelper wifiMacHelper;\n    wifiMacHelper.SetType(\"ns3::StaWifiMac\",\n                          \"ActiveProbing\", BooleanValue(false));\n\n    // Install Wi-Fi devices on nodes\n    NetDeviceContainer devices = wifiHelper.Install(wifiPhyHelper, wifiMacHelper, nodes);\n\n    // Setup mobility model for nodes\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node B\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1)); // Node B\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node A\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(128));\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0)); // Node A\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Enable tracing\n    wifiPhyHelper.EnablePcap(\"wifi_network\", devices);\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a wireless sensor network (WSN) with 10 nodes using the ZigBee protocol. One node should act as the coordinator, and the others should act as end devices. Each end device should send 128-byte UDP packets to the coordinator every 500ms. The simulation should run for 10 seconds. Use ZigBee PRO mode, and set the node mobility to random walk within a 100m x 100m area. Enable PCAP tracing for the ZigBee communication."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/zigbee-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ZigBeeExample\");\n\nint main(int argc, char *argv[])\n{\n    Time::SetResolution(Time::NS);\n    LogComponentEnable(\"ZigBeeExample\", LOG_LEVEL_INFO);\n\n    // Create sensor nodes\n    NodeContainer nodes;\n    nodes.Create(10);\n\n    // Configure ZigBee communication\n    ZigBeeHelper zigbeeHelper;\n    zigbeeHelper.SetInterfaceType(ZigBeeHelper::ZIGBEE_PRO);\n\n    // Install ZigBee devices\n    NetDeviceContainer devices = zigbeeHelper.Install(nodes);\n\n    // Configure mobility\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0.0, 100.0, 0.0, 100.0)));\n    mobility.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Create applications (UDP server on the coordinator, client on other nodes)\n    uint16_t port = 5000;\n\n    // Set up UDP server (Coordinator)\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(0)); // Coordinator\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP clients (End Devices)\n    for (uint32_t i = 1; i < 10; ++i)\n    {\n        UdpClientHelper udpClient(interfaces.GetAddress(0), port);\n        udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n        udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(500)));\n        udpClient.SetAttribute(\"PacketSize\", UintegerValue(128));\n\n        ApplicationContainer clientApp = udpClient.Install(nodes.Get(i));\n        clientApp.Start(Seconds(2.0));\n        clientApp.Stop(Seconds(10.0));\n    }\n\n    // Enable tracing\n    zigbeeHelper.EnablePcap(\"zigbee_network\", devices);\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Wi-Fi network with a UDP connection between a station (STA) and an access point (AP). The STA should act as a UDP client, and the AP should act as a UDP server. The Wi-Fi standard should be 802.11n. The client should send 50 packets of 1024 bytes each at an interval of 200ms. The server should receive the packets. Assign IP addresses from the range 192.168.1.0/24. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create nodes (1 AP and 1 STA)\n    NodeContainer wifiStaNode;\n    wifiStaNode.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Create Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up Wi-Fi helper\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    WifiMacHelper mac;\n\n    // Set up STA\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNode);\n\n    // Set up AP\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevices = wifi.Install(phy, mac, wifiApNode);\n\n    // Mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNode);\n    mobility.Install(wifiApNode);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNode);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterface = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevices);\n\n    // Set up UDP server on AP\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on STA\n    UdpClientHelper udpClient(apInterface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(50));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(200)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a Wi-Fi network with one access point (AP) and two stations (STA) using the 802.11g standard. The network should use the 192.168.1.0/24 subnet. One STA should act as a UDP server on port 8080, while the other STA should be a UDP client sending 10 packets of 1024 bytes at 1-second intervals. The server should start at 1 second, and the client should start at 2 seconds, with the simulation running for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create nodes: 1 Access Point (AP) + 2 Stations (STAs)\n    NodeContainer wifiStaNodes, wifiApNode;\n    wifiStaNodes.Create(2);\n    wifiApNode.Create(1);\n\n    // Configure Wi-Fi PHY and MAC\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211g);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Configure STA devices\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure AP device\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Configure UDP Server on one STA\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Configure UDP Client on the other STA\n    UdpClientHelper udpClient(staInterfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run Simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that creates a point-to-point network between two nodes with a 10 Mbps data rate and a 2 ms propagation delay. The nodes should use the 10.1.1.0/24 subnet. Node 1 should act as a TCP server listening on port 8080, and Node 0 should be a TCP client sending a maximum of 500,000 bytes of data. The server should start at 1 second and the client at 2 seconds, with the simulation running for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleP2PExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure point-to-point connection\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on both nodes\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Configure TCP Server on Node 1\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper tcpSink(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = tcpSink.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Configure TCP Client on Node 0\n    BulkSendHelper tcpClient(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    tcpClient.SetAttribute(\"MaxBytes\", UintegerValue(500000));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run Simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a Wi-Fi network with one access point (AP) and two stations (STA). The AP and STAs should use 802.11g Wi-Fi standard. The network should assign 192.168.1.x IP addresses. Station 1 should act as a UDP server listening on port 8080, while Station 0 should act as a UDP client, sending 1024-byte packets every 10 milliseconds starting at 2 seconds. The client should send a maximum of 1000 packets. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWifiExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create Nodes (1 Access Point + 2 Stations)\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(2);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Setup Wi-Fi Channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    // Setup Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211g);\n    WifiMacHelper mac;\n\n    // Configure Station Devices\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n\n    // Configure Access Point Device\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Setup Mobility Model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Install Internet Stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP Addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // UDP Server on Station 1\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiStaNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // UDP Client on Station 0\n    UdpClientHelper udpClient(staInterfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run Simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a simple point-to-point network with two nodes. The link should have a 5 Mbps data rate and a 2 ms delay. Node 0 should send TCP traffic to Node 1 using the BulkSendApplication. The receiver (Node 1) should use a TCP Packet Sink on port 8080. The TCP sender should start at 1 second and continue sending unlimited data until 10 seconds. The network should use the 192.168.1.x subnet."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP sink on Node 1\n    uint16_t port = 8080;\n    Address sinkAddress(InetSocketAddress(interfaces.GetAddress(1), port));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    ApplicationContainer sinkApp = sinkHelper.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(0.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Create a TCP sender on Node 0\n    BulkSendHelper sender(\"ns3::TcpSocketFactory\", sinkAddress);\n    sender.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n    ApplicationContainer senderApp = sender.Install(nodes.Get(0));\n    senderApp.Start(Seconds(1.0));\n    senderApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script for a three-node ad-hoc wireless network using the AODV routing protocol. The network should operate on 802.11g Wi-Fi. The nodes should be positioned in a straight line, 100 meters apart. The first node should send UDP packets to the third node, while the second node acts as a router. A UDP Echo server should run on Node 2 (port 9) starting at 1 second. The client on Node 0 should send 5 packets of 512 bytes at 2-second intervals, starting at 2 seconds. The simulation should run for 20 seconds. The IP network should be 10.1.1.x."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/aodv-helper.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"AdhocAodvExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create three nodes\n    NodeContainer adhocNodes;\n    adhocNodes.Create(3);\n\n    // Set up Wi-Fi for ad-hoc mode\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, adhocNodes);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(100.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(adhocNodes);\n\n    // Install AODV routing\n    AodvHelper aodv;\n    InternetStackHelper stack;\n    stack.SetRoutingHelper(aodv);\n    stack.Install(adhocNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a UDP Echo server on Node 2\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(adhocNodes.Get(2));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Set up a UDP Echo client on Node 0\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(2), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(2.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = echoClient.Install(adhocNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(20.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script for a Wi-Fi network with two nodes, using the 802.11n 5GHz standard. The nodes should be 5 meters apart. One node should run a UDP Echo server on port 9, starting at 1 second. The other node should act as a UDP Echo client, sending 10 packets of 1024 bytes each at 1-second intervals, starting at 2 seconds. The simulation should run for 10 seconds. The IP network should be 192.168.1.x, and nodes should have fixed positions."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Set up Wi-Fi\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, wifiNodes);\n\n    // Set mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a UDP Echo server on Node 1\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(wifiNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up a UDP Echo client on Node 0\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(wifiNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script for a wired point-to-point network with two nodes, connected by a link with a data rate of 5 Mbps and 2 ms delay. The first node should send TCP traffic using a BulkSend application, and the second node should act as a TCP receiver (sink). The receiver should start at 1 second, and the sender should start at 2 seconds. The simulation should run for 10 seconds. The TCP sink should listen on port 9, and the BulkSend application should send unlimited data."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up a point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a TCP receiver (Sink) on Node 1\n    uint16_t port = 9;\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\",\n                                InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sinkHelper.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Set up a TCP sender on Node 0\n    BulkSendHelper sender(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(interfaces.GetAddress(1), port));\n    sender.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n    ApplicationContainer senderApp = sender.Install(nodes.Get(0));\n    senderApp.Start(Seconds(2.0));\n    senderApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script for a Wi-Fi network with two nodes, using 802.11b. The nodes should have a fixed position. One node should send UDP packets to the other using a UDP client-server model. The sender should send 1000 packets of 512 bytes each at a rate of 100 packets per second (10 ms interval). The UDP server should listen on port 8080. The simulation should run for 10 seconds, with the sender starting at 2 seconds and the receiver at 1 second."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two Wi-Fi nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Set up Wi-Fi channel\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211b);\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"wifi-network\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, wifiNodes);\n\n    // Set mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP sink on Node 1\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP sender on Node 0\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10))); // 100 packets/sec\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script simulating a point-to-point network between two nodes with a TCP bulk sender on Node 0 and a TCP sink on Node 1. The link should have a 5 Mbps data rate and a 2 ms delay. The IP range should be 10.1.1.0/24. The TCP sink should start at 1 second and run until 10 seconds, while the TCP sender starts at 2 seconds. The sender should transfer unlimited data (MaxBytes = 0)."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"P2PTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create 2 nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install P2P devices on nodes\n    NetDeviceContainer devices = p2p.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP Sink on Node 1\n    uint16_t port = 8080;\n    Address sinkAddress(InetSocketAddress(interfaces.GetAddress(1), port));\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\", sinkAddress);\n    ApplicationContainer sinkApp = sinkHelper.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Set up TCP Bulk Sender on Node 0\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", sinkAddress);\n    source.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Send unlimited data\n    ApplicationContainer sourceApp = source.Install(nodes.Get(0));\n    sourceApp.Start(Seconds(2.0));\n    sourceApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a simple LTE network with one eNodeB (LTE base station) and two UE devices. The eNodeB should be attached to both UEs. One UE (UE 0) should act as a TCP server on port 8080, and the other UE (UE 1) should act as a TCP client, sending 1,000,000 bytes of data. The server should start at 1 second, and the client should start at 2 seconds. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleLTEExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create nodes: 1 eNodeB (LTE base station) + 2 UE (User Equipments)\n    NodeContainer ueNodes, enbNode;\n    ueNodes.Create(2);\n    enbNode.Create(1);\n\n    // Install LTE stack\n    LteHelper lte;\n    NetDeviceContainer ueDevices, enbDevices;\n\n    // Install LTE devices on UE and eNodeB\n    enbDevices = lte.InstallEnbDevice(enbNode);\n    ueDevices = lte.InstallUeDevice(ueNodes);\n\n    // Install the Internet stack\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    internet.Install(enbNode);\n\n    // Assign IP addresses\n    Ipv4InterfaceContainer ueIpInterface;\n    ueIpInterface = lte.AssignUeIpv4Address(ueDevices);\n\n    // Attach the UEs to the eNodeB\n    lte.Attach(ueDevices.Get(0), enbDevices.Get(0));\n    lte.Attach(ueDevices.Get(1), enbDevices.Get(0));\n\n    // Configure the TCP server on UE 0\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper tcpSink(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = tcpSink.Install(ueNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Configure the TCP client on UE 1\n    BulkSendHelper tcpClient(\"ns3::TcpSocketFactory\", InetSocketAddress(ueIpInterface.GetAddress(0), port));\n    tcpClient.SetAttribute(\"MaxBytes\", UintegerValue(1000000));\n    ApplicationContainer clientApp = tcpClient.Install(ueNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a wired network with two hosts connected via Point-to-Point links. The link should have a data rate of 5 Mbps and a delay of 2 ms. The first host (Node 0) should act as a TCP server on port 8080, while the second host (Node 1) should act as a TCP client, sending 1,000,000 bytes of data. The simulation should start at 1 second for the server and 2 seconds for the client, running for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWiredNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create two nodes (Hosts)\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the Point-to-Point link between the two hosts\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack (TCP/IP)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a TCP server on Node 0\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(Ipv4Address::GetAny(), port));\n    PacketSinkHelper tcpSink(\"ns3::TcpSocketFactory\", serverAddress);\n    ApplicationContainer serverApp = tcpSink.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up a TCP client on Node 1\n    BulkSendHelper tcpClient(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(0), port));\n    tcpClient.SetAttribute(\"MaxBytes\", UintegerValue(1000000));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a simple Wi-Fi network with two stations (STA) and one access point (AP). The AP should have a fixed position, and the STA devices should move randomly within a defined area. The STA 0 should act as a UDP server listening on port 9, while STA 1 should act as a UDP client, sending 1,000 packets of 1024 bytes each, with a packet interval of 0.01 seconds. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ssid.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWifiExample\");\n\nint main(int argc, char *argv[])\n{\n    CommandLine cmd;\n    cmd.Parse(argc, argv);\n\n    // Create nodes: 2 stations (STA) and 1 access point (AP)\n    NodeContainer wifiStaNodes, wifiApNode;\n    wifiStaNodes.Create(2);\n    wifiApNode.Create(1);\n\n    // Set up Wi-Fi devices (STA and AP)\n    WifiHelper wifi;\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns3-ssid\");\n\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Install Wi-Fi devices on stations\n    NetDeviceContainer staDevices = wifi.Install(wifiMac, wifi, wifiStaNodes);\n\n    // Install Wi-Fi devices on the access point\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(wifiMac, wifi, wifiApNode);\n\n    // Mobility model: Fixed position for AP, random for STA\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0), \"DeltaX\", DoubleValue(5.0), \"DeltaY\", DoubleValue(10.0), \"GridWidth\", UintegerValue(3), \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode);\n\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\", \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=100]\"), \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=100]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\", \"Time\", StringValue(\"1s\"), \"Distance\", StringValue(\"10m\"));\n    mobility.Install(wifiStaNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(wifiStaNodes);\n    internet.Install(wifiApNode);\n\n    // Assign IP addresses to all devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = ipv4.Assign(staDevices);\n    Ipv4InterfaceContainer apInterfaces = ipv4.Assign(apDevice);\n\n    // Set up a UDP server on STA 0\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up a UDP client on STA 1\n    UdpClientHelper udpClient(apInterfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a simple LTE network with one User Equipment (UE), one eNodeB (base station), and the Evolved Packet Core (EPC). The eNodeB should communicate with the UE using UDP. The UE should run a UDP server on port 9, and the eNodeB should send 1,000 UDP packets of 1024 bytes each, with a packet interval of 0.01 seconds. The simulation should run for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleLteExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleLteExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: UE (User Equipment), eNodeB (LTE base station), and EPC\n    NodeContainer ueNodes, enbNodes, epcNodes;\n    ueNodes.Create(1);\n    enbNodes.Create(1);\n    epcNodes.Create(1);\n\n    // Set up LTE helpers\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n    Ptr<EpcHelper> epcHelper = CreateObject<EpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    // Set up the eNodeB (base station) and UE\n    NetDeviceContainer ueDevices, enbDevices;\n    enbDevices = lteHelper->InstallEnbDevice(enbNodes);\n    ueDevices = lteHelper->InstallUeDevice(ueNodes);\n\n    // Install the internet stack (IP, TCP, UDP)\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    internet.Install(enbNodes);\n    internet.Install(epcNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface = ipv4.Assign(ueDevices);\n    Ipv4InterfaceContainer enbIpIface = ipv4.Assign(enbDevices);\n\n    // Attach UE to the eNodeB\n    lteHelper->Attach(ueDevices.Get(0), enbDevices.Get(0));\n\n    // Set up UDP server on the UE node (User Equipment)\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ueNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the eNodeB node\n    UdpClientHelper udpClient(ueIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(enbNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a simple 5G NR network with one User Equipment (UE), one gNB (5G base station), and the 5G Core Network (CN). The gNB should communicate with the UE using UDP. The UE should run a UDP server on port 9, and the gNB should send 1,000 UDP packets of 1024 bytes each, with a packet interval of 0.01 seconds. The simulation should run for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/gnb-module.h\"\n#include \"ns3/ue-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Simple5GExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"Simple5GExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: UE (User Equipment), gNB (5G Base Station), and 5G Core Network\n    NodeContainer ueNodes, gnbNodes, coreNetworkNodes;\n    ueNodes.Create(1);\n    gnbNodes.Create(1);\n    coreNetworkNodes.Create(1);\n\n    // Set up 5G NR helpers\n    Ptr<GnbHelper> gnbHelper = CreateObject<GnbHelper>();\n    Ptr<UeHelper> ueHelper = CreateObject<UeHelper>();\n    Ptr<CoreNetworkHelper> coreNetworkHelper = CreateObject<CoreNetworkHelper>();\n    gnbHelper->SetCoreNetworkHelper(coreNetworkHelper);\n\n    // Set up the gNB (base station) and UE\n    NetDeviceContainer ueDevices, gnbDevices;\n    gnbDevices = gnbHelper->InstallGnbDevice(gnbNodes);\n    ueDevices = ueHelper->InstallUeDevice(ueNodes);\n\n    // Install the internet stack (IP, TCP, UDP)\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    internet.Install(gnbNodes);\n    internet.Install(coreNetworkNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface = ipv4.Assign(ueDevices);\n    Ipv4InterfaceContainer gnbIpIface = ipv4.Assign(gnbDevices);\n\n    // Attach UE to the gNB (5G base station)\n    gnbHelper->Attach(ueDevices.Get(0), gnbDevices.Get(0));\n\n    // Set up UDP server on the UE node (User Equipment)\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ueNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the gNB node\n    UdpClientHelper udpClient(ueIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(gnbNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a simple WiFi network with one Station (STA) and one Access Point (AP). The STA should run a UDP client on port 9, and the AP should run a UDP server. The STA sends 1,000 UDP packets of 1024 bytes each, with a packet interval of 0.01 seconds. The simulation should run for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWifiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleWifiExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: Station (STA) and Access Point (AP)\n    NodeContainer staNodes, apNodes;\n    staNodes.Create(1);\n    apNodes.Create(1);\n\n    // Set up WiFi helper and configure WiFi standards\n    WifiHelper wifiHelper;\n    wifiHelper.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up WiFi channel and PHY layers\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up MAC layer with IEEE 802.11 standards\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices;\n    staDevices = wifiHelper.Install(phy, mac, staNodes);\n\n    // Set up AP MAC layer\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevices;\n    apDevices = wifiHelper.Install(phy, mac, apNodes);\n\n    // Install the internet stack (IP, TCP, UDP)\n    InternetStackHelper internet;\n    internet.Install(staNodes);\n    internet.Install(apNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staIpIface = ipv4.Assign(staDevices);\n    Ipv4InterfaceContainer apIpIface = ipv4.Assign(apDevices);\n\n    // Set up UDP server on the AP node (Access Point)\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(apNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the STA node (Station)\n    UdpClientHelper udpClient(apIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(staNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a simple LTE network with one User Equipment (UE) and one evolved NodeB (eNB). The UE runs a UDP client on port 9, and the eNB runs a UDP server. The UE sends 1,000 UDP packets of 1024 bytes each, with a packet interval of 0.01 seconds. The simulation should run for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleLteExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleLteExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: UE (User Equipment) and eNB (evolved NodeB)\n    NodeContainer ueNodes, enbNodes;\n    ueNodes.Create(1);\n    enbNodes.Create(1);\n\n    // Set up LTE helper\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n\n    // Set up EPC helper (Evolved Packet Core)\n    Ptr<EpcHelper> epcHelper = CreateObject<EpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    // Set up the LTE network\n    NetDeviceContainer ueDevices, enbDevices;\n    ueDevices = lteHelper->InstallUeDevice(ueNodes);\n    enbDevices = lteHelper->InstallEnbDevice(enbNodes);\n\n    // Install the internet stack (IP, TCP, UDP)\n    InternetStackHelper internet;\n    internet.Install(ueNodes);\n    internet.Install(enbNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface = ipv4.Assign(ueDevices);\n    Ipv4InterfaceContainer enbIpIface = ipv4.Assign(enbDevices);\n\n    // Attach the UE to the eNB\n    lteHelper->Attach(ueDevices.Get(0), enbDevices.Get(0));\n\n    // Set up UDP server on the eNB node (evolved NodeB)\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(enbNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the UE node (User Equipment)\n    UdpClientHelper udpClient(enbIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(ueNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a simple TCP communication between two nodes. One node runs a TCP server on port 8080, and the other node acts as a TCP client. The client sends 10 TCP packets of 1024 bytes each, with a packet interval of 1 second. The simulation runs for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleTcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes: one for the TCP client, one for the TCP server\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Install internet stack (IP, TCP, UDP)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Set up TCP server on the second node\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on the first node\n    InetSocketAddress remoteAddress = InetSocketAddress(Ipv4Address(\"10.1.1.2\"), port);\n    TcpClientHelper tcpClient(remoteAddress);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(nodes.Get(0)->GetDevice(0));\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    ipv4.Assign(nodes.Get(1)->GetDevice(0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that creates a Wi-Fi network with one Access Point (AP) and three stations (STA). The AP runs a UDP server on port 9, and the stations act as UDP clients. The UDP clients send 1,000 UDP packets of 1024 bytes each with an interval of 0.01 seconds. The simulation runs for 10 seconds, with the server starting at 1 second and the clients starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWifiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleWifiExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: one Access Point (AP) and multiple stations (STA)\n    NodeContainer apNode, staNodes;\n    apNode.Create(1);\n    staNodes.Create(3);\n\n    // Set up Wi-Fi helper\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up Wi-Fi PHY and MAC layer\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    WifiMacHelper apMac;\n    apMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    // Install devices (Wi-Fi NICs) on nodes\n    NetDeviceContainer apDevice, staDevices;\n    apDevice = wifi.Install(wifiPhy, apMac, apNode);\n    staDevices = wifi.Install(wifiPhy, wifiMac, staNodes);\n\n    // Install the internet stack\n    InternetStackHelper stack;\n    stack.Install(apNode);\n    stack.Install(staNodes);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apInterfaces = ipv4.Assign(apDevice);\n    Ipv4InterfaceContainer staInterfaces = ipv4.Assign(staDevices);\n\n    // Set up UDP server on the AP node\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(apNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the stations\n    UdpClientHelper udpClient(apInterfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(staNodes);\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a simple LTE network with one eNodeB (base station) and three UEs (User Equipments). The eNodeB runs a UDP server on port 9, and the UEs act as UDP clients. The UDP clients send 1,000 UDP packets of 1024 bytes each with an interval of 0.01 seconds. The simulation runs for 10 seconds, with the server starting at 1 second and the clients starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleLteExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleLteExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: one eNodeB (base station) and multiple UEs\n    NodeContainer enbNode, ueNodes;\n    enbNode.Create(1);\n    ueNodes.Create(3);\n\n    // Set up LTE helper and install LTE stack\n    LteHelper lteHelper;\n    lteHelper.SetSchedulerType(\"ns3::PfSocketScheduler\");\n    NetDeviceContainer enbDevice, ueDevices;\n    enbDevice = lteHelper.InstallEnbDevice(enbNode);\n    ueDevices = lteHelper.InstallUeDevice(ueNodes);\n\n    // Install internet stack (IP, UDP, etc.)\n    InternetStackHelper stack;\n    stack.Install(enbNode);\n    stack.Install(ueNodes);\n\n    // Assign IP addresses to UEs and eNodeB\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface = ipv4.Assign(ueDevices);\n    ipv4.SetBase(\"10.1.2.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer enbIpIface = ipv4.Assign(enbDevice);\n\n    // Set up UDP server on the eNodeB\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(enbNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on each UE\n    UdpClientHelper udpClient(enbIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(ueNodes);\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Attach UEs to the eNodeB\n    lteHelper.Attach(ueDevices.Get(0), enbDevice.Get(0));\n    lteHelper.Attach(ueDevices.Get(1), enbDevice.Get(0));\n    lteHelper.Attach(ueDevices.Get(2), enbDevice.Get(0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a Wi-Fi Mesh Network with four mesh nodes. The last node acts as a UDP server on port 9, and the first three nodes act as UDP clients. The UDP clients send 1,000 UDP packets of 1024 bytes each with an interval of 0.01 seconds. The simulation runs for 10 seconds, with the server starting at 1 second and the clients starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleMeshExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleMeshExample\", LOG_LEVEL_INFO);\n\n    // Create mesh nodes\n    NodeContainer meshNodes;\n    meshNodes.Create(4);\n\n    // Set up Wi-Fi mesh network\n    MeshHelper meshHelper;\n    meshHelper.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n    meshHelper.SetRemoteStationManager(\"ns3::ArfWifiManager\");\n\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns-3-mesh-ssid\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    WifiMacHelper apMac;\n    apMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    // Install Wi-Fi devices (mesh nodes)\n    NetDeviceContainer meshDevices = meshHelper.Install(wifiPhy, wifiMac, meshNodes);\n\n    // Install internet stack (IP, UDP, etc.)\n    InternetStackHelper stack;\n    stack.Install(meshNodes);\n\n    // Assign IP addresses to mesh nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer meshIpIface = ipv4.Assign(meshDevices);\n\n    // Set up UDP server on the last mesh node\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(meshNodes.Get(3));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on each of the other mesh nodes\n    UdpClientHelper udpClient(meshIpIface.GetAddress(3), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp;\n    for (uint32_t i = 0; i < 3; ++i)\n    {\n        clientApp.Add(udpClient.Install(meshNodes.Get(i)));\n    }\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Mobile Ad Hoc Network (MANET) with two nodes. The nodes communicate via UDP: one node acts as a server on port 9, and the other node acts as a client. The client sends 1,000 UDP packets of 1024 bytes each with an interval of 0.01 seconds. The nodes are configured with random waypoint mobility and move within a 100m x 100m area at a constant speed of 20 m/s. The simulation runs for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-routing-helper.h\"\n#include \"ns3/olsr-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleManetExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleManetExample\", LOG_LEVEL_INFO);\n\n    // Create mobile nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Wi-Fi devices (STA and AP)\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_PHY_STANDARD_80211b);\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns-3-manet\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices = wifiHelper.Install(wifiPhy, wifiMac, nodes);\n\n    // Set up internet stack (IP, UDP, etc.)\n    InternetStackHelper stack;\n    OlsrHelper olsr;\n    stack.SetRoutingHelper(olsr);\n    stack.Install(nodes);\n\n    // Assign IP addresses to nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on node 1\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on node 0\n    UdpClientHelper udpClient(ipInterfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up random waypoint mobility model\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"MinX\", DoubleValue(0.0),\n                              \"MaxX\", DoubleValue(100.0),\n                              \"MinY\", DoubleValue(0.0),\n                              \"MaxY\", DoubleValue(100.0),\n                              \"Speed\", StringValue(\"ns3::ConstantRandomVariable[Constant=20.0]\"));\n    mobility.Install(nodes);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Point-to-Point (P2P) network with two nodes. One node acts as a TCP server on port 8080, and the other node acts as a TCP client. The client sends 1,000 TCP packets of 1024 bytes each with an interval of 0.01 seconds. The server starts at 1 second, and the client starts at 2 seconds. The point-to-point link has a data rate of 5 Mbps and a delay of 2 ms. The simulation runs for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleP2PExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleP2PExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link between nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install internet stack (IP, TCP, etc.)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfaces = ipv4.Assign(devices);\n\n    // Set up TCP server on node 1\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on node 0\n    TcpClientHelper tcpClient(ipInterfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Wi-Fi network with two nodes. One node acts as a HTTP server on port 80, and the other node acts as a HTTP client. The client requests a web page from the server. The nodes are stationary and have static positions in a grid layout with a 5m x 5m grid. The Wi-Fi channel is based on the 802.11b standard. The simulation runs for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-routing-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"SimpleWiFiExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Wi-Fi devices (STA and AP)\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_PHY_STANDARD_80211b);\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns-3-wifi\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices = wifiHelper.Install(wifiPhy, wifiMac, nodes);\n\n    // Set up internet stack (IP, TCP, etc.)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfaces = ipv4.Assign(devices);\n\n    // Set up HTTP server on node 1\n    uint16_t port = 80;\n    HttpServerHelper httpServer(port);\n    ApplicationContainer serverApp = httpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up HTTP client on node 0\n    HttpClientHelper httpClient(ipInterfaces.GetAddress(1), port);\n    ApplicationContainer clientApp = httpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up mobility model for nodes (static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a TCP connection between two nodes using a point-to-point link. The client sends data to the server, and the Round-Trip Time (RTT) is measured and logged during the communication. The point-to-point link has a data rate of 5 Mbps and a delay of 10 ms. The server starts at 1 second, and the client starts at 2 seconds. The simulation runs for 10 seconds, and the RTT value should be printed during the simulation."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/ipv4-routing-helper.h\"\n#include \"ns3/tcp-header.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpRttExample\");\n\nvoid TraceRtt(Ptr<const TcpSocketState> state)\n{\n    // Print the RTT value\n    Time rtt = state->m_rtt;\n    NS_LOG_INFO(\"RTT: \" << rtt.GetSeconds() << \" seconds\");\n}\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"TcpRttExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link between nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install internet stack (IP, TCP, etc.)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfaces = ipv4.Assign(devices);\n\n    // Set up TCP server on node 1\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on node 0\n    TcpClientHelper tcpClient(ipInterfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.01)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Trace RTT for TCP connection\n    Config::Connect(\"/NodeList/0/DeviceList/0/$ns3::PointToPointNetDevice/TxQueue/Enqueue\", MakeCallback(&TraceRtt));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Mobile Ad-Hoc Network (MANET) with 5 nodes. The nodes use the AODV routing protocol, and their movement is simulated with the RandomWaypointMobilityModel. The nodes randomly move within a 100x100m area. Node 0 sends UDP packets to node 4, while node 4 receives the data. The network communication occurs using Wi-Fi with the 802.11b standard. The simulation runs for 10 seconds, with the application starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/aodv-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ManetExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"ManetExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the MANET\n    NodeContainer nodes;\n    nodes.Create(5);\n\n    // Set up mobility model for nodes (random movement)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"MinX\", DoubleValue(0.0),\n                              \"MinY\", DoubleValue(0.0),\n                              \"MaxX\", DoubleValue(100.0),\n                              \"MaxY\", DoubleValue(100.0),\n                              \"Speed\", StringValue(\"ns3::UniformRandomVariable[Min=5.0|Max=10.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"));\n    mobility.Install(nodes);\n\n    // Install AODV routing protocol\n    AodvHelper aodv;\n    InternetStackHelper stack;\n    stack.SetRoutingHelper(aodv); // Use AODV as the routing protocol\n    stack.Install(nodes);\n\n    // Set up point-to-point devices (Wi-Fi or similar)\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_PHY_STANDARD_80211b);\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns-3-manet\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices = wifiHelper.Install(wifiPhy, wifiMac, nodes);\n\n    // Install the internet stack and assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfaces = ipv4.Assign(devices);\n\n    // Set up application on node 0 (sending data)\n    OnOffHelper onOffHelper(\"ns3::UdpSocketFactory\", Address(InetSocketAddress(ipInterfaces.GetAddress(4), 9))); // Send to node 4\n    onOffHelper.SetConstantRate(DataRate(\"500kb/s\"));\n    ApplicationContainer senderApp = onOffHelper.Install(nodes.Get(0));\n    senderApp.Start(Seconds(2.0));\n    senderApp.Stop(Seconds(10.0));\n\n    // Set up application on node 4 (receiving data)\n    UdpServerHelper udpServer(9);\n    ApplicationContainer receiverApp = udpServer.Install(nodes.Get(4));\n    receiverApp.Start(Seconds(2.0));\n    receiverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Mobile Ad-Hoc Network (MANET) with 6 nodes using the OLSR routing protocol. The nodes are mobile and use the RandomWaypointMobilityModel for movement within a 100x100m area. Nodes have speeds between 5m/s and 15m/s, and the simulation runs for 10 seconds. A UDP packet is sent from node 0 to node 5. The simulation should print the routing behavior as nodes move and adjust the network topology."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/olsr-helper.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"OlsrExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"OlsrExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the MANET\n    NodeContainer nodes;\n    nodes.Create(6);\n\n    // Set up mobility model for nodes (random movement)\n    MobilityHelper mobility;\n    mobility.SetMobilityModel(\"ns3::RandomWaypointMobilityModel\",\n                              \"MinX\", DoubleValue(0.0),\n                              \"MinY\", DoubleValue(0.0),\n                              \"MaxX\", DoubleValue(100.0),\n                              \"MaxY\", DoubleValue(100.0),\n                              \"Speed\", StringValue(\"ns3::UniformRandomVariable[Min=5.0|Max=15.0]\"),\n                              \"Pause\", StringValue(\"ns3::ConstantRandomVariable[Constant=1.0]\"));\n    mobility.Install(nodes);\n\n    // Install OLSR routing protocol\n    OlsrHelper olsr;\n    InternetStackHelper stack;\n    stack.SetRoutingHelper(olsr); // Use OLSR as the routing protocol\n    stack.Install(nodes);\n\n    // Set up point-to-point devices (Wi-Fi or similar)\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_PHY_STANDARD_80211b);\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns-3-olsr\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices = wifiHelper.Install(wifiPhy, wifiMac, nodes);\n\n    // Install the internet stack and assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfaces = ipv4.Assign(devices);\n\n    // Set up UDP application on node 0 (sending data)\n    OnOffHelper onOffHelper(\"ns3::UdpSocketFactory\", Address(InetSocketAddress(ipInterfaces.GetAddress(5), 9))); // Send to node 5\n    onOffHelper.SetConstantRate(DataRate(\"500kb/s\"));\n    ApplicationContainer senderApp = onOffHelper.Install(nodes.Get(0));\n    senderApp.Start(Seconds(2.0));\n    senderApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on node 5 (receiving data)\n    UdpServerHelper udpServer(9);\n    ApplicationContainer receiverApp = udpServer.Install(nodes.Get(5));\n    receiverApp.Start(Seconds(2.0));\n    receiverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a simple Wi-Fi network with 2 nodes. The nodes use 802.11b Wi-Fi and are configured with the ConstantPositionMobilityModel for stationary behavior. Node 0 (the sender) transmits UDP packets to Node 1 (the receiver) at a constant rate of 500kb/s. The simulation should last for 10 seconds, with the application starting at 1 second and stopping at 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"WifiSimpleExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2); // Two nodes (sender and receiver)\n\n    // Set up mobility model for nodes (stationary)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Wi-Fi setup (using 802.11b standard)\n    WifiHelper wifiHelper;\n    wifiHelper.SetStandard(WIFI_PHY_STANDARD_80211b);\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns-3-simple-wifi\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices = wifiHelper.Install(wifiPhy, wifiMac, nodes);\n\n    // Install internet stack and assign IP addresses\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ipInterfaces = ipv4.Assign(devices);\n\n    // Create UDP application on node 0 (sender)\n    OnOffHelper onOffHelper(\"ns3::UdpSocketFactory\", Address(InetSocketAddress(ipInterfaces.GetAddress(1), 9))); // Sending to node 1\n    onOffHelper.SetConstantRate(DataRate(\"500kb/s\"));\n    ApplicationContainer senderApp = onOffHelper.Install(nodes.Get(0));\n    senderApp.Start(Seconds(1.0));\n    senderApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on node 1 (receiver)\n    UdpServerHelper udpServer(9);\n    ApplicationContainer receiverApp = udpServer.Install(nodes.Get(1));\n    receiverApp.Start(Seconds(1.0));\n    receiverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that sets up a simple TCP connection between three nodes. Two of the nodes (Node 0 and Node 1) act as clients, and one node (Node 2) is the TCP server. Use PointToPoint links to connect the nodes with a 1Mbps data rate and 2ms delay. The server (Node 2) listens on port 9, while the clients send TCP traffic starting at 2 seconds (Node 0) and 3 seconds (Node 1). The simulation should last for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpSimpleExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"TcpSimpleExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the network\n    NodeContainer nodes;\n    nodes.Create(3); // Three nodes: Two clients and one server\n\n    // Set up point-to-point link between nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes.Get(0), nodes.Get(1)); // Connection between node 0 and 1\n    pointToPoint.Install(nodes.Get(1), nodes.Get(2));           // Connection between node 1 and 2\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces;\n    interfaces = ipv4.Assign(devices);\n\n    // Set up the server application (Node 2)\n    uint16_t port = 9; // Server port\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(2)); // Install on Node 2 (Server)\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the client application (Node 0 and Node 1)\n    BulkSendHelper bulkSendHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(2), port));\n    bulkSendHelper.SetAttribute(\"MaxBytes\", UintegerValue(0));              // Unlimited data transfer\n    ApplicationContainer clientApp0 = bulkSendHelper.Install(nodes.Get(0)); // Install on Node 0 (Client 1)\n    ApplicationContainer clientApp1 = bulkSendHelper.Install(nodes.Get(1)); // Install on Node 1 (Client 2)\n\n    clientApp0.Start(Seconds(2.0));\n    clientApp0.Stop(Seconds(10.0));\n    clientApp1.Start(Seconds(3.0));\n    clientApp1.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a simple wired network with HTTP traffic between two nodes. Use PointToPoint links to connect the nodes with a 1Mbps data rate and 10ms delay. Node 0 is the HTTP client, and Node 1 is the HTTP server. The HTTP server listens on port 80. The HTTP client starts generating traffic at 2 seconds and stops at 10 seconds. The server starts at 1 second and stops at 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"HttpSimpleExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"HttpSimpleExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the network\n    NodeContainer nodes;\n    nodes.Create(2); // Two nodes: Client and Server\n\n    // Set up point-to-point link between nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes.Get(0), nodes.Get(1)); // Connection between node 0 and 1\n\n    // Install internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up the HTTP server application on Node 1 (server)\n    uint16_t port = 80; // Standard HTTP port\n    OnOffHelper httpServerHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    httpServerHelper.SetConstantRate(DataRate(\"500kb/s\"));\n    ApplicationContainer serverApp = httpServerHelper.Install(nodes.Get(1)); // Install on Node 1 (Server)\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the HTTP client application on Node 0 (client)\n    HttpRequestHelper httpClientHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    ApplicationContainer clientApp = httpClientHelper.Install(nodes.Get(0)); // Install on Node 0 (Client)\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a simple wireless network with WiFi nodes. The network consists of two nodes, where Node 0 is the TCP client and Node 1 is the TCP server. Use 802.11b WiFi standard and create a simple TCP connection between the nodes. Set the Ssid for WiFi to 'ns-3-ssid' and the TCP port to 9. The server starts at 1 second and stops at 10 seconds, while the client starts at 2 seconds and stops at 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"WifiSimpleExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the network\n    NodeContainer nodes;\n    nodes.Create(2); // Two nodes: Client and Server\n\n    // Set up mobility model (place nodes at fixed positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Set up WiFi helper for wireless communication\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    // Set up WiFi PHY (physical layer)\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(YansWifiChannelHelper::Default().Create());\n\n    // Set up WiFi MAC (media access control)\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(Ssid(\"ns-3-ssid\")));\n\n    // Install WiFi devices on nodes\n    NetDeviceContainer devices;\n    devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up the TCP server application on Node 1 (server)\n    uint16_t port = 9; // TCP port for communication\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1)); // Install on Node 1 (Server)\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the TCP client application on Node 0 (client)\n    BulkSendHelper bulkSendHelper(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    bulkSendHelper.SetAttribute(\"MaxBytes\", UintegerValue(0));             // Unlimited data transfer\n    ApplicationContainer clientApp = bulkSendHelper.Install(nodes.Get(0)); // Install on Node 0 (Client)\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a WiFi ad-hoc network with two nodes. The network consists of Node 0 (sender) and Node 1 (receiver). Use 802.11b WiFi standard in ad-hoc mode (no access point). Node 0 sends UDP packets to Node 1 on port 9 starting at 2 seconds and stops at 10 seconds. Node 1 receives UDP packets starting at 1 second and stops at 10 seconds. The packets are sent at an interval of 1 second, with each packet having a size of 1024 bytes, and the sender sends a total of 10 packets."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiAdhocExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"WifiAdhocExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the network\n    NodeContainer nodes;\n    nodes.Create(2); // Two nodes: Sender and Receiver\n\n    // Set up mobility model (place nodes at fixed positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Set up WiFi helper for wireless communication\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n\n    // Set up WiFi PHY (physical layer)\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(YansWifiChannelHelper::Default().Create());\n\n    // Set up WiFi MAC (media access control) for ad-hoc mode\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::AdhocWifiMac\");\n\n    // Install WiFi devices on nodes\n    NetDeviceContainer devices;\n    devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up the UDP receiver application on Node 1 (Receiver)\n    UdpServerHelper udpServer(9);                                     // UDP port 9\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1)); // Install on Node 1 (Receiver)\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the UDP sender application on Node 0 (Sender)\n    UdpClientHelper udpClient(interfaces.GetAddress(1), 9);      // Send to Node 1\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // Number of packets to send\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // Interval between packets\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // Packet size in bytes\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0)); // Install on Node 0 (Sender)\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to set up a TCP client-server communication. There are two nodes: Node 0 (client) and Node 1 (server). The server listens on TCP port 8080 and starts accepting connections at 1 second, stopping at 10 seconds. The client sends 10 TCP packets, each of 1024 bytes, with an interval of 1 second, starting at 2 seconds and stopping at 10 seconds. Both nodes should have IP addresses in the subnet 10.1.1.0/24."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpClientServerExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable log components\n    LogComponentEnable(\"TcpClientServerExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the network\n    NodeContainer nodes;\n    nodes.Create(2); // Two nodes: Client and Server\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Set up IP addresses for the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(nodes.Get(0), nodes.Get(1));\n\n    // Set up the TCP server application on Node 1 (Server)\n    uint16_t port = 8080;\n    Address serverAddress(InetSocketAddress(interfaces.GetAddress(1), port));\n    TcpServerHelper tcpServer(port);                                  // TCP port 8080\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1)); // Install on Node 1 (Server)\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the TCP client application on Node 0 (Client)\n    TcpClientHelper tcpClient(serverAddress);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));          // Number of packets to send\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));      // Interval between packets\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));        // Packet size in bytes\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0)); // Install on Node 0 (Client)\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to create a simple Wi-Fi network with a UDP communication between two nodes: Station (STA) and Access Point (AP). The STA sends 10 UDP packets of 1024 bytes each, with a 1-second interval to the AP, which listens on port 9. The station has a random mobility model in a 100x100 m² area, while the AP remains stationary. The IP address range used for both devices is 10.1.1.0/24."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for AP and STA\n    NodeContainer wifiStaNode, wifiApNode;\n    wifiStaNode.Create(1); // Station (STA)\n    wifiApNode.Create(1);  // Access Point (AP)\n\n    // Install Wi-Fi devices on both the AP and STA\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ); // 802.11n standard\n\n    WifiMacHelper mac;\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(Ssid(\"ns3-ssid\")));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNode);\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(Ssid(\"ns3-ssid\")));\n    NetDeviceContainer apDevices = wifi.Install(phy, mac, wifiApNode);\n\n    // Set up the mobility model for the STA (it moves around)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(wifiStaNode); // Install mobility on the STA node\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode); // Install stationary AP\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(wifiStaNode);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterfaces = address.Assign(apDevices);\n\n    // Set up UDP server on AP\n    UdpServerHelper udpServer(9); // Listening on port 9\n    ApplicationContainer serverApp = udpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on STA\n    UdpClientHelper udpClient(apInterfaces.GetAddress(0), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // 10 packets to send\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // 1 second interval\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // 1024 byte packets\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Wi-Fi network where a Client (STA) and an Access Point (AP) communicate using TCP. The Client sends 10 TCP packets (of 1024 bytes) to the Access Point at a 1-second interval. The Access Point listens on port 9. The Client follows a random walk mobility model within a 100x100 m² area, while the Access Point remains stationary. Use IPv4 addressing within the 10.1.1.0/24 subnet."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiTcpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for Client and Server\n    NodeContainer wifiStaNode, wifiApNode;\n    wifiStaNode.Create(1); // Client (STA)\n    wifiApNode.Create(1);  // Access Point (AP)\n\n    // Install Wi-Fi devices on both the Client and AP\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ); // 802.11n standard\n\n    WifiMacHelper mac;\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-ssid\")));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNode);\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-ssid\")));\n    NetDeviceContainer apDevices = wifi.Install(phy, mac, wifiApNode);\n\n    // Set up the mobility model for the STA\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(wifiStaNode); // Install mobility on the STA node\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode); // Install stationary AP\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(wifiStaNode);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterfaces = address.Assign(apDevices);\n\n    // Set up TCP server on AP\n    TcpServerHelper tcpServer(9); // Listening on port 9\n    ApplicationContainer serverApp = tcpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on STA\n    TcpClientHelper tcpClient(apInterfaces.GetAddress(0), 9);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // 10 packets to send\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // 1 second interval\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // 1024 byte packets\n    ApplicationContainer clientApp = tcpClient.Install(wifiStaNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a wired network with TCP communication between two computers. The first computer (Computer 1) sends 10 TCP packets (each 1024 bytes) to the second computer (Computer 2) over a Point-to-Point connection with a data rate of 5 Mbps and a 10 ms delay. The communication takes place on port 9, and the client sends packets at a 1-second interval. Use the IP address range 192.168.1.0/24."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WiredTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WiredTcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes representing the computers\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point connection between the two computers\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP server on the second node (Computer 2)\n    TcpServerHelper tcpServer(9); // Listening on port 9\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on the first node (Computer 1)\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), 9);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // Send 10 packets\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // 1-second interval\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // 1024 byte packets\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a wireless network with UDP communication between a sender (STA) and a receiver (AP). The sender sends 10 UDP packets (each 1024 bytes) to the receiver on port 9. The sender moves randomly within a 100x100 m² area using a random walk mobility model, while the receiver is stationary. Use the Wi-Fi 802.11n 5GHz standard, with IP addressing in the 10.1.1.0/24 range."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes for the sender (STA) and receiver (AP)\n    NodeContainer wifiStaNode, wifiApNode;\n    wifiStaNode.Create(1); // Sender (STA)\n    wifiApNode.Create(1);  // Receiver (AP)\n\n    // Install Wi-Fi devices on both the sender and receiver\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n\n    WifiMacHelper mac;\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-ssid\")));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNode);\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-ssid\")));\n    NetDeviceContainer apDevices = wifi.Install(phy, mac, wifiApNode);\n\n    // Set up the mobility model for the sender\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(wifiStaNode); // Install mobility on the sender node\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode); // Install stationary receiver\n\n    // Install the internet stack (UDP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(wifiStaNode);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterfaces = address.Assign(apDevices);\n\n    // Set up UDP server on the receiver (AP)\n    UdpServerHelper udpServer(9); // Listening on port 9\n    ApplicationContainer serverApp = udpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the sender (STA)\n    UdpClientHelper udpClient(apInterfaces.GetAddress(0), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // Send 10 packets\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // 1-second interval\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // 1024 byte packets\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Wi-Fi network with two mobile devices (STA) and a single access point (AP). Both devices exchange UDP packets (1024 bytes each) with the access point on port 9, with a 1-second interval between each packet. The mobile devices are using a random walk mobility model in a 100m x 100m area, while the access point is stationary. Use the Wi-Fi 802.11n 5GHz standard and assign IP addresses in the 10.1.1.0/24 range."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MobileWifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"MobileWifiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes: two mobile devices and one access point (AP)\n    NodeContainer wifiStaNodes, wifiApNode;\n    wifiStaNodes.Create(2); // Two mobile devices\n    wifiApNode.Create(1);   // One access point\n\n    // Install Wi-Fi devices on the nodes\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n\n    WifiMacHelper mac;\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-ssid\")));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiStaNodes);\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-ssid\")));\n    NetDeviceContainer apDevices = wifi.Install(phy, mac, wifiApNode);\n\n    // Set mobility for the sender and receiver (random walk in a 100m x 100m area)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(0, 100, 0, 100)));\n    mobility.Install(wifiStaNodes); // Install mobility on the mobile devices\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiApNode); // Install constant position for AP\n\n    // Install the internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevices);\n    Ipv4InterfaceContainer apInterfaces = address.Assign(apDevices);\n\n    // Set up UDP server on the access point\n    UdpServerHelper udpServer(9); // Listening on port 9\n    ApplicationContainer serverApp = udpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on the mobile devices\n    UdpClientHelper udpClient(apInterfaces.GetAddress(0), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // Send 10 packets\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // 1-second interval\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // 1024 byte packets\n\n    ApplicationContainer clientApp1 = udpClient.Install(wifiStaNodes.Get(0)); // First mobile device\n    ApplicationContainer clientApp2 = udpClient.Install(wifiStaNodes.Get(1)); // Second mobile device\n    clientApp1.Start(Seconds(2.0));\n    clientApp1.Stop(Seconds(10.0));\n    clientApp2.Start(Seconds(2.0));\n    clientApp2.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script for a TCP client-server simulation over a point-to-point link. Create two nodes: one as a TCP server and the other as a TCP client. The client sends 100 TCP packets of size 512 bytes to the server every 0.1 seconds. The link between the nodes has a 5 Mbps data rate and a 2 ms delay. Use port 9 for communication, and run the simulation for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpClientServerExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"TcpClientServerExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes: one for the server and one for the client\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link between the client and the server\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up the TCP server on node 1 (server side)\n    uint16_t port = 9; // Port number\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the TCP client on node 0 (client side)\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));    // Send 100 packets\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1))); // Send packets every 0.1 seconds\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(512));    // 512 bytes packets\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Wi-Fi network with two nodes. One node acts as a Wi-Fi Access Point (AP), and the other as a client that sends UDP packets to the server. The client should send 100 packets of 512 bytes at a rate of one packet every 0.1 seconds. Use port 9 for communication and run the simulation for 10 seconds. The Wi-Fi network should follow the 802.11b standard with SSID = 'ns3-wifi'."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes: one for the server and one for the client\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Create Wi-Fi devices and configure them\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n\n    WifiHelper wifiAp;\n    wifiAp.SetStandard(WIFI_PHY_STANDARD_80211b);\n    WifiMacHelper macAp;\n    macAp.SetType(\"ns3::ApWifiMac\",\n                  \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices;\n    devices.Add(wifi.Install(phy, mac, nodes.Get(0)));\n    devices.Add(wifiAp.Install(phy, macAp, nodes.Get(1)));\n\n    // Install the internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Install the UDP server application on node 1 (server side)\n    UdpServerHelper udpServer(9); // Port 9\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Install the UDP client application on node 0 (client side)\n    UdpClientHelper udpClient(interfaces.GetAddress(1), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));    // Send 100 packets\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1))); // Send packets every 0.1 seconds\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));    // 512 bytes packets\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a mobile ad hoc network (MANET) with two nodes. Configure random movement for both nodes using a random walk mobility model with speeds between 1 and 5 m/s and a time interval of 2 seconds. The nodes should send UDP packets from the client (node 0) to the server (node 1) over a 1 Mbps link with a 10 ms delay. Use port 9 for communication, and set the client to send 100 packets of 512 bytes with an interval of 0.1 seconds. The simulation should run for 20 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n#include \"ns3/udp-client-server-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"ManetUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"ManetUdpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes: one for the server and one for the client\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up mobility model for the nodes (to simulate movement)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::RandomRectanglePositionAllocator\",\n                                  \"X\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=100]\"),\n                                  \"Y\", StringValue(\"ns3::UniformRandomVariable[Min=0|Max=100]\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Time\", TimeValue(Seconds(2.0)),\n                              \"Speed\", StringValue(\"ns3::UniformRandomVariable[Min=1|Max=5]\"));\n    mobility.Install(nodes);\n\n    // Install the Internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Set up the point-to-point link (no physical link here, just logical for communication)\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"1Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Install UDP server on node 1 (server side)\n    UdpServerHelper udpServer(9); // Port 9\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Install UDP client on node 0 (client side)\n    UdpClientHelper udpClient(interfaces.GetAddress(1), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));    // Send 100 packets\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1))); // Send packets every 0.1 seconds\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));    // 512 bytes packets\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(20.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a WiFi network with two nodes communicating over TCP. The nodes should use WiFi 802.11b with a grid-based mobility model where nodes have static positions at (0,0) and (5,10) meters. Set the client node (node 0) to send 100 TCP packets of 512 bytes every 0.1 seconds to the server node (node 1) on port 9. The simulation should run for 20 seconds. Use a WiFi Aarf (adaptive rate) manager for connection management."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiTcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the WiFi channel (802.11b standard)\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up the WiFi mac layer\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(Ssid(\"wifi-network\")));\n\n    // Install the WiFi devices (NICs)\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set up mobility for the nodes (Static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the Internet stack (TCP/IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the WiFi devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Install a TCP server on node 1 (server side)\n    uint16_t port = 9; // Port 9\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Install a TCP client on node 0 (client side)\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(512)); // 512 bytes packets\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(20.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Point-to-Point network with two nodes communicating using UDP. The link between the nodes should have a bandwidth of 5Mbps and a delay of 2ms. The client node (node 0) sends 10 UDP packets of 1024 bytes every 1 second to the server node (node 1) on port 9. The server (node 1) should be running an UDP echo server on port 9. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"P2PUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"P2PUdpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the Point-to-Point link with a bandwidth of 5Mbps and delay of 2ms\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install the devices on the nodes\n    NetDeviceContainer devices = p2p.Install(nodes);\n\n    // Set up the Internet stack (IP/TCP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Install a UDP echo server on node 1 (server side)\n    UdpEchoServerHelper echoServer(9); // Port 9\n    ApplicationContainer serverApp = echoServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Install a UDP client on node 0 (client side)\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(1), 9); // Server address and port 9\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024)); // 1024 bytes packet\n    ApplicationContainer clientApp = echoClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a WiFi network with three nodes. The nodes are statically placed with a grid-based mobility model, and the WiFi devices should use 802.11b. Node 2 should act as a TCP server listening on port 9, while node 0 and node 1 act as TCP clients. Each client sends 10 TCP packets of 512 bytes to the server at intervals of 0.1 seconds. The simulation should run for 20 seconds. The nodes should be arranged in a 3x3 grid layout."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiTcpMultipleClients\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiTcpMultipleClients\", LOG_LEVEL_INFO);\n\n    // Create 3 nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Setup the WiFi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Setup the WiFi MAC layer\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(Ssid(\"wifi-network\")));\n\n    // Install WiFi devices on the nodes\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set up mobility for the nodes (Static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the Internet stack (IP/TCP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Install a TCP server on node 2 (server side)\n    uint16_t port = 9;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(2));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(20.0));\n\n    // Install TCP clients on nodes 0 and 1 (client side)\n    TcpClientHelper tcpClient1(interfaces.GetAddress(2), port);\n    tcpClient1.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    tcpClient1.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient1.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp1 = tcpClient1.Install(nodes.Get(0));\n    clientApp1.Start(Seconds(2.0));\n    clientApp1.Stop(Seconds(20.0));\n\n    TcpClientHelper tcpClient2(interfaces.GetAddress(2), port);\n    tcpClient2.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    tcpClient2.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient2.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp2 = tcpClient2.Install(nodes.Get(1));\n    clientApp2.Start(Seconds(3.0));\n    clientApp2.Stop(Seconds(20.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a simple wired network using a point-to-point link with two nodes. The nodes should be connected with a 5 Mbps data rate and a 2 ms delay. Node 1 should act as a TCP server listening on port 9. Node 0 should act as a TCP client, sending 10 packets of 512 bytes to the server at intervals of 0.1 seconds. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv4-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpServerClientExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"TcpServerClientExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack (IP/TCP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Install a TCP server on node 1 (server side)\n    uint16_t port = 9;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Install a TCP client on node 0 (client side)\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Wi-Fi network with two nodes, where Node 0 is a Wi-Fi Access Point (AP) and Node 1 is a Wi-Fi Station (STA). The Wi-Fi communication should use the 802.11n standard, and both nodes should be placed within a grid of 2x2 meters. Install an Internet stack on both nodes and assign IP addresses to the devices. Use a UDP Echo Server on the AP and a UDP Echo Client on the STA. The simulation should run for 10 seconds, with the client sending one 1024-byte packet every 1 second to the server, starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiApStaExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiApStaExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Set up Wi-Fi devices for AP and STA\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n\n    // Install Wi-Fi devices\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevices = wifi.Install(phy, mac, wifiNodes.Get(1));\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevices = wifi.Install(phy, mac, wifiNodes.Get(0));\n\n    // Install mobility model for the nodes\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0), \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2), \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install the Internet stack (IP stack)\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(staDevices);\n    address.Assign(apDevices);\n\n    // Install a simple UDP client on STA node\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(wifiNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    UdpEchoClientHelper echoClient(interfaces.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(1));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a TCP communication between two nodes. The simulation should include one node acting as a TCP server and the other node acting as a TCP client. The IPv4 protocol should be used for communication. The TCP server should be installed on Node 0, and the TCP client on Node 1. The client should send one 1024-byte packet to the server with a 1-second interval. The simulation should run for 10 seconds, starting the server at 1 second and the client at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpClientServerExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"TcpClientServerExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Install the internet stack (IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(nodes);\n\n    // Create and install the TCP server on Node 0\n    uint16_t port = 9; // Port number for TCP connection\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create and install the TCP client on Node 1\n    TcpClientHelper tcpClient(interfaces.GetAddress(0), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(1));      // Send 1 packet\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // Interval between packets\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // Packet size\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate UDP communication between two nodes. One node should act as a UDP server and the other as a UDP client. Both nodes should use IPv4 addresses. The UDP server should be installed on Node 0, and the UDP client on Node 1. The client should send 10 packets of size 1024 bytes at a rate of 1 packet per second. The simulation should run for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpClientServerExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"UdpClientServerExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Install the internet stack (IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(nodes);\n\n    // Create and install the UDP server on Node 0\n    uint16_t port = 9; // Port number for UDP connection\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create and install the UDP client on Node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // Send 10 packets\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // Interval between packets\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // Packet size\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate a Wi-Fi communication between two nodes in an ad hoc network using the 802.11b standard. One node should act as a UDP server and the other as a UDP client. The communication should use UDP packets, with the client sending 10 packets of 1024 bytes at a 1-second interval. The server should be installed on Node 0, and the client on Node 1. The simulation should run for 10 seconds, starting the server at 1 second and the client at 2 seconds. Use an SSID named \"wifi-adhoc-network\" and configure the Wi-Fi physical and MAC layers accordingly."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpClientServerExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiUdpClientServerExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Wi-Fi and install Wi-Fi devices on the nodes\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"wifi-adhoc-network\");\n    mac.SetType(\"ns3::AdhocWifiMac\");\n\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Install the internet stack (IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create and install the UDP server on Node 0\n    uint16_t port = 9; // Port number for UDP connection\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create and install the UDP client on Node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // Send 10 packets\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // Interval between packets\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // Packet size\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script to simulate TCP communication between two nodes in a point-to-point network. One node should act as a TCP server and the other as a TCP client. The client should send 10 packets of size 1024 bytes at a 1-second interval. The server should be installed on Node 0, and the client on Node 1. The nodes should be connected via a point-to-point link with a 5 Mbps data rate and 2 ms delay. The simulation should run for 10 seconds, with the server starting at 1 second and the client starting at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpClientServerExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"TcpClientServerExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link between the nodes\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install the internet stack (IP stack)\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create and install the TCP server on Node 0\n    uint16_t port = 9; // Port number for TCP connection\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create and install the TCP client on Node 1\n    TcpClientHelper tcpClient(interfaces.GetAddress(0), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));     // Send 10 packets\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0))); // Interval between packets\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));   // Packet size\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Wi-Fi network with two nodes: one acting as an Access Point (AP) and the other as a Wi-Fi client. The AP should run a UDP server on port 8080, while the client should run a UDP client sending 20 packets of size 512 bytes at an interval of 0.5 seconds. The simulation should assign IP addresses in the 192.168.1.0/24 subnet, with the AP at 192.168.1.1. Both nodes should have a constant position mobility model, and the simulation should run for 10 seconds, starting the server at 1 second and the client at 2 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create a Wi-Fi network with 2 nodes (1 AP + 1 Client)\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Configure Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    // Configure Wi-Fi MAC layer\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Configure AP (Access Point)\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiNodes.Get(0));\n\n    // Configure Client\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer clientDevice = wifi.Install(phy, mac, wifiNodes.Get(1));\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(apDevice);\n    interfaces.Add(address.Assign(clientDevice));\n\n    // Create a UDP server on the AP\n    uint16_t port = 8080;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create a UDP client on the Client node\n    UdpClientHelper udpClient(interfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(20));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.5)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Point-to-Point (P2P) wired network with two nodes connected via a 10 Mbps link with 2 ms delay. The first node should run a TCP client using the OnOff application, sending 1024-byte packets at a 5 Mbps data rate to the second node, which runs a TCP server. The simulation should assign IP addresses in the 192.168.1.0/24 subnet, with the server on 192.168.1.2. The server starts at 1 second, and the client starts at 2 seconds. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"PointToPointTcpExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure a Point-to-Point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices on the nodes\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a TCP server on node 1\n    uint16_t port = 8080;\n    PacketSinkHelper tcpServer(\"ns3::TcpSocketFactory\",\n                               InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up a TCP client on node 0\n    OnOffHelper tcpClient(\"ns3::TcpSocketFactory\",\n                          InetSocketAddress(interfaces.GetAddress(1), port));\n    tcpClient.SetAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    tcpClient.SetAttribute(\"OnTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=1]\"));\n    tcpClient.SetAttribute(\"OffTime\", StringValue(\"ns3::ConstantRandomVariable[Constant=0]\"));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Wi-Fi network with one access point (AP) and one client station (STA). The AP and client should use the 802.11 standard with a single SSID. The client should be stationary and should send UDP packets to the AP. The UDP client should send 100 packets of 512 bytes at 0.1-second intervals to the UDP server running on the AP. The network should use the 192.168.1.0/24 subnet. The server should start at 1 second, and the client should start at 2 seconds, running until 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/wifi-mac-helper.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"WifiSimpleExample\", LOG_LEVEL_INFO);\n\n    // Create Wi-Fi nodes (1 AP, 1 client)\n    NodeContainer wifiStaNode, wifiApNode;\n    wifiStaNode.Create(1);\n    wifiApNode.Create(1);\n\n    // Set up the Wi-Fi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Configure Wi-Fi devices\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up MAC layers\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-ssid\");\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n    NetDeviceContainer staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Set up mobility\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(0.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNode);\n    mobility.Install(wifiApNode);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNode);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterface = address.Assign(staDevice);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Create UDP server on the AP\n    uint16_t port = 4000;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create UDP client on the station\n    UdpClientHelper udpClient(apInterface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiStaNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a point-to-point (P2P) wired network with two nodes communicating over a 5 Mbps link with a 2 ms delay. Node 1 should run a TCP server listening on port 50000, while Node 0 should run a TCP client using the BulkSendHelper to send unlimited data to the server. The server should start at 1 second, and the client should start at 2 seconds, both running until 10 seconds. The network should use the 10.1.1.0/24 subnet."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleP2PExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging\n    LogComponentEnable(\"SimpleP2PExample\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Configure the point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install the point-to-point devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Create a TCP server on node 1\n    uint16_t port = 50000;\n    PacketSinkHelper sinkHelper(\"ns3::TcpSocketFactory\",\n                                InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer serverApp = sinkHelper.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Create a TCP client on node 0\n    BulkSendHelper sourceHelper(\"ns3::TcpSocketFactory\",\n                                InetSocketAddress(interfaces.GetAddress(1), port));\n    sourceHelper.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n    ApplicationContainer clientApp = sourceHelper.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Wi-Fi network with three nodes communicating using UDP. The network should use 802.11n, with nodes positioned in a grid layout. Node 0 should act as a UDP echo server listening on port 9, while Node 2 should act as a UDP echo client, sending five packets of 1024 bytes at 1-second intervals to Node 0. The simulation should run from 1 second to 10 seconds, using the 192.168.1.0/24 subnet."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create a Wi-Fi network with three nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(3);\n\n    // Set up Wi-Fi PHY and MAC layers\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_STANDARD_80211n);\n    WifiMacHelper wifiMac;\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer wifiDevices;\n    wifiDevices = wifi.Install(wifiPhy, wifiMac, wifiNodes);\n\n    // Set mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer wifiInterfaces = address.Assign(wifiDevices);\n\n    // Set up UDP Echo Server on node 0\n    UdpEchoServerHelper echoServer(9);\n    ApplicationContainer serverApp = echoServer.Install(wifiNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP Echo Client on node 2\n    UdpEchoClientHelper echoClient(wifiInterfaces.GetAddress(0), 9);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = echoClient.Install(wifiNodes.Get(2));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Point-to-Point (P2P) wired network between two nodes. The link should have a data rate of 5 Mbps and a propagation delay of 2 ms. Node 0 should send TCP traffic using a BulkSend application, transmitting unlimited data to Node 1, which runs a PacketSink application to receive the packets. The simulation should run from 1 second to 10 seconds, using the 10.1.1.0/24 subnet."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleP2PTCPExample\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"BulkSendApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"PacketSink\", LOG_LEVEL_INFO);\n\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up a Point-to-Point (P2P) link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install network devices\n    NetDeviceContainer devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up a TCP BulkSend application on Node 0\n    uint16_t port = 9;\n    BulkSendHelper source(\"ns3::TcpSocketFactory\", InetSocketAddress(interfaces.GetAddress(1), port));\n    source.SetAttribute(\"MaxBytes\", UintegerValue(0)); // Unlimited data transfer\n    ApplicationContainer sourceApp = source.Install(nodes.Get(0));\n    sourceApp.Start(Seconds(1.0));\n    sourceApp.Stop(Seconds(10.0));\n\n    // Set up a PacketSink application on Node 1 to receive the TCP data\n    PacketSinkHelper sink(\"ns3::TcpSocketFactory\", InetSocketAddress(Ipv4Address::GetAny(), port));\n    ApplicationContainer sinkApp = sink.Install(nodes.Get(1));\n    sinkApp.Start(Seconds(1.0));\n    sinkApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ script that simulates a Wi-Fi network with one Access Point (AP) and one Station (STA). The AP and STA should be assigned static positions. The STA should send UDP packets to the AP using a UDP Echo Client, and the AP should run a UDP Echo Server to respond. The simulation should use the 192.168.1.0/24 subnet, with the client starting at 2 seconds and stopping at 9 seconds, while the server runs from 1 second to 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    LogComponentEnable(\"UdpEchoClientApplication\", LOG_LEVEL_INFO);\n    LogComponentEnable(\"UdpEchoServerApplication\", LOG_LEVEL_INFO);\n\n    // Create two nodes: one AP and one STA\n    NodeContainer wifiStaNode;\n    wifiStaNode.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n    NodeContainer wifiNodes = NodeContainer(wifiApNode, wifiStaNode);\n\n    // Set up Wi-Fi PHY and MAC\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211g);\n\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n\n    // Configure AP\n    wifiMac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice = wifi.Install(wifiPhy, wifiMac, wifiApNode);\n\n    // Configure STA\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer staDevice = wifi.Install(wifiPhy, wifiMac, wifiStaNode);\n\n    // Set mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterface = address.Assign(staDevice);\n    Ipv4InterfaceContainer apInterface = address.Assign(apDevice);\n\n    // Set up UDP server on AP\n    uint16_t port = 9;\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApp = echoServer.Install(wifiApNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on STA\n    UdpEchoClientHelper echoClient(apInterface.GetAddress(0), port);\n    echoClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = echoClient.Install(wifiStaNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ simulation with a CSMA network of four nodes. The last node is a UDP echo server, and the others are clients sending packets to it. Use a 100Mbps data rate, assign IPs in the 10.1.1.0/24 range, and ensure proper network stack installation. Clients should send 512-byte packets at 1s intervals. The simulation should start at 1s, run until 10s, and terminate correctly."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/csma-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleCsmaExample\");\n\nint main(int argc, char *argv[])\n{\n    uint32_t nCsmaNodes = 4; // 3 clients + 1 server\n\n    // Create CSMA nodes\n    NodeContainer csmaNodes;\n    csmaNodes.Create(nCsmaNodes);\n\n    // Set up CSMA network\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(NanoSeconds(6560)));\n\n    // Install CSMA devices\n    NetDeviceContainer csmaDevices;\n    csmaDevices = csma.Install(csmaNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(csmaNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer csmaInterfaces = address.Assign(csmaDevices);\n\n    // Set up UDP server on the last node\n    uint16_t port = 9;\n    UdpEchoServerHelper echoServer(port);\n    ApplicationContainer serverApp = echoServer.Install(csmaNodes.Get(nCsmaNodes - 1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP clients on the first three nodes\n    for (uint32_t i = 0; i < nCsmaNodes - 1; ++i)\n    {\n        UdpEchoClientHelper echoClient(csmaInterfaces.GetAddress(nCsmaNodes - 1), port);\n        echoClient.SetAttribute(\"MaxPackets\", UintegerValue(5));\n        echoClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n        echoClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n        ApplicationContainer clientApp = echoClient.Install(csmaNodes.Get(i));\n        clientApp.Start(Seconds(2.0));\n        clientApp.Stop(Seconds(9.0));\n    }\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate a simple NS-3 C++ WiFi network simulation with two nodes. The first node (client) sends TCP packets to the second node (server) over a WiFi link. Use a 1Gbps data rate, assign IPs in the 192.168.1.0/24 range, and ensure the Internet stack is installed. The server should run from 1s to 10s, while the client starts at 2s and sends packets at 0.1s intervals. The simulation should start at 1s and run for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set up nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Set up WiFi devices\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::StaWifiMac\",\n                    \"Ssid\", SsidValue(Ssid(\"wifi-default\")));\n\n    NetDeviceContainer wifiDevices;\n    wifiDevices = wifi.Install(wifiPhy, wifiMac, wifiNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer wifiInterfaces = address.Assign(wifiDevices);\n\n    // Set up the TCP server on the second node (server)\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(wifiNodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the TCP client on the first node (client)\n    TcpClientHelper tcpClient(wifiInterfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(wifiNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nGenerate an NS-3 C++ LTE network simulation with one eNB and one UE. The UE should send UDP packets to the eNB, and the eNB should respond. Use the IP range 10.0.0.0/24, install the Internet stack, and attach the UE to the eNB. The server should run from 1s to 10s, and the client starts at 2s, sending packets at 0.1s intervals. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleLteExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create LTE nodes\n    NodeContainer enbNode, ueNode;\n    enbNode.Create(1);\n    ueNode.Create(1);\n\n    // Set up LTE devices\n    LteHelper lteHelper;\n    NetDeviceContainer enbLteDevice = lteHelper.InstallEnbDevice(enbNode);\n    NetDeviceContainer ueLteDevice = lteHelper.InstallUeDevice(ueNode);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(ueNode);\n    internet.Install(enbNode);\n\n    // Assign IP addresses\n    Ipv4InterfaceContainer ueIpIfaces;\n    ueIpIfaces = lteHelper.AssignUeIpv4Address(ueLteDevice);\n\n    // Attach UE to eNB\n    lteHelper.Attach(ueLteDevice, enbLteDevice.Get(0));\n\n    // Set up the UDP server on the UE\n    uint16_t port = 12345;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ueNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up the UDP client on the eNB (simulating data transmission)\n    UdpClientHelper udpClient(ueIpIfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(enbNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an NS-3 C++ point-to-point network with two nodes. The first node (client) sends TCP packets to the second node (server). Use a 5Mbps data rate and a 2ms delay. The client sends packets at 0.1s intervals, and the server runs from 1s to 10s. Assign IPs in the 10.1.1.0/24 range. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP server on node 1\n    uint16_t port = 9;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on node 0\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a Wi-Fi network in NS-3 with two nodes. The first node (AP) and the second node (STA) communicate via UDP packets. Set the Wi-Fi data rate to default and use 10.1.1.0/24 IP addresses. The client sends packets at 0.1s intervals starting at 2s, and the server runs from 1s to 10s. Use default Wi-Fi PHY and MAC models and run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(2);\n\n    // Set up Wi-Fi PHY and MAC layers\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiChannelHelper channel;\n    channel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    channel.AddPropagationLoss(\"ns3::FriisPropagationLossModel\");\n\n    YansWifiPhyHelper phy;\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::StaWifiMac\");\n\n    NetDeviceContainer staDevice = wifi.Install(phy, mac, wifiNodes.Get(1));\n\n    mac.SetType(\"ns3::ApWifiMac\");\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, wifiNodes.Get(0));\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(staDevice);\n    address.Assign(apDevice);\n\n    // Set up UDP server on AP\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(wifiNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on STA\n    UdpClientHelper udpClient(interfaces.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an Ethernet network in NS-3 with two nodes. The first node (client) sends TCP packets to the second node (server). Set the link data rate to 100Mbps and delay to 5ms. Use 192.168.1.0/24 IP addresses. The client sends packets at 0.1s intervals starting at 2s, and the server runs from 1s to 10s. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ethernet-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"EthernetTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Ethernet point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP server on node 1\n    uint16_t port = 9;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on node 0\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a two-node IPv6 network in NS-3 with a point-to-point link. The nodes are assigned IPv6 addresses in the 2001:1::/64 subnet. The client (node 0) sends ICMP Echo Requests (ping) to the server (node 1). Set the link data rate to 10Mbps and delay to 10ms. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/ipv6-address-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"Ipv6PingExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Point-to-Point link with IPv6\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install IPv6 stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IPv6 addresses\n    Ipv6AddressHelper address;\n    address.SetBase(Ipv6Address(\"2001:1::\"), Ipv6Mask(\"/64\"));\n    Ipv6InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up ICMP Echo Request (ping) from node 0 to node 1\n    V4PingHelper ping(interfaces.GetAddress(1));\n    ApplicationContainer pingApp = ping.Install(nodes.Get(0));\n    pingApp.Start(Seconds(2.0));\n    pingApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a Wi-Fi network in NS-3 with two nodes: one as an access point (AP) and the other as a station (STA). The station sends UDP packets to the access point. Use the SSID ns3-wifi for both devices. Set the link data rate to 54Mbps, and run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Wi-Fi settings\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, nodes.Get(1));\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\", SsidValue(ssid));\n    devices.Add(wifi.Install(phy, mac, nodes.Get(0)));\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP application on node 1 (server)\n    uint16_t port = 9;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on node 0 (station)\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSet up a simple TCP connection in NS-3 with two nodes using the TCP NewReno protocol. One node (server) listens on port 9, and the other node (client) sends TCP packets to the server. Set the link data rate to 5Mbps, and run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpNewRenoExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Point-to-Point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP server application on node 1 (server)\n    uint16_t port = 9;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client application on node 0 (client)\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(9.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSet up a simple LTE network in NS-3 with two nodes: one as an eNodeB (base station) and the other as a UE (user equipment). The UE sends TCP packets to the eNodeB. Use the default LTE parameters and run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer ueNode;\n    NodeContainer enbNode;\n    ueNode.Create(1);\n    enbNode.Create(1);\n\n    // Install LTE stack\n    LteHelper lte;\n    InternetStackHelper internet;\n    internet.Install(ueNode);\n    internet.Install(enbNode);\n\n    // Set up the eNodeB and UE devices\n    NetDeviceContainer ueDevice;\n    NetDeviceContainer enbDevice;\n    enbDevice = lte.InstallEnbDevice(enbNode);\n    ueDevice = lte.InstallUeDevice(ueNode);\n\n    // Set up IP addressing and assign IP to UE\n    Ipv4InterfaceContainer ueIpInterface;\n    Ipv4AddressHelper ipv4h;\n    ipv4h.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    ueIpInterface = ipv4h.Assign(ueDevice);\n\n    // Attach UE to eNodeB\n    lte.Attach(ueDevice, enbDevice.Get(0));\n\n    // Set up TCP application on UE (client)\n    uint16_t port = 9;\n    TcpClientHelper tcpClient(ueIpInterface.GetAddress(0), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n    ApplicationContainer clientApp = tcpClient.Install(enbNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up TCP server application on eNodeB (server)\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(ueNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple Wi-Fi network in NS-3 with one Access Point (AP) and one Station (STA). The STA sends UDP packets to the AP. Use 802.11n Wi-Fi and run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer wifiStaNode;\n    NodeContainer wifiApNode;\n    wifiStaNode.Create(1);\n    wifiApNode.Create(1);\n\n    // Set up Wi-Fi\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up the Wi-Fi channel and devices\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer staDevice;\n    staDevice = wifi.Install(phy, mac, wifiStaNode);\n\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNode);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterface;\n    staInterface = ipv4.Assign(staDevice);\n\n    // Set up UDP application on Wi-Fi STA (client)\n    UdpClientHelper udpClient(staInterface.GetAddress(0), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiApNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on Wi-Fi AP (server)\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(wifiStaNode.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple point-to-point network in NS-3 with two nodes. The first node sends UDP packets to the second node. Use a link speed of 5Mbps and a delay of 2ms. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link with a 5Mbps link speed and 2ms delay\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install point-to-point devices\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP client application on node 0 (sender)\n    uint16_t port = 9;\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on node 1 (receiver)\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple TCP connection in NS-3 with two nodes over a point-to-point link. The first node sends TCP packets to the second node. Use a 10Mbps link speed and a 5ms delay. Capture the throughput using a flow monitor and run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/flow-monitor-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link with a 10Mbps link speed and 5ms delay\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    // Install point-to-point devices\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP client application on node 0 (sender)\n    uint16_t port = 9;\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up TCP server application on node 1 (receiver)\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up flow monitor to capture throughput\n    FlowMonitorHelper flowmon;\n    Ptr<FlowMonitor> monitor = flowmon.InstallAll();\n\n    // Run the simulation\n    Simulator::Run();\n\n    // Print flow monitor statistics\n    monitor->CheckForLostPackets();\n    monitor->SerializeToXmlFile(\"tcp_flow_monitor.xml\", true, true);\n\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a WiFi network in NS-3 with two nodes. The first node sends UDP packets to the second node. Use default WiFi attributes and a simple grid mobility model. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up WiFi PHY and MAC attributes\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up WiFi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up WiFi device\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP client application on node 0 (sender)\n    uint16_t port = 9;\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on node 1 (receiver)\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an Ethernet-based TCP communication network in NS-3 with two nodes. One node sends TCP packets to the other using a point-to-point link with 100Mbps and 2ms delay. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"EthernetTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link with a 100Mbps speed and 2ms delay\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install point-to-point devices on nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up TCP client application on node 0 (client)\n    uint16_t port = 8080;\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up TCP server application on node 1 (server)\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a WiFi network in NS-3 with three nodes, where Node 1 is the access point and Node 2 sends UDP packets to Node 3 through the access point. Use a simple grid mobility model, and the simulation should last for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"SimpleWiFiNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Set up WiFi PHY and MAC\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up WiFi channel\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up WiFi device\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"simple-wifi\");\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer devices = wifi.Install(phy, mac, nodes);\n\n    // Set up mobility model (constant position for simplicity)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(3),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = address.Assign(devices);\n\n    // Set up UDP client application on Node 2 (sending)\n    uint16_t port = 9;\n    UdpClientHelper udpClient(interfaces.GetAddress(2), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(1));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on Node 3 (receiving)\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(2));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate an LTE mobile network in NS-3 with two nodes: Node 1 is the eNB, and Node 2 is the UE. Node 2 sends UDP packets to Node 1 using LTE communication. Simulate mobility with random walk for Node 2 and constant position for Node 1. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteMobileNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer eNodeB, ue;\n    eNodeB.Create(1);\n    ue.Create(1);\n\n    // Install LTE model\n    LteHelper lte;\n    InternetStackHelper internet;\n\n    // Install LTE devices on the nodes\n    NetDeviceContainer enbLteDevs, ueLteDevs;\n    enbLteDevs = lte.InstallEnbDevice(eNodeB);\n    ueLteDevs = lte.InstallUeDevice(ue);\n\n    // Install Internet stack\n    internet.Install(eNodeB);\n    internet.Install(ue);\n\n    // Set up mobility model for nodes\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(ue);\n\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(eNodeB);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper ipv4Address;\n    ipv4Address.SetBase(\"7.0.0.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer ueIpIface = ipv4Address.Assign(ueLteDevs);\n    Ipv4InterfaceContainer enbIpIface = ipv4Address.Assign(enbLteDevs);\n\n    // Set up UDP client application on Node 2 (UE)\n    uint16_t port = 1234;\n    UdpClientHelper udpClient(ueIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(eNodeB.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on Node 1 (eNB)\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(ue.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple Wi-Fi network in NS-3 with two nodes: Node 1 as the AP (Access Point) and Node 2 as the STA (Station). Node 2 sends UDP packets to Node 1 using Wi-Fi communication. Node 2 should move randomly within a specified area while Node 1 remains stationary. Run the simulation for 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer ap, sta;\n    ap.Create(1);\n    sta.Create(1);\n\n    // Install Wi-Fi devices on the nodes\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::ApWifiMac\",\n                \"Ssid\", SsidValue(Ssid(\"wifi-network\")));\n\n    NetDeviceContainer apDevice = wifi.Install(phy, mac, ap);\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(Ssid(\"wifi-network\")));\n    NetDeviceContainer staDevice = wifi.Install(phy, mac, sta);\n\n    // Install Internet stack\n    InternetStackHelper internet;\n    internet.Install(ap);\n    internet.Install(sta);\n\n    // Set up mobility model for nodes\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(10.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(ap);\n    mobility.SetMobilityModel(\"ns3::RandomWalk2dMobilityModel\",\n                              \"Bounds\", RectangleValue(Rectangle(-50, 50, -50, 50)));\n    mobility.Install(sta);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper ipv4Address;\n    ipv4Address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer apIpIface = ipv4Address.Assign(apDevice);\n    Ipv4InterfaceContainer staIpIface = ipv4Address.Assign(staDevice);\n\n    // Set up UDP client application on Node 2 (STA)\n    uint16_t port = 9;\n    UdpClientHelper udpClient(staIpIface.GetAddress(0), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(1.0)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(ap.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Set up UDP server application on Node 1 (AP)\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(sta.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a point-to-point network in NS-3 with two nodes. Node 1 (client) sends TCP packets to Node 2 (server) using a TCP connection. Set the data rate to 5Mbps and the delay to 2ms. Run the simulation for 10 seconds, with the server starting at 1s and the client starting at 2s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpConnectionExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Set up point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up TCP server on Node 2\n    uint16_t port = 9; // Arbitrary port\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on Node 1\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a Wi-Fi network in NS-3 with three nodes: one Wi-Fi access point and two stations. Node 1 (station) sends UDP packets to Node 2 (AP), and Node 2 forwards them to Node 3. Set up Wi-Fi parameters with a default channel and AARF station management. The simulation should run for 10 seconds, starting the server at 1s and the client at 2s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer wifiNodes;\n    wifiNodes.Create(3);\n\n    // Set up Wi-Fi channel and devices\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns-3-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, wifiNodes.Get(0));\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    devices.Add(wifi.Install(phy, mac, wifiNodes.Get(1)));\n    devices.Add(wifi.Install(phy, mac, wifiNodes.Get(2)));\n\n    // Install internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiNodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 2\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(wifiNodes.Get(2));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(2), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(wifiNodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a mesh network in NS-3 with three nodes. Set up mesh routing with Random Access for the MAC and YansWifiPhy for the physical layer. Node 1 sends UDP packets to Node 2, and Node 2 forwards the packets to Node 3. Run the simulation for 10 seconds, starting the server at 1s and the client at 2s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/mesh-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"MeshNetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Install mesh stack on all nodes\n    MeshHelper mesh;\n    mesh.SetStackInstall(true);\n    mesh.SetMacType(\"RandomAccess\");\n    mesh.SetPhyType(\"YansWifiPhy\");\n\n    // Set up mesh devices\n    NetDeviceContainer devices = mesh.Install(nodes);\n\n    // Install internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 2\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(1), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSet up a point-to-point network in NS-3 with two nodes. Configure a point-to-point link with a data rate of 5Mbps and a delay of 2ms. Node 1 sends UDP packets to Node 2, with a server running on Node 2. The simulation should run for 10 seconds, starting the server at 1s and the client at 2s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 2\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(1), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a WiFi network in NS-3 with two nodes using the 802.11n standard at 5GHz. Set up a UDP application where Node 1 sends packets to Node 2. Start the server on Node 2 at 1s and the client on Node 1 at 2s. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the WiFi PHY and MAC layer\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211n_5GHZ);\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::StaWifiMac\");\n\n    // Set up WiFi channel and PHY\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Install devices on nodes\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, nodes);\n\n    // Install internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 2\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(1), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple TCP connection in NS-3 between two nodes using a point-to-point link with a data rate of 10Mbps and a delay of 5ms. Set up a TCP server on Node 2 and a TCP client on Node 1. The client should start sending data at 1s and stop at 10s. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    // Install devices on nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack on nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up TCP server on Node 2\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client on Node 1\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(1.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a CSMA network in NS-3 with three nodes using Ethernet with a data rate of 100Mbps and a delay of 2ms. Set up a UDP server on Node 3 and a UDP client on Node 1. The client should start sending data at 2s and stop at 10s. The simulation should run for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/ethernet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CSMANetworkExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create three nodes\n    NodeContainer nodes;\n    nodes.Create(3);\n\n    // Set up CSMA channel\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", StringValue(\"100Mbps\"));\n    csma.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install devices on nodes\n    NetDeviceContainer devices;\n    devices = csma.Install(nodes);\n\n    // Install the internet stack on the nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 3\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(2));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 1\n    UdpClientHelper udpClient(interfaces.GetAddress(2), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a Wi-Fi network in NS-3 with two nodes: a station (Node 1) and an access point (Node 0). The station should send UDP packets to the access point starting at 2s and stopping at 10s. Use Wi-Fi with an SSID of ns-3-ssid, and set the simulation duration to 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Wi-Fi helper\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up Wi-Fi channel\n    YansWifiChannelHelper wifiChannel;\n    wifiChannel.SetPropagationDelay(\"ns3::ConstantSpeedPropagationDelayModel\");\n    wifiChannel.AddPropagationLoss(\"ns3::LogDistancePropagationLossModel\");\n\n    YansWifiPhyHelper wifiPhy;\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Set up MAC\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::StaWifiMac\",\n                    \"Ssid\", SsidValue(Ssid(\"ns-3-ssid\")),\n                    \"Active\", BooleanValue(true));\n\n    // Install Wi-Fi devices\n    NetDeviceContainer devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Set up Mobility Model for nodes\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the Internet stack on nodes\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 0 (Access Point)\n    UdpServerHelper udpServer(9);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 1 (Station)\n    UdpClientHelper udpClient(interfaces.GetAddress(0), 9);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.05)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(1));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a point-to-point network in NS-3 with two nodes. Node 0 sends TCP packets to Node 1 starting at 2s and stopping at 5s. Use a data rate of 5Mbps, a delay of 2ms, and assign IP addresses starting with 10.1.1.0/24. The server should start at 1s, and the simulation should run for 5 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"PointToPointTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n\n    // Install point-to-point devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up TCP server on Node 1 (Receiver)\n    uint16_t port = 8080;\n    TcpServerHelper tcpServer(port);\n    ApplicationContainer serverApp = tcpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(5.0));\n\n    // Set up TCP client on Node 0 (Sender)\n    TcpClientHelper tcpClient(interfaces.GetAddress(1), port);\n    tcpClient.SetAttribute(\"MaxPackets\", UintegerValue(10));\n    tcpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    tcpClient.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = tcpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(5.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a point-to-point network with two nodes in NS-3. Node 0 sends UDP packets to Node 1 starting at 2s and stopping at 10s. Use a data rate of 10Mbps, a delay of 5ms, and assign IP addresses starting with 192.168.1.0/24. The server on Node 1 starts at 1s and the simulation runs for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"UdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up point-to-point link\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"10Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"5ms\"));\n\n    // Install point-to-point devices on the nodes\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 1 (Receiver)\n    uint16_t port = 12345;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 0 (Sender)\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple Wi-Fi network in NS-3 with two nodes. Node 0 (UDP client) sends packets to Node 1 (UDP server) starting at 2s and stopping at 10s. Use a data rate of 10Mbps, and a fixed delay of 2ms. The Wi-Fi network should operate on the SSID ns3-wifi, and IP addresses should start with 10.1.1.0/24. Set the mobility model to constant position with grid placement for the nodes."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Wi-Fi configuration\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up Wi-Fi PHY and MAC layers\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    WifiMacHelper wifiMac;\n    Ssid ssid = Ssid(\"ns3-wifi\");\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid));\n\n    // Install Wi-Fi devices\n    NetDeviceContainer devices;\n    devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Set up mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the devices\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 1 (Receiver)\n    uint16_t port = 12345;\n    UdpServerHelper udpServer(port);\n    ApplicationContainer serverApp = udpServer.Install(nodes.Get(1));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 0 (Sender)\n    UdpClientHelper udpClient(interfaces.GetAddress(1), port);\n    udpClient.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    udpClient.SetAttribute(\"Interval\", TimeValue(Seconds(0.1)));\n    udpClient.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = udpClient.Install(nodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a TCP connection between two nodes in NS-3. Node 0 (client) sends TCP packets to Node 1 (server). The server listens on port 8080 and the client connects to the server on the same port. Use a grid mobility model with nodes positioned at 0,0 and 5,5. Ensure that the simulation runs from 1s to 10s."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpExample\");\n\nvoid ReceivePacket(Ptr<Socket> socket)\n{\n    while (socket->Recv())\n    {\n        NS_LOG_UNCOND(\"Received one packet!\");\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Set up mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Set up TCP socket\n    TypeId tid = TypeId::LookupByName(\"ns3::TcpSocketFactory\");\n    Ptr<Socket> tcpServerSocket = Socket::CreateSocket(nodes.Get(1), tid);\n\n    // Bind the server socket to a port\n    InetSocketAddress serverAddress = InetSocketAddress(Ipv4Address::GetAny(), 8080);\n    tcpServerSocket->Bind(serverAddress);\n    tcpServerSocket->Listen();\n    tcpServerSocket->SetRecvCallback(MakeCallback(&ReceivePacket));\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(nodes);\n\n    // Set up TCP client on Node 0\n    Ptr<Socket> tcpClientSocket = Socket::CreateSocket(nodes.Get(0), tid);\n    InetSocketAddress clientAddress = InetSocketAddress(interfaces.GetAddress(1), 8080);\n    tcpClientSocket->Connect(clientAddress);\n\n    // Create a TCP application (client)\n    Ptr<Socket> appSocket = Socket::CreateSocket(nodes.Get(0), tid);\n    Ptr<TcpClient> clientApp = CreateObject<TcpClient>();\n    clientApp->Setup(appSocket, InetSocketAddress(interfaces.GetAddress(1), 8080), 1000);\n    nodes.Get(0)->AddApplication(clientApp);\n    clientApp->SetStartTime(Seconds(1.0));\n    clientApp->SetStopTime(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSet up a simple Wi-Fi network with two nodes in NS-3. Node 0 (sender) sends UDP packets to Node 1 (receiver). Both nodes are statically placed with positions (0, 0) and (5, 5). Use the AARF Wi-Fi manager and configure the communication to last for 10 seconds. The server (Node 1) listens on port 9 and the client (Node 0) sends packets every 1 millisecond."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Install Wi-Fi devices\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    mac.SetType(\"ns3::StaWifiMac\", \"Active\", BooleanValue(true));\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Set up mobility model (static positions)\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server (Receiver) on Node 1\n    UdpServerHelper server(9);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP client (Sender) on Node 0\n    UdpClientHelper client(interfaces.GetAddress(1), 9);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(1)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple TCP connection between two nodes in NS-3. Node 0 (sender) sends data to Node 1 (receiver) using TCP over a connection. Both nodes should have IP addresses from the range 10.1.1.0/24. The server (Node 1) listens on port 9, and the client (Node 0) sends data packets of size 1024 bytes every millisecond for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(nodes);\n\n    // Set up TCP server (Receiver) on Node 1\n    uint16_t port = 9;\n    TcpServerHelper server(port);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up TCP client (Sender) on Node 0\n    TcpClientHelper client(interfaces.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(1)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple Ethernet network using CSMA in NS-3 with two nodes. Node 0 (sender) sends UDP packets to Node 1 (receiver) over a shared CSMA channel with a data rate of 100 Mbps and a delay of 2 milliseconds. Both nodes are assigned IP addresses in the 10.1.1.0/24 network, and the communication lasts for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/csma-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"CsmaExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up the CSMA channel\n    CsmaHelper csma;\n    csma.SetChannelAttribute(\"DataRate\", DataRateValue(DataRate(\"100Mbps\")));\n    csma.SetChannelAttribute(\"Delay\", TimeValue(MilliSeconds(2)));\n\n    NetDeviceContainer devices = csma.Install(nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server (Receiver) on Node 1\n    UdpServerHelper server(9);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP client (Sender) on Node 0\n    UdpClientHelper client(interfaces.GetAddress(1), 9);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(1)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple Wi-Fi network in NS-3 with two nodes. Node 0 (sender) sends UDP packets to Node 1 (receiver) over a Wi-Fi link. The nodes are positioned using a grid layout and assigned IP addresses from the 10.1.1.0/24 network. The Wi-Fi connection uses an SSID \"wifi-ssid\" and the simulation runs for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Setup mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(5.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Setup Wi-Fi device\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"wifi-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\",\n                \"Ssid\", SsidValue(ssid),\n                \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server (Receiver) on Node 1\n    UdpServerHelper server(9);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP client (Sender) on Node 0\n    UdpClientHelper client(interfaces.GetAddress(1), 9);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(1)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple TCP communication between two nodes in NS-3. Use a point-to-point link with a data rate of 5 Mbps and a delay of 2 ms. The sender (Node 0) sends TCP packets to the receiver (Node 1) over the connection. The simulation runs for 10 seconds and uses TCP as the transport protocol."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Point-to-Point link between the nodes\n    PointToPointHelper p2p;\n    p2p.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    p2p.SetChannelAttribute(\"Delay\", StringValue(\"2ms\"));\n    NetDeviceContainer devices = p2p.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up TCP server (Receiver) on Node 1\n    uint16_t port = 9;\n    TcpServerHelper server(port);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up TCP client (Sender) on Node 0\n    TcpClientHelper client(interfaces.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple Wi-Fi network simulation in NS-3 with two nodes. Set up a wireless link using IEEE 802.11 standards and make one node send UDP packets to the other over a wireless connection. Use a mobility model with constant position for the nodes, and run the simulation for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/point-to-point-module.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up Wi-Fi channel\n    YansWifiChannelHelper wifiChannel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper wifiPhy = YansWifiPhyHelper::Default();\n    wifiPhy.SetChannel(wifiChannel.Create());\n\n    // Configure Wi-Fi device\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n    WifiMacHelper wifiMac;\n    wifiMac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-ssid\")));\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(wifiPhy, wifiMac, nodes);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\",\n                                  \"MinX\", DoubleValue(0.0),\n                                  \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0),\n                                  \"DeltaY\", DoubleValue(10.0),\n                                  \"GridWidth\", UintegerValue(2),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up a UDP server (Receiver) on Node 1\n    uint16_t port = 9;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up a UDP client (Sender) on Node 0\n    UdpClientHelper client(interfaces.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple TCP connection simulation between two nodes over a point-to-point link in NS-3. Set the data rate to 5Mbps, the delay to 10ms, and introduce a 0.1 packet loss. One node should act as a TCP server, and the other as a TCP client, sending packets for 10 seconds."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/point-to-point-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"TcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up a point-to-point link with delay and packet loss\n    PointToPointHelper pointToPoint;\n    pointToPoint.SetDeviceAttribute(\"DataRate\", StringValue(\"5Mbps\"));\n    pointToPoint.SetChannelAttribute(\"Delay\", StringValue(\"10ms\"));\n    pointToPoint.SetChannelAttribute(\"Loss\", StringValue(\"0.1\"));\n\n    NetDeviceContainer devices;\n    devices = pointToPoint.Install(nodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up TCP server (Receiver) on Node 1\n    uint16_t port = 8080;\n    TcpServerHelper server(port);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up TCP client (Sender) on Node 0\n    TcpClientHelper client(interfaces.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(20)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(1.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple WiFi communication simulation in NS-3 between two nodes where one acts as a UDP server and the other as a client. The nodes should communicate using 802.11b standard, with an SSID 'wifi-network'. Set the UDP client to send 1000 packets with a 10ms interval."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/point-to-point-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WiFiExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create two nodes\n    NodeContainer nodes;\n    nodes.Create(2);\n\n    // Set up WiFi devices and configure the SSID\n    WifiHelper wifi;\n    wifi.SetStandard(WIFI_PHY_STANDARD_80211b);\n    WifiMacHelper mac;\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(Ssid(\"wifi-network\")));\n\n    NetDeviceContainer devices;\n    devices = wifi.Install(phy, mac, nodes);\n\n    // Install the Internet stack\n    InternetStackHelper stack;\n    stack.Install(nodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper ipv4;\n    ipv4.SetBase(\"192.168.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer interfaces = ipv4.Assign(devices);\n\n    // Set up UDP server on Node 1\n    uint16_t port = 9;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApps = server.Install(nodes.Get(1));\n    serverApps.Start(Seconds(1.0));\n    serverApps.Stop(Seconds(10.0));\n\n    // Set up UDP client on Node 0\n    UdpClientHelper client(interfaces.GetAddress(1), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(10)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApps = client.Install(nodes.Get(0));\n    clientApps.Start(Seconds(2.0));\n    clientApps.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nCreate a simple LTE communication simulation between two nodes in NS-3, where one node acts as a UDP server (UE) and the other as a client (eNB). The server should accept UDP packets on port 12345, and the client sends 1000 packets at 20ms intervals."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/lte-module.h\"\n#include \"ns3/epc-helper.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"LteExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set the simulation time\n    Time::SetResolution(Time::MS);\n\n    // Create nodes\n    NodeContainer eNBNodes;\n    eNBNodes.Create(1);\n    NodeContainer ueNodes;\n    ueNodes.Create(1);\n\n    // Create LTE helper\n    Ptr<LteHelper> lteHelper = CreateObject<LteHelper>();\n\n    // Create EPC helper\n    Ptr<EpcHelper> epcHelper = CreateObject<EpcHelper>();\n    lteHelper->SetEpcHelper(epcHelper);\n\n    // Install LTE devices\n    NetDeviceContainer enbDevs = lteHelper->InstallEnbDevice(eNBNodes);\n    NetDeviceContainer ueDevs = lteHelper->InstallUeDevice(ueNodes);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(ueNodes);\n    stack.Install(eNBNodes);\n\n    // Assign IP addresses to the nodes\n    Ipv4InterfaceContainer ueIpIface;\n    ueIpIface = epcHelper->AssignUeIpv4Address(ueDevs);\n\n    // Attach UE to the eNB\n    lteHelper->Attach(ueDevs.Get(0), enbDevs.Get(0));\n\n    // Set up a UDP server on UE\n    uint16_t port = 12345;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(ueNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up a UDP client on eNB\n    UdpClientHelper client(ueIpIface.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(20)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = client.Install(eNBNodes.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network with two nodes: a sender (AP) and a receiver (STA). Use UDP communication with the sender sending 1000 packets at intervals of 20ms to the receiver. Configure the nodes with static mobility and assign them IP addresses. The receiver should run a UDP server on port 9."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiSimpleExample\");\n\nint main(int argc, char *argv[])\n{\n    // Set up logging\n    LogComponentEnable(\"WifiSimpleExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Set up Wi-Fi\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::AarfWifiManager\");\n\n    // Set up the physical layer\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    // Set up MAC layer\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"ns3-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    // Install Wi-Fi devices on nodes\n    NetDeviceContainer staDevice;\n    staDevice = wifi.Install(phy, mac, wifiStaNodes);\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install Internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses to the nodes\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces;\n    staInterfaces = address.Assign(staDevice);\n    Ipv4InterfaceContainer apInterfaces;\n    apInterfaces = address.Assign(apDevice);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0), \"DeltaY\", DoubleValue(5.0), \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Set up UDP server on STA\n    UdpServerHelper server(9);\n    ApplicationContainer serverApp = server.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client on AP\n    UdpClientHelper client(staInterfaces.GetAddress(0), 9);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(1000));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(20)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(512));\n\n    ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network with two nodes: one as a TCP server and the other as a TCP client using the TCP Reno protocol. The client sends TCP packets (size 1024 bytes) at an interval of 100ms to the server. Configure the nodes with static mobility and assign them IP addresses. The server listens on port 9."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for debugging\n    LogComponentEnable(\"WifiTcpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Set up Wi-Fi devices\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::RenoWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"wifi-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer staDevice;\n    staDevice = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevice);\n    Ipv4InterfaceContainer apInterfaces = address.Assign(apDevice);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0), \"DeltaY\", DoubleValue(5.0), \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Set up TCP server (on the STA)\n    uint16_t port = 9;\n    TcpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client (on the AP)\n    TcpClientHelper client(staInterfaces.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a Wi-Fi network with two nodes: one as a UDP server and the other as a UDP client. The client sends UDP packets (size 1024 bytes) at an interval of 100ms to the server. Use a constant bit rate (CBR) application on the client and set the server to listen on port 9."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiUdpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Enable logging for debugging\n    LogComponentEnable(\"WifiUdpExample\", LOG_LEVEL_INFO);\n\n    // Create nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Set up Wi-Fi devices\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::ArfWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"wifi-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer staDevice;\n    staDevice = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevice);\n    Ipv4InterfaceContainer apInterfaces = address.Assign(apDevice);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0), \"DeltaY\", DoubleValue(5.0), \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Set up UDP server (on the STA)\n    uint16_t port = 9;\n    UdpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up UDP client (on the AP)\n    UdpClientHelper client(staInterfaces.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = client.Install(wif"}]}
{"size": "Small", "messages": [{"role": "system", "content": "\nYou are a computer networking expert that works with network simulation in ns-3. Your task is to generate **only** the ns-3 C++ source code for the given program description.\nOutput a single compilable .cc file – no commentary, no markdown fences, no explanations.\nUse ns-3 public APIs, assume ns-3 ≥ 3.41, and write error-free C++17.\n"}, {"role": "user", "content": "Simulation Description:\nSimulate a TCP connection between two Wi-Fi nodes: one as a TCP server and the other as a TCP client. The client sends packets of size 1024 bytes at a rate of 100ms interval to the server. The server listens on port 9."}, {"role": "assistant", "content": "#include \"ns3/core-module.h\"\n#include \"ns3/network-module.h\"\n#include \"ns3/internet-module.h\"\n#include \"ns3/applications-module.h\"\n#include \"ns3/wifi-module.h\"\n#include \"ns3/yans-wifi-helper.h\"\n#include \"ns3/ssid.h\"\n#include \"ns3/mobility-module.h\"\n\nusing namespace ns3;\n\nNS_LOG_COMPONENT_DEFINE(\"WifiTcpExample\");\n\nint main(int argc, char *argv[])\n{\n    // Create nodes\n    NodeContainer wifiStaNodes;\n    wifiStaNodes.Create(1);\n    NodeContainer wifiApNode;\n    wifiApNode.Create(1);\n\n    // Set up Wi-Fi devices\n    WifiHelper wifi;\n    wifi.SetRemoteStationManager(\"ns3::ArfWifiManager\");\n\n    YansWifiChannelHelper channel = YansWifiChannelHelper::Default();\n    YansWifiPhyHelper phy = YansWifiPhyHelper::Default();\n    phy.SetChannel(channel.Create());\n\n    WifiMacHelper mac;\n    Ssid ssid = Ssid(\"wifi-ssid\");\n    mac.SetType(\"ns3::StaWifiMac\", \"Ssid\", SsidValue(ssid), \"ActiveProbing\", BooleanValue(false));\n\n    NetDeviceContainer staDevice;\n    staDevice = wifi.Install(phy, mac, wifiStaNodes);\n\n    mac.SetType(\"ns3::ApWifiMac\", \"Ssid\", SsidValue(ssid));\n    NetDeviceContainer apDevice;\n    apDevice = wifi.Install(phy, mac, wifiApNode);\n\n    // Install internet stack\n    InternetStackHelper stack;\n    stack.Install(wifiStaNodes);\n    stack.Install(wifiApNode);\n\n    // Assign IP addresses to devices\n    Ipv4AddressHelper address;\n    address.SetBase(\"10.1.1.0\", \"255.255.255.0\");\n    Ipv4InterfaceContainer staInterfaces = address.Assign(staDevice);\n    Ipv4InterfaceContainer apInterfaces = address.Assign(apDevice);\n\n    // Set up mobility model\n    MobilityHelper mobility;\n    mobility.SetPositionAllocator(\"ns3::GridPositionAllocator\", \"MinX\", DoubleValue(0.0), \"MinY\", DoubleValue(0.0),\n                                  \"DeltaX\", DoubleValue(5.0), \"DeltaY\", DoubleValue(5.0), \"GridWidth\", UintegerValue(1),\n                                  \"LayoutType\", StringValue(\"RowFirst\"));\n    mobility.SetMobilityModel(\"ns3::ConstantPositionMobilityModel\");\n    mobility.Install(wifiStaNodes);\n    mobility.Install(wifiApNode);\n\n    // Set up TCP server (on the STA)\n    uint16_t port = 9;\n    TcpServerHelper server(port);\n    ApplicationContainer serverApp = server.Install(wifiStaNodes.Get(0));\n    serverApp.Start(Seconds(1.0));\n    serverApp.Stop(Seconds(10.0));\n\n    // Set up TCP client (on the AP)\n    TcpClientHelper client(staInterfaces.GetAddress(0), port);\n    client.SetAttribute(\"MaxPackets\", UintegerValue(100));\n    client.SetAttribute(\"Interval\", TimeValue(MilliSeconds(100)));\n    client.SetAttribute(\"PacketSize\", UintegerValue(1024));\n\n    ApplicationContainer clientApp = client.Install(wifiApNode.Get(0));\n    clientApp.Start(Seconds(2.0));\n    clientApp.Stop(Seconds(10.0));\n\n    // Run the simulation\n    Simulator::Run();\n    Simulator::Destroy();\n\n    return 0;\n}"}]}
